
OpusProfilingTool.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001f8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00014c98  080001f8  080001f8  000101f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000031e8  08014e90  08014e90  00024e90  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08018078  08018078  00030070  2**0
                  CONTENTS
  4 .ARM          00000000  08018078  08018078  00030070  2**0
                  CONTENTS
  5 .preinit_array 00000000  08018078  08018078  00030070  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  08018078  08018078  00028078  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000008  08018080  08018080  00028080  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000070  20000000  08018088  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000070  20000070  080180f8  00030070  2**2
                  ALLOC
 10 ._user_heap_stack 00028000  200000e0  080180f8  000300e0  2**0
                  ALLOC
 11 .ARM.attributes 00000036  00000000  00000000  00030070  2**0
                  CONTENTS, READONLY
 12 .debug_line   00038e95  00000000  00000000  000300a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0005ac40  00000000  00000000  00068f3b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 0000c610  00000000  00000000  000c3b7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 000011b8  00000000  00000000  000d0190  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0010cd3f  00000000  00000000  000d1348  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00007968  00000000  00000000  001de088  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00039c33  00000000  00000000  001e59f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macro  00036de9  00000000  00000000  0021f623  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  0025640c  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00003a18  00000000  00000000  00256488  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001f8 <__do_global_dtors_aux>:
 80001f8:	b510      	push	{r4, lr}
 80001fa:	4c05      	ldr	r4, [pc, #20]	; (8000210 <__do_global_dtors_aux+0x18>)
 80001fc:	7823      	ldrb	r3, [r4, #0]
 80001fe:	b933      	cbnz	r3, 800020e <__do_global_dtors_aux+0x16>
 8000200:	4b04      	ldr	r3, [pc, #16]	; (8000214 <__do_global_dtors_aux+0x1c>)
 8000202:	b113      	cbz	r3, 800020a <__do_global_dtors_aux+0x12>
 8000204:	4804      	ldr	r0, [pc, #16]	; (8000218 <__do_global_dtors_aux+0x20>)
 8000206:	e000      	b.n	800020a <__do_global_dtors_aux+0x12>
 8000208:	bf00      	nop
 800020a:	2301      	movs	r3, #1
 800020c:	7023      	strb	r3, [r4, #0]
 800020e:	bd10      	pop	{r4, pc}
 8000210:	20000070 	.word	0x20000070
 8000214:	00000000 	.word	0x00000000
 8000218:	08014e78 	.word	0x08014e78

0800021c <frame_dummy>:
 800021c:	b508      	push	{r3, lr}
 800021e:	4b03      	ldr	r3, [pc, #12]	; (800022c <frame_dummy+0x10>)
 8000220:	b11b      	cbz	r3, 800022a <frame_dummy+0xe>
 8000222:	4903      	ldr	r1, [pc, #12]	; (8000230 <frame_dummy+0x14>)
 8000224:	4803      	ldr	r0, [pc, #12]	; (8000234 <frame_dummy+0x18>)
 8000226:	e000      	b.n	800022a <frame_dummy+0xe>
 8000228:	bf00      	nop
 800022a:	bd08      	pop	{r3, pc}
 800022c:	00000000 	.word	0x00000000
 8000230:	20000074 	.word	0x20000074
 8000234:	08014e78 	.word	0x08014e78

08000238 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* set stack pointer */
 8000238:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000270 <LoopForever+0x2>

/* Call the clock system initialization function.*/
  bl  SystemInit
 800023c:	f000 f990 	bl	8000560 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8000240:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8000242:	e003      	b.n	800024c <LoopCopyDataInit>

08000244 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8000244:	4b0b      	ldr	r3, [pc, #44]	; (8000274 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8000246:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8000248:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800024a:	3104      	adds	r1, #4

0800024c <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 800024c:	480a      	ldr	r0, [pc, #40]	; (8000278 <LoopForever+0xa>)
	ldr	r3, =_edata
 800024e:	4b0b      	ldr	r3, [pc, #44]	; (800027c <LoopForever+0xe>)
	adds	r2, r0, r1
 8000250:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8000252:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8000254:	d3f6      	bcc.n	8000244 <CopyDataInit>
	ldr	r2, =_sbss
 8000256:	4a0a      	ldr	r2, [pc, #40]	; (8000280 <LoopForever+0x12>)
	b	LoopFillZerobss
 8000258:	e002      	b.n	8000260 <LoopFillZerobss>

0800025a <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 800025a:	2300      	movs	r3, #0
	str	r3, [r2], #4
 800025c:	f842 3b04 	str.w	r3, [r2], #4

08000260 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8000260:	4b08      	ldr	r3, [pc, #32]	; (8000284 <LoopForever+0x16>)
	cmp	r2, r3
 8000262:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8000264:	d3f9      	bcc.n	800025a <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8000266:	f013 fea3 	bl	8013fb0 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 800026a:	f000 f80f 	bl	800028c <main>

0800026e <LoopForever>:

LoopForever:
    b LoopForever
 800026e:	e7fe      	b.n	800026e <LoopForever>
  ldr   sp, =_estack    /* set stack pointer */
 8000270:	20040000 	.word	0x20040000
	ldr	r3, =_sidata
 8000274:	08018088 	.word	0x08018088
	ldr	r0, =_sdata
 8000278:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 800027c:	20000070 	.word	0x20000070
	ldr	r2, =_sbss
 8000280:	20000070 	.word	0x20000070
	ldr	r3, = _ebss
 8000284:	200000e0 	.word	0x200000e0

08000288 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000288:	e7fe      	b.n	8000288 <ADC1_2_IRQHandler>
	...

0800028c <main>:



//uint32_t led_toggle_count = 0;//commented out by Pritom
int main(void)
{
 800028c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800028e:	b099      	sub	sp, #100	; 0x64
   *    timer for example or other time source), keeping in mind that Time base
   *    duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and
   *    handled in milliseconds basis.
   *  - Low Level Initialization
   */
  HAL_Init();
 8000290:	f000 f9e2 	bl	8000658 <HAL_Init>
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000294:	a806      	add	r0, sp, #24
 8000296:	2248      	movs	r2, #72	; 0x48
 8000298:	2100      	movs	r1, #0
 800029a:	f013 ff45 	bl	8014128 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800029e:	2300      	movs	r3, #0

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0) != HAL_OK)
 80002a0:	4618      	mov	r0, r3
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80002a2:	e9cd 3301 	strd	r3, r3, [sp, #4]
 80002a6:	e9cd 3303 	strd	r3, r3, [sp, #12]
 80002aa:	9305      	str	r3, [sp, #20]
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0) != HAL_OK)
 80002ac:	f000 fb58 	bl	8000960 <HAL_PWREx_ControlVoltageScaling>
 80002b0:	b100      	cbz	r0, 80002b4 <main+0x28>
 80002b2:	e7fe      	b.n	80002b2 <main+0x26>
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 80002b4:	2040      	movs	r0, #64	; 0x40
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80002b6:	f44f 7580 	mov.w	r5, #256	; 0x100
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 80002ba:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 55;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 80002bc:	2307      	movs	r3, #7
  RCC_OscInitStruct.PLL.PLLM = 4;
 80002be:	2104      	movs	r1, #4
  RCC_OscInitStruct.PLL.PLLN = 55;
 80002c0:	2237      	movs	r2, #55	; 0x37
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 80002c2:	e9cd 5009 	strd	r5, r0, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80002c6:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 80002c8:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 80002cc:	9406      	str	r4, [sp, #24]
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 80002ce:	e9cd 4411 	strd	r4, r4, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 80002d2:	e9cd 4416 	strd	r4, r4, [sp, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLM = 4;
 80002d6:	9113      	str	r1, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80002d8:	f000 fbe4 	bl	8000aa4 <HAL_RCC_OscConfig>
 80002dc:	4603      	mov	r3, r0
 80002de:	b100      	cbz	r0, 80002e2 <main+0x56>
 80002e0:	e7fe      	b.n	80002e0 <main+0x54>
  {
    while(1);
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80002e2:	250f      	movs	r5, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80002e4:	2203      	movs	r2, #3
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 80002e6:	a801      	add	r0, sp, #4
 80002e8:	2105      	movs	r1, #5
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80002ea:	e9cd 3303 	strd	r3, r3, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80002ee:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80002f0:	e9cd 5201 	strd	r5, r2, [sp, #4]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 80002f4:	f000 ffa4 	bl	8001240 <HAL_RCC_ClockConfig>
 80002f8:	b100      	cbz	r0, 80002fc <main+0x70>
 80002fa:	e7fe      	b.n	80002fa <main+0x6e>
static void ICACHE_Init(void)
{

  /** Enable instruction cache in 1-way (direct mapped cache)
  */
  if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
 80002fc:	f000 fb0c 	bl	8000918 <HAL_ICACHE_ConfigAssociativityMode>
 8000300:	b100      	cbz	r0, 8000304 <main+0x78>
 8000302:	e7fe      	b.n	8000302 <main+0x76>
  {
    while(1);
  }
  if (HAL_ICACHE_Enable() != HAL_OK)
 8000304:	f000 fb1a 	bl	800093c <HAL_ICACHE_Enable>
 8000308:	4606      	mov	r6, r0
 800030a:	b100      	cbz	r0, 800030e <main+0x82>
 800030c:	e7fe      	b.n	800030c <main+0x80>
  BSP_LED_Init(LED1);
 800030e:	f000 f8e7 	bl	80004e0 <BSP_LED_Init>
  FILE *fp = fopen("D:\opus all\STM32CubeExpansion_OPUS_V1.0.0\Projects\NUCLEO-L552ZE-Q\Demonstrations\Profiling\OpusProfilingTool\Inc\foo.h", "r");
 8000312:	4926      	ldr	r1, [pc, #152]	; (80003ac <main+0x120>)
 8000314:	4826      	ldr	r0, [pc, #152]	; (80003b0 <main+0x124>)
 8000316:	f013 fc59 	bl	8013bcc <fopen>
  if (fp != NULL) {
 800031a:	4605      	mov	r5, r0
 800031c:	2800      	cmp	r0, #0
 800031e:	d039      	beq.n	8000394 <main+0x108>
      if (fseek(fp, 0L, SEEK_END) == 0) {
 8000320:	4622      	mov	r2, r4
 8000322:	4631      	mov	r1, r6
 8000324:	f013 fcba 	bl	8013c9c <fseek>
 8000328:	4607      	mov	r7, r0
 800032a:	b1b8      	cbz	r0, 800035c <main+0xd0>
 800032c:	4c21      	ldr	r4, [pc, #132]	; (80003b4 <main+0x128>)
      fclose(fp);
 800032e:	4628      	mov	r0, r5
 8000330:	f013 fa72 	bl	8013818 <fclose>
  free(source); /* Don't forget to call free() later! */
 8000334:	6820      	ldr	r0, [r4, #0]
 8000336:	f013 fecb 	bl	80140d0 <free>
  numDecShort=DEC_Opus_Decode((uint8_t*)source, sizeof(source), (uint8_t*)buff);
 800033a:	6820      	ldr	r0, [r4, #0]
 800033c:	4a1e      	ldr	r2, [pc, #120]	; (80003b8 <main+0x12c>)
 800033e:	2104      	movs	r1, #4
 8000340:	f000 f85e 	bl	8000400 <DEC_Opus_Decode>
 8000344:	4603      	mov	r3, r0
 8000346:	4c1d      	ldr	r4, [pc, #116]	; (80003bc <main+0x130>)
  sprintf(hex, "%x", numDecShort);
 8000348:	4602      	mov	r2, r0
 800034a:	491d      	ldr	r1, [pc, #116]	; (80003c0 <main+0x134>)
 800034c:	a806      	add	r0, sp, #24
  numDecShort=DEC_Opus_Decode((uint8_t*)source, sizeof(source), (uint8_t*)buff);
 800034e:	6023      	str	r3, [r4, #0]
  sprintf(hex, "%x", numDecShort);
 8000350:	f014 f8b6 	bl	80144c0 <siprintf>
  puts(hex);
 8000354:	a806      	add	r0, sp, #24
 8000356:	f014 f805 	bl	8014364 <puts>
 800035a:	e7fe      	b.n	800035a <main+0xce>
          long bufsize = ftell(fp);
 800035c:	4628      	mov	r0, r5
 800035e:	f013 fd37 	bl	8013dd0 <ftell>
 8000362:	4606      	mov	r6, r0
          source = malloc(sizeof(char) * (bufsize + 1));
 8000364:	3001      	adds	r0, #1
 8000366:	f013 feab 	bl	80140c0 <malloc>
 800036a:	4c12      	ldr	r4, [pc, #72]	; (80003b4 <main+0x128>)
          if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error */ }
 800036c:	463a      	mov	r2, r7
          source = malloc(sizeof(char) * (bufsize + 1));
 800036e:	6020      	str	r0, [r4, #0]
          if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error */ }
 8000370:	4639      	mov	r1, r7
 8000372:	4628      	mov	r0, r5
 8000374:	f013 fc92 	bl	8013c9c <fseek>
          size_t newLen = fread(source, sizeof(char), bufsize, fp);
 8000378:	4632      	mov	r2, r6
 800037a:	462b      	mov	r3, r5
 800037c:	6820      	ldr	r0, [r4, #0]
 800037e:	2101      	movs	r1, #1
 8000380:	f013 fc7c 	bl	8013c7c <fread>
 8000384:	4606      	mov	r6, r0
          if ( ferror( fp ) != 0 ) {
 8000386:	4628      	mov	r0, r5
 8000388:	f013 fa4e 	bl	8013828 <ferror>
 800038c:	b920      	cbnz	r0, 8000398 <main+0x10c>
              source[newLen++] = '\0'; /* Just to be safe. */
 800038e:	6823      	ldr	r3, [r4, #0]
 8000390:	5598      	strb	r0, [r3, r6]
 8000392:	e7cc      	b.n	800032e <main+0xa2>
 8000394:	4c07      	ldr	r4, [pc, #28]	; (80003b4 <main+0x128>)
 8000396:	e7cd      	b.n	8000334 <main+0xa8>
              fputs("Error reading file", stderr);
 8000398:	4b0a      	ldr	r3, [pc, #40]	; (80003c4 <main+0x138>)
 800039a:	2212      	movs	r2, #18
 800039c:	681b      	ldr	r3, [r3, #0]
 800039e:	2101      	movs	r1, #1
 80003a0:	68db      	ldr	r3, [r3, #12]
 80003a2:	4809      	ldr	r0, [pc, #36]	; (80003c8 <main+0x13c>)
 80003a4:	f013 fdf6 	bl	8013f94 <fwrite>
 80003a8:	e7c1      	b.n	800032e <main+0xa2>
 80003aa:	bf00      	nop
 80003ac:	08014ea0 	.word	0x08014ea0
 80003b0:	08014ea4 	.word	0x08014ea4
 80003b4:	20000090 	.word	0x20000090
 80003b8:	200000c4 	.word	0x200000c4
 80003bc:	2000008c 	.word	0x2000008c
 80003c0:	08014f28 	.word	0x08014f28
 80003c4:	2000000c 	.word	0x2000000c
 80003c8:	08014f14 	.word	0x08014f14

080003cc <HAL_MspInit>:
  }
}

void HAL_MspInit(void)
{
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003cc:	4b0b      	ldr	r3, [pc, #44]	; (80003fc <HAL_MspInit+0x30>)
{
 80003ce:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003d0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80003d2:	f042 0201 	orr.w	r2, r2, #1
 80003d6:	661a      	str	r2, [r3, #96]	; 0x60
 80003d8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80003da:	f002 0201 	and.w	r2, r2, #1
 80003de:	9200      	str	r2, [sp, #0]
 80003e0:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80003e2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80003e4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80003e8:	659a      	str	r2, [r3, #88]	; 0x58
 80003ea:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80003ec:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80003f0:	9301      	str	r3, [sp, #4]
 80003f2:	9b01      	ldr	r3, [sp, #4]


  /** Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral
  */
  HAL_PWREx_DisableUCPDDeadBattery();
}
 80003f4:	b002      	add	sp, #8
  HAL_PWREx_DisableUCPDDeadBattery();
 80003f6:	f000 baf7 	b.w	80009e8 <HAL_PWREx_DisableUCPDDeadBattery>
 80003fa:	bf00      	nop
 80003fc:	40021000 	.word	0x40021000

08000400 <DEC_Opus_Decode>:
 * @param  len: length of the buffer in.
 * @param  buf_out: pointer to the Decoded buffer.
 * @retval Number of decoded samples or @ref opus_errorcodes.
 */
int DEC_Opus_Decode(uint8_t * buf_in, uint32_t len, uint8_t * buf_out) 
{
 8000400:	b570      	push	{r4, r5, r6, lr}
  return opus_decode(hOpus.Decoder, (unsigned char *) buf_in, (opus_int32) len, (opus_int16 *) buf_out, hOpus.DEC_frame_size, 0);
 8000402:	2600      	movs	r6, #0
 8000404:	4c06      	ldr	r4, [pc, #24]	; (8000420 <DEC_Opus_Decode+0x20>)
{
 8000406:	b082      	sub	sp, #8
  return opus_decode(hOpus.Decoder, (unsigned char *) buf_in, (opus_int32) len, (opus_int16 *) buf_out, hOpus.DEC_frame_size, 0);
 8000408:	6865      	ldr	r5, [r4, #4]
 800040a:	8824      	ldrh	r4, [r4, #0]
 800040c:	4613      	mov	r3, r2
 800040e:	9400      	str	r4, [sp, #0]
 8000410:	460a      	mov	r2, r1
 8000412:	9601      	str	r6, [sp, #4]
 8000414:	4601      	mov	r1, r0
 8000416:	4628      	mov	r0, r5
 8000418:	f012 fdf2 	bl	8013000 <opus_decode>
}
 800041c:	b002      	add	sp, #8
 800041e:	bd70      	pop	{r4, r5, r6, pc}
 8000420:	20000094 	.word	0x20000094

08000424 <NMI_Handler>:
* @param  None
* @retval None
*/
void NMI_Handler(void)
{
}
 8000424:	4770      	bx	lr
 8000426:	bf00      	nop

08000428 <HardFault_Handler>:
* @brief  HardFault_Handler This function handles Hard Fault exception.
* @param  None
* @retval None
*/
void HardFault_Handler(void)
{
 8000428:	e7fe      	b.n	8000428 <HardFault_Handler>
 800042a:	bf00      	nop

0800042c <SVC_Handler>:
 800042c:	4770      	bx	lr
 800042e:	bf00      	nop

08000430 <DebugMon_Handler>:
 8000430:	4770      	bx	lr
 8000432:	bf00      	nop

08000434 <PendSV_Handler>:
 8000434:	4770      	bx	lr
 8000436:	bf00      	nop

08000438 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8000438:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800043a:	1e16      	subs	r6, r2, #0
 800043c:	dd07      	ble.n	800044e <_read+0x16>
 800043e:	460c      	mov	r4, r1
 8000440:	198d      	adds	r5, r1, r6
	{
		*ptr++ = __io_getchar();
 8000442:	e000      	b.n	8000446 <_read+0xe>
 8000444:	bf00      	nop
 8000446:	f804 0b01 	strb.w	r0, [r4], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800044a:	42a5      	cmp	r5, r4
 800044c:	d1f9      	bne.n	8000442 <_read+0xa>
	}

return len;
}
 800044e:	4630      	mov	r0, r6
 8000450:	bd70      	pop	{r4, r5, r6, pc}
 8000452:	bf00      	nop

08000454 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8000454:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000456:	1e16      	subs	r6, r2, #0
 8000458:	dd07      	ble.n	800046a <_write+0x16>
 800045a:	460c      	mov	r4, r1
 800045c:	198d      	adds	r5, r1, r6
	{
		__io_putchar(*ptr++);
 800045e:	f814 0b01 	ldrb.w	r0, [r4], #1
 8000462:	e000      	b.n	8000466 <_write+0x12>
 8000464:	bf00      	nop
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000466:	42ac      	cmp	r4, r5
 8000468:	d1f9      	bne.n	800045e <_write+0xa>
	}
	return len;
}
 800046a:	4630      	mov	r0, r6
 800046c:	bd70      	pop	{r4, r5, r6, pc}
 800046e:	bf00      	nop

08000470 <_close>:

int _close(int file)
{
	return -1;
}
 8000470:	f04f 30ff 	mov.w	r0, #4294967295
 8000474:	4770      	bx	lr
 8000476:	bf00      	nop

08000478 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8000478:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	return 0;
}
 800047c:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 800047e:	604b      	str	r3, [r1, #4]
}
 8000480:	4770      	bx	lr
 8000482:	bf00      	nop

08000484 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8000484:	2001      	movs	r0, #1
 8000486:	4770      	bx	lr

08000488 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8000488:	2000      	movs	r0, #0
 800048a:	4770      	bx	lr

0800048c <_open>:

int _open(char *path, int flags, ...)
{
 800048c:	b40e      	push	{r1, r2, r3}
	/* Pretend like we always fail */
	return -1;
}
 800048e:	f04f 30ff 	mov.w	r0, #4294967295
 8000492:	b003      	add	sp, #12
 8000494:	4770      	bx	lr
 8000496:	bf00      	nop

08000498 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initalize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8000498:	490d      	ldr	r1, [pc, #52]	; (80004d0 <_sbrk+0x38>)
{
 800049a:	b510      	push	{r4, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800049c:	4a0d      	ldr	r2, [pc, #52]	; (80004d4 <_sbrk+0x3c>)
 800049e:	4c0e      	ldr	r4, [pc, #56]	; (80004d8 <_sbrk+0x40>)
  if (NULL == __sbrk_heap_end)
 80004a0:	680b      	ldr	r3, [r1, #0]
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80004a2:	1b12      	subs	r2, r2, r4
  if (NULL == __sbrk_heap_end)
 80004a4:	b12b      	cbz	r3, 80004b2 <_sbrk+0x1a>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80004a6:	4418      	add	r0, r3
 80004a8:	4290      	cmp	r0, r2
 80004aa:	d808      	bhi.n	80004be <_sbrk+0x26>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 80004ac:	6008      	str	r0, [r1, #0]

  return (void *)prev_heap_end;
}
 80004ae:	4618      	mov	r0, r3
 80004b0:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 80004b2:	4c0a      	ldr	r4, [pc, #40]	; (80004dc <_sbrk+0x44>)
 80004b4:	4623      	mov	r3, r4
  if (__sbrk_heap_end + incr > max_heap)
 80004b6:	4418      	add	r0, r3
 80004b8:	4290      	cmp	r0, r2
    __sbrk_heap_end = &_end;
 80004ba:	600c      	str	r4, [r1, #0]
  if (__sbrk_heap_end + incr > max_heap)
 80004bc:	d9f6      	bls.n	80004ac <_sbrk+0x14>
    errno = ENOMEM;
 80004be:	f013 f953 	bl	8013768 <__errno>
 80004c2:	220c      	movs	r2, #12
    return (void *)-1;
 80004c4:	f04f 33ff 	mov.w	r3, #4294967295
    errno = ENOMEM;
 80004c8:	6002      	str	r2, [r0, #0]
}
 80004ca:	4618      	mov	r0, r3
 80004cc:	bd10      	pop	{r4, pc}
 80004ce:	bf00      	nop
 80004d0:	200000a0 	.word	0x200000a0
 80004d4:	20040000 	.word	0x20040000
 80004d8:	00008000 	.word	0x00008000
 80004dc:	200000e0 	.word	0x200000e0

080004e0 <BSP_LED_Init>:
  *     @arg  LED2
  *     @arg  LED3
  * @retval BSP error code
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 80004e0:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef GPIO_Init;

  /* Enable the GPIO_LED Clock */
  if (Led == LED1)
  {
    LED1_GPIO_CLK_ENABLE();
 80004e2:	4b1c      	ldr	r3, [pc, #112]	; (8000554 <BSP_LED_Init+0x74>)
{
 80004e4:	b089      	sub	sp, #36	; 0x24
    LED1_GPIO_CLK_ENABLE();
 80004e6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  if (Led == LED1)
 80004e8:	b308      	cbz	r0, 800052e <BSP_LED_Init+0x4e>
  }
  else if (Led == LED2)
 80004ea:	2801      	cmp	r0, #1
 80004ec:	d028      	beq.n	8000540 <BSP_LED_Init+0x60>
  {
    LED2_GPIO_CLK_ENABLE();
  }
  else /* Led = LED3 */
  {
    LED3_GPIO_CLK_ENABLE();
 80004ee:	f042 0201 	orr.w	r2, r2, #1
 80004f2:	64da      	str	r2, [r3, #76]	; 0x4c
 80004f4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80004f6:	f003 0301 	and.w	r3, r3, #1
 80004fa:	9302      	str	r3, [sp, #8]
 80004fc:	9b02      	ldr	r3, [sp, #8]
  }

  /* configure the GPIO_LED pin */
  GPIO_Init.Pin   = LED_PIN[Led];
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
 80004fe:	2301      	movs	r3, #1
  GPIO_Init.Pull  = GPIO_PULLUP;
  GPIO_Init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000500:	2203      	movs	r2, #3
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
 8000502:	4c15      	ldr	r4, [pc, #84]	; (8000558 <BSP_LED_Init+0x78>)
  GPIO_Init.Pin   = LED_PIN[Led];
 8000504:	4915      	ldr	r1, [pc, #84]	; (800055c <BSP_LED_Init+0x7c>)
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
 8000506:	f854 4020 	ldr.w	r4, [r4, r0, lsl #2]
  GPIO_Init.Pin   = LED_PIN[Led];
 800050a:	f831 5010 	ldrh.w	r5, [r1, r0, lsl #1]
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
 800050e:	4620      	mov	r0, r4
 8000510:	a903      	add	r1, sp, #12
  GPIO_Init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000512:	e9cd 3205 	strd	r3, r2, [sp, #20]
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
 8000516:	e9cd 5303 	strd	r5, r3, [sp, #12]
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
 800051a:	f000 f919 	bl	8000750 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 800051e:	4620      	mov	r0, r4
 8000520:	4629      	mov	r1, r5
 8000522:	2200      	movs	r2, #0
 8000524:	f000 f9f2 	bl	800090c <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 8000528:	2000      	movs	r0, #0
 800052a:	b009      	add	sp, #36	; 0x24
 800052c:	bd30      	pop	{r4, r5, pc}
    LED1_GPIO_CLK_ENABLE();
 800052e:	f042 0204 	orr.w	r2, r2, #4
 8000532:	64da      	str	r2, [r3, #76]	; 0x4c
 8000534:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000536:	f003 0304 	and.w	r3, r3, #4
 800053a:	9300      	str	r3, [sp, #0]
 800053c:	9b00      	ldr	r3, [sp, #0]
 800053e:	e7de      	b.n	80004fe <BSP_LED_Init+0x1e>
    LED2_GPIO_CLK_ENABLE();
 8000540:	f042 0202 	orr.w	r2, r2, #2
 8000544:	64da      	str	r2, [r3, #76]	; 0x4c
 8000546:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000548:	f003 0302 	and.w	r3, r3, #2
 800054c:	9301      	str	r3, [sp, #4]
 800054e:	9b01      	ldr	r3, [sp, #4]
 8000550:	e7d5      	b.n	80004fe <BSP_LED_Init+0x1e>
 8000552:	bf00      	nop
 8000554:	40021000 	.word	0x40021000
 8000558:	08014f34 	.word	0x08014f34
 800055c:	08014f2c 	.word	0x08014f2c

08000560 <SystemInit>:
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 8000560:	4a03      	ldr	r2, [pc, #12]	; (8000570 <SystemInit+0x10>)
 8000562:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8000566:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800056a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
#endif
}
 800056e:	4770      	bx	lr
 8000570:	e000ed00 	.word	0xe000ed00

08000574 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
  uint32_t tmp, msirange, pllvco, pllsource, pllm, pllr;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 8000574:	4b20      	ldr	r3, [pc, #128]	; (80005f8 <SystemCoreClockUpdate+0x84>)
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000576:	4920      	ldr	r1, [pc, #128]	; (80005f8 <SystemCoreClockUpdate+0x84>)
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 8000578:	681a      	ldr	r2, [r3, #0]
  msirange = MSIRangeTable[msirange];
 800057a:	4820      	ldr	r0, [pc, #128]	; (80005fc <SystemCoreClockUpdate+0x88>)
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 800057c:	0712      	lsls	r2, r2, #28
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 800057e:	bf54      	ite	pl
 8000580:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 8000584:	681b      	ldrmi	r3, [r3, #0]
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000586:	688a      	ldr	r2, [r1, #8]
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 8000588:	bf58      	it	pl
 800058a:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800058e:	f002 020c 	and.w	r2, r2, #12
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 8000592:	bf48      	it	mi
 8000594:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8000598:	2a08      	cmp	r2, #8
  msirange = MSIRangeTable[msirange];
 800059a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800059e:	d00d      	beq.n	80005bc <SystemCoreClockUpdate+0x48>
 80005a0:	2a0c      	cmp	r2, #12
 80005a2:	d00d      	beq.n	80005c0 <SystemCoreClockUpdate+0x4c>
 80005a4:	2a04      	cmp	r2, #4
 80005a6:	d009      	beq.n	80005bc <SystemCoreClockUpdate+0x48>
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 80005a8:	4a13      	ldr	r2, [pc, #76]	; (80005f8 <SystemCoreClockUpdate+0x84>)
 80005aa:	4815      	ldr	r0, [pc, #84]	; (8000600 <SystemCoreClockUpdate+0x8c>)
 80005ac:	6892      	ldr	r2, [r2, #8]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 80005ae:	4915      	ldr	r1, [pc, #84]	; (8000604 <SystemCoreClockUpdate+0x90>)
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 80005b0:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80005b4:	5c82      	ldrb	r2, [r0, r2]
  SystemCoreClock >>= tmp;
 80005b6:	40d3      	lsrs	r3, r2
 80005b8:	600b      	str	r3, [r1, #0]
}
 80005ba:	4770      	bx	lr
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80005bc:	4b12      	ldr	r3, [pc, #72]	; (8000608 <SystemCoreClockUpdate+0x94>)
 80005be:	e7f3      	b.n	80005a8 <SystemCoreClockUpdate+0x34>
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80005c0:	68c8      	ldr	r0, [r1, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 80005c2:	68ca      	ldr	r2, [r1, #12]
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80005c4:	f000 0103 	and.w	r1, r0, #3
      switch (pllsource)
 80005c8:	3902      	subs	r1, #2
 80005ca:	2901      	cmp	r1, #1
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 80005cc:	f3c2 1203 	ubfx	r2, r2, #4, #4
          pllvco = (HSE_VALUE / pllm);
 80005d0:	bf98      	it	ls
 80005d2:	4b0d      	ldrls	r3, [pc, #52]	; (8000608 <SystemCoreClockUpdate+0x94>)
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 80005d4:	3201      	adds	r2, #1
          pllvco = (msirange / pllm);
 80005d6:	fbb3 f3f2 	udiv	r3, r3, r2
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 80005da:	4907      	ldr	r1, [pc, #28]	; (80005f8 <SystemCoreClockUpdate+0x84>)
 80005dc:	68ca      	ldr	r2, [r1, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 80005de:	68c9      	ldr	r1, [r1, #12]
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 80005e0:	f3c2 2206 	ubfx	r2, r2, #8, #7
 80005e4:	fb03 f202 	mul.w	r2, r3, r2
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 80005e8:	f3c1 6341 	ubfx	r3, r1, #25, #2
 80005ec:	3301      	adds	r3, #1
 80005ee:	005b      	lsls	r3, r3, #1
      SystemCoreClock = pllvco/pllr;
 80005f0:	fbb2 f3f3 	udiv	r3, r2, r3
      break;
 80005f4:	e7d8      	b.n	80005a8 <SystemCoreClockUpdate+0x34>
 80005f6:	bf00      	nop
 80005f8:	40021000 	.word	0x40021000
 80005fc:	08014f50 	.word	0x08014f50
 8000600:	08014f40 	.word	0x08014f40
 8000604:	20000000 	.word	0x20000000
 8000608:	00f42400 	.word	0x00f42400

0800060c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800060c:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 800060e:	4b0f      	ldr	r3, [pc, #60]	; (800064c <HAL_InitTick+0x40>)
 8000610:	781b      	ldrb	r3, [r3, #0]
 8000612:	b90b      	cbnz	r3, 8000618 <HAL_InitTick+0xc>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 8000614:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 8000616:	bd38      	pop	{r3, r4, r5, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
 8000618:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800061c:	fbb2 f3f3 	udiv	r3, r2, r3
 8000620:	4a0b      	ldr	r2, [pc, #44]	; (8000650 <HAL_InitTick+0x44>)
 8000622:	4605      	mov	r5, r0
 8000624:	6810      	ldr	r0, [r2, #0]
 8000626:	fbb0 f0f3 	udiv	r0, r0, r3
 800062a:	f000 f879 	bl	8000720 <HAL_SYSTICK_Config>
 800062e:	4604      	mov	r4, r0
 8000630:	2800      	cmp	r0, #0
 8000632:	d1ef      	bne.n	8000614 <HAL_InitTick+0x8>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000634:	2d07      	cmp	r5, #7
 8000636:	d8ed      	bhi.n	8000614 <HAL_InitTick+0x8>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8000638:	4602      	mov	r2, r0
 800063a:	4629      	mov	r1, r5
 800063c:	f04f 30ff 	mov.w	r0, #4294967295
 8000640:	f000 f838 	bl	80006b4 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8000644:	4b03      	ldr	r3, [pc, #12]	; (8000654 <HAL_InitTick+0x48>)
 8000646:	4620      	mov	r0, r4
 8000648:	601d      	str	r5, [r3, #0]
}
 800064a:	bd38      	pop	{r3, r4, r5, pc}
 800064c:	20000004 	.word	0x20000004
 8000650:	20000000 	.word	0x20000000
 8000654:	20000008 	.word	0x20000008

08000658 <HAL_Init>:
{
 8000658:	b500      	push	{lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 800065a:	2004      	movs	r0, #4
{
 800065c:	b083      	sub	sp, #12
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 800065e:	f000 f817 	bl	8000690 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
 8000662:	f7ff ff87 	bl	8000574 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000666:	2000      	movs	r0, #0
 8000668:	f7ff ffd0 	bl	800060c <HAL_InitTick>
 800066c:	b118      	cbz	r0, 8000676 <HAL_Init+0x1e>
    status = HAL_ERROR;
 800066e:	2001      	movs	r0, #1
}
 8000670:	b003      	add	sp, #12
 8000672:	f85d fb04 	ldr.w	pc, [sp], #4
 8000676:	9001      	str	r0, [sp, #4]
    HAL_MspInit();
 8000678:	f7ff fea8 	bl	80003cc <HAL_MspInit>
 800067c:	9801      	ldr	r0, [sp, #4]
}
 800067e:	b003      	add	sp, #12
 8000680:	f85d fb04 	ldr.w	pc, [sp], #4

08000684 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000684:	4b01      	ldr	r3, [pc, #4]	; (800068c <HAL_GetTick+0x8>)
 8000686:	6818      	ldr	r0, [r3, #0]
}
 8000688:	4770      	bx	lr
 800068a:	bf00      	nop
 800068c:	200000d8 	.word	0x200000d8

08000690 <HAL_NVIC_SetPriorityGrouping>:
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000690:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000694:	4a06      	ldr	r2, [pc, #24]	; (80006b0 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priority group */
 8000696:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000698:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priority group */
 800069a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800069e:	400b      	ands	r3, r1
 80006a0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80006a4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 80006a8:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 80006aa:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80006ac:	4770      	bx	lr
 80006ae:	bf00      	nop
 80006b0:	e000ed00 	.word	0xe000ed00

080006b4 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80006b4:	4b18      	ldr	r3, [pc, #96]	; (8000718 <HAL_NVIC_SetPriority+0x64>)
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80006b6:	b430      	push	{r4, r5}
 80006b8:	68db      	ldr	r3, [r3, #12]
 80006ba:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80006be:	f1c3 0507 	rsb	r5, r3, #7
 80006c2:	2d03      	cmp	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80006c4:	f103 0403 	add.w	r4, r3, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80006c8:	bf28      	it	cs
 80006ca:	2503      	movcs	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80006cc:	2c06      	cmp	r4, #6
 80006ce:	d919      	bls.n	8000704 <HAL_NVIC_SetPriority+0x50>
 80006d0:	f04f 34ff 	mov.w	r4, #4294967295
 80006d4:	3b04      	subs	r3, #4
 80006d6:	409c      	lsls	r4, r3
 80006d8:	ea22 0404 	bic.w	r4, r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80006dc:	f04f 32ff 	mov.w	r2, #4294967295
 80006e0:	40aa      	lsls	r2, r5
 80006e2:	ea21 0102 	bic.w	r1, r1, r2
 80006e6:	fa01 f203 	lsl.w	r2, r1, r3
 80006ea:	4322      	orrs	r2, r4
 80006ec:	0152      	lsls	r2, r2, #5
  if ((int32_t)(IRQn) >= 0)
 80006ee:	2800      	cmp	r0, #0
 80006f0:	b2d2      	uxtb	r2, r2
 80006f2:	db0a      	blt.n	800070a <HAL_NVIC_SetPriority+0x56>
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006f4:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80006f8:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80006fc:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000700:	bc30      	pop	{r4, r5}
 8000702:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000704:	2400      	movs	r4, #0
 8000706:	4623      	mov	r3, r4
 8000708:	e7e8      	b.n	80006dc <HAL_NVIC_SetPriority+0x28>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800070a:	4b04      	ldr	r3, [pc, #16]	; (800071c <HAL_NVIC_SetPriority+0x68>)
 800070c:	f000 000f 	and.w	r0, r0, #15
 8000710:	4403      	add	r3, r0
 8000712:	761a      	strb	r2, [r3, #24]
 8000714:	bc30      	pop	{r4, r5}
 8000716:	4770      	bx	lr
 8000718:	e000ed00 	.word	0xe000ed00
 800071c:	e000ecfc 	.word	0xe000ecfc

08000720 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000720:	3801      	subs	r0, #1
 8000722:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000726:	d20d      	bcs.n	8000744 <HAL_SYSTICK_Config+0x24>
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8000728:	b430      	push	{r4, r5}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800072a:	25e0      	movs	r5, #224	; 0xe0
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800072c:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800072e:	2107      	movs	r1, #7
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000730:	4b05      	ldr	r3, [pc, #20]	; (8000748 <HAL_SYSTICK_Config+0x28>)
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000732:	4c06      	ldr	r4, [pc, #24]	; (800074c <HAL_SYSTICK_Config+0x2c>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000734:	6058      	str	r0, [r3, #4]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000736:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800073a:	4610      	mov	r0, r2
  return SysTick_Config(TicksNumb);
}
 800073c:	bc30      	pop	{r4, r5}
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800073e:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000740:	6019      	str	r1, [r3, #0]
 8000742:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000744:	2001      	movs	r0, #1
 8000746:	4770      	bx	lr
 8000748:	e000e010 	.word	0xe000e010
 800074c:	e000ed00 	.word	0xe000ed00

08000750 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000750:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 8000754:	f8d1 e000 	ldr.w	lr, [r1]
 8000758:	f1be 0f00 	cmp.w	lr, #0
 800075c:	d077      	beq.n	800084e <HAL_GPIO_Init+0xfe>
 800075e:	4688      	mov	r8, r1
  uint32_t position = 0U;
 8000760:	2600      	movs	r6, #0
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
        EXTI->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8000762:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 8000908 <HAL_GPIO_Init+0x1b8>
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8000766:	2301      	movs	r3, #1
 8000768:	fa03 fc06 	lsl.w	ip, r3, r6
    if(iocurrent != 0U)
 800076c:	ea1c 050e 	ands.w	r5, ip, lr
 8000770:	d069      	beq.n	8000846 <HAL_GPIO_Init+0xf6>
 8000772:	2303      	movs	r3, #3
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000774:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8000778:	0077      	lsls	r7, r6, #1
 800077a:	f021 0a10 	bic.w	sl, r1, #16
 800077e:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8000782:	f10a 34ff 	add.w	r4, sl, #4294967295
 8000786:	40bb      	lsls	r3, r7
 8000788:	2c01      	cmp	r4, #1
 800078a:	ea6f 0303 	mvn.w	r3, r3
 800078e:	fa02 f207 	lsl.w	r2, r2, r7
 8000792:	d95e      	bls.n	8000852 <HAL_GPIO_Init+0x102>
      temp = GPIOx->PUPDR;
 8000794:	68c4      	ldr	r4, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8000796:	401c      	ands	r4, r3
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8000798:	4322      	orrs	r2, r4
      GPIOx->PUPDR = temp;
 800079a:	60c2      	str	r2, [r0, #12]
      temp = GPIOx->MODER;
 800079c:	6804      	ldr	r4, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800079e:	f001 0203 	and.w	r2, r1, #3
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 80007a2:	401c      	ands	r4, r3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80007a4:	4613      	mov	r3, r2
 80007a6:	40bb      	lsls	r3, r7
 80007a8:	4323      	orrs	r3, r4
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80007aa:	00cf      	lsls	r7, r1, #3
      GPIOx->MODER = temp;
 80007ac:	6003      	str	r3, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80007ae:	d54a      	bpl.n	8000846 <HAL_GPIO_Init+0xf6>
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 80007b0:	220f      	movs	r2, #15
 80007b2:	f026 0403 	bic.w	r4, r6, #3
 80007b6:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 80007ba:	f504 343d 	add.w	r4, r4, #193536	; 0x2f400
 80007be:	f006 0303 	and.w	r3, r6, #3
        temp = EXTI->EXTICR[position >> 2U];
 80007c2:	6e27      	ldr	r7, [r4, #96]	; 0x60
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 80007c4:	00db      	lsls	r3, r3, #3
 80007c6:	409a      	lsls	r2, r3
 80007c8:	ea27 0202 	bic.w	r2, r7, r2
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 80007cc:	4f48      	ldr	r7, [pc, #288]	; (80008f0 <HAL_GPIO_Init+0x1a0>)
 80007ce:	42b8      	cmp	r0, r7
 80007d0:	d017      	beq.n	8000802 <HAL_GPIO_Init+0xb2>
 80007d2:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 80007d6:	42b8      	cmp	r0, r7
 80007d8:	d075      	beq.n	80008c6 <HAL_GPIO_Init+0x176>
 80007da:	4f46      	ldr	r7, [pc, #280]	; (80008f4 <HAL_GPIO_Init+0x1a4>)
 80007dc:	42b8      	cmp	r0, r7
 80007de:	d06d      	beq.n	80008bc <HAL_GPIO_Init+0x16c>
 80007e0:	4f45      	ldr	r7, [pc, #276]	; (80008f8 <HAL_GPIO_Init+0x1a8>)
 80007e2:	42b8      	cmp	r0, r7
 80007e4:	d079      	beq.n	80008da <HAL_GPIO_Init+0x18a>
 80007e6:	4f45      	ldr	r7, [pc, #276]	; (80008fc <HAL_GPIO_Init+0x1ac>)
 80007e8:	42b8      	cmp	r0, r7
 80007ea:	d07b      	beq.n	80008e4 <HAL_GPIO_Init+0x194>
 80007ec:	4f44      	ldr	r7, [pc, #272]	; (8000900 <HAL_GPIO_Init+0x1b0>)
 80007ee:	42b8      	cmp	r0, r7
 80007f0:	d06e      	beq.n	80008d0 <HAL_GPIO_Init+0x180>
 80007f2:	4f44      	ldr	r7, [pc, #272]	; (8000904 <HAL_GPIO_Init+0x1b4>)
 80007f4:	42b8      	cmp	r0, r7
 80007f6:	bf0c      	ite	eq
 80007f8:	2706      	moveq	r7, #6
 80007fa:	2707      	movne	r7, #7
 80007fc:	fa07 f303 	lsl.w	r3, r7, r3
 8000800:	431a      	orrs	r2, r3
        EXTI->EXTICR[position >> 2U] = temp;
 8000802:	6622      	str	r2, [r4, #96]	; 0x60
        temp &= ~(iocurrent);
 8000804:	43ea      	mvns	r2, r5
        temp = EXTI->IMR1;
 8000806:	f8d9 3080 	ldr.w	r3, [r9, #128]	; 0x80
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800080a:	03cc      	lsls	r4, r1, #15
        temp &= ~(iocurrent);
 800080c:	bf54      	ite	pl
 800080e:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8000810:	432b      	orrmi	r3, r5
        }
        EXTI->IMR1 = temp;
 8000812:	f8c9 3080 	str.w	r3, [r9, #128]	; 0x80

        temp = EXTI->EMR1;
 8000816:	f8d9 3084 	ldr.w	r3, [r9, #132]	; 0x84
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800081a:	038f      	lsls	r7, r1, #14
        temp &= ~(iocurrent);
 800081c:	bf54      	ite	pl
 800081e:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8000820:	432b      	orrmi	r3, r5
        }
        EXTI->EMR1 = temp;
 8000822:	f8c9 3084 	str.w	r3, [r9, #132]	; 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8000826:	f8d9 3000 	ldr.w	r3, [r9]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800082a:	02cc      	lsls	r4, r1, #11
        temp &= ~(iocurrent);
 800082c:	bf54      	ite	pl
 800082e:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8000830:	432b      	orrmi	r3, r5
        }
        EXTI->RTSR1 = temp;
 8000832:	f8c9 3000 	str.w	r3, [r9]

        temp = EXTI->FTSR1;
 8000836:	f8d9 3004 	ldr.w	r3, [r9, #4]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800083a:	0289      	lsls	r1, r1, #10
        temp &= ~(iocurrent);
 800083c:	bf54      	ite	pl
 800083e:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8000840:	432b      	orrmi	r3, r5
        }
        EXTI->FTSR1 = temp;
 8000842:	f8c9 3004 	str.w	r3, [r9, #4]
      }
    }

    position++;
 8000846:	3601      	adds	r6, #1
  while (((GPIO_Init->Pin) >> position) != 0U)
 8000848:	fa3e f306 	lsrs.w	r3, lr, r6
 800084c:	d18b      	bne.n	8000766 <HAL_GPIO_Init+0x16>
  }
}
 800084e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->OSPEEDR;
 8000852:	6884      	ldr	r4, [r0, #8]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000854:	f1ba 0f02 	cmp.w	sl, #2
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8000858:	ea04 0b03 	and.w	fp, r4, r3
        temp |= (GPIO_Init->Speed << (position * 2U));
 800085c:	f8d8 400c 	ldr.w	r4, [r8, #12]
 8000860:	fa04 f407 	lsl.w	r4, r4, r7
 8000864:	ea44 040b 	orr.w	r4, r4, fp
        GPIOx->OSPEEDR = temp;
 8000868:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 800086a:	f8d0 b004 	ldr.w	fp, [r0, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800086e:	f3c1 1400 	ubfx	r4, r1, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8000872:	ea2b 0c0c 	bic.w	ip, fp, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000876:	fa04 f406 	lsl.w	r4, r4, r6
 800087a:	ea44 040c 	orr.w	r4, r4, ip
        GPIOx->OTYPER = temp;
 800087e:	6044      	str	r4, [r0, #4]
      temp = GPIOx->PUPDR;
 8000880:	68c4      	ldr	r4, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8000882:	ea04 0403 	and.w	r4, r4, r3
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8000886:	ea42 0204 	orr.w	r2, r2, r4
      GPIOx->PUPDR = temp;
 800088a:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800088c:	d186      	bne.n	800079c <HAL_GPIO_Init+0x4c>
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 800088e:	f04f 0b0f 	mov.w	fp, #15
        temp = GPIOx->AFR[position >> 3U];
 8000892:	ea4f 0cd6 	mov.w	ip, r6, lsr #3
 8000896:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 800089a:	f006 0407 	and.w	r4, r6, #7
        temp = GPIOx->AFR[position >> 3U];
 800089e:	f8dc 2020 	ldr.w	r2, [ip, #32]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 80008a2:	00a4      	lsls	r4, r4, #2
 80008a4:	fa0b fb04 	lsl.w	fp, fp, r4
 80008a8:	ea22 0a0b 	bic.w	sl, r2, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80008ac:	f8d8 2010 	ldr.w	r2, [r8, #16]
 80008b0:	40a2      	lsls	r2, r4
 80008b2:	ea42 020a 	orr.w	r2, r2, sl
        GPIOx->AFR[position >> 3U] = temp;
 80008b6:	f8cc 2020 	str.w	r2, [ip, #32]
 80008ba:	e76f      	b.n	800079c <HAL_GPIO_Init+0x4c>
 80008bc:	2702      	movs	r7, #2
 80008be:	fa07 f303 	lsl.w	r3, r7, r3
 80008c2:	431a      	orrs	r2, r3
 80008c4:	e79d      	b.n	8000802 <HAL_GPIO_Init+0xb2>
 80008c6:	2701      	movs	r7, #1
 80008c8:	fa07 f303 	lsl.w	r3, r7, r3
 80008cc:	431a      	orrs	r2, r3
 80008ce:	e798      	b.n	8000802 <HAL_GPIO_Init+0xb2>
 80008d0:	2705      	movs	r7, #5
 80008d2:	fa07 f303 	lsl.w	r3, r7, r3
 80008d6:	431a      	orrs	r2, r3
 80008d8:	e793      	b.n	8000802 <HAL_GPIO_Init+0xb2>
 80008da:	2703      	movs	r7, #3
 80008dc:	fa07 f303 	lsl.w	r3, r7, r3
 80008e0:	431a      	orrs	r2, r3
 80008e2:	e78e      	b.n	8000802 <HAL_GPIO_Init+0xb2>
 80008e4:	2704      	movs	r7, #4
 80008e6:	fa07 f303 	lsl.w	r3, r7, r3
 80008ea:	431a      	orrs	r2, r3
 80008ec:	e789      	b.n	8000802 <HAL_GPIO_Init+0xb2>
 80008ee:	bf00      	nop
 80008f0:	42020000 	.word	0x42020000
 80008f4:	42020800 	.word	0x42020800
 80008f8:	42020c00 	.word	0x42020c00
 80008fc:	42021000 	.word	0x42021000
 8000900:	42021400 	.word	0x42021400
 8000904:	42021800 	.word	0x42021800
 8000908:	4002f400 	.word	0x4002f400

0800090c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800090c:	b90a      	cbnz	r2, 8000912 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800090e:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 8000910:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8000912:	6181      	str	r1, [r0, #24]
 8000914:	4770      	bx	lr
 8000916:	bf00      	nop

08000918 <HAL_ICACHE_ConfigAssociativityMode>:

  /* Check the parameters */
  assert_param(IS_ICACHE_ASSOCIATIVITY_MODE(AssociativityMode));

  /* Check cache is not enabled */
  if (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 8000918:	4907      	ldr	r1, [pc, #28]	; (8000938 <HAL_ICACHE_ConfigAssociativityMode+0x20>)
 800091a:	680b      	ldr	r3, [r1, #0]
 800091c:	f013 0301 	ands.w	r3, r3, #1
 8000920:	d106      	bne.n	8000930 <HAL_ICACHE_ConfigAssociativityMode+0x18>
  {
    status = HAL_ERROR;
  }
  else
  {
    MODIFY_REG(ICACHE->CR, ICACHE_CR_WAYSEL, AssociativityMode);
 8000922:	680a      	ldr	r2, [r1, #0]
 8000924:	f022 0204 	bic.w	r2, r2, #4
 8000928:	4310      	orrs	r0, r2
 800092a:	6008      	str	r0, [r1, #0]
  }

  return status;
}
 800092c:	4618      	mov	r0, r3
 800092e:	4770      	bx	lr
    status = HAL_ERROR;
 8000930:	2301      	movs	r3, #1
}
 8000932:	4618      	mov	r0, r3
 8000934:	4770      	bx	lr
 8000936:	bf00      	nop
 8000938:	40030400 	.word	0x40030400

0800093c <HAL_ICACHE_Enable>:
  *         cache operation completes.
  * @retval HAL status (HAL_OK)
  */
HAL_StatusTypeDef HAL_ICACHE_Enable(void)
{
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 800093c:	4a03      	ldr	r2, [pc, #12]	; (800094c <HAL_ICACHE_Enable+0x10>)

  return HAL_OK;
}
 800093e:	2000      	movs	r0, #0
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 8000940:	6813      	ldr	r3, [r2, #0]
 8000942:	f043 0301 	orr.w	r3, r3, #1
 8000946:	6013      	str	r3, [r2, #0]
}
 8000948:	4770      	bx	lr
 800094a:	bf00      	nop
 800094c:	40030400 	.word	0x40030400

08000950 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE0, PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 8000950:	4b02      	ldr	r3, [pc, #8]	; (800095c <HAL_PWREx_GetVoltageRange+0xc>)
 8000952:	6818      	ldr	r0, [r3, #0]
}
 8000954:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8000958:	4770      	bx	lr
 800095a:	bf00      	nop
 800095c:	40007000 	.word	0x40007000

08000960 <HAL_PWREx_ControlVoltageScaling>:
{
  uint32_t wait_loop_index;

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  uint32_t vos_old = READ_BIT(PWR->CR1, PWR_CR1_VOS);
 8000960:	4a1d      	ldr	r2, [pc, #116]	; (80009d8 <HAL_PWREx_ControlVoltageScaling+0x78>)
 8000962:	6813      	ldr	r3, [r2, #0]
uint32_t HAL_PWREx_SMPS_GetEffectiveMode(void)
{
  uint32_t mode;
  uint32_t pwr_sr1;

  pwr_sr1 = READ_REG(PWR->SR1);
 8000964:	6911      	ldr	r1, [r2, #16]
  if (READ_BIT(pwr_sr1, PWR_SR1_SMPSBYPRDY) != 0U)
  {
    mode = PWR_SMPS_BYPASS;
  }
  else if (READ_BIT(pwr_sr1, PWR_SR1_SMPSHPRDY) == 0U)
 8000966:	f411 4f10 	tst.w	r1, #36864	; 0x9000
 800096a:	d02e      	beq.n	80009ca <HAL_PWREx_ControlVoltageScaling+0x6a>
  if (READ_BIT(PWR->CR4, PWR_CR4_SMPSLPEN) == PWR_CR4_SMPSLPEN)
 800096c:	68d1      	ldr	r1, [r2, #12]
 800096e:	0409      	lsls	r1, r1, #16
 8000970:	d42b      	bmi.n	80009ca <HAL_PWREx_ControlVoltageScaling+0x6a>
  uint32_t vos_old = READ_BIT(PWR->CR1, PWR_CR1_VOS);
 8000972:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
  if (vos_old == VoltageScaling)
 8000976:	4283      	cmp	r3, r0
 8000978:	d02b      	beq.n	80009d2 <HAL_PWREx_ControlVoltageScaling+0x72>
  wait_loop_index = ((PWR_VOSF_SETTING_DELAY_VALUE * (SystemCoreClock / 100000U)) / 10U) + 1U;
 800097a:	2332      	movs	r3, #50	; 0x32
  MODIFY_REG(PWR->CR1, PWR_CR1_VOS, VoltageScaling);
 800097c:	6811      	ldr	r1, [r2, #0]
{
 800097e:	b410      	push	{r4}
  MODIFY_REG(PWR->CR1, PWR_CR1_VOS, VoltageScaling);
 8000980:	f421 61c0 	bic.w	r1, r1, #1536	; 0x600
 8000984:	4308      	orrs	r0, r1
  wait_loop_index = ((PWR_VOSF_SETTING_DELAY_VALUE * (SystemCoreClock / 100000U)) / 10U) + 1U;
 8000986:	4c15      	ldr	r4, [pc, #84]	; (80009dc <HAL_PWREx_ControlVoltageScaling+0x7c>)
  MODIFY_REG(PWR->CR1, PWR_CR1_VOS, VoltageScaling);
 8000988:	6010      	str	r0, [r2, #0]
  wait_loop_index = ((PWR_VOSF_SETTING_DELAY_VALUE * (SystemCoreClock / 100000U)) / 10U) + 1U;
 800098a:	6821      	ldr	r1, [r4, #0]
 800098c:	4814      	ldr	r0, [pc, #80]	; (80009e0 <HAL_PWREx_ControlVoltageScaling+0x80>)
 800098e:	0949      	lsrs	r1, r1, #5
 8000990:	fba0 0101 	umull	r0, r1, r0, r1
 8000994:	09c9      	lsrs	r1, r1, #7
 8000996:	fb03 f301 	mul.w	r3, r3, r1
 800099a:	4812      	ldr	r0, [pc, #72]	; (80009e4 <HAL_PWREx_ControlVoltageScaling+0x84>)
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800099c:	6951      	ldr	r1, [r2, #20]
  wait_loop_index = ((PWR_VOSF_SETTING_DELAY_VALUE * (SystemCoreClock / 100000U)) / 10U) + 1U;
 800099e:	fba0 0303 	umull	r0, r3, r0, r3
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80009a2:	0548      	lsls	r0, r1, #21
  wait_loop_index = ((PWR_VOSF_SETTING_DELAY_VALUE * (SystemCoreClock / 100000U)) / 10U) + 1U;
 80009a4:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 80009a8:	f103 0301 	add.w	r3, r3, #1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80009ac:	d505      	bpl.n	80009ba <HAL_PWREx_ControlVoltageScaling+0x5a>
 80009ae:	e000      	b.n	80009b2 <HAL_PWREx_ControlVoltageScaling+0x52>
 80009b0:	b11b      	cbz	r3, 80009ba <HAL_PWREx_ControlVoltageScaling+0x5a>
 80009b2:	6951      	ldr	r1, [r2, #20]
    wait_loop_index--;
 80009b4:	3b01      	subs	r3, #1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80009b6:	0549      	lsls	r1, r1, #21
 80009b8:	d4fa      	bmi.n	80009b0 <HAL_PWREx_ControlVoltageScaling+0x50>
  if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 80009ba:	4b07      	ldr	r3, [pc, #28]	; (80009d8 <HAL_PWREx_ControlVoltageScaling+0x78>)
 80009bc:	695b      	ldr	r3, [r3, #20]
 80009be:	055b      	lsls	r3, r3, #21
 80009c0:	d405      	bmi.n	80009ce <HAL_PWREx_ControlVoltageScaling+0x6e>
  return HAL_OK;
 80009c2:	2000      	movs	r0, #0
}
 80009c4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80009c8:	4770      	bx	lr
    return HAL_ERROR;
 80009ca:	2001      	movs	r0, #1
 80009cc:	4770      	bx	lr
    return HAL_TIMEOUT;
 80009ce:	2003      	movs	r0, #3
 80009d0:	e7f8      	b.n	80009c4 <HAL_PWREx_ControlVoltageScaling+0x64>
  return HAL_OK;
 80009d2:	2000      	movs	r0, #0
}
 80009d4:	4770      	bx	lr
 80009d6:	bf00      	nop
 80009d8:	40007000 	.word	0x40007000
 80009dc:	20000000 	.word	0x20000000
 80009e0:	0a7c5ac5 	.word	0x0a7c5ac5
 80009e4:	cccccccd 	.word	0xcccccccd

080009e8 <HAL_PWREx_DisableUCPDDeadBattery>:
  SET_BIT(PWR->CR3, PWR_CR3_UCPD_DBDIS);
 80009e8:	4a02      	ldr	r2, [pc, #8]	; (80009f4 <HAL_PWREx_DisableUCPDDeadBattery+0xc>)
 80009ea:	6893      	ldr	r3, [r2, #8]
 80009ec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80009f0:	6093      	str	r3, [r2, #8]
}
 80009f2:	4770      	bx	lr
 80009f4:	40007000 	.word	0x40007000

080009f8 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t msirange = 0U, sysclockfreq = 0U;
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80009f8:	4a27      	ldr	r2, [pc, #156]	; (8000a98 <HAL_RCC_GetSysClockFreq+0xa0>)
 80009fa:	6893      	ldr	r3, [r2, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 80009fc:	68d2      	ldr	r2, [r2, #12]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80009fe:	f013 030c 	ands.w	r3, r3, #12
 8000a02:	d008      	beq.n	8000a16 <HAL_RCC_GetSysClockFreq+0x1e>
 8000a04:	2b0c      	cmp	r3, #12
 8000a06:	d038      	beq.n	8000a7a <HAL_RCC_GetSysClockFreq+0x82>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 8000a08:	2b04      	cmp	r3, #4
 8000a0a:	4824      	ldr	r0, [pc, #144]	; (8000a9c <HAL_RCC_GetSysClockFreq+0xa4>)
 8000a0c:	d03b      	beq.n	8000a86 <HAL_RCC_GetSysClockFreq+0x8e>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8000a0e:	2b08      	cmp	r3, #8
 8000a10:	bf18      	it	ne
 8000a12:	2000      	movne	r0, #0
 8000a14:	4770      	bx	lr
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8000a16:	4a20      	ldr	r2, [pc, #128]	; (8000a98 <HAL_RCC_GetSysClockFreq+0xa0>)
 8000a18:	6811      	ldr	r1, [r2, #0]
 8000a1a:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8000a1c:	bf54      	ite	pl
 8000a1e:	f8d2 2094 	ldrpl.w	r2, [r2, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8000a22:	6812      	ldrmi	r2, [r2, #0]
    msirange = MSIRangeTable[msirange];
 8000a24:	491e      	ldr	r1, [pc, #120]	; (8000aa0 <HAL_RCC_GetSysClockFreq+0xa8>)
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8000a26:	bf54      	ite	pl
 8000a28:	f3c2 2203 	ubfxpl	r2, r2, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8000a2c:	f3c2 1203 	ubfxmi	r2, r2, #4, #4
    msirange = MSIRangeTable[msirange];
 8000a30:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8000a34:	b303      	cbz	r3, 8000a78 <HAL_RCC_GetSysClockFreq+0x80>
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000a36:	2b0c      	cmp	r3, #12
 8000a38:	d11d      	bne.n	8000a76 <HAL_RCC_GetSysClockFreq+0x7e>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8000a3a:	4917      	ldr	r1, [pc, #92]	; (8000a98 <HAL_RCC_GetSysClockFreq+0xa0>)
 8000a3c:	68ca      	ldr	r2, [r1, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8000a3e:	68cb      	ldr	r3, [r1, #12]
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8000a40:	f002 0203 	and.w	r2, r2, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8000a44:	f3c3 1303 	ubfx	r3, r3, #4, #4

    switch (pllsource)
 8000a48:	2a02      	cmp	r2, #2
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8000a4a:	f103 0301 	add.w	r3, r3, #1
    switch (pllsource)
 8000a4e:	d001      	beq.n	8000a54 <HAL_RCC_GetSysClockFreq+0x5c>
 8000a50:	2a03      	cmp	r2, #3
 8000a52:	d119      	bne.n	8000a88 <HAL_RCC_GetSysClockFreq+0x90>
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
        break;

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8000a54:	4811      	ldr	r0, [pc, #68]	; (8000a9c <HAL_RCC_GetSysClockFreq+0xa4>)
 8000a56:	68ca      	ldr	r2, [r1, #12]
 8000a58:	fbb0 f0f3 	udiv	r0, r0, r3
 8000a5c:	f3c2 2306 	ubfx	r3, r2, #8, #7
 8000a60:	fb00 f003 	mul.w	r0, r0, r3
      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
        break;
    }
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 8000a64:	4b0c      	ldr	r3, [pc, #48]	; (8000a98 <HAL_RCC_GetSysClockFreq+0xa0>)
 8000a66:	68db      	ldr	r3, [r3, #12]
 8000a68:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8000a6c:	3301      	adds	r3, #1
 8000a6e:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco / pllr;
 8000a70:	fbb0 f0f3 	udiv	r0, r0, r3
 8000a74:	4770      	bx	lr
 8000a76:	2000      	movs	r0, #0
  }

  return sysclockfreq;
}
 8000a78:	4770      	bx	lr
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8000a7a:	f002 0203 	and.w	r2, r2, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8000a7e:	2a01      	cmp	r2, #1
 8000a80:	d0c9      	beq.n	8000a16 <HAL_RCC_GetSysClockFreq+0x1e>
  uint32_t msirange = 0U, sysclockfreq = 0U;
 8000a82:	2000      	movs	r0, #0
 8000a84:	e7d9      	b.n	8000a3a <HAL_RCC_GetSysClockFreq+0x42>
 8000a86:	4770      	bx	lr
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8000a88:	fbb0 f0f3 	udiv	r0, r0, r3
 8000a8c:	68cb      	ldr	r3, [r1, #12]
 8000a8e:	f3c3 2306 	ubfx	r3, r3, #8, #7
 8000a92:	fb00 f003 	mul.w	r0, r0, r3
        break;
 8000a96:	e7e5      	b.n	8000a64 <HAL_RCC_GetSysClockFreq+0x6c>
 8000a98:	40021000 	.word	0x40021000
 8000a9c:	00f42400 	.word	0x00f42400
 8000aa0:	08014f50 	.word	0x08014f50

08000aa4 <HAL_RCC_OscConfig>:
  if (RCC_OscInitStruct == NULL)
 8000aa4:	2800      	cmp	r0, #0
 8000aa6:	f000 81e2 	beq.w	8000e6e <HAL_RCC_OscConfig+0x3ca>
{
 8000aaa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8000aae:	4aaf      	ldr	r2, [pc, #700]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8000ab0:	6803      	ldr	r3, [r0, #0]
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8000ab2:	6895      	ldr	r5, [r2, #8]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8000ab4:	68d6      	ldr	r6, [r2, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8000ab6:	06da      	lsls	r2, r3, #27
{
 8000ab8:	b084      	sub	sp, #16
 8000aba:	4604      	mov	r4, r0
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8000abc:	f005 050c 	and.w	r5, r5, #12
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8000ac0:	f006 0603 	and.w	r6, r6, #3
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8000ac4:	d52f      	bpl.n	8000b26 <HAL_RCC_OscConfig+0x82>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8000ac6:	2d00      	cmp	r5, #0
 8000ac8:	f000 8157 	beq.w	8000d7a <HAL_RCC_OscConfig+0x2d6>
 8000acc:	2d0c      	cmp	r5, #12
 8000ace:	f000 8151 	beq.w	8000d74 <HAL_RCC_OscConfig+0x2d0>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8000ad2:	69e3      	ldr	r3, [r4, #28]
 8000ad4:	2b00      	cmp	r3, #0
 8000ad6:	f000 81b4 	beq.w	8000e42 <HAL_RCC_OscConfig+0x39e>
        __HAL_RCC_MSI_ENABLE();
 8000ada:	4ba4      	ldr	r3, [pc, #656]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
 8000adc:	681a      	ldr	r2, [r3, #0]
        while (READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8000ade:	461f      	mov	r7, r3
        __HAL_RCC_MSI_ENABLE();
 8000ae0:	f042 0201 	orr.w	r2, r2, #1
 8000ae4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8000ae6:	f7ff fdcd 	bl	8000684 <HAL_GetTick>
 8000aea:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8000aec:	e006      	b.n	8000afc <HAL_RCC_OscConfig+0x58>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8000aee:	f7ff fdc9 	bl	8000684 <HAL_GetTick>
 8000af2:	eba0 0008 	sub.w	r0, r0, r8
 8000af6:	2802      	cmp	r0, #2
 8000af8:	f200 81b5 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8000afc:	683b      	ldr	r3, [r7, #0]
 8000afe:	079a      	lsls	r2, r3, #30
 8000b00:	d5f5      	bpl.n	8000aee <HAL_RCC_OscConfig+0x4a>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000b02:	683b      	ldr	r3, [r7, #0]
 8000b04:	f043 0308 	orr.w	r3, r3, #8
 8000b08:	603b      	str	r3, [r7, #0]
 8000b0a:	683b      	ldr	r3, [r7, #0]
 8000b0c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000b0e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8000b12:	4313      	orrs	r3, r2
 8000b14:	603b      	str	r3, [r7, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000b16:	687b      	ldr	r3, [r7, #4]
 8000b18:	6a22      	ldr	r2, [r4, #32]
 8000b1a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8000b1e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000b22:	607b      	str	r3, [r7, #4]
 8000b24:	6823      	ldr	r3, [r4, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000b26:	07d8      	lsls	r0, r3, #31
 8000b28:	f100 80f6 	bmi.w	8000d18 <HAL_RCC_OscConfig+0x274>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000b2c:	079f      	lsls	r7, r3, #30
 8000b2e:	d524      	bpl.n	8000b7a <HAL_RCC_OscConfig+0xd6>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 8000b30:	2d04      	cmp	r5, #4
 8000b32:	f000 8176 	beq.w	8000e22 <HAL_RCC_OscConfig+0x37e>
 8000b36:	2d0c      	cmp	r5, #12
 8000b38:	f000 8170 	beq.w	8000e1c <HAL_RCC_OscConfig+0x378>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000b3c:	68e3      	ldr	r3, [r4, #12]
 8000b3e:	2b00      	cmp	r3, #0
 8000b40:	f000 81ad 	beq.w	8000e9e <HAL_RCC_OscConfig+0x3fa>
        __HAL_RCC_HSI_ENABLE();
 8000b44:	4b89      	ldr	r3, [pc, #548]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
 8000b46:	681a      	ldr	r2, [r3, #0]
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8000b48:	461e      	mov	r6, r3
        __HAL_RCC_HSI_ENABLE();
 8000b4a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000b4e:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8000b50:	f7ff fd98 	bl	8000684 <HAL_GetTick>
 8000b54:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8000b56:	e005      	b.n	8000b64 <HAL_RCC_OscConfig+0xc0>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8000b58:	f7ff fd94 	bl	8000684 <HAL_GetTick>
 8000b5c:	1b40      	subs	r0, r0, r5
 8000b5e:	2802      	cmp	r0, #2
 8000b60:	f200 8181 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8000b64:	6833      	ldr	r3, [r6, #0]
 8000b66:	0558      	lsls	r0, r3, #21
 8000b68:	d5f6      	bpl.n	8000b58 <HAL_RCC_OscConfig+0xb4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000b6a:	6873      	ldr	r3, [r6, #4]
 8000b6c:	6922      	ldr	r2, [r4, #16]
 8000b6e:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8000b72:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8000b76:	6073      	str	r3, [r6, #4]
 8000b78:	6823      	ldr	r3, [r4, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000b7a:	071a      	lsls	r2, r3, #28
 8000b7c:	d525      	bpl.n	8000bca <HAL_RCC_OscConfig+0x126>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8000b7e:	6963      	ldr	r3, [r4, #20]
 8000b80:	2b00      	cmp	r3, #0
 8000b82:	f000 81a7 	beq.w	8000ed4 <HAL_RCC_OscConfig+0x430>
      if (RCC_OscInitStruct->LSIDiv == RCC_LSI_DIV1)
 8000b86:	69a3      	ldr	r3, [r4, #24]
        CLEAR_BIT(RCC->CSR, RCC_CSR_LSIPRE);
 8000b88:	4a78      	ldr	r2, [pc, #480]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
      if (RCC_OscInitStruct->LSIDiv == RCC_LSI_DIV1)
 8000b8a:	2b00      	cmp	r3, #0
 8000b8c:	f040 819b 	bne.w	8000ec6 <HAL_RCC_OscConfig+0x422>
        CLEAR_BIT(RCC->CSR, RCC_CSR_LSIPRE);
 8000b90:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8000b94:	f023 0310 	bic.w	r3, r3, #16
 8000b98:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
      __HAL_RCC_LSI_ENABLE();
 8000b9c:	4b73      	ldr	r3, [pc, #460]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
 8000b9e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8000ba2:	461d      	mov	r5, r3
      __HAL_RCC_LSI_ENABLE();
 8000ba4:	f042 0201 	orr.w	r2, r2, #1
 8000ba8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
      tickstart = HAL_GetTick();
 8000bac:	f7ff fd6a 	bl	8000684 <HAL_GetTick>
 8000bb0:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8000bb2:	e005      	b.n	8000bc0 <HAL_RCC_OscConfig+0x11c>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8000bb4:	f7ff fd66 	bl	8000684 <HAL_GetTick>
 8000bb8:	1b80      	subs	r0, r0, r6
 8000bba:	2807      	cmp	r0, #7
 8000bbc:	f200 8153 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8000bc0:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8000bc4:	079b      	lsls	r3, r3, #30
 8000bc6:	d5f5      	bpl.n	8000bb4 <HAL_RCC_OscConfig+0x110>
 8000bc8:	6823      	ldr	r3, [r4, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000bca:	075d      	lsls	r5, r3, #29
 8000bcc:	d559      	bpl.n	8000c82 <HAL_RCC_OscConfig+0x1de>
    if (HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8000bce:	4b67      	ldr	r3, [pc, #412]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
 8000bd0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000bd2:	00d0      	lsls	r0, r2, #3
 8000bd4:	f100 8161 	bmi.w	8000e9a <HAL_RCC_OscConfig+0x3f6>
      pwrclkchanged = SET;
 8000bd8:	2601      	movs	r6, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 8000bda:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000bdc:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000be0:	659a      	str	r2, [r3, #88]	; 0x58
 8000be2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000be4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000be8:	9301      	str	r3, [sp, #4]
 8000bea:	9b01      	ldr	r3, [sp, #4]
    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8000bec:	4b60      	ldr	r3, [pc, #384]	; (8000d70 <HAL_RCC_OscConfig+0x2cc>)
 8000bee:	681a      	ldr	r2, [r3, #0]
 8000bf0:	05d1      	lsls	r1, r2, #23
 8000bf2:	f140 8261 	bpl.w	80010b8 <HAL_RCC_OscConfig+0x614>
    if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSEON) != 0U)
 8000bf6:	68a3      	ldr	r3, [r4, #8]
 8000bf8:	07da      	lsls	r2, r3, #31
 8000bfa:	f140 8181 	bpl.w	8000f00 <HAL_RCC_OscConfig+0x45c>
      if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSEBYP) != 0U)
 8000bfe:	0758      	lsls	r0, r3, #29
 8000c00:	f140 8210 	bpl.w	8001024 <HAL_RCC_OscConfig+0x580>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8000c04:	4b59      	ldr	r3, [pc, #356]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
 8000c06:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8000c0a:	f042 0204 	orr.w	r2, r2, #4
 8000c0e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8000c12:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8000c16:	f042 0201 	orr.w	r2, r2, #1
 8000c1a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
      tickstart = HAL_GetTick();
 8000c1e:	f7ff fd31 	bl	8000684 <HAL_GetTick>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8000c22:	f8df 8148 	ldr.w	r8, [pc, #328]	; 8000d6c <HAL_RCC_OscConfig+0x2c8>
      tickstart = HAL_GetTick();
 8000c26:	4607      	mov	r7, r0
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000c28:	f241 3588 	movw	r5, #5000	; 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8000c2c:	e005      	b.n	8000c3a <HAL_RCC_OscConfig+0x196>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000c2e:	f7ff fd29 	bl	8000684 <HAL_GetTick>
 8000c32:	1bc0      	subs	r0, r0, r7
 8000c34:	42a8      	cmp	r0, r5
 8000c36:	f200 8116 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8000c3a:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 8000c3e:	0799      	lsls	r1, r3, #30
 8000c40:	d5f5      	bpl.n	8000c2e <HAL_RCC_OscConfig+0x18a>
      if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 8000c42:	68a3      	ldr	r3, [r4, #8]
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8000c44:	4d49      	ldr	r5, [pc, #292]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
      if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 8000c46:	f013 0f80 	tst.w	r3, #128	; 0x80
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8000c4a:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
      if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 8000c4e:	f000 8295 	beq.w	800117c <HAL_RCC_OscConfig+0x6d8>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8000c52:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000c56:	f8c8 3090 	str.w	r3, [r8, #144]	; 0x90
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000c5a:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8000c5e:	e005      	b.n	8000c6c <HAL_RCC_OscConfig+0x1c8>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000c60:	f7ff fd10 	bl	8000684 <HAL_GetTick>
 8000c64:	1bc0      	subs	r0, r0, r7
 8000c66:	4540      	cmp	r0, r8
 8000c68:	f200 80fd 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8000c6c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8000c70:	051a      	lsls	r2, r3, #20
 8000c72:	d5f5      	bpl.n	8000c60 <HAL_RCC_OscConfig+0x1bc>
    if (pwrclkchanged == SET)
 8000c74:	b126      	cbz	r6, 8000c80 <HAL_RCC_OscConfig+0x1dc>
      __HAL_RCC_PWR_CLK_DISABLE();
 8000c76:	4a3d      	ldr	r2, [pc, #244]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
 8000c78:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8000c7a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000c7e:	6593      	str	r3, [r2, #88]	; 0x58
 8000c80:	6823      	ldr	r3, [r4, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8000c82:	069b      	lsls	r3, r3, #26
 8000c84:	d519      	bpl.n	8000cba <HAL_RCC_OscConfig+0x216>
    if (RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8000c86:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000c88:	2b00      	cmp	r3, #0
 8000c8a:	f000 81b4 	beq.w	8000ff6 <HAL_RCC_OscConfig+0x552>
      __HAL_RCC_HSI48_ENABLE();
 8000c8e:	4b37      	ldr	r3, [pc, #220]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
 8000c90:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
      while (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8000c94:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_ENABLE();
 8000c96:	f042 0201 	orr.w	r2, r2, #1
 8000c9a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
      tickstart = HAL_GetTick();
 8000c9e:	f7ff fcf1 	bl	8000684 <HAL_GetTick>
 8000ca2:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8000ca4:	e005      	b.n	8000cb2 <HAL_RCC_OscConfig+0x20e>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8000ca6:	f7ff fced 	bl	8000684 <HAL_GetTick>
 8000caa:	1b80      	subs	r0, r0, r6
 8000cac:	2802      	cmp	r0, #2
 8000cae:	f200 80da 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
      while (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8000cb2:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8000cb6:	079f      	lsls	r7, r3, #30
 8000cb8:	d5f5      	bpl.n	8000ca6 <HAL_RCC_OscConfig+0x202>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8000cba:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8000cbc:	b350      	cbz	r0, 8000d14 <HAL_RCC_OscConfig+0x270>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000cbe:	4b2b      	ldr	r3, [pc, #172]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
 8000cc0:	689a      	ldr	r2, [r3, #8]
 8000cc2:	f002 020c 	and.w	r2, r2, #12
 8000cc6:	2a0c      	cmp	r2, #12
 8000cc8:	f000 81c2 	beq.w	8001050 <HAL_RCC_OscConfig+0x5ac>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8000ccc:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 8000cce:	681a      	ldr	r2, [r3, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8000cd0:	f000 8266 	beq.w	80011a0 <HAL_RCC_OscConfig+0x6fc>
        __HAL_RCC_PLL_DISABLE();
 8000cd4:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8000cd8:	601a      	str	r2, [r3, #0]
        if (READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 8000cda:	681a      	ldr	r2, [r3, #0]
 8000cdc:	f012 5f20 	tst.w	r2, #671088640	; 0x28000000
 8000ce0:	d103      	bne.n	8000cea <HAL_RCC_OscConfig+0x246>
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8000ce2:	68da      	ldr	r2, [r3, #12]
 8000ce4:	f022 0203 	bic.w	r2, r2, #3
 8000ce8:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 8000cea:	4a20      	ldr	r2, [pc, #128]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
 8000cec:	68d3      	ldr	r3, [r2, #12]
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8000cee:	4614      	mov	r4, r2
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 8000cf0:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8000cf4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000cf8:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 8000cfa:	f7ff fcc3 	bl	8000684 <HAL_GetTick>
 8000cfe:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8000d00:	e005      	b.n	8000d0e <HAL_RCC_OscConfig+0x26a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8000d02:	f7ff fcbf 	bl	8000684 <HAL_GetTick>
 8000d06:	1b40      	subs	r0, r0, r5
 8000d08:	2802      	cmp	r0, #2
 8000d0a:	f200 80ac 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8000d0e:	6823      	ldr	r3, [r4, #0]
 8000d10:	019b      	lsls	r3, r3, #6
 8000d12:	d4f6      	bmi.n	8000d02 <HAL_RCC_OscConfig+0x25e>
  return HAL_OK;
 8000d14:	2000      	movs	r0, #0
 8000d16:	e072      	b.n	8000dfe <HAL_RCC_OscConfig+0x35a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 8000d18:	2d08      	cmp	r5, #8
 8000d1a:	d075      	beq.n	8000e08 <HAL_RCC_OscConfig+0x364>
 8000d1c:	2d0c      	cmp	r5, #12
 8000d1e:	d071      	beq.n	8000e04 <HAL_RCC_OscConfig+0x360>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000d20:	6863      	ldr	r3, [r4, #4]
 8000d22:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8000d26:	f000 80a4 	beq.w	8000e72 <HAL_RCC_OscConfig+0x3ce>
 8000d2a:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8000d2e:	f000 81ff 	beq.w	8001130 <HAL_RCC_OscConfig+0x68c>
 8000d32:	4f0e      	ldr	r7, [pc, #56]	; (8000d6c <HAL_RCC_OscConfig+0x2c8>)
 8000d34:	683a      	ldr	r2, [r7, #0]
 8000d36:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000d3a:	603a      	str	r2, [r7, #0]
 8000d3c:	683a      	ldr	r2, [r7, #0]
 8000d3e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000d42:	603a      	str	r2, [r7, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8000d44:	2b00      	cmp	r3, #0
 8000d46:	f040 8099 	bne.w	8000e7c <HAL_RCC_OscConfig+0x3d8>
        tickstart = HAL_GetTick();
 8000d4a:	f7ff fc9b 	bl	8000684 <HAL_GetTick>
 8000d4e:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8000d50:	e006      	b.n	8000d60 <HAL_RCC_OscConfig+0x2bc>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8000d52:	f7ff fc97 	bl	8000684 <HAL_GetTick>
 8000d56:	eba0 0008 	sub.w	r0, r0, r8
 8000d5a:	2864      	cmp	r0, #100	; 0x64
 8000d5c:	f200 8083 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8000d60:	683b      	ldr	r3, [r7, #0]
 8000d62:	039b      	lsls	r3, r3, #14
 8000d64:	d4f5      	bmi.n	8000d52 <HAL_RCC_OscConfig+0x2ae>
 8000d66:	6823      	ldr	r3, [r4, #0]
 8000d68:	e6e0      	b.n	8000b2c <HAL_RCC_OscConfig+0x88>
 8000d6a:	bf00      	nop
 8000d6c:	40021000 	.word	0x40021000
 8000d70:	40007000 	.word	0x40007000
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 8000d74:	2e01      	cmp	r6, #1
 8000d76:	f47f aeac 	bne.w	8000ad2 <HAL_RCC_OscConfig+0x2e>
      if ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8000d7a:	4bb0      	ldr	r3, [pc, #704]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000d7c:	681b      	ldr	r3, [r3, #0]
 8000d7e:	079b      	lsls	r3, r3, #30
 8000d80:	d439      	bmi.n	8000df6 <HAL_RCC_OscConfig+0x352>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8000d82:	4bae      	ldr	r3, [pc, #696]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000d84:	f8d4 8024 	ldr.w	r8, [r4, #36]	; 0x24
 8000d88:	681a      	ldr	r2, [r3, #0]
 8000d8a:	0717      	lsls	r7, r2, #28
 8000d8c:	bf56      	itet	pl
 8000d8e:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 8000d92:	681b      	ldrmi	r3, [r3, #0]
 8000d94:	091b      	lsrpl	r3, r3, #4
 8000d96:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8000d9a:	4598      	cmp	r8, r3
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t vos;

  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 8000d9c:	4fa7      	ldr	r7, [pc, #668]	; (800103c <HAL_RCC_OscConfig+0x598>)
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8000d9e:	f200 80ea 	bhi.w	8000f76 <HAL_RCC_OscConfig+0x4d2>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000da2:	683b      	ldr	r3, [r7, #0]
 8000da4:	f043 0308 	orr.w	r3, r3, #8
 8000da8:	603b      	str	r3, [r7, #0]
 8000daa:	683b      	ldr	r3, [r7, #0]
 8000dac:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8000db0:	ea43 0308 	orr.w	r3, r3, r8
 8000db4:	603b      	str	r3, [r7, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000db6:	687b      	ldr	r3, [r7, #4]
 8000db8:	6a22      	ldr	r2, [r4, #32]
 8000dba:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8000dbe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000dc2:	607b      	str	r3, [r7, #4]
          if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8000dc4:	2d00      	cmp	r5, #0
 8000dc6:	f000 8189 	beq.w	80010dc <HAL_RCC_OscConfig+0x638>
  return (HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]);
 8000dca:	f7ff fe15 	bl	80009f8 <HAL_RCC_GetSysClockFreq>
 8000dce:	4b9b      	ldr	r3, [pc, #620]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000dd0:	4a9b      	ldr	r2, [pc, #620]	; (8001040 <HAL_RCC_OscConfig+0x59c>)
 8000dd2:	689b      	ldr	r3, [r3, #8]
        status = HAL_InitTick(uwTickPrio);
 8000dd4:	499b      	ldr	r1, [pc, #620]	; (8001044 <HAL_RCC_OscConfig+0x5a0>)
  return (HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]);
 8000dd6:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8000dda:	5cd3      	ldrb	r3, [r2, r3]
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8000ddc:	4a9a      	ldr	r2, [pc, #616]	; (8001048 <HAL_RCC_OscConfig+0x5a4>)
  return (HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]);
 8000dde:	fa20 f303 	lsr.w	r3, r0, r3
        status = HAL_InitTick(uwTickPrio);
 8000de2:	6808      	ldr	r0, [r1, #0]
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8000de4:	6013      	str	r3, [r2, #0]
        status = HAL_InitTick(uwTickPrio);
 8000de6:	f7ff fc11 	bl	800060c <HAL_InitTick>
        if (status != HAL_OK)
 8000dea:	b940      	cbnz	r0, 8000dfe <HAL_RCC_OscConfig+0x35a>
 8000dec:	6823      	ldr	r3, [r4, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000dee:	07d8      	lsls	r0, r3, #31
 8000df0:	f57f ae9c 	bpl.w	8000b2c <HAL_RCC_OscConfig+0x88>
 8000df4:	e790      	b.n	8000d18 <HAL_RCC_OscConfig+0x274>
      if ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8000df6:	69e3      	ldr	r3, [r4, #28]
 8000df8:	2b00      	cmp	r3, #0
 8000dfa:	d1c2      	bne.n	8000d82 <HAL_RCC_OscConfig+0x2de>
        return HAL_ERROR;
 8000dfc:	2001      	movs	r0, #1
}
 8000dfe:	b004      	add	sp, #16
 8000e00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 8000e04:	2e03      	cmp	r6, #3
 8000e06:	d18b      	bne.n	8000d20 <HAL_RCC_OscConfig+0x27c>
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000e08:	4a8c      	ldr	r2, [pc, #560]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000e0a:	6812      	ldr	r2, [r2, #0]
 8000e0c:	0391      	lsls	r1, r2, #14
 8000e0e:	f57f ae8d 	bpl.w	8000b2c <HAL_RCC_OscConfig+0x88>
 8000e12:	6862      	ldr	r2, [r4, #4]
 8000e14:	2a00      	cmp	r2, #0
 8000e16:	f47f ae89 	bne.w	8000b2c <HAL_RCC_OscConfig+0x88>
 8000e1a:	e7ef      	b.n	8000dfc <HAL_RCC_OscConfig+0x358>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 8000e1c:	2e02      	cmp	r6, #2
 8000e1e:	f47f ae8d 	bne.w	8000b3c <HAL_RCC_OscConfig+0x98>
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8000e22:	4a86      	ldr	r2, [pc, #536]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000e24:	6812      	ldr	r2, [r2, #0]
 8000e26:	0555      	lsls	r5, r2, #21
 8000e28:	d502      	bpl.n	8000e30 <HAL_RCC_OscConfig+0x38c>
 8000e2a:	68e2      	ldr	r2, [r4, #12]
 8000e2c:	2a00      	cmp	r2, #0
 8000e2e:	d0e5      	beq.n	8000dfc <HAL_RCC_OscConfig+0x358>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000e30:	4982      	ldr	r1, [pc, #520]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000e32:	6920      	ldr	r0, [r4, #16]
 8000e34:	684a      	ldr	r2, [r1, #4]
 8000e36:	f022 42fe 	bic.w	r2, r2, #2130706432	; 0x7f000000
 8000e3a:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8000e3e:	604a      	str	r2, [r1, #4]
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8000e40:	e69b      	b.n	8000b7a <HAL_RCC_OscConfig+0xd6>
        __HAL_RCC_MSI_DISABLE();
 8000e42:	4b7e      	ldr	r3, [pc, #504]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000e44:	681a      	ldr	r2, [r3, #0]
        while (READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8000e46:	4698      	mov	r8, r3
        __HAL_RCC_MSI_DISABLE();
 8000e48:	f022 0201 	bic.w	r2, r2, #1
 8000e4c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8000e4e:	f7ff fc19 	bl	8000684 <HAL_GetTick>
 8000e52:	4607      	mov	r7, r0
        while (READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8000e54:	f8d8 3000 	ldr.w	r3, [r8]
 8000e58:	079b      	lsls	r3, r3, #30
 8000e5a:	d5c7      	bpl.n	8000dec <HAL_RCC_OscConfig+0x348>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8000e5c:	f7ff fc12 	bl	8000684 <HAL_GetTick>
 8000e60:	1bc0      	subs	r0, r0, r7
 8000e62:	2802      	cmp	r0, #2
 8000e64:	d9f6      	bls.n	8000e54 <HAL_RCC_OscConfig+0x3b0>
            return HAL_TIMEOUT;
 8000e66:	2003      	movs	r0, #3
}
 8000e68:	b004      	add	sp, #16
 8000e6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_ERROR;
 8000e6e:	2001      	movs	r0, #1
}
 8000e70:	4770      	bx	lr
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000e72:	4a72      	ldr	r2, [pc, #456]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000e74:	6813      	ldr	r3, [r2, #0]
 8000e76:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000e7a:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8000e7c:	f7ff fc02 	bl	8000684 <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8000e80:	4f6e      	ldr	r7, [pc, #440]	; (800103c <HAL_RCC_OscConfig+0x598>)
        tickstart = HAL_GetTick();
 8000e82:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8000e84:	e005      	b.n	8000e92 <HAL_RCC_OscConfig+0x3ee>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8000e86:	f7ff fbfd 	bl	8000684 <HAL_GetTick>
 8000e8a:	eba0 0008 	sub.w	r0, r0, r8
 8000e8e:	2864      	cmp	r0, #100	; 0x64
 8000e90:	d8e9      	bhi.n	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8000e92:	683b      	ldr	r3, [r7, #0]
 8000e94:	039a      	lsls	r2, r3, #14
 8000e96:	d5f6      	bpl.n	8000e86 <HAL_RCC_OscConfig+0x3e2>
 8000e98:	e765      	b.n	8000d66 <HAL_RCC_OscConfig+0x2c2>
    FlagStatus       pwrclkchanged = RESET;
 8000e9a:	2600      	movs	r6, #0
 8000e9c:	e6a6      	b.n	8000bec <HAL_RCC_OscConfig+0x148>
        __HAL_RCC_HSI_DISABLE();
 8000e9e:	4b67      	ldr	r3, [pc, #412]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000ea0:	681a      	ldr	r2, [r3, #0]
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8000ea2:	461d      	mov	r5, r3
        __HAL_RCC_HSI_DISABLE();
 8000ea4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8000ea8:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8000eaa:	f7ff fbeb 	bl	8000684 <HAL_GetTick>
 8000eae:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8000eb0:	e004      	b.n	8000ebc <HAL_RCC_OscConfig+0x418>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8000eb2:	f7ff fbe7 	bl	8000684 <HAL_GetTick>
 8000eb6:	1b80      	subs	r0, r0, r6
 8000eb8:	2802      	cmp	r0, #2
 8000eba:	d8d4      	bhi.n	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8000ebc:	682b      	ldr	r3, [r5, #0]
 8000ebe:	0559      	lsls	r1, r3, #21
 8000ec0:	d4f7      	bmi.n	8000eb2 <HAL_RCC_OscConfig+0x40e>
 8000ec2:	6823      	ldr	r3, [r4, #0]
 8000ec4:	e659      	b.n	8000b7a <HAL_RCC_OscConfig+0xd6>
        SET_BIT(RCC->CSR, RCC_CSR_LSIPRE);
 8000ec6:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8000eca:	f043 0310 	orr.w	r3, r3, #16
 8000ece:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 8000ed2:	e663      	b.n	8000b9c <HAL_RCC_OscConfig+0xf8>
      __HAL_RCC_LSI_DISABLE();
 8000ed4:	4b59      	ldr	r3, [pc, #356]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000ed6:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8000eda:	461d      	mov	r5, r3
      __HAL_RCC_LSI_DISABLE();
 8000edc:	f022 0201 	bic.w	r2, r2, #1
 8000ee0:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
      tickstart = HAL_GetTick();
 8000ee4:	f7ff fbce 	bl	8000684 <HAL_GetTick>
 8000ee8:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8000eea:	e004      	b.n	8000ef6 <HAL_RCC_OscConfig+0x452>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8000eec:	f7ff fbca 	bl	8000684 <HAL_GetTick>
 8000ef0:	1b80      	subs	r0, r0, r6
 8000ef2:	2807      	cmp	r0, #7
 8000ef4:	d8b7      	bhi.n	8000e66 <HAL_RCC_OscConfig+0x3c2>
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8000ef6:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8000efa:	079f      	lsls	r7, r3, #30
 8000efc:	d4f6      	bmi.n	8000eec <HAL_RCC_OscConfig+0x448>
 8000efe:	e663      	b.n	8000bc8 <HAL_RCC_OscConfig+0x124>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8000f00:	4d4e      	ldr	r5, [pc, #312]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000f02:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8000f06:	f022 0201 	bic.w	r2, r2, #1
 8000f0a:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8000f0e:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8000f12:	f022 0204 	bic.w	r2, r2, #4
 8000f16:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8000f1a:	2b00      	cmp	r3, #0
 8000f1c:	f47f ae7f 	bne.w	8000c1e <HAL_RCC_OscConfig+0x17a>
      tickstart = HAL_GetTick();
 8000f20:	f7ff fbb0 	bl	8000684 <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000f24:	f241 3788 	movw	r7, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8000f28:	4680      	mov	r8, r0
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8000f2a:	e005      	b.n	8000f38 <HAL_RCC_OscConfig+0x494>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000f2c:	f7ff fbaa 	bl	8000684 <HAL_GetTick>
 8000f30:	eba0 0008 	sub.w	r0, r0, r8
 8000f34:	42b8      	cmp	r0, r7
 8000f36:	d896      	bhi.n	8000e66 <HAL_RCC_OscConfig+0x3c2>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8000f38:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8000f3c:	0798      	lsls	r0, r3, #30
 8000f3e:	d4f5      	bmi.n	8000f2c <HAL_RCC_OscConfig+0x488>
      if (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN) != 0U)
 8000f40:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8000f44:	0619      	lsls	r1, r3, #24
 8000f46:	f57f ae95 	bpl.w	8000c74 <HAL_RCC_OscConfig+0x1d0>
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8000f4a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8000f4e:	4f3b      	ldr	r7, [pc, #236]	; (800103c <HAL_RCC_OscConfig+0x598>)
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8000f50:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000f54:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000f58:	f241 3588 	movw	r5, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8000f5c:	e006      	b.n	8000f6c <HAL_RCC_OscConfig+0x4c8>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000f5e:	f7ff fb91 	bl	8000684 <HAL_GetTick>
 8000f62:	eba0 0008 	sub.w	r0, r0, r8
 8000f66:	42a8      	cmp	r0, r5
 8000f68:	f63f af7d 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8000f6c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8000f70:	051a      	lsls	r2, r3, #20
 8000f72:	d4f4      	bmi.n	8000f5e <HAL_RCC_OscConfig+0x4ba>
 8000f74:	e67e      	b.n	8000c74 <HAL_RCC_OscConfig+0x1d0>
  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 8000f76:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8000f78:	00d8      	lsls	r0, r3, #3
 8000f7a:	d45b      	bmi.n	8001034 <HAL_RCC_OscConfig+0x590>
  {
    vos = HAL_PWREx_GetVoltageRange();
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8000f7c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8000f7e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000f82:	65bb      	str	r3, [r7, #88]	; 0x58
 8000f84:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8000f86:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000f8a:	9302      	str	r3, [sp, #8]
 8000f8c:	9b02      	ldr	r3, [sp, #8]
    vos = HAL_PWREx_GetVoltageRange();
 8000f8e:	f7ff fcdf 	bl	8000950 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8000f92:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8000f94:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8000f98:	65bb      	str	r3, [r7, #88]	; 0x58
  }

  if ((vos == PWR_REGULATOR_VOLTAGE_SCALE0) || (vos == PWR_REGULATOR_VOLTAGE_SCALE1))
 8000f9a:	f430 7000 	bics.w	r0, r0, #512	; 0x200
 8000f9e:	f000 80bd 	beq.w	800111c <HAL_RCC_OscConfig+0x678>
    }
    /* else MSI <= 16Mhz default FLASH_LATENCY_0 0WS */
  }
  else
  {
    if (msirange > RCC_MSIRANGE_8)
 8000fa2:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
 8000fa6:	f200 813d 	bhi.w	8001224 <HAL_RCC_OscConfig+0x780>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if (msirange == RCC_MSIRANGE_8)
 8000faa:	f000 813f 	beq.w	800122c <HAL_RCC_OscConfig+0x788>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else if (msirange == RCC_MSIRANGE_7)
 8000fae:	f1a8 0070 	sub.w	r0, r8, #112	; 0x70
 8000fb2:	fab0 f080 	clz	r0, r0
 8000fb6:	0940      	lsrs	r0, r0, #5
        /* MSI < 8Mhz default FLASH_LATENCY_0 0WS */
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8000fb8:	4a24      	ldr	r2, [pc, #144]	; (800104c <HAL_RCC_OscConfig+0x5a8>)
 8000fba:	6813      	ldr	r3, [r2, #0]
 8000fbc:	f023 030f 	bic.w	r3, r3, #15
 8000fc0:	4303      	orrs	r3, r0
 8000fc2:	6013      	str	r3, [r2, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if ((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 8000fc4:	6813      	ldr	r3, [r2, #0]
 8000fc6:	f003 030f 	and.w	r3, r3, #15
 8000fca:	4298      	cmp	r0, r3
 8000fcc:	f47f af16 	bne.w	8000dfc <HAL_RCC_OscConfig+0x358>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000fd0:	4b1a      	ldr	r3, [pc, #104]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000fd2:	681a      	ldr	r2, [r3, #0]
 8000fd4:	f042 0208 	orr.w	r2, r2, #8
 8000fd8:	601a      	str	r2, [r3, #0]
 8000fda:	681a      	ldr	r2, [r3, #0]
 8000fdc:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8000fde:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000fe2:	430a      	orrs	r2, r1
 8000fe4:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000fe6:	685a      	ldr	r2, [r3, #4]
 8000fe8:	6a21      	ldr	r1, [r4, #32]
 8000fea:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8000fee:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8000ff2:	605a      	str	r2, [r3, #4]
 8000ff4:	e6e9      	b.n	8000dca <HAL_RCC_OscConfig+0x326>
      __HAL_RCC_HSI48_DISABLE();
 8000ff6:	4b11      	ldr	r3, [pc, #68]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8000ff8:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
      while (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8000ffc:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_DISABLE();
 8000ffe:	f022 0201 	bic.w	r2, r2, #1
 8001002:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
      tickstart = HAL_GetTick();
 8001006:	f7ff fb3d 	bl	8000684 <HAL_GetTick>
 800100a:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 800100c:	e005      	b.n	800101a <HAL_RCC_OscConfig+0x576>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800100e:	f7ff fb39 	bl	8000684 <HAL_GetTick>
 8001012:	1b80      	subs	r0, r0, r6
 8001014:	2802      	cmp	r0, #2
 8001016:	f63f af26 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
      while (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 800101a:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 800101e:	0798      	lsls	r0, r3, #30
 8001020:	d4f5      	bmi.n	800100e <HAL_RCC_OscConfig+0x56a>
 8001022:	e64a      	b.n	8000cba <HAL_RCC_OscConfig+0x216>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8001024:	4a05      	ldr	r2, [pc, #20]	; (800103c <HAL_RCC_OscConfig+0x598>)
 8001026:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 800102a:	f043 0301 	orr.w	r3, r3, #1
 800102e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8001032:	e5f4      	b.n	8000c1e <HAL_RCC_OscConfig+0x17a>
    vos = HAL_PWREx_GetVoltageRange();
 8001034:	f7ff fc8c 	bl	8000950 <HAL_PWREx_GetVoltageRange>
 8001038:	e7af      	b.n	8000f9a <HAL_RCC_OscConfig+0x4f6>
 800103a:	bf00      	nop
 800103c:	40021000 	.word	0x40021000
 8001040:	08014f40 	.word	0x08014f40
 8001044:	20000008 	.word	0x20000008
 8001048:	20000000 	.word	0x20000000
 800104c:	40022000 	.word	0x40022000
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_OFF)
 8001050:	2801      	cmp	r0, #1
 8001052:	f43f aed4 	beq.w	8000dfe <HAL_RCC_OscConfig+0x35a>
        pll_config = RCC->PLLCFGR;
 8001056:	68db      	ldr	r3, [r3, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8001058:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800105a:	f003 0103 	and.w	r1, r3, #3
 800105e:	4291      	cmp	r1, r2
 8001060:	f47f aecc 	bne.w	8000dfc <HAL_RCC_OscConfig+0x358>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8001064:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8001066:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 800106a:	3901      	subs	r1, #1
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 800106c:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 8001070:	f47f aec4 	bne.w	8000dfc <HAL_RCC_OscConfig+0x358>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8001074:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8001076:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 800107a:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 800107e:	f47f aebd 	bne.w	8000dfc <HAL_RCC_OscConfig+0x358>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8001082:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001084:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8001088:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 800108c:	f47f aeb6 	bne.w	8000dfc <HAL_RCC_OscConfig+0x358>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8001090:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001092:	f403 01c0 	and.w	r1, r3, #6291456	; 0x600000
 8001096:	0852      	lsrs	r2, r2, #1
 8001098:	3a01      	subs	r2, #1
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 800109a:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 800109e:	f47f aead 	bne.w	8000dfc <HAL_RCC_OscConfig+0x358>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 80010a2:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80010a4:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 80010a8:	0852      	lsrs	r2, r2, #1
 80010aa:	3a01      	subs	r2, #1
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 80010ac:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
    return HAL_ERROR;
 80010b0:	bf14      	ite	ne
 80010b2:	2001      	movne	r0, #1
 80010b4:	2000      	moveq	r0, #0
 80010b6:	e6a2      	b.n	8000dfe <HAL_RCC_OscConfig+0x35a>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80010b8:	681a      	ldr	r2, [r3, #0]
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80010ba:	461d      	mov	r5, r3
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80010bc:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80010c0:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80010c2:	f7ff fadf 	bl	8000684 <HAL_GetTick>
 80010c6:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80010c8:	682b      	ldr	r3, [r5, #0]
 80010ca:	05db      	lsls	r3, r3, #23
 80010cc:	f53f ad93 	bmi.w	8000bf6 <HAL_RCC_OscConfig+0x152>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80010d0:	f7ff fad8 	bl	8000684 <HAL_GetTick>
 80010d4:	1bc0      	subs	r0, r0, r7
 80010d6:	2802      	cmp	r0, #2
 80010d8:	d9f6      	bls.n	80010c8 <HAL_RCC_OscConfig+0x624>
 80010da:	e6c4      	b.n	8000e66 <HAL_RCC_OscConfig+0x3c2>
  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 80010dc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80010de:	00d9      	lsls	r1, r3, #3
 80010e0:	d53c      	bpl.n	800115c <HAL_RCC_OscConfig+0x6b8>
    vos = HAL_PWREx_GetVoltageRange();
 80010e2:	f7ff fc35 	bl	8000950 <HAL_PWREx_GetVoltageRange>
  if ((vos == PWR_REGULATOR_VOLTAGE_SCALE0) || (vos == PWR_REGULATOR_VOLTAGE_SCALE1))
 80010e6:	f430 7000 	bics.w	r0, r0, #512	; 0x200
 80010ea:	d02e      	beq.n	800114a <HAL_RCC_OscConfig+0x6a6>
    if (msirange > RCC_MSIRANGE_8)
 80010ec:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
 80010f0:	f200 809a 	bhi.w	8001228 <HAL_RCC_OscConfig+0x784>
      if (msirange == RCC_MSIRANGE_8)
 80010f4:	f000 809c 	beq.w	8001230 <HAL_RCC_OscConfig+0x78c>
      else if (msirange == RCC_MSIRANGE_7)
 80010f8:	f1a8 0070 	sub.w	r0, r8, #112	; 0x70
 80010fc:	fab0 f080 	clz	r0, r0
 8001100:	0940      	lsrs	r0, r0, #5
  __HAL_FLASH_SET_LATENCY(latency);
 8001102:	4a4c      	ldr	r2, [pc, #304]	; (8001234 <HAL_RCC_OscConfig+0x790>)
 8001104:	6813      	ldr	r3, [r2, #0]
 8001106:	f023 030f 	bic.w	r3, r3, #15
 800110a:	4303      	orrs	r3, r0
 800110c:	6013      	str	r3, [r2, #0]
  if ((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 800110e:	6813      	ldr	r3, [r2, #0]
 8001110:	f003 030f 	and.w	r3, r3, #15
 8001114:	4298      	cmp	r0, r3
 8001116:	f47f ae71 	bne.w	8000dfc <HAL_RCC_OscConfig+0x358>
 800111a:	e656      	b.n	8000dca <HAL_RCC_OscConfig+0x326>
    if (msirange > RCC_MSIRANGE_8)
 800111c:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
 8001120:	f67f af4a 	bls.w	8000fb8 <HAL_RCC_OscConfig+0x514>
        latency = FLASH_LATENCY_2; /* 2WS */
 8001124:	f1b8 0fa1 	cmp.w	r8, #161	; 0xa1
 8001128:	bf34      	ite	cc
 800112a:	2001      	movcc	r0, #1
 800112c:	2002      	movcs	r0, #2
 800112e:	e743      	b.n	8000fb8 <HAL_RCC_OscConfig+0x514>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001130:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001134:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8001138:	681a      	ldr	r2, [r3, #0]
 800113a:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800113e:	601a      	str	r2, [r3, #0]
 8001140:	681a      	ldr	r2, [r3, #0]
 8001142:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001146:	601a      	str	r2, [r3, #0]
 8001148:	e698      	b.n	8000e7c <HAL_RCC_OscConfig+0x3d8>
    if (msirange > RCC_MSIRANGE_8)
 800114a:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
 800114e:	d9d8      	bls.n	8001102 <HAL_RCC_OscConfig+0x65e>
        latency = FLASH_LATENCY_2; /* 2WS */
 8001150:	f1b8 0fa1 	cmp.w	r8, #161	; 0xa1
 8001154:	bf34      	ite	cc
 8001156:	2001      	movcc	r0, #1
 8001158:	2002      	movcs	r0, #2
 800115a:	e7d2      	b.n	8001102 <HAL_RCC_OscConfig+0x65e>
    __HAL_RCC_PWR_CLK_ENABLE();
 800115c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800115e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001162:	65bb      	str	r3, [r7, #88]	; 0x58
 8001164:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001166:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800116a:	9303      	str	r3, [sp, #12]
 800116c:	9b03      	ldr	r3, [sp, #12]
    vos = HAL_PWREx_GetVoltageRange();
 800116e:	f7ff fbef 	bl	8000950 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8001172:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001174:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001178:	65bb      	str	r3, [r7, #88]	; 0x58
 800117a:	e7b4      	b.n	80010e6 <HAL_RCC_OscConfig+0x642>
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 800117c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001180:	f8c8 3090 	str.w	r3, [r8, #144]	; 0x90
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001184:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8001188:	e005      	b.n	8001196 <HAL_RCC_OscConfig+0x6f2>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800118a:	f7ff fa7b 	bl	8000684 <HAL_GetTick>
 800118e:	1bc0      	subs	r0, r0, r7
 8001190:	4540      	cmp	r0, r8
 8001192:	f63f ae68 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8001196:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800119a:	051b      	lsls	r3, r3, #20
 800119c:	d4f5      	bmi.n	800118a <HAL_RCC_OscConfig+0x6e6>
 800119e:	e569      	b.n	8000c74 <HAL_RCC_OscConfig+0x1d0>
        __HAL_RCC_PLL_DISABLE();
 80011a0:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80011a4:	601a      	str	r2, [r3, #0]
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80011a6:	461d      	mov	r5, r3
        tickstart = HAL_GetTick();
 80011a8:	f7ff fa6c 	bl	8000684 <HAL_GetTick>
 80011ac:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80011ae:	e005      	b.n	80011bc <HAL_RCC_OscConfig+0x718>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80011b0:	f7ff fa68 	bl	8000684 <HAL_GetTick>
 80011b4:	1b80      	subs	r0, r0, r6
 80011b6:	2802      	cmp	r0, #2
 80011b8:	f63f ae55 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80011bc:	682b      	ldr	r3, [r5, #0]
 80011be:	0199      	lsls	r1, r3, #6
 80011c0:	d4f6      	bmi.n	80011b0 <HAL_RCC_OscConfig+0x70c>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80011c2:	68ea      	ldr	r2, [r5, #12]
 80011c4:	4b1c      	ldr	r3, [pc, #112]	; (8001238 <HAL_RCC_OscConfig+0x794>)
 80011c6:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80011c8:	4013      	ands	r3, r2
 80011ca:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80011cc:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 80011ce:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80011d0:	430b      	orrs	r3, r1
 80011d2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80011d6:	3801      	subs	r0, #1
 80011d8:	e9d4 1210 	ldrd	r1, r2, [r4, #64]	; 0x40
 80011dc:	ea43 63c6 	orr.w	r3, r3, r6, lsl #27
 80011e0:	0849      	lsrs	r1, r1, #1
 80011e2:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 80011e6:	3901      	subs	r1, #1
 80011e8:	0852      	lsrs	r2, r2, #1
 80011ea:	ea43 5341 	orr.w	r3, r3, r1, lsl #21
 80011ee:	3a01      	subs	r2, #1
 80011f0:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 80011f4:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 80011f6:	682b      	ldr	r3, [r5, #0]
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80011f8:	4c10      	ldr	r4, [pc, #64]	; (800123c <HAL_RCC_OscConfig+0x798>)
        __HAL_RCC_PLL_ENABLE();
 80011fa:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80011fe:	602b      	str	r3, [r5, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8001200:	68eb      	ldr	r3, [r5, #12]
 8001202:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001206:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 8001208:	f7ff fa3c 	bl	8000684 <HAL_GetTick>
 800120c:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800120e:	e005      	b.n	800121c <HAL_RCC_OscConfig+0x778>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001210:	f7ff fa38 	bl	8000684 <HAL_GetTick>
 8001214:	1b40      	subs	r0, r0, r5
 8001216:	2802      	cmp	r0, #2
 8001218:	f63f ae25 	bhi.w	8000e66 <HAL_RCC_OscConfig+0x3c2>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800121c:	6823      	ldr	r3, [r4, #0]
 800121e:	019a      	lsls	r2, r3, #6
 8001220:	d5f6      	bpl.n	8001210 <HAL_RCC_OscConfig+0x76c>
 8001222:	e577      	b.n	8000d14 <HAL_RCC_OscConfig+0x270>
      latency = FLASH_LATENCY_3; /* 3WS */
 8001224:	2003      	movs	r0, #3
 8001226:	e6c7      	b.n	8000fb8 <HAL_RCC_OscConfig+0x514>
 8001228:	2003      	movs	r0, #3
 800122a:	e76a      	b.n	8001102 <HAL_RCC_OscConfig+0x65e>
        latency = FLASH_LATENCY_2; /* 2WS */
 800122c:	2002      	movs	r0, #2
 800122e:	e6c3      	b.n	8000fb8 <HAL_RCC_OscConfig+0x514>
 8001230:	2002      	movs	r0, #2
 8001232:	e766      	b.n	8001102 <HAL_RCC_OscConfig+0x65e>
 8001234:	40022000 	.word	0x40022000
 8001238:	019f800c 	.word	0x019f800c
 800123c:	40021000 	.word	0x40021000

08001240 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8001240:	2800      	cmp	r0, #0
 8001242:	f000 80d5 	beq.w	80013f0 <HAL_RCC_ClockConfig+0x1b0>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8001246:	4a83      	ldr	r2, [pc, #524]	; (8001454 <HAL_RCC_ClockConfig+0x214>)
{
 8001248:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800124c:	6813      	ldr	r3, [r2, #0]
 800124e:	f003 030f 	and.w	r3, r3, #15
 8001252:	428b      	cmp	r3, r1
 8001254:	d20c      	bcs.n	8001270 <HAL_RCC_ClockConfig+0x30>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001256:	6813      	ldr	r3, [r2, #0]
 8001258:	f023 030f 	bic.w	r3, r3, #15
 800125c:	430b      	orrs	r3, r1
 800125e:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8001260:	6813      	ldr	r3, [r2, #0]
 8001262:	f003 030f 	and.w	r3, r3, #15
 8001266:	428b      	cmp	r3, r1
 8001268:	d002      	beq.n	8001270 <HAL_RCC_ClockConfig+0x30>
    return HAL_ERROR;
 800126a:	2001      	movs	r0, #1
}
 800126c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001270:	6803      	ldr	r3, [r0, #0]
 8001272:	4604      	mov	r4, r0
 8001274:	07da      	lsls	r2, r3, #31
 8001276:	460d      	mov	r5, r1
 8001278:	d56d      	bpl.n	8001356 <HAL_RCC_ClockConfig+0x116>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800127a:	6842      	ldr	r2, [r0, #4]
 800127c:	2a03      	cmp	r2, #3
 800127e:	d07a      	beq.n	8001376 <HAL_RCC_ClockConfig+0x136>
        if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8001280:	4b75      	ldr	r3, [pc, #468]	; (8001458 <HAL_RCC_ClockConfig+0x218>)
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001282:	2a02      	cmp	r2, #2
        if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8001284:	681b      	ldr	r3, [r3, #0]
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001286:	f000 80b5 	beq.w	80013f4 <HAL_RCC_ClockConfig+0x1b4>
      else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800128a:	2a00      	cmp	r2, #0
 800128c:	f040 80b6 	bne.w	80013fc <HAL_RCC_ClockConfig+0x1bc>
        if (READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8001290:	079e      	lsls	r6, r3, #30
 8001292:	d5ea      	bpl.n	800126a <HAL_RCC_ClockConfig+0x2a>
      pllfreq = HAL_RCC_GetSysClockFreq();
 8001294:	f7ff fbb0 	bl	80009f8 <HAL_RCC_GetSysClockFreq>
      if (pllfreq > 80000000U)
 8001298:	4b70      	ldr	r3, [pc, #448]	; (800145c <HAL_RCC_ClockConfig+0x21c>)
 800129a:	4298      	cmp	r0, r3
 800129c:	f200 80b2 	bhi.w	8001404 <HAL_RCC_ClockConfig+0x1c4>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 80012a0:	f04f 0800 	mov.w	r8, #0
 80012a4:	6862      	ldr	r2, [r4, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80012a6:	4e6c      	ldr	r6, [pc, #432]	; (8001458 <HAL_RCC_ClockConfig+0x218>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80012a8:	f241 3988 	movw	r9, #5000	; 0x1388
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80012ac:	68b3      	ldr	r3, [r6, #8]
 80012ae:	f023 0303 	bic.w	r3, r3, #3
 80012b2:	431a      	orrs	r2, r3
 80012b4:	60b2      	str	r2, [r6, #8]
    tickstart = HAL_GetTick();
 80012b6:	f7ff f9e5 	bl	8000684 <HAL_GetTick>
 80012ba:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80012bc:	e005      	b.n	80012ca <HAL_RCC_ClockConfig+0x8a>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80012be:	f7ff f9e1 	bl	8000684 <HAL_GetTick>
 80012c2:	1bc0      	subs	r0, r0, r7
 80012c4:	4548      	cmp	r0, r9
 80012c6:	f200 80a8 	bhi.w	800141a <HAL_RCC_ClockConfig+0x1da>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80012ca:	68b3      	ldr	r3, [r6, #8]
 80012cc:	6862      	ldr	r2, [r4, #4]
 80012ce:	f003 030c 	and.w	r3, r3, #12
 80012d2:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80012d6:	d1f2      	bne.n	80012be <HAL_RCC_ClockConfig+0x7e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80012d8:	6823      	ldr	r3, [r4, #0]
 80012da:	0799      	lsls	r1, r3, #30
 80012dc:	d43d      	bmi.n	800135a <HAL_RCC_ClockConfig+0x11a>
    if (hpre == RCC_SYSCLK_DIV2)
 80012de:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
 80012e2:	d103      	bne.n	80012ec <HAL_RCC_ClockConfig+0xac>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 80012e4:	68b2      	ldr	r2, [r6, #8]
 80012e6:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80012ea:	60b2      	str	r2, [r6, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80012ec:	4959      	ldr	r1, [pc, #356]	; (8001454 <HAL_RCC_ClockConfig+0x214>)
 80012ee:	680a      	ldr	r2, [r1, #0]
 80012f0:	f002 020f 	and.w	r2, r2, #15
 80012f4:	42aa      	cmp	r2, r5
 80012f6:	d909      	bls.n	800130c <HAL_RCC_ClockConfig+0xcc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80012f8:	680a      	ldr	r2, [r1, #0]
 80012fa:	f022 020f 	bic.w	r2, r2, #15
 80012fe:	432a      	orrs	r2, r5
 8001300:	600a      	str	r2, [r1, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8001302:	680a      	ldr	r2, [r1, #0]
 8001304:	f002 020f 	and.w	r2, r2, #15
 8001308:	42aa      	cmp	r2, r5
 800130a:	d1ae      	bne.n	800126a <HAL_RCC_ClockConfig+0x2a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800130c:	075a      	lsls	r2, r3, #29
 800130e:	d506      	bpl.n	800131e <HAL_RCC_ClockConfig+0xde>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001310:	4951      	ldr	r1, [pc, #324]	; (8001458 <HAL_RCC_ClockConfig+0x218>)
 8001312:	68e0      	ldr	r0, [r4, #12]
 8001314:	688a      	ldr	r2, [r1, #8]
 8001316:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 800131a:	4302      	orrs	r2, r0
 800131c:	608a      	str	r2, [r1, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800131e:	071b      	lsls	r3, r3, #28
 8001320:	d507      	bpl.n	8001332 <HAL_RCC_ClockConfig+0xf2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8001322:	4a4d      	ldr	r2, [pc, #308]	; (8001458 <HAL_RCC_ClockConfig+0x218>)
 8001324:	6921      	ldr	r1, [r4, #16]
 8001326:	6893      	ldr	r3, [r2, #8]
 8001328:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 800132c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001330:	6093      	str	r3, [r2, #8]
  return (HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]);
 8001332:	f7ff fb61 	bl	80009f8 <HAL_RCC_GetSysClockFreq>
 8001336:	4b48      	ldr	r3, [pc, #288]	; (8001458 <HAL_RCC_ClockConfig+0x218>)
 8001338:	4a49      	ldr	r2, [pc, #292]	; (8001460 <HAL_RCC_ClockConfig+0x220>)
 800133a:	689b      	ldr	r3, [r3, #8]
  return HAL_InitTick(uwTickPrio);
 800133c:	4949      	ldr	r1, [pc, #292]	; (8001464 <HAL_RCC_ClockConfig+0x224>)
  return (HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]);
 800133e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8001342:	5cd3      	ldrb	r3, [r2, r3]
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8001344:	4a48      	ldr	r2, [pc, #288]	; (8001468 <HAL_RCC_ClockConfig+0x228>)
  return (HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]);
 8001346:	fa20 f303 	lsr.w	r3, r0, r3
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 800134a:	6013      	str	r3, [r2, #0]
  return HAL_InitTick(uwTickPrio);
 800134c:	6808      	ldr	r0, [r1, #0]
}
 800134e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return HAL_InitTick(uwTickPrio);
 8001352:	f7ff b95b 	b.w	800060c <HAL_InitTick>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001356:	079f      	lsls	r7, r3, #30
 8001358:	d5c8      	bpl.n	80012ec <HAL_RCC_ClockConfig+0xac>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800135a:	493f      	ldr	r1, [pc, #252]	; (8001458 <HAL_RCC_ClockConfig+0x218>)
 800135c:	68a0      	ldr	r0, [r4, #8]
 800135e:	688a      	ldr	r2, [r1, #8]
 8001360:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001364:	4302      	orrs	r2, r0
 8001366:	608a      	str	r2, [r1, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8001368:	493a      	ldr	r1, [pc, #232]	; (8001454 <HAL_RCC_ClockConfig+0x214>)
 800136a:	680a      	ldr	r2, [r1, #0]
 800136c:	f002 020f 	and.w	r2, r2, #15
 8001370:	42aa      	cmp	r2, r5
 8001372:	d8c1      	bhi.n	80012f8 <HAL_RCC_ClockConfig+0xb8>
 8001374:	e7ca      	b.n	800130c <HAL_RCC_ClockConfig+0xcc>
      if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8001376:	4938      	ldr	r1, [pc, #224]	; (8001458 <HAL_RCC_ClockConfig+0x218>)
 8001378:	6808      	ldr	r0, [r1, #0]
 800137a:	0186      	lsls	r6, r0, #6
 800137c:	f57f af75 	bpl.w	800126a <HAL_RCC_ClockConfig+0x2a>
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
  uint32_t msirange = 0U;
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;    /* no init needed */

  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
 8001380:	68c8      	ldr	r0, [r1, #12]
 8001382:	f000 0003 	and.w	r0, r0, #3
 8001386:	2801      	cmp	r0, #1
 8001388:	d055      	beq.n	8001436 <HAL_RCC_ClockConfig+0x1f6>
  uint32_t msirange = 0U;
 800138a:	2100      	movs	r1, #0
  }

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 800138c:	4f32      	ldr	r7, [pc, #200]	; (8001458 <HAL_RCC_ClockConfig+0x218>)
 800138e:	68fe      	ldr	r6, [r7, #12]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8001390:	68f8      	ldr	r0, [r7, #12]
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8001392:	f006 0603 	and.w	r6, r6, #3
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8001396:	f3c0 1003 	ubfx	r0, r0, #4, #4

  switch (pllsource)
 800139a:	2e02      	cmp	r6, #2
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800139c:	f100 0001 	add.w	r0, r0, #1
  switch (pllsource)
 80013a0:	d03d      	beq.n	800141e <HAL_RCC_ClockConfig+0x1de>
 80013a2:	2e03      	cmp	r6, #3
 80013a4:	d03b      	beq.n	800141e <HAL_RCC_ClockConfig+0x1de>
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
      break;

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80013a6:	fbb1 f1f0 	udiv	r1, r1, r0
 80013aa:	68f8      	ldr	r0, [r7, #12]
 80013ac:	f3c0 2006 	ubfx	r0, r0, #8, #7
 80013b0:	fb01 f100 	mul.w	r1, r1, r0
      break;
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 80013b4:	4e28      	ldr	r6, [pc, #160]	; (8001458 <HAL_RCC_ClockConfig+0x218>)
      if (pllfreq > 80000000U)
 80013b6:	4f29      	ldr	r7, [pc, #164]	; (800145c <HAL_RCC_ClockConfig+0x21c>)
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 80013b8:	68f0      	ldr	r0, [r6, #12]
 80013ba:	f3c0 6041 	ubfx	r0, r0, #25, #2
 80013be:	3001      	adds	r0, #1
 80013c0:	0040      	lsls	r0, r0, #1
  sysclockfreq = pllvco / pllr;
 80013c2:	fbb1 f1f0 	udiv	r1, r1, r0
      if (pllfreq > 80000000U)
 80013c6:	42b9      	cmp	r1, r7
 80013c8:	d932      	bls.n	8001430 <HAL_RCC_ClockConfig+0x1f0>
        if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 80013ca:	68b1      	ldr	r1, [r6, #8]
 80013cc:	f011 0ff0 	tst.w	r1, #240	; 0xf0
 80013d0:	d005      	beq.n	80013de <HAL_RCC_ClockConfig+0x19e>
        else if ((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
 80013d2:	f013 0802 	ands.w	r8, r3, #2
 80013d6:	f43f af66 	beq.w	80012a6 <HAL_RCC_ClockConfig+0x66>
 80013da:	68a3      	ldr	r3, [r4, #8]
 80013dc:	bb43      	cbnz	r3, 8001430 <HAL_RCC_ClockConfig+0x1f0>
          hpre = RCC_SYSCLK_DIV2;
 80013de:	f04f 0880 	mov.w	r8, #128	; 0x80
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 80013e2:	68b3      	ldr	r3, [r6, #8]
 80013e4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80013e8:	ea43 0308 	orr.w	r3, r3, r8
 80013ec:	60b3      	str	r3, [r6, #8]
 80013ee:	e75a      	b.n	80012a6 <HAL_RCC_ClockConfig+0x66>
    return HAL_ERROR;
 80013f0:	2001      	movs	r0, #1
}
 80013f2:	4770      	bx	lr
        if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80013f4:	039f      	lsls	r7, r3, #14
 80013f6:	f53f af4d 	bmi.w	8001294 <HAL_RCC_ClockConfig+0x54>
 80013fa:	e736      	b.n	800126a <HAL_RCC_ClockConfig+0x2a>
        if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80013fc:	0558      	lsls	r0, r3, #21
 80013fe:	f57f af34 	bpl.w	800126a <HAL_RCC_ClockConfig+0x2a>
 8001402:	e747      	b.n	8001294 <HAL_RCC_ClockConfig+0x54>
        hpre = RCC_SYSCLK_DIV2;
 8001404:	f04f 0880 	mov.w	r8, #128	; 0x80
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8001408:	4a13      	ldr	r2, [pc, #76]	; (8001458 <HAL_RCC_ClockConfig+0x218>)
 800140a:	6893      	ldr	r3, [r2, #8]
 800140c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8001410:	ea43 0308 	orr.w	r3, r3, r8
 8001414:	6093      	str	r3, [r2, #8]
 8001416:	6862      	ldr	r2, [r4, #4]
 8001418:	e745      	b.n	80012a6 <HAL_RCC_ClockConfig+0x66>
        return HAL_TIMEOUT;
 800141a:	2003      	movs	r0, #3
 800141c:	e726      	b.n	800126c <HAL_RCC_ClockConfig+0x2c>
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800141e:	4913      	ldr	r1, [pc, #76]	; (800146c <HAL_RCC_ClockConfig+0x22c>)
 8001420:	68fe      	ldr	r6, [r7, #12]
 8001422:	fbb1 f1f0 	udiv	r1, r1, r0
 8001426:	f3c6 2006 	ubfx	r0, r6, #8, #7
 800142a:	fb01 f100 	mul.w	r1, r1, r0
 800142e:	e7c1      	b.n	80013b4 <HAL_RCC_ClockConfig+0x174>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8001430:	f04f 0800 	mov.w	r8, #0
 8001434:	e737      	b.n	80012a6 <HAL_RCC_ClockConfig+0x66>
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8001436:	6808      	ldr	r0, [r1, #0]
 8001438:	0700      	lsls	r0, r0, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 800143a:	bf54      	ite	pl
 800143c:	f8d1 1094 	ldrpl.w	r1, [r1, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8001440:	6809      	ldrmi	r1, [r1, #0]
    msirange = MSIRangeTable[msirange];
 8001442:	480b      	ldr	r0, [pc, #44]	; (8001470 <HAL_RCC_ClockConfig+0x230>)
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8001444:	bf54      	ite	pl
 8001446:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 800144a:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    msirange = MSIRangeTable[msirange];
 800144e:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
 8001452:	e79b      	b.n	800138c <HAL_RCC_ClockConfig+0x14c>
 8001454:	40022000 	.word	0x40022000
 8001458:	40021000 	.word	0x40021000
 800145c:	04c4b400 	.word	0x04c4b400
 8001460:	08014f40 	.word	0x08014f40
 8001464:	20000008 	.word	0x20000008
 8001468:	20000000 	.word	0x20000000
 800146c:	00f42400 	.word	0x00f42400
 8001470:	08014f50 	.word	0x08014f50

08001474 <intensity_stereo.isra.2>:
#endif
   w[0] = VSHR32(Ex, shift);
   w[1] = VSHR32(Ey, shift);
}

static void intensity_stereo(const CELTMode *m, celt_norm * OPUS_RESTRICT X, const celt_norm * OPUS_RESTRICT Y, const celt_ener *bandE, int bandID, int N)
 8001474:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001478:	9d08      	ldr	r5, [sp, #32]
 800147a:	460c      	mov	r4, r1
   int j;
   opus_val16 a1, a2;
   opus_val16 left, right;
   opus_val16 norm;
#ifdef FIXED_POINT
   int shift = celt_zlog2(MAX32(bandE[i], bandE[i+m->nbEBands]))-13;
 800147c:	4428      	add	r0, r5
 800147e:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 8001482:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
 8001486:	460b      	mov	r3, r1
 8001488:	42a9      	cmp	r1, r5
 800148a:	bfb8      	it	lt
 800148c:	462b      	movlt	r3, r5


/** Integer log in base2. Defined for zero, but not for negative numbers */
static OPUS_INLINE opus_int16 celt_zlog2(opus_val32 x)
{
   return x <= 0 ? 0 : celt_ilog2(x);
 800148e:	2b00      	cmp	r3, #0
static void intensity_stereo(const CELTMode *m, celt_norm * OPUS_RESTRICT X, const celt_norm * OPUS_RESTRICT Y, const celt_ener *bandE, int bandID, int N)
 8001490:	4690      	mov	r8, r2
 8001492:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 8001496:	dd37      	ble.n	8001508 <intensity_stereo.isra.2+0x94>
   return EC_ILOG(x)-1;
 8001498:	fab3 f383 	clz	r3, r3
 800149c:	f1c3 031f 	rsb	r3, r3, #31
   int shift = celt_zlog2(MAX32(bandE[i], bandE[i+m->nbEBands]))-13;
 80014a0:	b29b      	uxth	r3, r3
 80014a2:	f1a3 070d 	sub.w	r7, r3, #13
#endif
   left = VSHR32(bandE[i],shift);
 80014a6:	2f00      	cmp	r7, #0
 80014a8:	dd35      	ble.n	8001516 <intensity_stereo.isra.2+0xa2>
 80014aa:	413d      	asrs	r5, r7
   right = VSHR32(bandE[i+m->nbEBands],shift);
 80014ac:	fa41 f707 	asr.w	r7, r1, r7
   left = VSHR32(bandE[i],shift);
 80014b0:	b22d      	sxth	r5, r5
   right = VSHR32(bandE[i+m->nbEBands],shift);
 80014b2:	b23f      	sxth	r7, r7
   norm = EPSILON + celt_sqrt(EPSILON+MULT16_16(left,left)+MULT16_16(right,right));
 80014b4:	2001      	movs	r0, #1
 80014b6:	fb05 0005 	mla	r0, r5, r5, r0
 80014ba:	fb07 0007 	mla	r0, r7, r7, r0
 80014be:	f008 f9fd 	bl	80098bc <celt_sqrt>
 80014c2:	3001      	adds	r0, #1
   a1 = DIV32_16(SHL32(EXTEND32(left),14),norm);
 80014c4:	b200      	sxth	r0, r0
 80014c6:	03ad      	lsls	r5, r5, #14
   a2 = DIV32_16(SHL32(EXTEND32(right),14),norm);
 80014c8:	03be      	lsls	r6, r7, #14
   a1 = DIV32_16(SHL32(EXTEND32(left),14),norm);
 80014ca:	fb95 f5f0 	sdiv	r5, r5, r0
   a2 = DIV32_16(SHL32(EXTEND32(right),14),norm);
 80014ce:	fb96 f6f0 	sdiv	r6, r6, r0
   for (j=0;j<N;j++)
 80014d2:	f1b9 0f00 	cmp.w	r9, #0
   a1 = DIV32_16(SHL32(EXTEND32(left),14),norm);
 80014d6:	b22d      	sxth	r5, r5
   a2 = DIV32_16(SHL32(EXTEND32(right),14),norm);
 80014d8:	b236      	sxth	r6, r6
   for (j=0;j<N;j++)
 80014da:	dd13      	ble.n	8001504 <intensity_stereo.isra.2+0x90>
 80014dc:	eb04 0949 	add.w	r9, r4, r9, lsl #1
 80014e0:	f1a9 0902 	sub.w	r9, r9, #2
 80014e4:	1ea1      	subs	r1, r4, #2
 80014e6:	f1a8 0802 	sub.w	r8, r8, #2
   {
      celt_norm r, l;
      l = X[j];
      r = Y[j];
      X[j] = EXTRACT16(SHR32(MAC16_16(MULT16_16(a1, l), a2, r), 14));
 80014ea:	f838 0f02 	ldrh.w	r0, [r8, #2]!
 80014ee:	f831 3f02 	ldrh.w	r3, [r1, #2]!
 80014f2:	fb10 f006 	smulbb	r0, r0, r6
 80014f6:	fb13 0305 	smlabb	r3, r3, r5, r0
   for (j=0;j<N;j++)
 80014fa:	4589      	cmp	r9, r1
      X[j] = EXTRACT16(SHR32(MAC16_16(MULT16_16(a1, l), a2, r), 14));
 80014fc:	ea4f 33a3 	mov.w	r3, r3, asr #14
 8001500:	800b      	strh	r3, [r1, #0]
   for (j=0;j<N;j++)
 8001502:	d1f2      	bne.n	80014ea <intensity_stereo.isra.2+0x76>
      /* Side is not encoded, no need to calculate */
   }
}
 8001504:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   return x <= 0 ? 0 : celt_ilog2(x);
 8001508:	230d      	movs	r3, #13
   left = VSHR32(bandE[i],shift);
 800150a:	409d      	lsls	r5, r3
   right = VSHR32(bandE[i+m->nbEBands],shift);
 800150c:	fa01 f703 	lsl.w	r7, r1, r3
   left = VSHR32(bandE[i],shift);
 8001510:	b22d      	sxth	r5, r5
   right = VSHR32(bandE[i+m->nbEBands],shift);
 8001512:	b23f      	sxth	r7, r7
 8001514:	e7ce      	b.n	80014b4 <intensity_stereo.isra.2+0x40>
 8001516:	f1c3 030d 	rsb	r3, r3, #13
 800151a:	e7f6      	b.n	800150a <intensity_stereo.isra.2+0x96>

0800151c <quant_partition>:
   split in 8 parts. */
static unsigned quant_partition(struct band_ctx *ctx, celt_norm *X,
      int N, int b, int B, celt_norm *lowband,
      int LM,
      opus_val16 gain, int fill)
{
 800151c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001520:	4604      	mov	r4, r0
   int i;
   int spread;
   ec_ctx *ec;

   encode = ctx->encode;
   m = ctx->m;
 8001522:	6880      	ldr	r0, [r0, #8]
{
 8001524:	b095      	sub	sp, #84	; 0x54
 8001526:	f8dd c080 	ldr.w	ip, [sp, #128]	; 0x80
   i = ctx->i;
   spread = ctx->spread;
   ec = ctx->ec;

   /* If we need 1.5 more bit than we can produce, split the band in two. */
   cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
 800152a:	6885      	ldr	r5, [r0, #8]
   i = ctx->i;
 800152c:	f8d4 e00c 	ldr.w	lr, [r4, #12]
   cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
 8001530:	fb0c 5505 	mla	r5, ip, r5, r5
 8001534:	6d86      	ldr	r6, [r0, #88]	; 0x58
 8001536:	4475      	add	r5, lr
 8001538:	f936 7015 	ldrsh.w	r7, [r6, r5, lsl #1]
{
 800153c:	461d      	mov	r5, r3
   encode = ctx->encode;
 800153e:	6823      	ldr	r3, [r4, #0]
   cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
 8001540:	f8d0 805c 	ldr.w	r8, [r0, #92]	; 0x5c
   encode = ctx->encode;
 8001544:	9308      	str	r3, [sp, #32]
{
 8001546:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   if (LM != -1 && b > cache[cache[0]]+12 && N>2)
 8001548:	f1bc 3fff 	cmp.w	ip, #4294967295
{
 800154c:	9307      	str	r3, [sp, #28]
 800154e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
 8001550:	eb08 0607 	add.w	r6, r8, r7
{
 8001554:	930b      	str	r3, [sp, #44]	; 0x2c
 8001556:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8001558:	468b      	mov	fp, r1
 800155a:	f9bd a084 	ldrsh.w	sl, [sp, #132]	; 0x84
 800155e:	4611      	mov	r1, r2
 8001560:	930a      	str	r3, [sp, #40]	; 0x28
 8001562:	f818 2007 	ldrb.w	r2, [r8, r7]
   spread = ctx->spread;
 8001566:	f8d4 8014 	ldr.w	r8, [r4, #20]
   ec = ctx->ec;
 800156a:	69e7      	ldr	r7, [r4, #28]
   if (LM != -1 && b > cache[cache[0]]+12 && N>2)
 800156c:	f000 810a 	beq.w	8001784 <quant_partition+0x268>
 8001570:	f816 9002 	ldrb.w	r9, [r6, r2]
 8001574:	f109 090c 	add.w	r9, r9, #12
 8001578:	45a9      	cmp	r9, r5
 800157a:	f280 8103 	bge.w	8001784 <quant_partition+0x268>
 800157e:	2902      	cmp	r1, #2
 8001580:	f340 8100 	ble.w	8001784 <quant_partition+0x268>
      int qalloc;
      struct split_ctx sctx;
      celt_norm *next_lowband2=NULL;
      opus_int32 rebalance;

      N >>= 1;
 8001584:	ea4f 0961 	mov.w	r9, r1, asr #1
      Y = X+N;
      LM -= 1;
      if (B==1)
 8001588:	9b07      	ldr	r3, [sp, #28]
      Y = X+N;
 800158a:	ea4f 0249 	mov.w	r2, r9, lsl #1
 800158e:	920e      	str	r2, [sp, #56]	; 0x38
      LM -= 1;
 8001590:	f10c 31ff 	add.w	r1, ip, #4294967295
      Y = X+N;
 8001594:	445a      	add	r2, fp
      if (B==1)
 8001596:	2b01      	cmp	r3, #1
      LM -= 1;
 8001598:	910c      	str	r1, [sp, #48]	; 0x30
      Y = X+N;
 800159a:	920f      	str	r2, [sp, #60]	; 0x3c
      if (B==1)
 800159c:	d103      	bne.n	80015a6 <quant_partition+0x8a>
         fill = (fill&1)|(fill<<1);
 800159e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80015a0:	f363 035f 	bfi	r3, r3, #1, #31
 80015a4:	930a      	str	r3, [sp, #40]	; 0x28
   int N2 = 2*N-1;
 80015a6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
 80015a8:	6b01      	ldr	r1, [r0, #48]	; 0x30
   int N2 = 2*N-1;
 80015aa:	1e5a      	subs	r2, r3, #1
      B = (B+1)>>1;
 80015ac:	9b07      	ldr	r3, [sp, #28]
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
 80015ae:	f931 601e 	ldrsh.w	r6, [r1, lr, lsl #1]
      B = (B+1)>>1;
 80015b2:	1c59      	adds	r1, r3, #1
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
 80015b4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80015b6:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
 80015ba:	ea4f 0c66 	mov.w	ip, r6, asr #1
 80015be:	f1ac 0c04 	sub.w	ip, ip, #4
   qb = celt_sudiv(b+N2*offset, N2);
 80015c2:	fb02 5c0c 	mla	ip, r2, ip, r5
      B = (B+1)>>1;
 80015c6:	104b      	asrs	r3, r1, #1
}

static OPUS_INLINE opus_int32 celt_sudiv(opus_int32 n, opus_int32 d) {
   celt_sig_assert(d>0);
#ifdef USE_SMALL_DIV_TABLE
   if (n<0)
 80015c8:	f1bc 0f00 	cmp.w	ip, #0
 80015cc:	930d      	str	r3, [sp, #52]	; 0x34
 80015ce:	f2c0 8245 	blt.w	8001a5c <quant_partition+0x540>
   if (d>256)
 80015d2:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80015d6:	f340 8313 	ble.w	8001c00 <quant_partition+0x6e4>
      return n/d;
 80015da:	fbbc f2f2 	udiv	r2, ip, r2
   qb = IMIN(b-pulse_cap-(4<<BITRES), qb);
 80015de:	1bae      	subs	r6, r5, r6
 80015e0:	f1a6 011f 	sub.w	r1, r6, #31
 80015e4:	4291      	cmp	r1, r2
 80015e6:	bfd8      	it	le
 80015e8:	f1a6 0220 	suble.w	r2, r6, #32
   if (qb<(1<<BITRES>>1)) {
 80015ec:	2a03      	cmp	r2, #3
 80015ee:	f340 8197 	ble.w	8001920 <quant_partition+0x404>
   qb = IMIN(8<<BITRES, qb);
 80015f2:	2a40      	cmp	r2, #64	; 0x40
 80015f4:	bfa8      	it	ge
 80015f6:	2240      	movge	r2, #64	; 0x40
      qn = exp2_table8[qb&0x7]>>(14-(qb>>BITRES));
 80015f8:	49c6      	ldr	r1, [pc, #792]	; (8001914 <quant_partition+0x3f8>)
 80015fa:	f002 0007 	and.w	r0, r2, #7
 80015fe:	f931 6010 	ldrsh.w	r6, [r1, r0, lsl #1]
 8001602:	10d2      	asrs	r2, r2, #3
 8001604:	f1c2 020e 	rsb	r2, r2, #14
 8001608:	4116      	asrs	r6, r2
   if (encode)
 800160a:	9b08      	ldr	r3, [sp, #32]
      qn = (qn+1)>>1<<1;
 800160c:	3601      	adds	r6, #1
 800160e:	f026 0601 	bic.w	r6, r6, #1
   if (encode)
 8001612:	2b00      	cmp	r3, #0
 8001614:	f040 8240 	bne.w	8001a98 <quant_partition+0x57c>
   tell = ec_tell_frac(ec);
 8001618:	4638      	mov	r0, r7
 800161a:	f006 fe51 	bl	80082c0 <ec_tell_frac>
      } else if (B0>1 || stereo) {
 800161e:	9b07      	ldr	r3, [sp, #28]
   tell = ec_tell_frac(ec);
 8001620:	9012      	str	r0, [sp, #72]	; 0x48
      } else if (B0>1 || stereo) {
 8001622:	2b01      	cmp	r3, #1
 8001624:	f340 831a 	ble.w	8001c5c <quant_partition+0x740>
            itheta = ec_dec_uint(ec, qn+1);
 8001628:	1c71      	adds	r1, r6, #1
 800162a:	4638      	mov	r0, r7
 800162c:	f007 f806 	bl	800863c <ec_dec_uint>
 8001630:	0383      	lsls	r3, r0, #14
 8001632:	9308      	str	r3, [sp, #32]
   if (d>256)
 8001634:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 8001638:	f240 833a 	bls.w	8001cb0 <quant_partition+0x794>
      return n/d;
 800163c:	9b08      	ldr	r3, [sp, #32]
 800163e:	fbb3 f6f6 	udiv	r6, r3, r6
      itheta = celt_udiv((opus_int32)itheta*16384, qn);
 8001642:	9608      	str	r6, [sp, #32]
   qalloc = ec_tell_frac(ec) - tell;
 8001644:	4638      	mov	r0, r7
 8001646:	f006 fe3b 	bl	80082c0 <ec_tell_frac>
 800164a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800164c:	eba0 0803 	sub.w	r8, r0, r3
   if (itheta == 0)
 8001650:	9b08      	ldr	r3, [sp, #32]
   *b -= qalloc;
 8001652:	eba5 0508 	sub.w	r5, r5, r8
   if (itheta == 0)
 8001656:	2b00      	cmp	r3, #0
 8001658:	f000 8171 	beq.w	800193e <quant_partition+0x422>
   } else if (itheta == 16384)
 800165c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8001660:	f000 8355 	beq.w	8001d0e <quant_partition+0x7f2>
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
 8001664:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8001668:	461e      	mov	r6, r3
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
 800166a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
 800166e:	f64f 538e 	movw	r3, #64910	; 0xfd8e
 8001672:	f242 0e55 	movw	lr, #8277	; 0x2055
      iside = bitexact_cos((opus_int16)(16384-itheta));
 8001676:	1b81      	subs	r1, r0, r6
      imid = bitexact_cos((opus_int16)itheta);
 8001678:	f9bd 6020 	ldrsh.w	r6, [sp, #32]
      iside = bitexact_cos((opus_int16)(16384-itheta));
 800167c:	b209      	sxth	r1, r1
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
 800167e:	fb01 2101 	mla	r1, r1, r1, r2
 8001682:	fb06 2606 	mla	r6, r6, r6, r2
 8001686:	1349      	asrs	r1, r1, #13
 8001688:	1376      	asrs	r6, r6, #13
   x2 = tmp;
 800168a:	fa0f fc81 	sxth.w	ip, r1
 800168e:	b237      	sxth	r7, r6
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
 8001690:	fb1c 0203 	smlabb	r2, ip, r3, r0
 8001694:	fb17 0303 	smlabb	r3, r7, r3, r0
 8001698:	eb0e 32e2 	add.w	r2, lr, r2, asr #15
 800169c:	eb0e 33e3 	add.w	r3, lr, r3, asr #15
 80016a0:	b292      	uxth	r2, r2
 80016a2:	b29b      	uxth	r3, r3
 80016a4:	fb0c f202 	mul.w	r2, ip, r2
 80016a8:	fb07 f303 	mul.w	r3, r7, r3
 80016ac:	4402      	add	r2, r0
 80016ae:	4403      	add	r3, r0
 80016b0:	13d2      	asrs	r2, r2, #15
 80016b2:	13db      	asrs	r3, r3, #15
 80016b4:	f5a2 52ef 	sub.w	r2, r2, #7648	; 0x1de0
 80016b8:	f5a3 53ef 	sub.w	r3, r3, #7648	; 0x1de0
 80016bc:	3b03      	subs	r3, #3
 80016be:	3a03      	subs	r2, #3
 80016c0:	fb17 0703 	smlabb	r7, r7, r3, r0
 80016c4:	fb1c 0202 	smlabb	r2, ip, r2, r0
   return 1+x2;
 80016c8:	f5c1 4300 	rsb	r3, r1, #32768	; 0x8000
 80016cc:	f5c6 4600 	rsb	r6, r6, #32768	; 0x8000
 80016d0:	eb06 36e7 	add.w	r6, r6, r7, asr #15
 80016d4:	eb03 32e2 	add.w	r2, r3, r2, asr #15
 80016d8:	b213      	sxth	r3, r2
 80016da:	b232      	sxth	r2, r6
   ls=EC_ILOG(isin);
 80016dc:	fab3 f783 	clz	r7, r3
   lc=EC_ILOG(icos);
 80016e0:	fab2 f182 	clz	r1, r2
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 80016e4:	f24f 56db 	movw	r6, #62939	; 0xf5db
 80016e8:	f641 6cfc 	movw	ip, #7932	; 0x1efc
   icos<<=15-lc;
 80016ec:	9112      	str	r1, [sp, #72]	; 0x48
   isin<<=15-ls;
 80016ee:	f1a7 0e11 	sub.w	lr, r7, #17
   icos<<=15-lc;
 80016f2:	3911      	subs	r1, #17
   isin<<=15-ls;
 80016f4:	fa03 fe0e 	lsl.w	lr, r3, lr
   icos<<=15-lc;
 80016f8:	fa02 f101 	lsl.w	r1, r2, r1
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 80016fc:	b209      	sxth	r1, r1
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 80016fe:	fa0f fe8e 	sxth.w	lr, lr
   isin<<=15-ls;
 8001702:	9710      	str	r7, [sp, #64]	; 0x40
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001704:	fb1e 0706 	smlabb	r7, lr, r6, r0
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8001708:	fb11 0606 	smlabb	r6, r1, r6, r0
 800170c:	9613      	str	r6, [sp, #76]	; 0x4c
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 800170e:	eb0c 36e7 	add.w	r6, ip, r7, asr #15
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8001712:	9f13      	ldr	r7, [sp, #76]	; 0x4c
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001714:	b2b6      	uxth	r6, r6
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8001716:	eb0c 3ce7 	add.w	ip, ip, r7, asr #15
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 800171a:	fb0e f606 	mul.w	r6, lr, r6
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 800171e:	fa1f fc8c 	uxth.w	ip, ip
 8001722:	fb01 fc0c 	mul.w	ip, r1, ip
   return (ls-lc)*(1<<11)
 8001726:	9f10      	ldr	r7, [sp, #64]	; 0x40
 8001728:	9912      	ldr	r1, [sp, #72]	; 0x48
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 800172a:	4406      	add	r6, r0
   return (ls-lc)*(1<<11)
 800172c:	1bcf      	subs	r7, r1, r7
 800172e:	fb03 030a 	mla	r3, r3, sl, r0
 8001732:	fb02 020a 	mla	r2, r2, sl, r0
 8001736:	02ff      	lsls	r7, r7, #11
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001738:	eb07 37e6 	add.w	r7, r7, r6, asr #15
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 800173c:	4484      	add	ip, r0
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
 800173e:	f109 36ff 	add.w	r6, r9, #4294967295
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8001742:	eba7 3cec 	sub.w	ip, r7, ip, asr #15
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
 8001746:	01f1      	lsls	r1, r6, #7
 8001748:	fb11 0c0c 	smlabb	ip, r1, ip, r0
 800174c:	f343 37cf 	sbfx	r7, r3, #15, #16
 8001750:	f342 33cf 	sbfx	r3, r2, #15, #16
      mid = (1.f/32768)*imid;
      side = (1.f/32768)*iside;
#endif

      /* Give more bits to low-energy MDCTs than they would otherwise deserve */
      if (B0>1 && (itheta&0x3fff))
 8001754:	9a07      	ldr	r2, [sp, #28]
 8001756:	9312      	str	r3, [sp, #72]	; 0x48
 8001758:	2a01      	cmp	r2, #1
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
 800175a:	ea4f 33ec 	mov.w	r3, ip, asr #15
      if (B0>1 && (itheta&0x3fff))
 800175e:	f340 8101 	ble.w	8001964 <quant_partition+0x448>
 8001762:	9e08      	ldr	r6, [sp, #32]
 8001764:	f3c6 020d 	ubfx	r2, r6, #0, #14
 8001768:	2a00      	cmp	r2, #0
 800176a:	f000 80fb 	beq.w	8001964 <quant_partition+0x448>
      {
         if (itheta > 8192)
 800176e:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
 8001772:	f340 82df 	ble.w	8001d34 <quant_partition+0x818>
            /* Rough approximation for pre-echo masking */
            delta -= delta>>(4-LM);
 8001776:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8001778:	f1c2 0204 	rsb	r2, r2, #4
 800177c:	fa43 f202 	asr.w	r2, r3, r2
 8001780:	1a9b      	subs	r3, r3, r2
 8001782:	e0ef      	b.n	8001964 <quant_partition+0x448>
   lo = 0;
   hi = cache[0];
   bits--;
   for (i=0;i<LOG_MAX_PSEUDO;i++)
   {
      int mid = (lo+hi+1)>>1;
 8001784:	f102 0e01 	add.w	lr, r2, #1
 8001788:	ea4f 0e6e 	mov.w	lr, lr, asr #1
      /* OPT: Make sure this is implemented with a conditional move */
      if ((int)cache[mid] >= bits)
 800178c:	f816 000e 	ldrb.w	r0, [r6, lr]
   bits--;
 8001790:	f105 3cff 	add.w	ip, r5, #4294967295
      if ((int)cache[mid] >= bits)
 8001794:	4560      	cmp	r0, ip
      int mid = (lo+hi+1)>>1;
 8001796:	bfb6      	itet	lt
 8001798:	4670      	movlt	r0, lr
   lo = 0;
 800179a:	2000      	movge	r0, #0
   hi = cache[0];
 800179c:	4696      	movlt	lr, r2
      int mid = (lo+hi+1)>>1;
 800179e:	eb00 020e 	add.w	r2, r0, lr
 80017a2:	3201      	adds	r2, #1
 80017a4:	1052      	asrs	r2, r2, #1
      if ((int)cache[mid] >= bits)
 80017a6:	f816 9002 	ldrb.w	r9, [r6, r2]
 80017aa:	45e1      	cmp	r9, ip
      int mid = (lo+hi+1)>>1;
 80017ac:	bfbc      	itt	lt
 80017ae:	4610      	movlt	r0, r2
      if ((int)cache[mid] >= bits)
 80017b0:	4672      	movlt	r2, lr
      int mid = (lo+hi+1)>>1;
 80017b2:	eb00 0e02 	add.w	lr, r0, r2
 80017b6:	f10e 0e01 	add.w	lr, lr, #1
 80017ba:	ea4f 0e6e 	mov.w	lr, lr, asr #1
      if ((int)cache[mid] >= bits)
 80017be:	f816 900e 	ldrb.w	r9, [r6, lr]
 80017c2:	45cc      	cmp	ip, r9
      int mid = (lo+hi+1)>>1;
 80017c4:	bfc4      	itt	gt
 80017c6:	4670      	movgt	r0, lr
      if ((int)cache[mid] >= bits)
 80017c8:	4696      	movgt	lr, r2
      int mid = (lo+hi+1)>>1;
 80017ca:	eb00 020e 	add.w	r2, r0, lr
 80017ce:	3201      	adds	r2, #1
 80017d0:	1052      	asrs	r2, r2, #1
      if ((int)cache[mid] >= bits)
 80017d2:	f816 9002 	ldrb.w	r9, [r6, r2]
 80017d6:	45cc      	cmp	ip, r9
      int mid = (lo+hi+1)>>1;
 80017d8:	bfc4      	itt	gt
 80017da:	4610      	movgt	r0, r2
      if ((int)cache[mid] >= bits)
 80017dc:	4672      	movgt	r2, lr
      int mid = (lo+hi+1)>>1;
 80017de:	eb02 0e00 	add.w	lr, r2, r0
 80017e2:	f10e 0e01 	add.w	lr, lr, #1
 80017e6:	ea4f 0e6e 	mov.w	lr, lr, asr #1
      if ((int)cache[mid] >= bits)
 80017ea:	f816 900e 	ldrb.w	r9, [r6, lr]
 80017ee:	45cc      	cmp	ip, r9
      int mid = (lo+hi+1)>>1;
 80017f0:	bfc4      	itt	gt
 80017f2:	4670      	movgt	r0, lr
      if ((int)cache[mid] >= bits)
 80017f4:	4696      	movgt	lr, r2
      int mid = (lo+hi+1)>>1;
 80017f6:	eb0e 0200 	add.w	r2, lr, r0
 80017fa:	3201      	adds	r2, #1
 80017fc:	1052      	asrs	r2, r2, #1
      if ((int)cache[mid] >= bits)
 80017fe:	f816 9002 	ldrb.w	r9, [r6, r2]
 8001802:	45cc      	cmp	ip, r9
      int mid = (lo+hi+1)>>1;
 8001804:	bfc4      	itt	gt
 8001806:	4610      	movgt	r0, r2
      if ((int)cache[mid] >= bits)
 8001808:	4672      	movgt	r2, lr
 800180a:	f816 e002 	ldrb.w	lr, [r6, r2]
 800180e:	4691      	mov	r9, r2
 8001810:	ebae 0e0c 	sub.w	lr, lr, ip
         hi = mid;
      else
         lo = mid;
   }
   if (bits- (lo == 0 ? -1 : (int)cache[lo]) <= (int)cache[hi]-bits)
 8001814:	bb80      	cbnz	r0, 8001878 <quant_partition+0x35c>
 8001816:	4575      	cmp	r5, lr
 8001818:	dc34      	bgt.n	8001884 <quant_partition+0x368>
            cm = alg_unquant(X, N, K, spread, B, ec, gain);
         }
      } else {
         /* If there's no pulse, fill the band anyway */
         int j;
         if (ctx->resynth)
 800181a:	6867      	ldr	r7, [r4, #4]
 800181c:	b347      	cbz	r7, 8001870 <quant_partition+0x354>
         {
            unsigned cm_mask;
            /* B can be as large as 16, so this shift might overflow an int on a
               16-bit platform; use a long to get defined behavior.*/
            cm_mask = (unsigned)(1UL<<B)-1;
 800181e:	2701      	movs	r7, #1
 8001820:	9b07      	ldr	r3, [sp, #28]
            fill &= cm_mask;
            if (!fill)
 8001822:	9a0a      	ldr	r2, [sp, #40]	; 0x28
            cm_mask = (unsigned)(1UL<<B)-1;
 8001824:	409f      	lsls	r7, r3
 8001826:	1e7b      	subs	r3, r7, #1
            if (!fill)
 8001828:	ea12 0703 	ands.w	r7, r2, r3
 800182c:	d065      	beq.n	80018fa <quant_partition+0x3de>
            {
               OPUS_CLEAR(X, N);
            } else {
               if (lowband == NULL)
 800182e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8001830:	2a00      	cmp	r2, #0
 8001832:	f000 8258 	beq.w	8001ce6 <quant_partition+0x7ca>
                     X[j] = (celt_norm)((opus_int32)ctx->seed>>20);
                  }
                  cm = cm_mask;
               } else {
                  /* Folded spectrum */
                  for (j=0;j<N;j++)
 8001836:	2900      	cmp	r1, #0
 8001838:	dd15      	ble.n	8001866 <quant_partition+0x34a>
 800183a:	3a02      	subs	r2, #2
 800183c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   return 1664525 * seed + 1013904223;
 800183e:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 800191c <quant_partition+0x400>
 8001842:	4e35      	ldr	r6, [pc, #212]	; (8001918 <quant_partition+0x3fc>)
 8001844:	eb02 0e41 	add.w	lr, r2, r1, lsl #1
 8001848:	f1ab 0002 	sub.w	r0, fp, #2
 800184c:	fb0c 6303 	mla	r3, ip, r3, r6
                  {
                     opus_val16 tmp;
                     ctx->seed = celt_lcg_rand(ctx->seed);
                     /* About 48 dB below the "normal" folding level */
                     tmp = QCONST16(1.0f/256, 10);
                     tmp = (ctx->seed)&0x8000 ? tmp : -tmp;
 8001850:	f413 4f00 	tst.w	r3, #32768	; 0x8000
                     X[j] = lowband[j]+tmp;
 8001854:	f832 5f02 	ldrh.w	r5, [r2, #2]!
                     tmp = (ctx->seed)&0x8000 ? tmp : -tmp;
 8001858:	d055      	beq.n	8001906 <quant_partition+0x3ea>
                     X[j] = lowband[j]+tmp;
 800185a:	3504      	adds	r5, #4
                  for (j=0;j<N;j++)
 800185c:	4596      	cmp	lr, r2
                     X[j] = lowband[j]+tmp;
 800185e:	f820 5f02 	strh.w	r5, [r0, #2]!
                  for (j=0;j<N;j++)
 8001862:	d1f3      	bne.n	800184c <quant_partition+0x330>
 8001864:	62a3      	str	r3, [r4, #40]	; 0x28
                  }
                  cm = fill;
               }
               renormalise_vector(X, N, gain, ctx->arch);
 8001866:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001868:	4652      	mov	r2, sl
 800186a:	4658      	mov	r0, fp
 800186c:	f00a fafe 	bl	800be6c <renormalise_vector>
         }
      }
   }

   return cm;
}
 8001870:	4638      	mov	r0, r7
 8001872:	b015      	add	sp, #84	; 0x54
 8001874:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001878:	5c35      	ldrb	r5, [r6, r0]
 800187a:	ebac 0c05 	sub.w	ip, ip, r5
 800187e:	45f4      	cmp	ip, lr
 8001880:	f340 82c9 	ble.w	8001e16 <quant_partition+0x8fa>
{
   const unsigned char *cache;

   LM++;
   cache = m->cache.bits + m->cache.index[LM*m->nbEBands+band];
   return pulses == 0 ? 0 : cache[pulses]+1;
 8001884:	2a00      	cmp	r2, #0
 8001886:	d0c8      	beq.n	800181a <quant_partition+0x2fe>
 8001888:	f816 5009 	ldrb.w	r5, [r6, r9]
      ctx->remaining_bits -= curr_bits;
 800188c:	6a20      	ldr	r0, [r4, #32]
 800188e:	3501      	adds	r5, #1
 8001890:	1b40      	subs	r0, r0, r5
      while (ctx->remaining_bits < 0 && q > 0)
 8001892:	2800      	cmp	r0, #0
      ctx->remaining_bits -= curr_bits;
 8001894:	6220      	str	r0, [r4, #32]
      while (ctx->remaining_bits < 0 && q > 0)
 8001896:	da0b      	bge.n	80018b0 <quant_partition+0x394>
 8001898:	9b08      	ldr	r3, [sp, #32]
         ctx->remaining_bits += curr_bits;
 800189a:	4428      	add	r0, r5
 800189c:	3a01      	subs	r2, #1
 800189e:	6220      	str	r0, [r4, #32]
 80018a0:	d0bb      	beq.n	800181a <quant_partition+0x2fe>
 80018a2:	5cb5      	ldrb	r5, [r6, r2]
 80018a4:	3501      	adds	r5, #1
 80018a6:	1b40      	subs	r0, r0, r5
      while (ctx->remaining_bits < 0 && q > 0)
 80018a8:	2800      	cmp	r0, #0
         ctx->remaining_bits -= curr_bits;
 80018aa:	6220      	str	r0, [r4, #32]
      while (ctx->remaining_bits < 0 && q > 0)
 80018ac:	dbf5      	blt.n	800189a <quant_partition+0x37e>
 80018ae:	9308      	str	r3, [sp, #32]
   return i<8 ? i : (8 + (i&7)) << ((i>>3)-1);
 80018b0:	2a07      	cmp	r2, #7
 80018b2:	dd06      	ble.n	80018c2 <quant_partition+0x3a6>
 80018b4:	f002 0007 	and.w	r0, r2, #7
 80018b8:	10d2      	asrs	r2, r2, #3
 80018ba:	3008      	adds	r0, #8
 80018bc:	3a01      	subs	r2, #1
 80018be:	fa00 f202 	lsl.w	r2, r0, r2
         if (encode)
 80018c2:	9b08      	ldr	r3, [sp, #32]
 80018c4:	b173      	cbz	r3, 80018e4 <quant_partition+0x3c8>
            cm = alg_quant(X, N, K, spread, B, ec, gain, ctx->resynth, ctx->arch);
 80018c6:	9b07      	ldr	r3, [sp, #28]
 80018c8:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 80018ca:	4658      	mov	r0, fp
 80018cc:	6864      	ldr	r4, [r4, #4]
 80018ce:	931e      	str	r3, [sp, #120]	; 0x78
 80018d0:	4643      	mov	r3, r8
 80018d2:	e9cd 7a1f 	strd	r7, sl, [sp, #124]	; 0x7c
 80018d6:	e9cd 4521 	strd	r4, r5, [sp, #132]	; 0x84
}
 80018da:	b015      	add	sp, #84	; 0x54
 80018dc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            cm = alg_quant(X, N, K, spread, B, ec, gain, ctx->resynth, ctx->arch);
 80018e0:	f00a b8a8 	b.w	800ba34 <alg_quant>
            cm = alg_unquant(X, N, K, spread, B, ec, gain);
 80018e4:	9b07      	ldr	r3, [sp, #28]
 80018e6:	4658      	mov	r0, fp
 80018e8:	931e      	str	r3, [sp, #120]	; 0x78
 80018ea:	4643      	mov	r3, r8
 80018ec:	e9cd 7a1f 	strd	r7, sl, [sp, #124]	; 0x7c
}
 80018f0:	b015      	add	sp, #84	; 0x54
 80018f2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            cm = alg_unquant(X, N, K, spread, B, ec, gain);
 80018f6:	f00a ba1d 	b.w	800bd34 <alg_unquant>
               OPUS_CLEAR(X, N);
 80018fa:	004a      	lsls	r2, r1, #1
 80018fc:	4658      	mov	r0, fp
 80018fe:	4639      	mov	r1, r7
 8001900:	f012 fc12 	bl	8014128 <memset>
 8001904:	e7b4      	b.n	8001870 <quant_partition+0x354>
                     X[j] = lowband[j]+tmp;
 8001906:	3d04      	subs	r5, #4
                  for (j=0;j<N;j++)
 8001908:	4572      	cmp	r2, lr
                     X[j] = lowband[j]+tmp;
 800190a:	f820 5f02 	strh.w	r5, [r0, #2]!
                  for (j=0;j<N;j++)
 800190e:	d19d      	bne.n	800184c <quant_partition+0x330>
 8001910:	e7a8      	b.n	8001864 <quant_partition+0x348>
 8001912:	bf00      	nop
 8001914:	08014fb0 	.word	0x08014fb0
 8001918:	3c6ef35f 	.word	0x3c6ef35f
 800191c:	0019660d 	.word	0x0019660d
   if (encode)
 8001920:	9b08      	ldr	r3, [sp, #32]
 8001922:	2b00      	cmp	r3, #0
 8001924:	f040 8227 	bne.w	8001d76 <quant_partition+0x85a>
   tell = ec_tell_frac(ec);
 8001928:	4638      	mov	r0, r7
 800192a:	f006 fcc9 	bl	80082c0 <ec_tell_frac>
 800192e:	4680      	mov	r8, r0
   qalloc = ec_tell_frac(ec) - tell;
 8001930:	4638      	mov	r0, r7
 8001932:	f006 fcc5 	bl	80082c0 <ec_tell_frac>
 8001936:	eba0 0808 	sub.w	r8, r0, r8
   *b -= qalloc;
 800193a:	eba5 0508 	sub.w	r5, r5, r8
 800193e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8001942:	f647 71ff 	movw	r1, #32767	; 0x7fff
      *fill &= (1<<B)-1;
 8001946:	2301      	movs	r3, #1
 8001948:	2700      	movs	r7, #0
 800194a:	fb1a 2a01 	smlabb	sl, sl, r1, r2
 800194e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8001950:	9708      	str	r7, [sp, #32]
 8001952:	4093      	lsls	r3, r2
 8001954:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8001956:	3b01      	subs	r3, #1
 8001958:	401a      	ands	r2, r3
 800195a:	f34a 33cf 	sbfx	r3, sl, #15, #16
 800195e:	9312      	str	r3, [sp, #72]	; 0x48
      delta = -16384;
 8001960:	4bbc      	ldr	r3, [pc, #752]	; (8001c54 <quant_partition+0x738>)
      *fill &= (1<<B)-1;
 8001962:	920a      	str	r2, [sp, #40]	; 0x28
      mbits = IMAX(0, IMIN(b, (b-delta)/2));
 8001964:	1aeb      	subs	r3, r5, r3
 8001966:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 800196a:	105e      	asrs	r6, r3, #1
 800196c:	42ae      	cmp	r6, r5
 800196e:	bfa8      	it	ge
 8001970:	462e      	movge	r6, r5
      ctx->remaining_bits -= qalloc;
 8001972:	6a20      	ldr	r0, [r4, #32]
      if (lowband)
 8001974:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
      mbits = IMAX(0, IMIN(b, (b-delta)/2));
 8001976:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      ctx->remaining_bits -= qalloc;
 800197a:	eba0 0808 	sub.w	r8, r0, r8
      sbits = b-mbits;
 800197e:	1bad      	subs	r5, r5, r6
      ctx->remaining_bits -= qalloc;
 8001980:	f8c4 8020 	str.w	r8, [r4, #32]
      if (lowband)
 8001984:	2b00      	cmp	r3, #0
 8001986:	f000 8152 	beq.w	8001c2e <quant_partition+0x712>
         next_lowband2 = lowband+N; /* >32-bit split case */
 800198a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800198c:	441a      	add	r2, r3
 800198e:	920e      	str	r2, [sp, #56]	; 0x38
 8001990:	9b07      	ldr	r3, [sp, #28]
 8001992:	990d      	ldr	r1, [sp, #52]	; 0x34
 8001994:	105b      	asrs	r3, r3, #1
 8001996:	9307      	str	r3, [sp, #28]
 8001998:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      if (mbits >= sbits)
 800199a:	42ae      	cmp	r6, r5
 800199c:	fa43 fa01 	asr.w	sl, r3, r1
 80019a0:	db2c      	blt.n	80019fc <quant_partition+0x4e0>
         cm = quant_partition(ctx, X, N, mbits, B, lowband, LM,
 80019a2:	9304      	str	r3, [sp, #16]
 80019a4:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80019a6:	464a      	mov	r2, r9
 80019a8:	9303      	str	r3, [sp, #12]
 80019aa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80019ac:	4620      	mov	r0, r4
 80019ae:	9302      	str	r3, [sp, #8]
 80019b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80019b2:	e9cd 1300 	strd	r1, r3, [sp]
 80019b6:	4633      	mov	r3, r6
 80019b8:	4659      	mov	r1, fp
 80019ba:	f7ff fdaf 	bl	800151c <quant_partition>
         rebalance = mbits - (rebalance-ctx->remaining_bits);
 80019be:	6a23      	ldr	r3, [r4, #32]
         cm = quant_partition(ctx, X, N, mbits, B, lowband, LM,
 80019c0:	4683      	mov	fp, r0
         rebalance = mbits - (rebalance-ctx->remaining_bits);
 80019c2:	eba8 0303 	sub.w	r3, r8, r3
 80019c6:	1af6      	subs	r6, r6, r3
         if (rebalance > 3<<BITRES && itheta!=0)
 80019c8:	2e18      	cmp	r6, #24
 80019ca:	dd03      	ble.n	80019d4 <quant_partition+0x4b8>
 80019cc:	9b08      	ldr	r3, [sp, #32]
 80019ce:	b10b      	cbz	r3, 80019d4 <quant_partition+0x4b8>
            sbits += rebalance - (3<<BITRES);
 80019d0:	3e18      	subs	r6, #24
 80019d2:	4435      	add	r5, r6
         cm |= quant_partition(ctx, Y, N, sbits, B, next_lowband2, LM,
 80019d4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80019d6:	e9cd 7a03 	strd	r7, sl, [sp, #12]
 80019da:	9302      	str	r3, [sp, #8]
 80019dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80019de:	464a      	mov	r2, r9
 80019e0:	9301      	str	r3, [sp, #4]
 80019e2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80019e4:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80019e6:	9300      	str	r3, [sp, #0]
 80019e8:	4620      	mov	r0, r4
 80019ea:	462b      	mov	r3, r5
 80019ec:	f7ff fd96 	bl	800151c <quant_partition>
               MULT16_16_P15(gain,side), fill>>B)<<(B0>>1);
 80019f0:	9b07      	ldr	r3, [sp, #28]
 80019f2:	fa00 f703 	lsl.w	r7, r0, r3
         cm |= quant_partition(ctx, Y, N, sbits, B, next_lowband2, LM,
 80019f6:	ea47 070b 	orr.w	r7, r7, fp
 80019fa:	e739      	b.n	8001870 <quant_partition+0x354>
         cm = quant_partition(ctx, Y, N, sbits, B, next_lowband2, LM,
 80019fc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80019fe:	e9cd 7a03 	strd	r7, sl, [sp, #12]
 8001a02:	9302      	str	r3, [sp, #8]
 8001a04:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8001a06:	464a      	mov	r2, r9
 8001a08:	9301      	str	r3, [sp, #4]
 8001a0a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001a0c:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8001a0e:	9300      	str	r3, [sp, #0]
 8001a10:	4620      	mov	r0, r4
 8001a12:	462b      	mov	r3, r5
 8001a14:	f7ff fd82 	bl	800151c <quant_partition>
         rebalance = sbits - (rebalance-ctx->remaining_bits);
 8001a18:	6a23      	ldr	r3, [r4, #32]
         cm = quant_partition(ctx, Y, N, sbits, B, next_lowband2, LM,
 8001a1a:	9a07      	ldr	r2, [sp, #28]
         rebalance = sbits - (rebalance-ctx->remaining_bits);
 8001a1c:	eba8 0803 	sub.w	r8, r8, r3
 8001a20:	eba5 0508 	sub.w	r5, r5, r8
         if (rebalance > 3<<BITRES && itheta!=16384)
 8001a24:	2d18      	cmp	r5, #24
         cm = quant_partition(ctx, Y, N, sbits, B, next_lowband2, LM,
 8001a26:	fa00 f702 	lsl.w	r7, r0, r2
         if (rebalance > 3<<BITRES && itheta!=16384)
 8001a2a:	dd05      	ble.n	8001a38 <quant_partition+0x51c>
 8001a2c:	9b08      	ldr	r3, [sp, #32]
 8001a2e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
            mbits += rebalance - (3<<BITRES);
 8001a32:	bf1c      	itt	ne
 8001a34:	3d18      	subne	r5, #24
 8001a36:	1976      	addne	r6, r6, r5
         cm |= quant_partition(ctx, X, N, mbits, B, lowband, LM,
 8001a38:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001a3a:	464a      	mov	r2, r9
 8001a3c:	9304      	str	r3, [sp, #16]
 8001a3e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8001a40:	4659      	mov	r1, fp
 8001a42:	9303      	str	r3, [sp, #12]
 8001a44:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8001a46:	4620      	mov	r0, r4
 8001a48:	9302      	str	r3, [sp, #8]
 8001a4a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8001a4c:	9301      	str	r3, [sp, #4]
 8001a4e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001a50:	9300      	str	r3, [sp, #0]
 8001a52:	4633      	mov	r3, r6
 8001a54:	f7ff fd62 	bl	800151c <quant_partition>
 8001a58:	4307      	orrs	r7, r0
   {
 8001a5a:	e709      	b.n	8001870 <quant_partition+0x354>
   if (d>256)
 8001a5c:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
      return -(opus_int32)celt_udiv(-n, d);
 8001a60:	f1cc 0c00 	rsb	ip, ip, #0
   if (d>256)
 8001a64:	f300 80e5 	bgt.w	8001c32 <quant_partition+0x716>
      t = EC_ILOG(d&-d);
 8001a68:	4251      	negs	r1, r2
 8001a6a:	4011      	ands	r1, r2
 8001a6c:	fab1 f181 	clz	r1, r1
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8001a70:	4879      	ldr	r0, [pc, #484]	; (8001c58 <quant_partition+0x73c>)
      t = EC_ILOG(d&-d);
 8001a72:	f1c1 0120 	rsb	r1, r1, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8001a76:	fa22 fe01 	lsr.w	lr, r2, r1
 8001a7a:	f850 002e 	ldr.w	r0, [r0, lr, lsl #2]
 8001a7e:	3901      	subs	r1, #1
 8001a80:	fa2c f101 	lsr.w	r1, ip, r1
 8001a84:	fba1 0100 	umull	r0, r1, r1, r0
      return q+(n-q*d >= d);
 8001a88:	fb02 cc11 	mls	ip, r2, r1, ip
 8001a8c:	4594      	cmp	ip, r2
 8001a8e:	bf34      	ite	cc
 8001a90:	460a      	movcc	r2, r1
 8001a92:	1c4a      	addcs	r2, r1, #1
      return -(opus_int32)celt_udiv(-n, d);
 8001a94:	4252      	negs	r2, r2
 8001a96:	e5a2      	b.n	80015de <quant_partition+0xc2>
      itheta = stereo_itheta(X, Y, stereo, N, ctx->arch);
 8001a98:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001a9a:	464b      	mov	r3, r9
 8001a9c:	9200      	str	r2, [sp, #0]
 8001a9e:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8001aa0:	2200      	movs	r2, #0
 8001aa2:	4658      	mov	r0, fp
 8001aa4:	f00a fa26 	bl	800bef4 <stereo_itheta>
 8001aa8:	4680      	mov	r8, r0
   tell = ec_tell_frac(ec);
 8001aaa:	4638      	mov	r0, r7
 8001aac:	f006 fc08 	bl	80082c0 <ec_tell_frac>
            itheta = (itheta*(opus_int32)qn+8192)>>14;
 8001ab0:	fb06 f808 	mul.w	r8, r6, r8
            if (!stereo && ctx->avoid_split_noise && itheta > 0 && itheta < qn)
 8001ab4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
            itheta = (itheta*(opus_int32)qn+8192)>>14;
 8001ab6:	f508 5800 	add.w	r8, r8, #8192	; 0x2000
   tell = ec_tell_frac(ec);
 8001aba:	9012      	str	r0, [sp, #72]	; 0x48
            itheta = (itheta*(opus_int32)qn+8192)>>14;
 8001abc:	ea4f 38a8 	mov.w	r8, r8, asr #14
            if (!stereo && ctx->avoid_split_noise && itheta > 0 && itheta < qn)
 8001ac0:	2b00      	cmp	r3, #0
 8001ac2:	f000 80b9 	beq.w	8001c38 <quant_partition+0x71c>
 8001ac6:	f1b8 0f00 	cmp.w	r8, #0
 8001aca:	f340 813d 	ble.w	8001d48 <quant_partition+0x82c>
               int unquantized = celt_udiv((opus_int32)itheta*16384, qn);
 8001ace:	ea4f 3388 	mov.w	r3, r8, lsl #14
            if (!stereo && ctx->avoid_split_noise && itheta > 0 && itheta < qn)
 8001ad2:	45b0      	cmp	r8, r6
               int unquantized = celt_udiv((opus_int32)itheta*16384, qn);
 8001ad4:	9308      	str	r3, [sp, #32]
            if (!stereo && ctx->avoid_split_noise && itheta > 0 && itheta < qn)
 8001ad6:	f280 80b2 	bge.w	8001c3e <quant_partition+0x722>
   if (d>256)
 8001ada:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 8001ade:	f240 817f 	bls.w	8001de0 <quant_partition+0x8c4>
      return n/d;
 8001ae2:	fbb3 f2f6 	udiv	r2, r3, r6
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
 8001ae6:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
               iside = bitexact_cos((opus_int16)(16384-unquantized));
 8001aea:	f5c2 4080 	rsb	r0, r2, #16384	; 0x4000
               imid = bitexact_cos((opus_int16)unquantized);
 8001aee:	b212      	sxth	r2, r2
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
 8001af0:	fb02 c202 	mla	r2, r2, r2, ip
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
 8001af4:	f64f 538e 	movw	r3, #64910	; 0xfd8e
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
 8001af8:	ea4f 3e62 	mov.w	lr, r2, asr #13
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
 8001afc:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8001b00:	f44f 4280 	mov.w	r2, #16384	; 0x4000
               iside = bitexact_cos((opus_int16)(16384-unquantized));
 8001b04:	b200      	sxth	r0, r0
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
 8001b06:	fb00 c000 	mla	r0, r0, r0, ip
 8001b0a:	1340      	asrs	r0, r0, #13
   x2 = tmp;
 8001b0c:	9010      	str	r0, [sp, #64]	; 0x40
 8001b0e:	f9bd c040 	ldrsh.w	ip, [sp, #64]	; 0x40
 8001b12:	fa0f f08e 	sxth.w	r0, lr
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
 8001b16:	fb10 1103 	smlabb	r1, r0, r3, r1
 8001b1a:	fb1c 2203 	smlabb	r2, ip, r3, r2
 8001b1e:	f242 0355 	movw	r3, #8277	; 0x2055
 8001b22:	eb03 32e2 	add.w	r2, r3, r2, asr #15
 8001b26:	eb03 33e1 	add.w	r3, r3, r1, asr #15
 8001b2a:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8001b2e:	b292      	uxth	r2, r2
 8001b30:	b29b      	uxth	r3, r3
 8001b32:	fb0c f202 	mul.w	r2, ip, r2
 8001b36:	fb00 f303 	mul.w	r3, r0, r3
 8001b3a:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
 8001b3e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8001b42:	13d2      	asrs	r2, r2, #15
 8001b44:	13db      	asrs	r3, r3, #15
 8001b46:	f5a2 52ef 	sub.w	r2, r2, #7648	; 0x1de0
 8001b4a:	f5a3 53ef 	sub.w	r3, r3, #7648	; 0x1de0
 8001b4e:	3a03      	subs	r2, #3
 8001b50:	3b03      	subs	r3, #3
 8001b52:	fb10 1303 	smlabb	r3, r0, r3, r1
 8001b56:	fb1c 1202 	smlabb	r2, ip, r2, r1
   return 1+x2;
 8001b5a:	9810      	ldr	r0, [sp, #64]	; 0x40
 8001b5c:	f5ce 4e00 	rsb	lr, lr, #32768	; 0x8000
 8001b60:	f5c0 4000 	rsb	r0, r0, #32768	; 0x8000
 8001b64:	eb00 32e2 	add.w	r2, r0, r2, asr #15
 8001b68:	eb0e 3ee3 	add.w	lr, lr, r3, asr #15
 8001b6c:	b212      	sxth	r2, r2
 8001b6e:	fa0f fe8e 	sxth.w	lr, lr
   ls=EC_ILOG(isin);
 8001b72:	fab2 f382 	clz	r3, r2
   lc=EC_ILOG(icos);
 8001b76:	fabe f08e 	clz	r0, lr
   ls=EC_ILOG(isin);
 8001b7a:	4619      	mov	r1, r3
   lc=EC_ILOG(icos);
 8001b7c:	9010      	str	r0, [sp, #64]	; 0x40
   isin<<=15-ls;
 8001b7e:	3b11      	subs	r3, #17
 8001b80:	fa02 f303 	lsl.w	r3, r2, r3
   icos<<=15-lc;
 8001b84:	9a10      	ldr	r2, [sp, #64]	; 0x40
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001b86:	f24f 5cdb 	movw	ip, #62939	; 0xf5db
   icos<<=15-lc;
 8001b8a:	3a11      	subs	r2, #17
 8001b8c:	fa0e fe02 	lsl.w	lr, lr, r2
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001b90:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8001b94:	b21b      	sxth	r3, r3
 8001b96:	fb13 220c 	smlabb	r2, r3, ip, r2
 8001b9a:	9213      	str	r2, [sp, #76]	; 0x4c
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8001b9c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001ba0:	f641 60fc 	movw	r0, #7932	; 0x1efc
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8001ba4:	fa0f fe8e 	sxth.w	lr, lr
 8001ba8:	fb1e 2c0c 	smlabb	ip, lr, ip, r2
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001bac:	9a13      	ldr	r2, [sp, #76]	; 0x4c
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8001bae:	eb00 3cec 	add.w	ip, r0, ip, asr #15
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001bb2:	eb00 32e2 	add.w	r2, r0, r2, asr #15
   return (ls-lc)*(1<<11)
 8001bb6:	9810      	ldr	r0, [sp, #64]	; 0x40
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001bb8:	b292      	uxth	r2, r2
 8001bba:	fb03 f302 	mul.w	r3, r3, r2
   return (ls-lc)*(1<<11)
 8001bbe:	1a42      	subs	r2, r0, r1
               delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
 8001bc0:	f44f 4180 	mov.w	r1, #16384	; 0x4000
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8001bc4:	fa1f fc8c 	uxth.w	ip, ip
 8001bc8:	fb0e fe0c 	mul.w	lr, lr, ip
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001bcc:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   return (ls-lc)*(1<<11)
 8001bd0:	02d2      	lsls	r2, r2, #11
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8001bd2:	eb02 32e3 	add.w	r2, r2, r3, asr #15
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8001bd6:	f50e 4e80 	add.w	lr, lr, #16384	; 0x4000
               delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
 8001bda:	f109 33ff 	add.w	r3, r9, #4294967295
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8001bde:	eba2 32ee 	sub.w	r2, r2, lr, asr #15
               delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
 8001be2:	01db      	lsls	r3, r3, #7
 8001be4:	fb13 1302 	smlabb	r3, r3, r2, r1
 8001be8:	13db      	asrs	r3, r3, #15
               if (delta > *b)
 8001bea:	42ab      	cmp	r3, r5
 8001bec:	f300 80f4 	bgt.w	8001dd8 <quant_partition+0x8bc>
               else if (delta < -*b)
 8001bf0:	426a      	negs	r2, r5
 8001bf2:	4293      	cmp	r3, r2
 8001bf4:	da23      	bge.n	8001c3e <quant_partition+0x722>
                  itheta = 0;
 8001bf6:	f04f 0800 	mov.w	r8, #0
 8001bfa:	f8cd 8020 	str.w	r8, [sp, #32]
 8001bfe:	e01e      	b.n	8001c3e <quant_partition+0x722>
      t = EC_ILOG(d&-d);
 8001c00:	4251      	negs	r1, r2
 8001c02:	4011      	ands	r1, r2
 8001c04:	fab1 f181 	clz	r1, r1
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8001c08:	4813      	ldr	r0, [pc, #76]	; (8001c58 <quant_partition+0x73c>)
      t = EC_ILOG(d&-d);
 8001c0a:	f1c1 0120 	rsb	r1, r1, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8001c0e:	fa22 fe01 	lsr.w	lr, r2, r1
 8001c12:	f850 002e 	ldr.w	r0, [r0, lr, lsl #2]
 8001c16:	3901      	subs	r1, #1
 8001c18:	fa2c f101 	lsr.w	r1, ip, r1
 8001c1c:	fba1 0100 	umull	r0, r1, r1, r0
      return q+(n-q*d >= d);
 8001c20:	fb02 cc11 	mls	ip, r2, r1, ip
 8001c24:	4594      	cmp	ip, r2
 8001c26:	bf34      	ite	cc
 8001c28:	460a      	movcc	r2, r1
 8001c2a:	1c4a      	addcs	r2, r1, #1
 8001c2c:	e4d7      	b.n	80015de <quant_partition+0xc2>
      celt_norm *next_lowband2=NULL;
 8001c2e:	930e      	str	r3, [sp, #56]	; 0x38
 8001c30:	e6ae      	b.n	8001990 <quant_partition+0x474>
      return n/d;
 8001c32:	fbbc f2f2 	udiv	r2, ip, r2
 8001c36:	e72d      	b.n	8001a94 <quant_partition+0x578>
 8001c38:	ea4f 3388 	mov.w	r3, r8, lsl #14
 8001c3c:	9308      	str	r3, [sp, #32]
      } else if (B0>1 || stereo) {
 8001c3e:	9b07      	ldr	r3, [sp, #28]
 8001c40:	2b01      	cmp	r3, #1
 8001c42:	f340 8088 	ble.w	8001d56 <quant_partition+0x83a>
            ec_enc_uint(ec, itheta, qn+1);
 8001c46:	4641      	mov	r1, r8
 8001c48:	1c72      	adds	r2, r6, #1
 8001c4a:	4638      	mov	r0, r7
 8001c4c:	f006 ff34 	bl	8008ab8 <ec_enc_uint>
 8001c50:	e4f0      	b.n	8001634 <quant_partition+0x118>
 8001c52:	bf00      	nop
 8001c54:	ffffc000 	.word	0xffffc000
 8001c58:	0801649c 	.word	0x0801649c
         ft = ((qn>>1)+1)*((qn>>1)+1);
 8001c5c:	ea4f 0866 	mov.w	r8, r6, asr #1
 8001c60:	f108 0201 	add.w	r2, r8, #1
 8001c64:	fb02 f302 	mul.w	r3, r2, r2
            fm = ec_decode(ec, ft);
 8001c68:	4638      	mov	r0, r7
 8001c6a:	4619      	mov	r1, r3
         ft = ((qn>>1)+1)*((qn>>1)+1);
 8001c6c:	9210      	str	r2, [sp, #64]	; 0x40
            fm = ec_decode(ec, ft);
 8001c6e:	9308      	str	r3, [sp, #32]
 8001c70:	f006 fba8 	bl	80083c4 <ec_decode>
            if (fm < ((qn>>1)*((qn>>1) + 1)>>1))
 8001c74:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8001c76:	9b08      	ldr	r3, [sp, #32]
 8001c78:	fb08 f802 	mul.w	r8, r8, r2
 8001c7c:	ebb0 0f68 	cmp.w	r0, r8, asr #1
 8001c80:	f280 8094 	bge.w	8001dac <quant_partition+0x890>
               itheta = (isqrt32(8*(opus_uint32)fm + 1) - 1)>>1;
 8001c84:	00c0      	lsls	r0, r0, #3
 8001c86:	3001      	adds	r0, #1
 8001c88:	9308      	str	r3, [sp, #32]
 8001c8a:	f007 fc9f 	bl	80095cc <isqrt32>
 8001c8e:	3801      	subs	r0, #1
 8001c90:	ea4f 0850 	mov.w	r8, r0, lsr #1
               fs = itheta + 1;
 8001c94:	f108 0201 	add.w	r2, r8, #1
               fl = itheta*(itheta + 1)>>1;
 8001c98:	fb02 f108 	mul.w	r1, r2, r8
 8001c9c:	9b08      	ldr	r3, [sp, #32]
 8001c9e:	1049      	asrs	r1, r1, #1
            ec_dec_update(ec, fl, fl+fs, ft);
 8001ca0:	440a      	add	r2, r1
 8001ca2:	4638      	mov	r0, r7
 8001ca4:	f006 fbd0 	bl	8008448 <ec_dec_update>
 8001ca8:	ea4f 3388 	mov.w	r3, r8, lsl #14
 8001cac:	9308      	str	r3, [sp, #32]
 8001cae:	e4c1      	b.n	8001634 <quant_partition+0x118>
      t = EC_ILOG(d&-d);
 8001cb0:	4273      	negs	r3, r6
 8001cb2:	4033      	ands	r3, r6
 8001cb4:	fab3 f383 	clz	r3, r3
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8001cb8:	4958      	ldr	r1, [pc, #352]	; (8001e1c <quant_partition+0x900>)
      t = EC_ILOG(d&-d);
 8001cba:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8001cbe:	fa26 f003 	lsr.w	r0, r6, r3
 8001cc2:	1e5a      	subs	r2, r3, #1
 8001cc4:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 8001cc8:	9908      	ldr	r1, [sp, #32]
 8001cca:	fa21 f202 	lsr.w	r2, r1, r2
 8001cce:	fba2 2303 	umull	r2, r3, r2, r3
      return q+(n-q*d >= d);
 8001cd2:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8001cd6:	fb06 1213 	mls	r2, r6, r3, r1
 8001cda:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001cdc:	42b2      	cmp	r2, r6
 8001cde:	bf28      	it	cs
 8001ce0:	3301      	addcs	r3, #1
 8001ce2:	461e      	mov	r6, r3
 8001ce4:	e4ad      	b.n	8001642 <quant_partition+0x126>
                  for (j=0;j<N;j++)
 8001ce6:	2900      	cmp	r1, #0
 8001ce8:	dd5e      	ble.n	8001da8 <quant_partition+0x88c>
 8001cea:	f1ab 0202 	sub.w	r2, fp, #2
 8001cee:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   return 1664525 * seed + 1013904223;
 8001cf0:	f8df c130 	ldr.w	ip, [pc, #304]	; 8001e24 <quant_partition+0x908>
 8001cf4:	4f4a      	ldr	r7, [pc, #296]	; (8001e20 <quant_partition+0x904>)
 8001cf6:	eb02 0641 	add.w	r6, r2, r1, lsl #1
 8001cfa:	fb0c 7000 	mla	r0, ip, r0, r7
                     X[j] = (celt_norm)((opus_int32)ctx->seed>>20);
 8001cfe:	1505      	asrs	r5, r0, #20
 8001d00:	f822 5f02 	strh.w	r5, [r2, #2]!
                  for (j=0;j<N;j++)
 8001d04:	4296      	cmp	r6, r2
 8001d06:	d1f8      	bne.n	8001cfa <quant_partition+0x7de>
 8001d08:	62a0      	str	r0, [r4, #40]	; 0x28
 8001d0a:	461f      	mov	r7, r3
 8001d0c:	e5ab      	b.n	8001866 <quant_partition+0x34a>
 8001d0e:	4619      	mov	r1, r3
 8001d10:	f647 72ff 	movw	r2, #32767	; 0x7fff
      *fill &= ((1<<B)-1)<<B;
 8001d14:	2301      	movs	r3, #1
 8001d16:	fb1a 1a02 	smlabb	sl, sl, r2, r1
 8001d1a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8001d1c:	f34a 37cf 	sbfx	r7, sl, #15, #16
 8001d20:	4093      	lsls	r3, r2
 8001d22:	3b01      	subs	r3, #1
 8001d24:	4093      	lsls	r3, r2
 8001d26:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8001d28:	401a      	ands	r2, r3
 8001d2a:	920a      	str	r2, [sp, #40]	; 0x28
 8001d2c:	2200      	movs	r2, #0
      delta = 16384;
 8001d2e:	460b      	mov	r3, r1
      *fill &= ((1<<B)-1)<<B;
 8001d30:	9212      	str	r2, [sp, #72]	; 0x48
 8001d32:	e617      	b.n	8001964 <quant_partition+0x448>
            delta = IMIN(0, delta + (N<<BITRES>>(5-LM)));
 8001d34:	990c      	ldr	r1, [sp, #48]	; 0x30
 8001d36:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 8001d3a:	f1c1 0105 	rsb	r1, r1, #5
 8001d3e:	410a      	asrs	r2, r1
 8001d40:	4413      	add	r3, r2
 8001d42:	ea03 73e3 	and.w	r3, r3, r3, asr #31
 8001d46:	e60d      	b.n	8001964 <quant_partition+0x448>
      } else if (B0>1 || stereo) {
 8001d48:	9b07      	ldr	r3, [sp, #28]
 8001d4a:	2b01      	cmp	r3, #1
 8001d4c:	ea4f 3388 	mov.w	r3, r8, lsl #14
 8001d50:	9308      	str	r3, [sp, #32]
 8001d52:	f73f af78 	bgt.w	8001c46 <quant_partition+0x72a>
         ft = ((qn>>1)+1)*((qn>>1)+1);
 8001d56:	1072      	asrs	r2, r6, #1
 8001d58:	1c53      	adds	r3, r2, #1
            fs = itheta <= (qn>>1) ? itheta + 1 : qn + 1 - itheta;
 8001d5a:	4590      	cmp	r8, r2
         ft = ((qn>>1)+1)*((qn>>1)+1);
 8001d5c:	fb03 f303 	mul.w	r3, r3, r3
            fs = itheta <= (qn>>1) ? itheta + 1 : qn + 1 - itheta;
 8001d60:	dc17      	bgt.n	8001d92 <quant_partition+0x876>
 8001d62:	f108 0201 	add.w	r2, r8, #1
            fl = itheta <= (qn>>1) ? itheta*(itheta + 1)>>1 :
 8001d66:	fb02 f108 	mul.w	r1, r2, r8
 8001d6a:	1049      	asrs	r1, r1, #1
            ec_encode(ec, fl, fl+fs, ft);
 8001d6c:	440a      	add	r2, r1
 8001d6e:	4638      	mov	r0, r7
 8001d70:	f006 fda8 	bl	80088c4 <ec_encode>
 8001d74:	e45e      	b.n	8001634 <quant_partition+0x118>
      itheta = stereo_itheta(X, Y, stereo, N, ctx->arch);
 8001d76:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001d78:	464b      	mov	r3, r9
 8001d7a:	9200      	str	r2, [sp, #0]
 8001d7c:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8001d7e:	2200      	movs	r2, #0
 8001d80:	4658      	mov	r0, fp
 8001d82:	f00a f8b7 	bl	800bef4 <stereo_itheta>
 8001d86:	9008      	str	r0, [sp, #32]
   tell = ec_tell_frac(ec);
 8001d88:	4638      	mov	r0, r7
 8001d8a:	f006 fa99 	bl	80082c0 <ec_tell_frac>
 8001d8e:	9012      	str	r0, [sp, #72]	; 0x48
 8001d90:	e458      	b.n	8001644 <quant_partition+0x128>
            fs = itheta <= (qn>>1) ? itheta + 1 : qn + 1 - itheta;
 8001d92:	1c72      	adds	r2, r6, #1
             ft - ((qn + 1 - itheta)*(qn + 2 - itheta)>>1);
 8001d94:	1cb1      	adds	r1, r6, #2
            fs = itheta <= (qn>>1) ? itheta + 1 : qn + 1 - itheta;
 8001d96:	eba2 0208 	sub.w	r2, r2, r8
             ft - ((qn + 1 - itheta)*(qn + 2 - itheta)>>1);
 8001d9a:	eba1 0108 	sub.w	r1, r1, r8
 8001d9e:	fb02 f101 	mul.w	r1, r2, r1
            fl = itheta <= (qn>>1) ? itheta*(itheta + 1)>>1 :
 8001da2:	eba3 0161 	sub.w	r1, r3, r1, asr #1
 8001da6:	e7e1      	b.n	8001d6c <quant_partition+0x850>
                  for (j=0;j<N;j++)
 8001da8:	461f      	mov	r7, r3
 8001daa:	e55c      	b.n	8001866 <quant_partition+0x34a>
                - isqrt32(8*(opus_uint32)(ft - fm - 1) + 1))>>1;
 8001dac:	1a18      	subs	r0, r3, r0
 8001dae:	00c0      	lsls	r0, r0, #3
 8001db0:	3807      	subs	r0, #7
 8001db2:	9308      	str	r3, [sp, #32]
 8001db4:	f007 fc0a 	bl	80095cc <isqrt32>
               itheta = (2*(qn + 1)
 8001db8:	1c72      	adds	r2, r6, #1
                - isqrt32(8*(opus_uint32)(ft - fm - 1) + 1))>>1;
 8001dba:	ebc0 0042 	rsb	r0, r0, r2, lsl #1
 8001dbe:	ea4f 0850 	mov.w	r8, r0, lsr #1
               fl = ft - ((qn + 1 - itheta)*(qn + 2 - itheta)>>1);
 8001dc2:	1cb1      	adds	r1, r6, #2
               fs = qn + 1 - itheta;
 8001dc4:	eba2 0208 	sub.w	r2, r2, r8
               fl = ft - ((qn + 1 - itheta)*(qn + 2 - itheta)>>1);
 8001dc8:	eba1 0108 	sub.w	r1, r1, r8
 8001dcc:	fb02 f101 	mul.w	r1, r2, r1
 8001dd0:	9b08      	ldr	r3, [sp, #32]
 8001dd2:	eba3 0161 	sub.w	r1, r3, r1, asr #1
 8001dd6:	e763      	b.n	8001ca0 <quant_partition+0x784>
 8001dd8:	03b3      	lsls	r3, r6, #14
               if (delta > *b)
 8001dda:	46b0      	mov	r8, r6
 8001ddc:	9308      	str	r3, [sp, #32]
 8001dde:	e72e      	b.n	8001c3e <quant_partition+0x722>
      t = EC_ILOG(d&-d);
 8001de0:	4273      	negs	r3, r6
 8001de2:	4033      	ands	r3, r6
 8001de4:	fab3 f383 	clz	r3, r3
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8001de8:	490c      	ldr	r1, [pc, #48]	; (8001e1c <quant_partition+0x900>)
      t = EC_ILOG(d&-d);
 8001dea:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8001dee:	fa26 f003 	lsr.w	r0, r6, r3
 8001df2:	1e5a      	subs	r2, r3, #1
 8001df4:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 8001df8:	9908      	ldr	r1, [sp, #32]
 8001dfa:	fa21 f202 	lsr.w	r2, r1, r2
 8001dfe:	fba2 2303 	umull	r2, r3, r2, r3
      return q+(n-q*d >= d);
 8001e02:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
 8001e06:	fb06 1213 	mls	r2, r6, r3, r1
 8001e0a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8001e0c:	42b2      	cmp	r2, r6
 8001e0e:	bf28      	it	cs
 8001e10:	3301      	addcs	r3, #1
 8001e12:	461a      	mov	r2, r3
 8001e14:	e667      	b.n	8001ae6 <quant_partition+0x5ca>
   if (bits- (lo == 0 ? -1 : (int)cache[lo]) <= (int)cache[hi]-bits)
 8001e16:	4602      	mov	r2, r0
 8001e18:	4681      	mov	r9, r0
 8001e1a:	e535      	b.n	8001888 <quant_partition+0x36c>
 8001e1c:	0801649c 	.word	0x0801649c
 8001e20:	3c6ef35f 	.word	0x3c6ef35f
 8001e24:	0019660d 	.word	0x0019660d

08001e28 <quant_band>:
/* This function is responsible for encoding and decoding a band for the mono case. */
static unsigned quant_band(struct band_ctx *ctx, celt_norm *X,
      int N, int b, int B, celt_norm *lowband,
      int LM, celt_norm *lowband_out,
      opus_val16 gain, celt_norm *lowband_scratch, int fill)
{
 8001e28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001e2c:	b095      	sub	sp, #84	; 0x54
 8001e2e:	af06      	add	r7, sp, #24
 8001e30:	60bb      	str	r3, [r7, #8]
   int k;
   int encode;
   int tf_change;

   encode = ctx->encode;
   tf_change = ctx->tf_change;
 8001e32:	6983      	ldr	r3, [r0, #24]
{
 8001e34:	468a      	mov	sl, r1
   tf_change = ctx->tf_change;
 8001e36:	627b      	str	r3, [r7, #36]	; 0x24
{
 8001e38:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
   encode = ctx->encode;
 8001e3c:	6801      	ldr	r1, [r0, #0]
{
 8001e3e:	607b      	str	r3, [r7, #4]
   if (d>256)
 8001e40:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8001e42:	6138      	str	r0, [r7, #16]
 8001e44:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8001e48:	61fa      	str	r2, [r7, #28]
   encode = ctx->encode;
 8001e4a:	6239      	str	r1, [r7, #32]
{
 8001e4c:	f8d7 9064 	ldr.w	r9, [r7, #100]	; 0x64
 8001e50:	f240 8194 	bls.w	800217c <quant_band+0x354>
      return n/d;
 8001e54:	4613      	mov	r3, r2
 8001e56:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8001e58:	fbb3 f3f2 	udiv	r3, r3, r2
 8001e5c:	60fb      	str	r3, [r7, #12]
 8001e5e:	469b      	mov	fp, r3
   longBlocks = B0==1;

   N_B = celt_udiv(N_B, B);

   /* Special case for one sample */
   if (N==1)
 8001e60:	69fb      	ldr	r3, [r7, #28]
 8001e62:	2b01      	cmp	r3, #1
 8001e64:	f000 81aa 	beq.w	80021bc <quant_band+0x394>
   {
      return quant_band_n1(ctx, X, NULL, b, lowband_out);
   }

   if (tf_change>0)
 8001e68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001e6a:	2b00      	cmp	r3, #0
 8001e6c:	f340 8248 	ble.w	8002300 <quant_band+0x4d8>
      recombine = tf_change;
   /* Band recombining to increase frequency resolution */

   if (lowband_scratch && lowband && (recombine || ((N_B&1) == 0 && tf_change<0) || B0>1))
 8001e70:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8001e72:	b153      	cbz	r3, 8001e8a <quant_band+0x62>
 8001e74:	f1b9 0f00 	cmp.w	r9, #0
 8001e78:	d007      	beq.n	8001e8a <quant_band+0x62>
 8001e7a:	4618      	mov	r0, r3
   {
      OPUS_COPY(lowband_scratch, lowband, N);
 8001e7c:	69fb      	ldr	r3, [r7, #28]
 8001e7e:	4649      	mov	r1, r9
 8001e80:	005a      	lsls	r2, r3, #1
 8001e82:	f012 f92d 	bl	80140e0 <memcpy>
 8001e86:	f8d7 9074 	ldr.w	r9, [r7, #116]	; 0x74
      lowband = lowband_scratch;
   }

   for (k=0;k<recombine;k++)
 8001e8a:	2300      	movs	r3, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8001e8c:	f645 2b82 	movw	fp, #23170	; 0x5a82
 8001e90:	46d6      	mov	lr, sl
   for (k=0;k<recombine;k++)
 8001e92:	62bb      	str	r3, [r7, #40]	; 0x28
   {
      static const unsigned char bit_interleave_table[16]={
            0,1,1,1,2,3,3,3,2,3,3,3,2,3,3,3
      };
      if (encode)
 8001e94:	6a3b      	ldr	r3, [r7, #32]
 8001e96:	2b00      	cmp	r3, #0
 8001e98:	f040 81e8 	bne.w	800226c <quant_band+0x444>
         haar1(X, N>>k, 1<<k);
      if (lowband)
 8001e9c:	f1b9 0f00 	cmp.w	r9, #0
 8001ea0:	d04c      	beq.n	8001f3c <quant_band+0x114>
         haar1(lowband, N>>k, 1<<k);
 8001ea2:	69fb      	ldr	r3, [r7, #28]
 8001ea4:	2201      	movs	r2, #1
 8001ea6:	4619      	mov	r1, r3
 8001ea8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001eaa:	fa41 fc03 	asr.w	ip, r1, r3
 8001eae:	fa02 f303 	lsl.w	r3, r2, r3
   for (i=0;i<stride;i++)
 8001eb2:	2b00      	cmp	r3, #0
         haar1(lowband, N>>k, 1<<k);
 8001eb4:	633b      	str	r3, [r7, #48]	; 0x30
   N0 >>= 1;
 8001eb6:	fa4c fc02 	asr.w	ip, ip, r2
   for (i=0;i<stride;i++)
 8001eba:	dd3f      	ble.n	8001f3c <quant_band+0x114>
 8001ebc:	2202      	movs	r2, #2
 8001ebe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001ec0:	f1bc 0f00 	cmp.w	ip, #0
 8001ec4:	fa02 fa03 	lsl.w	sl, r2, r3
 8001ec8:	dd38      	ble.n	8001f3c <quant_band+0x114>
 8001eca:	ea4f 034a 	mov.w	r3, sl, lsl #1
 8001ece:	61bb      	str	r3, [r7, #24]
 8001ed0:	2102      	movs	r1, #2
 8001ed2:	2201      	movs	r2, #1
      for (j=0;j<N0;j++)
 8001ed4:	f04f 0800 	mov.w	r8, #0
 8001ed8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001eda:	f8c7 e014 	str.w	lr, [r7, #20]
 8001ede:	fa01 fa03 	lsl.w	sl, r1, r3
 8001ee2:	f8d7 e018 	ldr.w	lr, [r7, #24]
 8001ee6:	fa02 f303 	lsl.w	r3, r2, r3
 8001eea:	f8c7 9034 	str.w	r9, [r7, #52]	; 0x34
 8001eee:	62fb      	str	r3, [r7, #44]	; 0x2c
 8001ef0:	2400      	movs	r4, #0
   for (i=0;i<stride;i++)
 8001ef2:	6afd      	ldr	r5, [r7, #44]	; 0x2c
 8001ef4:	6b78      	ldr	r0, [r7, #52]	; 0x34
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 8001ef6:	eb05 0208 	add.w	r2, r5, r8
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8001efa:	8801      	ldrh	r1, [r0, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 8001efc:	f839 3012 	ldrh.w	r3, [r9, r2, lsl #1]
      for (j=0;j<N0;j++)
 8001f00:	3401      	adds	r4, #1
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 8001f02:	fb13 f60b 	smulbb	r6, r3, fp
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8001f06:	fb11 f30b 	smulbb	r3, r1, fp
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8001f0a:	1999      	adds	r1, r3, r6
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8001f0c:	1b9b      	subs	r3, r3, r6
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8001f0e:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8001f12:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8001f16:	13c9      	asrs	r1, r1, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8001f18:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
 8001f1a:	4564      	cmp	r4, ip
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8001f1c:	8001      	strh	r1, [r0, #0]
 8001f1e:	4455      	add	r5, sl
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8001f20:	f829 3012 	strh.w	r3, [r9, r2, lsl #1]
 8001f24:	4470      	add	r0, lr
      for (j=0;j<N0;j++)
 8001f26:	d1e6      	bne.n	8001ef6 <quant_band+0xce>
 8001f28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   for (i=0;i<stride;i++)
 8001f2a:	f108 0801 	add.w	r8, r8, #1
 8001f2e:	3302      	adds	r3, #2
 8001f30:	637b      	str	r3, [r7, #52]	; 0x34
 8001f32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001f34:	4598      	cmp	r8, r3
 8001f36:	dbdb      	blt.n	8001ef0 <quant_band+0xc8>
 8001f38:	f8d7 e014 	ldr.w	lr, [r7, #20]
      fill = bit_interleave_table[fill&0xF]|bit_interleave_table[fill>>4]<<2;
 8001f3c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8001f3e:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8001f40:	49ae      	ldr	r1, [pc, #696]	; (80021fc <quant_band+0x3d4>)
 8001f42:	f003 030f 	and.w	r3, r3, #15
 8001f46:	1112      	asrs	r2, r2, #4
 8001f48:	5ccb      	ldrb	r3, [r1, r3]
 8001f4a:	5c8a      	ldrb	r2, [r1, r2]
   for (k=0;k<recombine;k++)
 8001f4c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
      fill = bit_interleave_table[fill&0xF]|bit_interleave_table[fill>>4]<<2;
 8001f4e:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
 8001f52:	67bb      	str	r3, [r7, #120]	; 0x78
   for (k=0;k<recombine;k++)
 8001f54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001f56:	3101      	adds	r1, #1
 8001f58:	428b      	cmp	r3, r1
 8001f5a:	62b9      	str	r1, [r7, #40]	; 0x28
 8001f5c:	d19a      	bne.n	8001e94 <quant_band+0x6c>
 8001f5e:	68fb      	ldr	r3, [r7, #12]
 8001f60:	46f2      	mov	sl, lr
 8001f62:	4619      	mov	r1, r3
 8001f64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001f66:	fa01 fb03 	lsl.w	fp, r1, r3
 8001f6a:	f00b 0201 	and.w	r2, fp, #1
 8001f6e:	637a      	str	r2, [r7, #52]	; 0x34
 8001f70:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8001f72:	fa42 f303 	asr.w	r3, r2, r3
 8001f76:	633b      	str	r3, [r7, #48]	; 0x30
   }
   B>>=recombine;
   N_B<<=recombine;

   /* Increasing the time resolution */
   while ((N_B&1) == 0 && tf_change<0)
 8001f78:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001f7a:	2b00      	cmp	r3, #0
 8001f7c:	f040 83a5 	bne.w	80026ca <quant_band+0x8a2>
 8001f80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001f82:	2b00      	cmp	r3, #0
 8001f84:	da5a      	bge.n	800203c <quant_band+0x214>
 8001f86:	2300      	movs	r3, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8001f88:	f645 2582 	movw	r5, #23170	; 0x5a82
   while ((N_B&1) == 0 && tf_change<0)
 8001f8c:	637b      	str	r3, [r7, #52]	; 0x34
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8001f8e:	f8c7 a02c 	str.w	sl, [r7, #44]	; 0x2c
 8001f92:	f8c7 9064 	str.w	r9, [r7, #100]	; 0x64
   {
      if (encode)
 8001f96:	6a3b      	ldr	r3, [r7, #32]
 8001f98:	ea4f 0b6b 	mov.w	fp, fp, asr #1
 8001f9c:	2b00      	cmp	r3, #0
 8001f9e:	f040 8133 	bne.w	8002208 <quant_band+0x3e0>
         haar1(X, N_B, B);
      if (lowband)
 8001fa2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001fa4:	2b00      	cmp	r3, #0
 8001fa6:	f000 8125 	beq.w	80021f4 <quant_band+0x3cc>
   for (i=0;i<stride;i++)
 8001faa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001fac:	2b00      	cmp	r3, #0
 8001fae:	f340 8122 	ble.w	80021f6 <quant_band+0x3ce>
 8001fb2:	f1bb 0f00 	cmp.w	fp, #0
 8001fb6:	ea4f 0a43 	mov.w	sl, r3, lsl #1
 8001fba:	dd27      	ble.n	800200c <quant_band+0x1e4>
 8001fbc:	f8d7 8064 	ldr.w	r8, [r7, #100]	; 0x64
 8001fc0:	ea4f 0c83 	mov.w	ip, r3, lsl #2
      for (j=0;j<N0;j++)
 8001fc4:	f04f 0900 	mov.w	r9, #0
 8001fc8:	ea4f 0e4a 	mov.w	lr, sl, lsl #1
 8001fcc:	4640      	mov	r0, r8
 8001fce:	2600      	movs	r6, #0
 8001fd0:	eb0a 0408 	add.w	r4, sl, r8
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8001fd4:	8803      	ldrh	r3, [r0, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 8001fd6:	8821      	ldrh	r1, [r4, #0]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8001fd8:	fb13 f305 	smulbb	r3, r3, r5
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 8001fdc:	fb11 f105 	smulbb	r1, r1, r5
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8001fe0:	185a      	adds	r2, r3, r1
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8001fe2:	1a5b      	subs	r3, r3, r1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8001fe4:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8001fe8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      for (j=0;j<N0;j++)
 8001fec:	3601      	adds	r6, #1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8001fee:	13d2      	asrs	r2, r2, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8001ff0:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
 8001ff2:	455e      	cmp	r6, fp
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8001ff4:	8002      	strh	r2, [r0, #0]
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8001ff6:	8023      	strh	r3, [r4, #0]
 8001ff8:	4470      	add	r0, lr
 8001ffa:	4464      	add	r4, ip
      for (j=0;j<N0;j++)
 8001ffc:	d1ea      	bne.n	8001fd4 <quant_band+0x1ac>
   for (i=0;i<stride;i++)
 8001ffe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002000:	f109 0901 	add.w	r9, r9, #1
 8002004:	4599      	cmp	r9, r3
 8002006:	f108 0802 	add.w	r8, r8, #2
 800200a:	dbdf      	blt.n	8001fcc <quant_band+0x1a4>
         haar1(lowband, N_B, B);
      fill |= fill<<B;
 800200c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800200e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   while ((N_B&1) == 0 && tf_change<0)
 8002010:	f01b 0f01 	tst.w	fp, #1
      fill |= fill<<B;
 8002014:	fa03 f302 	lsl.w	r3, r3, r2
 8002018:	6fba      	ldr	r2, [r7, #120]	; 0x78
      B <<= 1;
 800201a:	f8c7 a030 	str.w	sl, [r7, #48]	; 0x30
      fill |= fill<<B;
 800201e:	ea42 0203 	orr.w	r2, r2, r3
      N_B >>= 1;
      time_divide++;
 8002022:	6b7b      	ldr	r3, [r7, #52]	; 0x34
      fill |= fill<<B;
 8002024:	67ba      	str	r2, [r7, #120]	; 0x78
      time_divide++;
 8002026:	f103 0301 	add.w	r3, r3, #1
 800202a:	637b      	str	r3, [r7, #52]	; 0x34
   while ((N_B&1) == 0 && tf_change<0)
 800202c:	d102      	bne.n	8002034 <quant_band+0x20c>
 800202e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002030:	42d3      	cmn	r3, r2
 8002032:	d4b0      	bmi.n	8001f96 <quant_band+0x16e>
 8002034:	f8d7 a02c 	ldr.w	sl, [r7, #44]	; 0x2c
 8002038:	f8d7 9064 	ldr.w	r9, [r7, #100]	; 0x64
   }
   B0=B;
   N_B0 = N_B;

   /* Reorganize the samples in time order instead of frequency order */
   if (B0>1)
 800203c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800203e:	2b01      	cmp	r3, #1
 8002040:	f340 81bb 	ble.w	80023ba <quant_band+0x592>
   {
      if (encode)
 8002044:	6a3b      	ldr	r3, [r7, #32]
 8002046:	2b00      	cmp	r3, #0
 8002048:	f040 8180 	bne.w	800234c <quant_band+0x524>
         deinterleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
      if (lowband)
 800204c:	f1b9 0f00 	cmp.w	r9, #0
 8002050:	d043      	beq.n	80020da <quant_band+0x2b2>
         deinterleave_hadamard(lowband, N_B>>recombine, B0<<recombine, longBlocks);
 8002052:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002054:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8002056:	fa4b fc03 	asr.w	ip, fp, r3
 800205a:	fa02 f103 	lsl.w	r1, r2, r3
   N = N0*stride;
 800205e:	fb01 f30c 	mul.w	r3, r1, ip
   ALLOC(tmp, N, celt_norm);
 8002062:	005b      	lsls	r3, r3, #1
 8002064:	627b      	str	r3, [r7, #36]	; 0x24
 8002066:	3308      	adds	r3, #8
 8002068:	f023 0307 	bic.w	r3, r3, #7
{
 800206c:	f8c7 d02c 	str.w	sp, [r7, #44]	; 0x2c
   ALLOC(tmp, N, celt_norm);
 8002070:	ebad 0d03 	sub.w	sp, sp, r3
   if (hadamard)
 8002074:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   ALLOC(tmp, N, celt_norm);
 8002076:	f10d 0e18 	add.w	lr, sp, #24
   if (hadamard)
 800207a:	2b01      	cmp	r3, #1
 800207c:	f040 8275 	bne.w	800256a <quant_band+0x742>
      const int *ordery = ordery_table+stride-2;
 8002080:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
 8002084:	3b02      	subs	r3, #2
      for (i=0;i<stride;i++)
 8002086:	2900      	cmp	r1, #0
      const int *ordery = ordery_table+stride-2;
 8002088:	ea4f 0383 	mov.w	r3, r3, lsl #2
      for (i=0;i<stride;i++)
 800208c:	f340 8284 	ble.w	8002598 <quant_band+0x770>
 8002090:	f1bc 0f00 	cmp.w	ip, #0
 8002094:	f340 8280 	ble.w	8002598 <quant_band+0x770>
 8002098:	464d      	mov	r5, r9
 800209a:	4e59      	ldr	r6, [pc, #356]	; (8002200 <quant_band+0x3d8>)
 800209c:	0049      	lsls	r1, r1, #1
 800209e:	eb01 0809 	add.w	r8, r1, r9
 80020a2:	441e      	add	r6, r3
            tmp[ordery[i]*N0+j] = X[j*stride+i];
 80020a4:	462a      	mov	r2, r5
 80020a6:	f856 3f04 	ldr.w	r3, [r6, #4]!
 80020aa:	fb03 f30c 	mul.w	r3, r3, ip
 80020ae:	eb0c 0003 	add.w	r0, ip, r3
 80020b2:	eb0e 0040 	add.w	r0, lr, r0, lsl #1
 80020b6:	eb0e 0343 	add.w	r3, lr, r3, lsl #1
 80020ba:	8814      	ldrh	r4, [r2, #0]
 80020bc:	440a      	add	r2, r1
 80020be:	f823 4b02 	strh.w	r4, [r3], #2
         for (j=0;j<N0;j++)
 80020c2:	4298      	cmp	r0, r3
 80020c4:	d1f9      	bne.n	80020ba <quant_band+0x292>
 80020c6:	3502      	adds	r5, #2
      for (i=0;i<stride;i++)
 80020c8:	45a8      	cmp	r8, r5
 80020ca:	d1eb      	bne.n	80020a4 <quant_band+0x27c>
   OPUS_COPY(X, tmp, N);
 80020cc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80020ce:	4671      	mov	r1, lr
 80020d0:	4648      	mov	r0, r9
 80020d2:	f012 f805 	bl	80140e0 <memcpy>
 80020d6:	f8d7 d02c 	ldr.w	sp, [r7, #44]	; 0x2c
   }

   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
 80020da:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80020dc:	4651      	mov	r1, sl
 80020de:	9304      	str	r3, [sp, #16]
 80020e0:	687b      	ldr	r3, [r7, #4]
 80020e2:	9303      	str	r3, [sp, #12]
 80020e4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80020e6:	e9cd 9301 	strd	r9, r3, [sp, #4]
 80020ea:	6b3c      	ldr	r4, [r7, #48]	; 0x30
 80020ec:	9400      	str	r4, [sp, #0]
 80020ee:	693d      	ldr	r5, [r7, #16]
 80020f0:	68bb      	ldr	r3, [r7, #8]
 80020f2:	69fa      	ldr	r2, [r7, #28]
 80020f4:	4628      	mov	r0, r5
 80020f6:	f7ff fa11 	bl	800151c <quant_partition>

   /* This code is used by the decoder and by the resynthesis-enabled encoder */
   if (ctx->resynth)
 80020fa:	686b      	ldr	r3, [r5, #4]
   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
 80020fc:	6278      	str	r0, [r7, #36]	; 0x24
   if (ctx->resynth)
 80020fe:	2b00      	cmp	r3, #0
 8002100:	d074      	beq.n	80021ec <quant_band+0x3c4>
   {
      /* Undo the sample reorganization going from time order to frequency order */
      if (B0>1)
         interleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
 8002102:	6abb      	ldr	r3, [r7, #40]	; 0x28
{
 8002104:	f8c7 d02c 	str.w	sp, [r7, #44]	; 0x2c
         interleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
 8002108:	fa4b f503 	asr.w	r5, fp, r3
 800210c:	fa04 f103 	lsl.w	r1, r4, r3
   N = N0*stride;
 8002110:	fb01 f905 	mul.w	r9, r1, r5
   ALLOC(tmp, N, celt_norm);
 8002114:	ea4f 0949 	mov.w	r9, r9, lsl #1
 8002118:	f109 0308 	add.w	r3, r9, #8
 800211c:	f023 0307 	bic.w	r3, r3, #7
 8002120:	ebad 0d03 	sub.w	sp, sp, r3
   if (hadamard)
 8002124:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   ALLOC(tmp, N, celt_norm);
 8002126:	f10d 0e18 	add.w	lr, sp, #24
   if (hadamard)
 800212a:	2b01      	cmp	r3, #1
 800212c:	f040 8251 	bne.w	80025d2 <quant_band+0x7aa>
      const int *ordery = ordery_table+stride-2;
 8002130:	f101 4c80 	add.w	ip, r1, #1073741824	; 0x40000000
 8002134:	f1ac 0c02 	sub.w	ip, ip, #2
      for (i=0;i<stride;i++)
 8002138:	2900      	cmp	r1, #0
      const int *ordery = ordery_table+stride-2;
 800213a:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
      for (i=0;i<stride;i++)
 800213e:	f340 825d 	ble.w	80025fc <quant_band+0x7d4>
 8002142:	2d00      	cmp	r5, #0
 8002144:	f340 825a 	ble.w	80025fc <quant_band+0x7d4>
 8002148:	4676      	mov	r6, lr
 800214a:	4b2d      	ldr	r3, [pc, #180]	; (8002200 <quant_band+0x3d8>)
 800214c:	0049      	lsls	r1, r1, #1
 800214e:	eb01 080e 	add.w	r8, r1, lr
 8002152:	449c      	add	ip, r3
            tmp[j*stride+i] = X[ordery[i]*N0+j];
 8002154:	4632      	mov	r2, r6
 8002156:	f85c 3f04 	ldr.w	r3, [ip, #4]!
 800215a:	fb03 f305 	mul.w	r3, r3, r5
 800215e:	18e8      	adds	r0, r5, r3
 8002160:	eb0a 0040 	add.w	r0, sl, r0, lsl #1
 8002164:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
 8002168:	f933 4b02 	ldrsh.w	r4, [r3], #2
         for (j=0;j<N0;j++)
 800216c:	4298      	cmp	r0, r3
            tmp[j*stride+i] = X[ordery[i]*N0+j];
 800216e:	8014      	strh	r4, [r2, #0]
 8002170:	440a      	add	r2, r1
         for (j=0;j<N0;j++)
 8002172:	d1f9      	bne.n	8002168 <quant_band+0x340>
 8002174:	3602      	adds	r6, #2
      for (i=0;i<stride;i++)
 8002176:	45b0      	cmp	r8, r6
 8002178:	d1ec      	bne.n	8002154 <quant_band+0x32c>
 800217a:	e23f      	b.n	80025fc <quant_band+0x7d4>
 800217c:	461a      	mov	r2, r3
      t = EC_ILOG(d&-d);
 800217e:	425b      	negs	r3, r3
 8002180:	4013      	ands	r3, r2
 8002182:	fab3 f383 	clz	r3, r3
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8002186:	491f      	ldr	r1, [pc, #124]	; (8002204 <quant_band+0x3dc>)
      t = EC_ILOG(d&-d);
 8002188:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800218c:	fa22 f003 	lsr.w	r0, r2, r3
 8002190:	1e5a      	subs	r2, r3, #1
 8002192:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 8002196:	69f9      	ldr	r1, [r7, #28]
 8002198:	fa21 f202 	lsr.w	r2, r1, r2
 800219c:	fba2 4503 	umull	r4, r5, r2, r3
      return q+(n-q*d >= d);
 80021a0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80021a2:	fb03 1215 	mls	r2, r3, r5, r1
 80021a6:	462b      	mov	r3, r5
 80021a8:	6e39      	ldr	r1, [r7, #96]	; 0x60
 80021aa:	4291      	cmp	r1, r2
 80021ac:	bf98      	it	ls
 80021ae:	3301      	addls	r3, #1
 80021b0:	60fb      	str	r3, [r7, #12]
 80021b2:	469b      	mov	fp, r3
   if (N==1)
 80021b4:	69fb      	ldr	r3, [r7, #28]
 80021b6:	2b01      	cmp	r3, #1
 80021b8:	f47f ae56 	bne.w	8001e68 <quant_band+0x40>
      if (ctx->remaining_bits>=1<<BITRES)
 80021bc:	693a      	ldr	r2, [r7, #16]
   ec = ctx->ec;
 80021be:	e9d2 0307 	ldrd	r0, r3, [r2, #28]
      if (ctx->remaining_bits>=1<<BITRES)
 80021c2:	2b07      	cmp	r3, #7
 80021c4:	f300 8227 	bgt.w	8002616 <quant_band+0x7ee>
      if (ctx->resynth)
 80021c8:	6853      	ldr	r3, [r2, #4]
 80021ca:	b11b      	cbz	r3, 80021d4 <quant_band+0x3ac>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
 80021cc:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80021d0:	f8aa 3000 	strh.w	r3, [sl]
   if (lowband_out)
 80021d4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80021d6:	2b00      	cmp	r3, #0
 80021d8:	f000 8233 	beq.w	8002642 <quant_band+0x81a>
      return quant_band_n1(ctx, X, NULL, b, lowband_out);
 80021dc:	2201      	movs	r2, #1
      lowband_out[0] = SHR16(X[0],4);
 80021de:	f9ba 3000 	ldrsh.w	r3, [sl]
      return quant_band_n1(ctx, X, NULL, b, lowband_out);
 80021e2:	627a      	str	r2, [r7, #36]	; 0x24
      lowband_out[0] = SHR16(X[0],4);
 80021e4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80021e6:	111b      	asrs	r3, r3, #4
 80021e8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80021ea:	8013      	strh	r3, [r2, #0]
            lowband_out[j] = MULT16_16_Q15(n,X[j]);
      }
      cm &= (1<<B)-1;
   }
   return cm;
}
 80021ec:	373c      	adds	r7, #60	; 0x3c
 80021ee:	46bd      	mov	sp, r7
 80021f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80021f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80021f6:	ea4f 0a43 	mov.w	sl, r3, lsl #1
 80021fa:	e707      	b.n	800200c <quant_band+0x1e4>
 80021fc:	08014fa0 	.word	0x08014fa0
 8002200:	08014fbc 	.word	0x08014fbc
 8002204:	0801649c 	.word	0x0801649c
   for (i=0;i<stride;i++)
 8002208:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800220a:	2b00      	cmp	r3, #0
 800220c:	ddf3      	ble.n	80021f6 <quant_band+0x3ce>
 800220e:	f1bb 0f00 	cmp.w	fp, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8002212:	ea4f 0a43 	mov.w	sl, r3, lsl #1
 8002216:	f77f aef9 	ble.w	800200c <quant_band+0x1e4>
 800221a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800221c:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 8002220:	4696      	mov	lr, r2
 8002222:	eb02 080a 	add.w	r8, r2, sl
   while ((N_B&1) == 0 && tf_change<0)
 8002226:	4671      	mov	r1, lr
      for (j=0;j<N0;j++)
 8002228:	2400      	movs	r4, #0
 800222a:	eb0a 000e 	add.w	r0, sl, lr
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 800222e:	880b      	ldrh	r3, [r1, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 8002230:	8806      	ldrh	r6, [r0, #0]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8002232:	fb13 f305 	smulbb	r3, r3, r5
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 8002236:	fb16 f605 	smulbb	r6, r6, r5
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 800223a:	199a      	adds	r2, r3, r6
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 800223c:	1b9b      	subs	r3, r3, r6
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 800223e:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8002242:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      for (j=0;j<N0;j++)
 8002246:	3401      	adds	r4, #1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8002248:	13d2      	asrs	r2, r2, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 800224a:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
 800224c:	455c      	cmp	r4, fp
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 800224e:	800a      	strh	r2, [r1, #0]
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8002250:	8003      	strh	r3, [r0, #0]
 8002252:	4461      	add	r1, ip
 8002254:	4460      	add	r0, ip
      for (j=0;j<N0;j++)
 8002256:	d1ea      	bne.n	800222e <quant_band+0x406>
 8002258:	f10e 0e02 	add.w	lr, lr, #2
   for (i=0;i<stride;i++)
 800225c:	45f0      	cmp	r8, lr
 800225e:	d1e2      	bne.n	8002226 <quant_band+0x3fe>
      if (lowband)
 8002260:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8002262:	2b00      	cmp	r3, #0
 8002264:	f43f aed2 	beq.w	800200c <quant_band+0x1e4>
 8002268:	4698      	mov	r8, r3
 800226a:	e6ab      	b.n	8001fc4 <quant_band+0x19c>
         haar1(X, N>>k, 1<<k);
 800226c:	69fb      	ldr	r3, [r7, #28]
 800226e:	4619      	mov	r1, r3
 8002270:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002272:	fa41 fc03 	asr.w	ip, r1, r3
 8002276:	2101      	movs	r1, #1
 8002278:	fa01 f203 	lsl.w	r2, r1, r3
   for (i=0;i<stride;i++)
 800227c:	2a00      	cmp	r2, #0
         haar1(X, N>>k, 1<<k);
 800227e:	633a      	str	r2, [r7, #48]	; 0x30
   N0 >>= 1;
 8002280:	fa4c fc01 	asr.w	ip, ip, r1
   for (i=0;i<stride;i++)
 8002284:	f77f ae5a 	ble.w	8001f3c <quant_band+0x114>
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8002288:	2202      	movs	r2, #2
 800228a:	f1bc 0f00 	cmp.w	ip, #0
 800228e:	fa02 fa03 	lsl.w	sl, r2, r3
 8002292:	f77f ae53 	ble.w	8001f3c <quant_band+0x114>
 8002296:	fa0a f301 	lsl.w	r3, sl, r1
 800229a:	f8c7 9064 	str.w	r9, [r7, #100]	; 0x64
   for (i=0;i<stride;i++)
 800229e:	f04f 0800 	mov.w	r8, #0
 80022a2:	4699      	mov	r9, r3
 80022a4:	f8c7 e034 	str.w	lr, [r7, #52]	; 0x34
 80022a8:	61bb      	str	r3, [r7, #24]
      for (j=0;j<N0;j++)
 80022aa:	2400      	movs	r4, #0
   for (k=0;k<recombine;k++)
 80022ac:	e9d7 500c 	ldrd	r5, r0, [r7, #48]	; 0x30
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 80022b0:	eb05 0208 	add.w	r2, r5, r8
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 80022b4:	8801      	ldrh	r1, [r0, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 80022b6:	f83e 3012 	ldrh.w	r3, [lr, r2, lsl #1]
      for (j=0;j<N0;j++)
 80022ba:	3401      	adds	r4, #1
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 80022bc:	fb13 f60b 	smulbb	r6, r3, fp
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 80022c0:	fb11 f30b 	smulbb	r3, r1, fp
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 80022c4:	1999      	adds	r1, r3, r6
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 80022c6:	1b9b      	subs	r3, r3, r6
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 80022c8:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 80022cc:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 80022d0:	13c9      	asrs	r1, r1, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 80022d2:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
 80022d4:	45a4      	cmp	ip, r4
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 80022d6:	8001      	strh	r1, [r0, #0]
 80022d8:	4455      	add	r5, sl
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 80022da:	f82e 3012 	strh.w	r3, [lr, r2, lsl #1]
 80022de:	4448      	add	r0, r9
      for (j=0;j<N0;j++)
 80022e0:	d1e6      	bne.n	80022b0 <quant_band+0x488>
 80022e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   for (i=0;i<stride;i++)
 80022e4:	f108 0801 	add.w	r8, r8, #1
 80022e8:	3302      	adds	r3, #2
 80022ea:	637b      	str	r3, [r7, #52]	; 0x34
 80022ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80022ee:	4543      	cmp	r3, r8
 80022f0:	d1db      	bne.n	80022aa <quant_band+0x482>
 80022f2:	f8d7 9064 	ldr.w	r9, [r7, #100]	; 0x64
      if (lowband)
 80022f6:	f1b9 0f00 	cmp.w	r9, #0
 80022fa:	f47f ade9 	bne.w	8001ed0 <quant_band+0xa8>
 80022fe:	e61d      	b.n	8001f3c <quant_band+0x114>
 8002300:	f00b 0301 	and.w	r3, fp, #1
 8002304:	637b      	str	r3, [r7, #52]	; 0x34
   if (lowband_scratch && lowband && (recombine || ((N_B&1) == 0 && tf_change<0) || B0>1))
 8002306:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002308:	2b00      	cmp	r3, #0
 800230a:	f000 81a6 	beq.w	800265a <quant_band+0x832>
 800230e:	f1b9 0f00 	cmp.w	r9, #0
 8002312:	f000 817b 	beq.w	800260c <quant_band+0x7e4>
 8002316:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002318:	2b00      	cmp	r3, #0
 800231a:	f040 8145 	bne.w	80025a8 <quant_band+0x780>
 800231e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002320:	2b00      	cmp	r3, #0
 8002322:	f040 81c5 	bne.w	80026b0 <quant_band+0x888>
 8002326:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8002328:	2b01      	cmp	r3, #1
 800232a:	dd43      	ble.n	80023b4 <quant_band+0x58c>
      OPUS_COPY(lowband_scratch, lowband, N);
 800232c:	69fb      	ldr	r3, [r7, #28]
 800232e:	4649      	mov	r1, r9
 8002330:	005a      	lsls	r2, r3, #1
 8002332:	6f78      	ldr	r0, [r7, #116]	; 0x74
 8002334:	f011 fed4 	bl	80140e0 <memcpy>
   while ((N_B&1) == 0 && tf_change<0)
 8002338:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800233a:	f8d7 9074 	ldr.w	r9, [r7, #116]	; 0x74
 800233e:	62bb      	str	r3, [r7, #40]	; 0x28
 8002340:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8002342:	633b      	str	r3, [r7, #48]	; 0x30
      if (encode)
 8002344:	6a3b      	ldr	r3, [r7, #32]
 8002346:	2b00      	cmp	r3, #0
 8002348:	f43f ae80 	beq.w	800204c <quant_band+0x224>
         deinterleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
 800234c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800234e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8002350:	fa4b f603 	asr.w	r6, fp, r3
 8002354:	fa02 f103 	lsl.w	r1, r2, r3
   N = N0*stride;
 8002358:	fb01 f306 	mul.w	r3, r1, r6
   ALLOC(tmp, N, celt_norm);
 800235c:	005b      	lsls	r3, r3, #1
 800235e:	627b      	str	r3, [r7, #36]	; 0x24
 8002360:	3308      	adds	r3, #8
 8002362:	f023 0307 	bic.w	r3, r3, #7
{
 8002366:	f8c7 d02c 	str.w	sp, [r7, #44]	; 0x2c
   ALLOC(tmp, N, celt_norm);
 800236a:	ebad 0d03 	sub.w	sp, sp, r3
   if (hadamard)
 800236e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   ALLOC(tmp, N, celt_norm);
 8002370:	f10d 0818 	add.w	r8, sp, #24
   if (hadamard)
 8002374:	2b01      	cmp	r3, #1
 8002376:	f000 8175 	beq.w	8002664 <quant_band+0x83c>
      for (i=0;i<stride;i++)
 800237a:	2900      	cmp	r1, #0
 800237c:	dd12      	ble.n	80023a4 <quant_band+0x57c>
 800237e:	2e00      	cmp	r6, #0
 8002380:	dd10      	ble.n	80023a4 <quant_band+0x57c>
 8002382:	4655      	mov	r5, sl
 8002384:	4643      	mov	r3, r8
 8002386:	0049      	lsls	r1, r1, #1
 8002388:	0076      	lsls	r6, r6, #1
 800238a:	eb01 0c0a 	add.w	ip, r1, sl
            tmp[ordery[i]*N0+j] = X[j*stride+i];
 800238e:	462a      	mov	r2, r5
 8002390:	18f4      	adds	r4, r6, r3
            tmp[i*N0+j] = X[j*stride+i];
 8002392:	8810      	ldrh	r0, [r2, #0]
 8002394:	440a      	add	r2, r1
 8002396:	f823 0b02 	strh.w	r0, [r3], #2
         for (j=0;j<N0;j++)
 800239a:	429c      	cmp	r4, r3
 800239c:	d1f9      	bne.n	8002392 <quant_band+0x56a>
 800239e:	3502      	adds	r5, #2
      for (i=0;i<stride;i++)
 80023a0:	45ac      	cmp	ip, r5
 80023a2:	d1f4      	bne.n	800238e <quant_band+0x566>
   OPUS_COPY(X, tmp, N);
 80023a4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80023a6:	4641      	mov	r1, r8
 80023a8:	4650      	mov	r0, sl
 80023aa:	f011 fe99 	bl	80140e0 <memcpy>
 80023ae:	f8d7 d02c 	ldr.w	sp, [r7, #44]	; 0x2c
 80023b2:	e64b      	b.n	800204c <quant_band+0x224>
   while ((N_B&1) == 0 && tf_change<0)
 80023b4:	633b      	str	r3, [r7, #48]	; 0x30
 80023b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80023b8:	62bb      	str	r3, [r7, #40]	; 0x28
   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
 80023ba:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80023bc:	4651      	mov	r1, sl
 80023be:	9304      	str	r3, [sp, #16]
 80023c0:	687b      	ldr	r3, [r7, #4]
 80023c2:	9303      	str	r3, [sp, #12]
 80023c4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80023c6:	e9cd 9301 	strd	r9, r3, [sp, #4]
 80023ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80023cc:	9300      	str	r3, [sp, #0]
 80023ce:	693c      	ldr	r4, [r7, #16]
 80023d0:	68bb      	ldr	r3, [r7, #8]
 80023d2:	69fa      	ldr	r2, [r7, #28]
 80023d4:	4620      	mov	r0, r4
 80023d6:	f7ff f8a1 	bl	800151c <quant_partition>
   if (ctx->resynth)
 80023da:	6863      	ldr	r3, [r4, #4]
   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
 80023dc:	6278      	str	r0, [r7, #36]	; 0x24
   if (ctx->resynth)
 80023de:	2b00      	cmp	r3, #0
 80023e0:	f43f af04 	beq.w	80021ec <quant_band+0x3c4>
      for (k=0;k<time_divide;k++)
 80023e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80023e6:	2b00      	cmp	r3, #0
 80023e8:	d04a      	beq.n	8002480 <quant_band+0x658>
 80023ea:	2300      	movs	r3, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 80023ec:	f645 2c82 	movw	ip, #23170	; 0x5a82
 80023f0:	f8c7 b020 	str.w	fp, [r7, #32]
 80023f4:	f8d7 b030 	ldr.w	fp, [r7, #48]	; 0x30
      for (k=0;k<time_divide;k++)
 80023f8:	62fb      	str	r3, [r7, #44]	; 0x2c
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 80023fa:	f8c7 a018 	str.w	sl, [r7, #24]
         N_B <<= 1;
 80023fe:	6a3b      	ldr	r3, [r7, #32]
         cm |= cm>>B;
 8002400:	6a79      	ldr	r1, [r7, #36]	; 0x24
         B >>= 1;
 8002402:	ea4f 0b6b 	mov.w	fp, fp, asr #1
         N_B <<= 1;
 8002406:	005a      	lsls	r2, r3, #1
         cm |= cm>>B;
 8002408:	fa21 f30b 	lsr.w	r3, r1, fp
 800240c:	430b      	orrs	r3, r1
   for (i=0;i<stride;i++)
 800240e:	f1bb 0f00 	cmp.w	fp, #0
         N_B <<= 1;
 8002412:	623a      	str	r2, [r7, #32]
         cm |= cm>>B;
 8002414:	627b      	str	r3, [r7, #36]	; 0x24
   N0 >>= 1;
 8002416:	ea4f 0e62 	mov.w	lr, r2, asr #1
   for (i=0;i<stride;i++)
 800241a:	dd27      	ble.n	800246c <quant_band+0x644>
 800241c:	f1be 0f00 	cmp.w	lr, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8002420:	ea4f 094b 	mov.w	r9, fp, lsl #1
 8002424:	dd22      	ble.n	800246c <quant_band+0x644>
 8002426:	69bb      	ldr	r3, [r7, #24]
 8002428:	ea4f 068b 	mov.w	r6, fp, lsl #2
 800242c:	4698      	mov	r8, r3
 800242e:	eb09 0a03 	add.w	sl, r9, r3
      for (k=0;k<time_divide;k++)
 8002432:	4641      	mov	r1, r8
      for (j=0;j<N0;j++)
 8002434:	2400      	movs	r4, #0
 8002436:	eb09 0008 	add.w	r0, r9, r8
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 800243a:	880b      	ldrh	r3, [r1, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 800243c:	8805      	ldrh	r5, [r0, #0]
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 800243e:	fb13 f30c 	smulbb	r3, r3, ip
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 8002442:	fb15 f50c 	smulbb	r5, r5, ip
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8002446:	195a      	adds	r2, r3, r5
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8002448:	1b5b      	subs	r3, r3, r5
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 800244a:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 800244e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      for (j=0;j<N0;j++)
 8002452:	3401      	adds	r4, #1
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 8002454:	13d2      	asrs	r2, r2, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 8002456:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
 8002458:	45a6      	cmp	lr, r4
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 800245a:	800a      	strh	r2, [r1, #0]
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 800245c:	8003      	strh	r3, [r0, #0]
 800245e:	4431      	add	r1, r6
 8002460:	4430      	add	r0, r6
      for (j=0;j<N0;j++)
 8002462:	d1ea      	bne.n	800243a <quant_band+0x612>
 8002464:	f108 0802 	add.w	r8, r8, #2
   for (i=0;i<stride;i++)
 8002468:	45c2      	cmp	sl, r8
 800246a:	d1e2      	bne.n	8002432 <quant_band+0x60a>
      for (k=0;k<time_divide;k++)
 800246c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800246e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8002470:	3301      	adds	r3, #1
 8002472:	4293      	cmp	r3, r2
 8002474:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002476:	d1c2      	bne.n	80023fe <quant_band+0x5d6>
 8002478:	f8d7 a018 	ldr.w	sl, [r7, #24]
 800247c:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
      for (k=0;k<recombine;k++)
 8002480:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002482:	2b00      	cmp	r3, #0
 8002484:	d04b      	beq.n	800251e <quant_band+0x6f6>
 8002486:	2300      	movs	r3, #0
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 8002488:	f645 2b82 	movw	fp, #23170	; 0x5a82
      for (k=0;k<recombine;k++)
 800248c:	623b      	str	r3, [r7, #32]
         haar1(X, N0>>k, 1<<k);
 800248e:	69fb      	ldr	r3, [r7, #28]
         cm = bit_deinterleave_table[cm];
 8002490:	6a78      	ldr	r0, [r7, #36]	; 0x24
         haar1(X, N0>>k, 1<<k);
 8002492:	4619      	mov	r1, r3
 8002494:	6a3b      	ldr	r3, [r7, #32]
 8002496:	fa41 fe03 	asr.w	lr, r1, r3
 800249a:	2101      	movs	r1, #1
 800249c:	fa01 f203 	lsl.w	r2, r1, r3
         cm = bit_deinterleave_table[cm];
 80024a0:	49a4      	ldr	r1, [pc, #656]	; (8002734 <quant_band+0x90c>)
   for (i=0;i<stride;i++)
 80024a2:	2a00      	cmp	r2, #0
         cm = bit_deinterleave_table[cm];
 80024a4:	5c09      	ldrb	r1, [r1, r0]
         haar1(X, N0>>k, 1<<k);
 80024a6:	62fa      	str	r2, [r7, #44]	; 0x2c
         cm = bit_deinterleave_table[cm];
 80024a8:	6279      	str	r1, [r7, #36]	; 0x24
   N0 >>= 1;
 80024aa:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   for (i=0;i<stride;i++)
 80024ae:	dd2f      	ble.n	8002510 <quant_band+0x6e8>
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 80024b0:	2202      	movs	r2, #2
 80024b2:	f1be 0f00 	cmp.w	lr, #0
 80024b6:	fa02 f803 	lsl.w	r8, r2, r3
 80024ba:	dd29      	ble.n	8002510 <quant_band+0x6e8>
   for (i=0;i<stride;i++)
 80024bc:	f04f 0c00 	mov.w	ip, #0
 80024c0:	f8c7 a034 	str.w	sl, [r7, #52]	; 0x34
 80024c4:	ea4f 0948 	mov.w	r9, r8, lsl #1
      for (j=0;j<N0;j++)
 80024c8:	2400      	movs	r4, #0
      for (k=0;k<recombine;k++)
 80024ca:	6afd      	ldr	r5, [r7, #44]	; 0x2c
 80024cc:	6b78      	ldr	r0, [r7, #52]	; 0x34
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 80024ce:	eb05 020c 	add.w	r2, r5, ip
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 80024d2:	8801      	ldrh	r1, [r0, #0]
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 80024d4:	f83a 3012 	ldrh.w	r3, [sl, r2, lsl #1]
      for (j=0;j<N0;j++)
 80024d8:	3401      	adds	r4, #1
         tmp2 = MULT16_16(QCONST16(.70710678f,15), X[stride*(2*j+1)+i]);
 80024da:	fb13 f60b 	smulbb	r6, r3, fp
         tmp1 = MULT16_16(QCONST16(.70710678f,15), X[stride*2*j+i]);
 80024de:	fb11 f30b 	smulbb	r3, r1, fp
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 80024e2:	1999      	adds	r1, r3, r6
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 80024e4:	1b9b      	subs	r3, r3, r6
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 80024e6:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 80024ea:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 80024ee:	13c9      	asrs	r1, r1, #15
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 80024f0:	13db      	asrs	r3, r3, #15
      for (j=0;j<N0;j++)
 80024f2:	45a6      	cmp	lr, r4
         X[stride*2*j+i] = EXTRACT16(PSHR32(ADD32(tmp1, tmp2), 15));
 80024f4:	8001      	strh	r1, [r0, #0]
 80024f6:	4445      	add	r5, r8
         X[stride*(2*j+1)+i] = EXTRACT16(PSHR32(SUB32(tmp1, tmp2), 15));
 80024f8:	f82a 3012 	strh.w	r3, [sl, r2, lsl #1]
 80024fc:	4448      	add	r0, r9
      for (j=0;j<N0;j++)
 80024fe:	d1e6      	bne.n	80024ce <quant_band+0x6a6>
 8002500:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   for (i=0;i<stride;i++)
 8002502:	f10c 0c01 	add.w	ip, ip, #1
 8002506:	3302      	adds	r3, #2
 8002508:	637b      	str	r3, [r7, #52]	; 0x34
 800250a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800250c:	4563      	cmp	r3, ip
 800250e:	d1db      	bne.n	80024c8 <quant_band+0x6a0>
      for (k=0;k<recombine;k++)
 8002510:	6a3b      	ldr	r3, [r7, #32]
 8002512:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8002514:	3301      	adds	r3, #1
 8002516:	429a      	cmp	r2, r3
 8002518:	623b      	str	r3, [r7, #32]
 800251a:	d1b8      	bne.n	800248e <quant_band+0x666>
 800251c:	4613      	mov	r3, r2
      B<<=recombine;
 800251e:	6b3c      	ldr	r4, [r7, #48]	; 0x30
 8002520:	409c      	lsls	r4, r3
      if (lowband_out)
 8002522:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002524:	b1b3      	cbz	r3, 8002554 <quant_band+0x72c>
         n = celt_sqrt(SHL32(EXTEND32(N0),22));
 8002526:	69fd      	ldr	r5, [r7, #28]
 8002528:	05a8      	lsls	r0, r5, #22
 800252a:	f007 f9c7 	bl	80098bc <celt_sqrt>
         for (j=0;j<N0;j++)
 800252e:	2d00      	cmp	r5, #0
         n = celt_sqrt(SHL32(EXTEND32(N0),22));
 8002530:	b200      	sxth	r0, r0
         for (j=0;j<N0;j++)
 8002532:	dd0f      	ble.n	8002554 <quant_band+0x72c>
 8002534:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002536:	f1aa 0202 	sub.w	r2, sl, #2
 800253a:	eb02 0545 	add.w	r5, r2, r5, lsl #1
 800253e:	1e99      	subs	r1, r3, #2
            lowband_out[j] = MULT16_16_Q15(n,X[j]);
 8002540:	f832 3f02 	ldrh.w	r3, [r2, #2]!
 8002544:	fb13 f300 	smulbb	r3, r3, r0
         for (j=0;j<N0;j++)
 8002548:	4295      	cmp	r5, r2
            lowband_out[j] = MULT16_16_Q15(n,X[j]);
 800254a:	ea4f 33e3 	mov.w	r3, r3, asr #15
 800254e:	f821 3f02 	strh.w	r3, [r1, #2]!
         for (j=0;j<N0;j++)
 8002552:	d1f5      	bne.n	8002540 <quant_band+0x718>
      cm &= (1<<B)-1;
 8002554:	2301      	movs	r3, #1
 8002556:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002558:	40a3      	lsls	r3, r4
 800255a:	3b01      	subs	r3, #1
 800255c:	401a      	ands	r2, r3
 800255e:	4610      	mov	r0, r2
 8002560:	627a      	str	r2, [r7, #36]	; 0x24
}
 8002562:	373c      	adds	r7, #60	; 0x3c
 8002564:	46bd      	mov	sp, r7
 8002566:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for (i=0;i<stride;i++)
 800256a:	2900      	cmp	r1, #0
 800256c:	dd14      	ble.n	8002598 <quant_band+0x770>
 800256e:	f1bc 0f00 	cmp.w	ip, #0
 8002572:	dd11      	ble.n	8002598 <quant_band+0x770>
 8002574:	464d      	mov	r5, r9
 8002576:	4673      	mov	r3, lr
 8002578:	0048      	lsls	r0, r1, #1
 800257a:	ea4f 064c 	mov.w	r6, ip, lsl #1
 800257e:	eb00 0c09 	add.w	ip, r0, r9
            tmp[ordery[i]*N0+j] = X[j*stride+i];
 8002582:	462a      	mov	r2, r5
 8002584:	18f4      	adds	r4, r6, r3
            tmp[i*N0+j] = X[j*stride+i];
 8002586:	8811      	ldrh	r1, [r2, #0]
 8002588:	4402      	add	r2, r0
 800258a:	f823 1b02 	strh.w	r1, [r3], #2
         for (j=0;j<N0;j++)
 800258e:	429c      	cmp	r4, r3
 8002590:	d1f9      	bne.n	8002586 <quant_band+0x75e>
 8002592:	3502      	adds	r5, #2
      for (i=0;i<stride;i++)
 8002594:	45ac      	cmp	ip, r5
 8002596:	d1f4      	bne.n	8002582 <quant_band+0x75a>
   OPUS_COPY(X, tmp, N);
 8002598:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800259a:	4671      	mov	r1, lr
 800259c:	4648      	mov	r0, r9
 800259e:	f011 fd9f 	bl	80140e0 <memcpy>
 80025a2:	f8d7 d02c 	ldr.w	sp, [r7, #44]	; 0x2c
 80025a6:	e598      	b.n	80020da <quant_band+0x2b2>
   if (lowband_scratch && lowband && (recombine || ((N_B&1) == 0 && tf_change<0) || B0>1))
 80025a8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80025aa:	2b01      	cmp	r3, #1
 80025ac:	f340 8090 	ble.w	80026d0 <quant_band+0x8a8>
      OPUS_COPY(lowband_scratch, lowband, N);
 80025b0:	69fb      	ldr	r3, [r7, #28]
 80025b2:	4649      	mov	r1, r9
 80025b4:	005a      	lsls	r2, r3, #1
 80025b6:	6f78      	ldr	r0, [r7, #116]	; 0x74
 80025b8:	f011 fd92 	bl	80140e0 <memcpy>
      if (encode)
 80025bc:	6a3b      	ldr	r3, [r7, #32]
 80025be:	2b00      	cmp	r3, #0
 80025c0:	f040 80a0 	bne.w	8002704 <quant_band+0x8dc>
   B>>=recombine;
 80025c4:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   int time_divide=0;
 80025c6:	637b      	str	r3, [r7, #52]	; 0x34
   B>>=recombine;
 80025c8:	633a      	str	r2, [r7, #48]	; 0x30
      if (encode)
 80025ca:	62bb      	str	r3, [r7, #40]	; 0x28
 80025cc:	f8d7 9074 	ldr.w	r9, [r7, #116]	; 0x74
 80025d0:	e53f      	b.n	8002052 <quant_band+0x22a>
      for (i=0;i<stride;i++)
 80025d2:	2900      	cmp	r1, #0
 80025d4:	dd12      	ble.n	80025fc <quant_band+0x7d4>
 80025d6:	2d00      	cmp	r5, #0
 80025d8:	dd10      	ble.n	80025fc <quant_band+0x7d4>
 80025da:	006e      	lsls	r6, r5, #1
 80025dc:	4653      	mov	r3, sl
 80025de:	4675      	mov	r5, lr
 80025e0:	0048      	lsls	r0, r1, #1
 80025e2:	eb00 0c0e 	add.w	ip, r0, lr
            tmp[j*stride+i] = X[ordery[i]*N0+j];
 80025e6:	462a      	mov	r2, r5
 80025e8:	18f4      	adds	r4, r6, r3
            tmp[j*stride+i] = X[i*N0+j];
 80025ea:	f933 1b02 	ldrsh.w	r1, [r3], #2
         for (j=0;j<N0;j++)
 80025ee:	429c      	cmp	r4, r3
            tmp[j*stride+i] = X[i*N0+j];
 80025f0:	8011      	strh	r1, [r2, #0]
 80025f2:	4402      	add	r2, r0
         for (j=0;j<N0;j++)
 80025f4:	d1f9      	bne.n	80025ea <quant_band+0x7c2>
 80025f6:	3502      	adds	r5, #2
      for (i=0;i<stride;i++)
 80025f8:	45ac      	cmp	ip, r5
 80025fa:	d1f4      	bne.n	80025e6 <quant_band+0x7be>
   OPUS_COPY(X, tmp, N);
 80025fc:	464a      	mov	r2, r9
 80025fe:	4671      	mov	r1, lr
 8002600:	4650      	mov	r0, sl
 8002602:	f011 fd6d 	bl	80140e0 <memcpy>
 8002606:	f8d7 d02c 	ldr.w	sp, [r7, #44]	; 0x2c
 800260a:	e6eb      	b.n	80023e4 <quant_band+0x5bc>
   if (lowband_scratch && lowband && (recombine || ((N_B&1) == 0 && tf_change<0) || B0>1))
 800260c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800260e:	f8c7 9028 	str.w	r9, [r7, #40]	; 0x28
 8002612:	633b      	str	r3, [r7, #48]	; 0x30
 8002614:	e4b0      	b.n	8001f78 <quant_band+0x150>
         if (encode)
 8002616:	6a3b      	ldr	r3, [r7, #32]
 8002618:	b1d3      	cbz	r3, 8002650 <quant_band+0x828>
            sign = x[0]<0;
 800261a:	f8ba 4000 	ldrh.w	r4, [sl]
            ec_enc_bits(ec, sign, 1);
 800261e:	69fa      	ldr	r2, [r7, #28]
            sign = x[0]<0;
 8002620:	0be4      	lsrs	r4, r4, #15
            ec_enc_bits(ec, sign, 1);
 8002622:	4621      	mov	r1, r4
 8002624:	f006 fa98 	bl	8008b58 <ec_enc_bits>
         ctx->remaining_bits -= 1<<BITRES;
 8002628:	6939      	ldr	r1, [r7, #16]
 800262a:	6a0b      	ldr	r3, [r1, #32]
      if (ctx->resynth)
 800262c:	684a      	ldr	r2, [r1, #4]
         ctx->remaining_bits -= 1<<BITRES;
 800262e:	3b08      	subs	r3, #8
 8002630:	620b      	str	r3, [r1, #32]
      if (ctx->resynth)
 8002632:	2a00      	cmp	r2, #0
 8002634:	f43f adce 	beq.w	80021d4 <quant_band+0x3ac>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
 8002638:	2c00      	cmp	r4, #0
 800263a:	f43f adc7 	beq.w	80021cc <quant_band+0x3a4>
 800263e:	4b3e      	ldr	r3, [pc, #248]	; (8002738 <quant_band+0x910>)
 8002640:	e5c6      	b.n	80021d0 <quant_band+0x3a8>
      return quant_band_n1(ctx, X, NULL, b, lowband_out);
 8002642:	2301      	movs	r3, #1
 8002644:	4618      	mov	r0, r3
 8002646:	627b      	str	r3, [r7, #36]	; 0x24
}
 8002648:	373c      	adds	r7, #60	; 0x3c
 800264a:	46bd      	mov	sp, r7
 800264c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            sign = ec_dec_bits(ec, 1);
 8002650:	69f9      	ldr	r1, [r7, #28]
 8002652:	f006 f913 	bl	800887c <ec_dec_bits>
 8002656:	4604      	mov	r4, r0
 8002658:	e7e6      	b.n	8002628 <quant_band+0x800>
   if (lowband_scratch && lowband && (recombine || ((N_B&1) == 0 && tf_change<0) || B0>1))
 800265a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800265c:	633b      	str	r3, [r7, #48]	; 0x30
 800265e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002660:	62bb      	str	r3, [r7, #40]	; 0x28
 8002662:	e489      	b.n	8001f78 <quant_band+0x150>
      const int *ordery = ordery_table+stride-2;
 8002664:	f101 4c80 	add.w	ip, r1, #1073741824	; 0x40000000
 8002668:	f1ac 0c02 	sub.w	ip, ip, #2
      for (i=0;i<stride;i++)
 800266c:	2900      	cmp	r1, #0
      const int *ordery = ordery_table+stride-2;
 800266e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
      for (i=0;i<stride;i++)
 8002672:	f77f ae97 	ble.w	80023a4 <quant_band+0x57c>
 8002676:	2e00      	cmp	r6, #0
 8002678:	f77f ae94 	ble.w	80023a4 <quant_band+0x57c>
 800267c:	4655      	mov	r5, sl
 800267e:	4b2f      	ldr	r3, [pc, #188]	; (800273c <quant_band+0x914>)
 8002680:	0049      	lsls	r1, r1, #1
 8002682:	eb01 0e0a 	add.w	lr, r1, sl
 8002686:	449c      	add	ip, r3
            tmp[ordery[i]*N0+j] = X[j*stride+i];
 8002688:	462a      	mov	r2, r5
 800268a:	f85c 3f04 	ldr.w	r3, [ip, #4]!
 800268e:	fb03 f306 	mul.w	r3, r3, r6
 8002692:	18f0      	adds	r0, r6, r3
 8002694:	eb08 0040 	add.w	r0, r8, r0, lsl #1
 8002698:	eb08 0343 	add.w	r3, r8, r3, lsl #1
 800269c:	8814      	ldrh	r4, [r2, #0]
 800269e:	440a      	add	r2, r1
 80026a0:	f823 4b02 	strh.w	r4, [r3], #2
         for (j=0;j<N0;j++)
 80026a4:	4298      	cmp	r0, r3
 80026a6:	d1f9      	bne.n	800269c <quant_band+0x874>
 80026a8:	3502      	adds	r5, #2
      for (i=0;i<stride;i++)
 80026aa:	45ae      	cmp	lr, r5
 80026ac:	d1ec      	bne.n	8002688 <quant_band+0x860>
 80026ae:	e679      	b.n	80023a4 <quant_band+0x57c>
      OPUS_COPY(lowband_scratch, lowband, N);
 80026b0:	69fb      	ldr	r3, [r7, #28]
 80026b2:	4649      	mov	r1, r9
 80026b4:	005a      	lsls	r2, r3, #1
 80026b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80026b8:	6f78      	ldr	r0, [r7, #116]	; 0x74
 80026ba:	62bb      	str	r3, [r7, #40]	; 0x28
 80026bc:	f011 fd10 	bl	80140e0 <memcpy>
 80026c0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80026c2:	f8d7 9074 	ldr.w	r9, [r7, #116]	; 0x74
 80026c6:	633b      	str	r3, [r7, #48]	; 0x30
 80026c8:	e45d      	b.n	8001f86 <quant_band+0x15e>
   int time_divide=0;
 80026ca:	2300      	movs	r3, #0
 80026cc:	637b      	str	r3, [r7, #52]	; 0x34
 80026ce:	e4b5      	b.n	800203c <quant_band+0x214>
   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
 80026d0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80026d2:	4651      	mov	r1, sl
 80026d4:	9304      	str	r3, [sp, #16]
 80026d6:	687b      	ldr	r3, [r7, #4]
 80026d8:	9303      	str	r3, [sp, #12]
 80026da:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80026dc:	e9cd 9301 	strd	r9, r3, [sp, #4]
 80026e0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80026e2:	9300      	str	r3, [sp, #0]
 80026e4:	693c      	ldr	r4, [r7, #16]
 80026e6:	68bb      	ldr	r3, [r7, #8]
 80026e8:	69fa      	ldr	r2, [r7, #28]
 80026ea:	4620      	mov	r0, r4
 80026ec:	f7fe ff16 	bl	800151c <quant_partition>
   if (ctx->resynth)
 80026f0:	6863      	ldr	r3, [r4, #4]
   cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill);
 80026f2:	6278      	str	r0, [r7, #36]	; 0x24
   if (ctx->resynth)
 80026f4:	2b00      	cmp	r3, #0
 80026f6:	f43f ad79 	beq.w	80021ec <quant_band+0x3c4>
   B>>=recombine;
 80026fa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80026fc:	633b      	str	r3, [r7, #48]	; 0x30
   if (ctx->resynth)
 80026fe:	2300      	movs	r3, #0
 8002700:	62bb      	str	r3, [r7, #40]	; 0x28
 8002702:	e70c      	b.n	800251e <quant_band+0x6f6>
   int time_divide=0;
 8002704:	2200      	movs	r2, #0
   N = N0*stride;
 8002706:	6e3b      	ldr	r3, [r7, #96]	; 0x60
         deinterleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
 8002708:	6e39      	ldr	r1, [r7, #96]	; 0x60
   N = N0*stride;
 800270a:	fb0b f903 	mul.w	r9, fp, r3
   ALLOC(tmp, N, celt_norm);
 800270e:	ea4f 0349 	mov.w	r3, r9, lsl #1
 8002712:	627b      	str	r3, [r7, #36]	; 0x24
 8002714:	3308      	adds	r3, #8
 8002716:	f023 0307 	bic.w	r3, r3, #7
{
 800271a:	f8c7 d02c 	str.w	sp, [r7, #44]	; 0x2c
   ALLOC(tmp, N, celt_norm);
 800271e:	ebad 0d03 	sub.w	sp, sp, r3
   int time_divide=0;
 8002722:	637a      	str	r2, [r7, #52]	; 0x34
   ALLOC(tmp, N, celt_norm);
 8002724:	f10d 0818 	add.w	r8, sp, #24
 8002728:	62ba      	str	r2, [r7, #40]	; 0x28
         deinterleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
 800272a:	465e      	mov	r6, fp
   ALLOC(tmp, N, celt_norm);
 800272c:	f8d7 9074 	ldr.w	r9, [r7, #116]	; 0x74
   B>>=recombine;
 8002730:	6339      	str	r1, [r7, #48]	; 0x30
 8002732:	e624      	b.n	800237e <quant_band+0x556>
 8002734:	08014f90 	.word	0x08014f90
 8002738:	ffffc000 	.word	0xffffc000
 800273c:	08014fbc 	.word	0x08014fbc

08002740 <quant_band_stereo>:
/* This function is responsible for encoding and decoding a band for the stereo case. */
static unsigned quant_band_stereo(struct band_ctx *ctx, celt_norm *X, celt_norm *Y,
      int N, int b, int B, celt_norm *lowband,
      int LM, celt_norm *lowband_out,
      celt_norm *lowband_scratch, int fill)
{
 8002740:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002744:	469a      	mov	sl, r3
   struct split_ctx sctx;
   int orig_fill;
   int encode;
   ec_ctx *ec;

   encode = ctx->encode;
 8002746:	6803      	ldr	r3, [r0, #0]
{
 8002748:	b091      	sub	sp, #68	; 0x44
   ec = ctx->ec;

   /* Special case for one sample */
   if (N==1)
 800274a:	f1ba 0f01 	cmp.w	sl, #1
{
 800274e:	4604      	mov	r4, r0
 8002750:	9109      	str	r1, [sp, #36]	; 0x24
 8002752:	4693      	mov	fp, r2
   encode = ctx->encode;
 8002754:	9308      	str	r3, [sp, #32]
   ec = ctx->ec;
 8002756:	f8d0 801c 	ldr.w	r8, [r0, #28]
   if (N==1)
 800275a:	f000 81a7 	beq.w	8002aac <quant_band_stereo+0x36c>
   i = ctx->i;
 800275e:	e9d0 9302 	ldrd	r9, r3, [r0, #8]
 8002762:	4619      	mov	r1, r3
 8002764:	930a      	str	r3, [sp, #40]	; 0x28
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
 8002766:	f8d9 3030 	ldr.w	r3, [r9, #48]	; 0x30
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
 800276a:	f1ba 0f02 	cmp.w	sl, #2
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
 800276e:	f933 3011 	ldrsh.w	r3, [r3, r1, lsl #1]
   bandE = ctx->bandE;
 8002772:	6a41      	ldr	r1, [r0, #36]	; 0x24
   intensity = ctx->intensity;
 8002774:	6902      	ldr	r2, [r0, #16]
   bandE = ctx->bandE;
 8002776:	910d      	str	r1, [sp, #52]	; 0x34
   pulse_cap = m->logN[i]+LM*(1<<BITRES);
 8002778:	991d      	ldr	r1, [sp, #116]	; 0x74
 800277a:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
 800277e:	ea4f 0063 	mov.w	r0, r3, asr #1
 8002782:	f000 8148 	beq.w	8002a16 <quant_band_stereo+0x2d6>
   int N2 = 2*N-1;
 8002786:	ea4f 054a 	mov.w	r5, sl, lsl #1
 800278a:	1e69      	subs	r1, r5, #1
   qb = celt_sudiv(b+N2*offset, N2);
 800278c:	9d1a      	ldr	r5, [sp, #104]	; 0x68
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
 800278e:	3804      	subs	r0, #4
   qb = celt_sudiv(b+N2*offset, N2);
 8002790:	fb01 5000 	mla	r0, r1, r0, r5
   if (n<0)
 8002794:	2800      	cmp	r0, #0
 8002796:	460d      	mov	r5, r1
 8002798:	f2c0 842b 	blt.w	8002ff2 <quant_band_stereo+0x8b2>
   if (d>256)
 800279c:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   else
      return celt_udiv(n, d);
 80027a0:	4606      	mov	r6, r0
   if (d>256)
 80027a2:	f240 8140 	bls.w	8002a26 <quant_band_stereo+0x2e6>
      return n/d;
 80027a6:	fbb0 f5f1 	udiv	r5, r0, r1
   qb = IMIN(b-pulse_cap-(4<<BITRES), qb);
 80027aa:	991a      	ldr	r1, [sp, #104]	; 0x68
 80027ac:	1acb      	subs	r3, r1, r3
 80027ae:	f1a3 011f 	sub.w	r1, r3, #31
 80027b2:	42a9      	cmp	r1, r5
 80027b4:	bfd8      	it	le
 80027b6:	f1a3 0520 	suble.w	r5, r3, #32
   if (qb<(1<<BITRES>>1)) {
 80027ba:	2d03      	cmp	r5, #3
 80027bc:	f340 814a 	ble.w	8002a54 <quant_band_stereo+0x314>
   qb = IMIN(8<<BITRES, qb);
 80027c0:	2d40      	cmp	r5, #64	; 0x40
 80027c2:	bfa8      	it	ge
 80027c4:	2540      	movge	r5, #64	; 0x40
      qn = exp2_table8[qb&0x7]>>(14-(qb>>BITRES));
 80027c6:	4bbe      	ldr	r3, [pc, #760]	; (8002ac0 <quant_band_stereo+0x380>)
 80027c8:	f005 0107 	and.w	r1, r5, #7
 80027cc:	f933 7011 	ldrsh.w	r7, [r3, r1, lsl #1]
 80027d0:	10ed      	asrs	r5, r5, #3
 80027d2:	f1c5 050e 	rsb	r5, r5, #14
   if (stereo && i>=intensity)
 80027d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      qn = exp2_table8[qb&0x7]>>(14-(qb>>BITRES));
 80027d8:	fa47 f505 	asr.w	r5, r7, r5
      qn = (qn+1)>>1<<1;
 80027dc:	1c6f      	adds	r7, r5, #1
   if (stereo && i>=intensity)
 80027de:	4293      	cmp	r3, r2
      qn = (qn+1)>>1<<1;
 80027e0:	f027 0501 	bic.w	r5, r7, #1
   if (stereo && i>=intensity)
 80027e4:	f280 8136 	bge.w	8002a54 <quant_band_stereo+0x314>
   if (encode)
 80027e8:	9b08      	ldr	r3, [sp, #32]
 80027ea:	2b00      	cmp	r3, #0
 80027ec:	f040 8325 	bne.w	8002e3a <quant_band_stereo+0x6fa>
   tell = ec_tell_frac(ec);
 80027f0:	4640      	mov	r0, r8
 80027f2:	f005 fd65 	bl	80082c0 <ec_tell_frac>
      if (stereo && N>2)
 80027f6:	f1ba 0f02 	cmp.w	sl, #2
   tell = ec_tell_frac(ec);
 80027fa:	900b      	str	r0, [sp, #44]	; 0x2c
      if (stereo && N>2)
 80027fc:	f300 84da 	bgt.w	80031b4 <quant_band_stereo+0xa74>
            itheta = ec_dec_uint(ec, qn+1);
 8002800:	1c69      	adds	r1, r5, #1
 8002802:	4640      	mov	r0, r8
 8002804:	f005 ff1a 	bl	800863c <ec_dec_uint>
 8002808:	4606      	mov	r6, r0
   if (d>256)
 800280a:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
      itheta = celt_udiv((opus_int32)itheta*16384, qn);
 800280e:	ea4f 3686 	mov.w	r6, r6, lsl #14
 8002812:	f240 82fb 	bls.w	8002e0c <quant_band_stereo+0x6cc>
      return n/d;
 8002816:	fbb6 f5f5 	udiv	r5, r6, r5
      if (encode && stereo)
 800281a:	9b08      	ldr	r3, [sp, #32]
      itheta = celt_udiv((opus_int32)itheta*16384, qn);
 800281c:	950c      	str	r5, [sp, #48]	; 0x30
      if (encode && stereo)
 800281e:	2b00      	cmp	r3, #0
 8002820:	f000 82cd 	beq.w	8002dbe <quant_band_stereo+0x67e>
         if (itheta==0)
 8002824:	2d00      	cmp	r5, #0
 8002826:	f000 84b0 	beq.w	800318a <quant_band_stereo+0xa4a>
   for (j=0;j<N;j++)
 800282a:	f1ba 0f00 	cmp.w	sl, #0
 800282e:	dd17      	ble.n	8002860 <quant_band_stereo+0x120>
      l = MULT16_16(QCONST16(.70710678f, 15), X[j]);
 8002830:	f645 2782 	movw	r7, #23170	; 0x5a82
 8002834:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002836:	f1ab 0602 	sub.w	r6, fp, #2
 800283a:	1e99      	subs	r1, r3, #2
 800283c:	eb01 0c4a 	add.w	ip, r1, sl, lsl #1
 8002840:	f831 3f02 	ldrh.w	r3, [r1, #2]!
      r = MULT16_16(QCONST16(.70710678f, 15), Y[j]);
 8002844:	f836 2f02 	ldrh.w	r2, [r6, #2]!
      l = MULT16_16(QCONST16(.70710678f, 15), X[j]);
 8002848:	fb13 f007 	smulbb	r0, r3, r7
      r = MULT16_16(QCONST16(.70710678f, 15), Y[j]);
 800284c:	fb12 f307 	smulbb	r3, r2, r7
      X[j] = EXTRACT16(SHR32(ADD32(l, r), 15));
 8002850:	18c2      	adds	r2, r0, r3
      Y[j] = EXTRACT16(SHR32(SUB32(r, l), 15));
 8002852:	1a1b      	subs	r3, r3, r0
      X[j] = EXTRACT16(SHR32(ADD32(l, r), 15));
 8002854:	13d2      	asrs	r2, r2, #15
      Y[j] = EXTRACT16(SHR32(SUB32(r, l), 15));
 8002856:	13db      	asrs	r3, r3, #15
   for (j=0;j<N;j++)
 8002858:	458c      	cmp	ip, r1
      X[j] = EXTRACT16(SHR32(ADD32(l, r), 15));
 800285a:	800a      	strh	r2, [r1, #0]
      Y[j] = EXTRACT16(SHR32(SUB32(r, l), 15));
 800285c:	8033      	strh	r3, [r6, #0]
   for (j=0;j<N;j++)
 800285e:	d1ef      	bne.n	8002840 <quant_band_stereo+0x100>
   qalloc = ec_tell_frac(ec) - tell;
 8002860:	4640      	mov	r0, r8
 8002862:	f005 fd2d 	bl	80082c0 <ec_tell_frac>
 8002866:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   } else if (itheta == 16384)
 8002868:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
   qalloc = ec_tell_frac(ec) - tell;
 800286c:	eba0 0003 	sub.w	r0, r0, r3
   *b -= qalloc;
 8002870:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8002872:	eba3 0300 	sub.w	r3, r3, r0
 8002876:	930a      	str	r3, [sp, #40]	; 0x28
   } else if (itheta == 16384)
 8002878:	f000 82b0 	beq.w	8002ddc <quant_band_stereo+0x69c>
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
 800287c:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
 8002880:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
 8002884:	f64f 538e 	movw	r3, #64910	; 0xfd8e
 8002888:	f242 0955 	movw	r9, #8277	; 0x2055
      iside = bitexact_cos((opus_int16)(16384-itheta));
 800288c:	ebac 0105 	sub.w	r1, ip, r5
 8002890:	b209      	sxth	r1, r1
      imid = bitexact_cos((opus_int16)itheta);
 8002892:	fa0f fe85 	sxth.w	lr, r5
   tmp = (4096+((opus_int32)(x)*(x)))>>13;
 8002896:	fb01 2101 	mla	r1, r1, r1, r2
 800289a:	fb0e 2e0e 	mla	lr, lr, lr, r2
 800289e:	1349      	asrs	r1, r1, #13
 80028a0:	ea4f 3e6e 	mov.w	lr, lr, asr #13
   x2 = tmp;
 80028a4:	b20f      	sxth	r7, r1
 80028a6:	fa0f f68e 	sxth.w	r6, lr
   x2 = (32767-x2) + FRAC_MUL16(x2, (-7651 + FRAC_MUL16(x2, (8277 + FRAC_MUL16(-626, x2)))));
 80028aa:	fb17 c203 	smlabb	r2, r7, r3, ip
 80028ae:	fb16 c303 	smlabb	r3, r6, r3, ip
 80028b2:	eb09 32e2 	add.w	r2, r9, r2, asr #15
 80028b6:	eb09 33e3 	add.w	r3, r9, r3, asr #15
 80028ba:	b292      	uxth	r2, r2
 80028bc:	b29b      	uxth	r3, r3
 80028be:	fb07 f202 	mul.w	r2, r7, r2
 80028c2:	fb06 f303 	mul.w	r3, r6, r3
 80028c6:	4462      	add	r2, ip
 80028c8:	4463      	add	r3, ip
 80028ca:	13d2      	asrs	r2, r2, #15
 80028cc:	13db      	asrs	r3, r3, #15
 80028ce:	f5a2 52ef 	sub.w	r2, r2, #7648	; 0x1de0
 80028d2:	f5a3 53ef 	sub.w	r3, r3, #7648	; 0x1de0
 80028d6:	3a03      	subs	r2, #3
 80028d8:	3b03      	subs	r3, #3
 80028da:	fb16 c303 	smlabb	r3, r6, r3, ip
 80028de:	fb17 c202 	smlabb	r2, r7, r2, ip
   return 1+x2;
 80028e2:	f5c1 4100 	rsb	r1, r1, #32768	; 0x8000
 80028e6:	f5ce 4600 	rsb	r6, lr, #32768	; 0x8000
 80028ea:	eb01 32e2 	add.w	r2, r1, r2, asr #15
 80028ee:	eb06 36e3 	add.w	r6, r6, r3, asr #15
 80028f2:	b217      	sxth	r7, r2
 80028f4:	b236      	sxth	r6, r6
   ls=EC_ILOG(isin);
 80028f6:	fab7 f387 	clz	r3, r7
   lc=EC_ILOG(icos);
 80028fa:	fab6 f286 	clz	r2, r6
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 80028fe:	f24f 51db 	movw	r1, #62939	; 0xf5db
 8002902:	f641 6efc 	movw	lr, #7932	; 0x1efc
   icos<<=15-lc;
 8002906:	920b      	str	r2, [sp, #44]	; 0x2c
   isin<<=15-ls;
 8002908:	f1a3 0911 	sub.w	r9, r3, #17
   icos<<=15-lc;
 800290c:	3a11      	subs	r2, #17
   isin<<=15-ls;
 800290e:	fa07 f909 	lsl.w	r9, r7, r9
   icos<<=15-lc;
 8002912:	fa06 f202 	lsl.w	r2, r6, r2
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8002916:	fa0f f989 	sxth.w	r9, r9
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 800291a:	b212      	sxth	r2, r2
   isin<<=15-ls;
 800291c:	930d      	str	r3, [sp, #52]	; 0x34
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 800291e:	fb19 c301 	smlabb	r3, r9, r1, ip
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8002922:	fb12 c101 	smlabb	r1, r2, r1, ip
 8002926:	910e      	str	r1, [sp, #56]	; 0x38
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8002928:	eb0e 31e3 	add.w	r1, lr, r3, asr #15
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 800292c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 800292e:	b289      	uxth	r1, r1
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8002930:	eb0e 3ee3 	add.w	lr, lr, r3, asr #15
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8002934:	fb09 f101 	mul.w	r1, r9, r1
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8002938:	fa1f fe8e 	uxth.w	lr, lr
 800293c:	fb02 fe0e 	mul.w	lr, r2, lr
   return (ls-lc)*(1<<11)
 8002940:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8002942:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 8002944:	4461      	add	r1, ip
   return (ls-lc)*(1<<11)
 8002946:	1ad3      	subs	r3, r2, r3
 8002948:	02db      	lsls	r3, r3, #11
         +FRAC_MUL16(isin, FRAC_MUL16(isin, -2597) + 7932)
 800294a:	eb03 31e1 	add.w	r1, r3, r1, asr #15
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 800294e:	44e6      	add	lr, ip
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
 8002950:	f10a 33ff 	add.w	r3, sl, #4294967295
 8002954:	01db      	lsls	r3, r3, #7
         -FRAC_MUL16(icos, FRAC_MUL16(icos, -2597) + 7932);
 8002956:	eba1 3eee 	sub.w	lr, r1, lr, asr #15
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
 800295a:	fb13 cc0e 	smlabb	ip, r3, lr, ip
#endif

   /* This is a special case for N=2 that only works for stereo and takes
      advantage of the fact that mid and side are orthogonal to encode
      the side with just one bit. */
   if (N==2)
 800295e:	f1ba 0f02 	cmp.w	sl, #2
      iside = bitexact_cos((opus_int16)(16384-itheta));
 8002962:	46b9      	mov	r9, r7
      delta = FRAC_MUL16((N-1)<<7,bitexact_log2tan(iside,imid));
 8002964:	ea4f 33ec 	mov.w	r3, ip, asr #15
      imid = bitexact_cos((opus_int16)itheta);
 8002968:	960b      	str	r6, [sp, #44]	; 0x2c
 800296a:	6a22      	ldr	r2, [r4, #32]
   if (N==2)
 800296c:	f000 83d3 	beq.w	8003116 <quant_band_stereo+0x9d6>
 8002970:	2100      	movs	r1, #0
 8002972:	9108      	str	r1, [sp, #32]
      }
   } else {
      /* "Normal" split code */
      opus_int32 rebalance;

      mbits = IMAX(0, IMIN(b, (b-delta)/2));
 8002974:	990a      	ldr	r1, [sp, #40]	; 0x28
      sbits = b-mbits;
      ctx->remaining_bits -= qalloc;
 8002976:	1a17      	subs	r7, r2, r0
      mbits = IMAX(0, IMIN(b, (b-delta)/2));
 8002978:	1acd      	subs	r5, r1, r3
 800297a:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 800297e:	106d      	asrs	r5, r5, #1
 8002980:	428d      	cmp	r5, r1
 8002982:	bfa8      	it	ge
 8002984:	460d      	movge	r5, r1
 8002986:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8002988:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
 800298c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
      sbits = b-mbits;
 800298e:	eba1 0805 	sub.w	r8, r1, r5
 8002992:	4113      	asrs	r3, r2

      rebalance = ctx->remaining_bits;
      if (mbits >= sbits)
 8002994:	4545      	cmp	r5, r8
      ctx->remaining_bits -= qalloc;
 8002996:	6227      	str	r7, [r4, #32]
 8002998:	930a      	str	r3, [sp, #40]	; 0x28
      if (mbits >= sbits)
 800299a:	f2c0 8105 	blt.w	8002ba8 <quant_band_stereo+0x468>
      {
         /* In stereo mode, we do not apply a scaling to the mid because we need the normalized
            mid for folding later. */
         cm = quant_band(ctx, X, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
 800299e:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80029a2:	9a20      	ldr	r2, [sp, #128]	; 0x80
 80029a4:	9304      	str	r3, [sp, #16]
 80029a6:	9206      	str	r2, [sp, #24]
 80029a8:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 80029aa:	462b      	mov	r3, r5
 80029ac:	9205      	str	r2, [sp, #20]
 80029ae:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 80029b0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80029b2:	9203      	str	r2, [sp, #12]
 80029b4:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 80029b6:	4620      	mov	r0, r4
 80029b8:	9202      	str	r2, [sp, #8]
 80029ba:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 80029bc:	9201      	str	r2, [sp, #4]
 80029be:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80029c0:	9200      	str	r2, [sp, #0]
 80029c2:	4652      	mov	r2, sl
 80029c4:	f7ff fa30 	bl	8001e28 <quant_band>
               lowband_scratch, fill);
         rebalance = mbits - (rebalance-ctx->remaining_bits);
 80029c8:	6a23      	ldr	r3, [r4, #32]
         cm = quant_band(ctx, X, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
 80029ca:	900d      	str	r0, [sp, #52]	; 0x34
         rebalance = mbits - (rebalance-ctx->remaining_bits);
 80029cc:	1aff      	subs	r7, r7, r3
 80029ce:	1bed      	subs	r5, r5, r7
         if (rebalance > 3<<BITRES && itheta!=0)
 80029d0:	2d18      	cmp	r5, #24
 80029d2:	dd03      	ble.n	80029dc <quant_band_stereo+0x29c>
 80029d4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80029d6:	b10b      	cbz	r3, 80029dc <quant_band_stereo+0x29c>
            sbits += rebalance - (3<<BITRES);
 80029d8:	3d18      	subs	r5, #24
 80029da:	44a8      	add	r8, r5

         /* For a stereo split, the high bits of fill are always zero, so no
            folding will be done to the side. */
         cm |= quant_band(ctx, Y, N, sbits, B, NULL, LM, NULL, side, NULL, fill>>B);
 80029dc:	2200      	movs	r2, #0
 80029de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80029e0:	9205      	str	r2, [sp, #20]
 80029e2:	9306      	str	r3, [sp, #24]
 80029e4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80029e6:	9203      	str	r2, [sp, #12]
 80029e8:	9302      	str	r3, [sp, #8]
 80029ea:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80029ec:	9201      	str	r2, [sp, #4]
 80029ee:	9300      	str	r3, [sp, #0]
 80029f0:	f8cd 9010 	str.w	r9, [sp, #16]
 80029f4:	4643      	mov	r3, r8
 80029f6:	4652      	mov	r2, sl
 80029f8:	4659      	mov	r1, fp
 80029fa:	4620      	mov	r0, r4
 80029fc:	f7ff fa14 	bl	8001e28 <quant_band>
 8002a00:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8002a02:	ea43 0800 	orr.w	r8, r3, r0
      }
   }


   /* This code is used by the decoder and by the resynthesis-enabled encoder */
   if (ctx->resynth)
 8002a06:	6863      	ldr	r3, [r4, #4]
 8002a08:	2b00      	cmp	r3, #0
 8002a0a:	f040 8109 	bne.w	8002c20 <quant_band_stereo+0x4e0>
         for (j=0;j<N;j++)
            Y[j] = -Y[j];
      }
   }
   return cm;
}
 8002a0e:	4640      	mov	r0, r8
 8002a10:	b011      	add	sp, #68	; 0x44
 8002a12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (n<0)
 8002a16:	991a      	ldr	r1, [sp, #104]	; 0x68
   offset = (pulse_cap>>1) - (stereo&&N==2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
 8002a18:	f1a0 0610 	sub.w	r6, r0, #16
 8002a1c:	eb11 0646 	adds.w	r6, r1, r6, lsl #1
 8002a20:	f100 809f 	bmi.w	8002b62 <quant_band_stereo+0x422>
      return celt_udiv(n, d);
 8002a24:	4655      	mov	r5, sl
      t = EC_ILOG(d&-d);
 8002a26:	4268      	negs	r0, r5
 8002a28:	4028      	ands	r0, r5
 8002a2a:	fab0 f080 	clz	r0, r0
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8002a2e:	4925      	ldr	r1, [pc, #148]	; (8002ac4 <quant_band_stereo+0x384>)
      t = EC_ILOG(d&-d);
 8002a30:	f1c0 0020 	rsb	r0, r0, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8002a34:	fa25 f700 	lsr.w	r7, r5, r0
 8002a38:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 8002a3c:	3801      	subs	r0, #1
 8002a3e:	fa26 f000 	lsr.w	r0, r6, r0
 8002a42:	fba0 0101 	umull	r0, r1, r0, r1
      return q+(n-q*d >= d);
 8002a46:	fb05 6611 	mls	r6, r5, r1, r6
 8002a4a:	42b5      	cmp	r5, r6
 8002a4c:	bf8c      	ite	hi
 8002a4e:	460d      	movhi	r5, r1
 8002a50:	1c4d      	addls	r5, r1, #1
 8002a52:	e6aa      	b.n	80027aa <quant_band_stereo+0x6a>
   if (encode)
 8002a54:	9d08      	ldr	r5, [sp, #32]
 8002a56:	2d00      	cmp	r5, #0
 8002a58:	f040 8220 	bne.w	8002e9c <quant_band_stereo+0x75c>
   tell = ec_tell_frac(ec);
 8002a5c:	4640      	mov	r0, r8
 8002a5e:	f005 fc2f 	bl	80082c0 <ec_tell_frac>
 8002a62:	4607      	mov	r7, r0
      if (*b>2<<BITRES && ctx->remaining_bits > 2<<BITRES)
 8002a64:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8002a66:	2b10      	cmp	r3, #16
 8002a68:	dc6d      	bgt.n	8002b46 <quant_band_stereo+0x406>
         inv = 0;
 8002a6a:	2300      	movs	r3, #0
 8002a6c:	9308      	str	r3, [sp, #32]
      if (ctx->disable_inv)
 8002a6e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   qalloc = ec_tell_frac(ec) - tell;
 8002a70:	4640      	mov	r0, r8
      if (ctx->disable_inv)
 8002a72:	2b00      	cmp	r3, #0
 8002a74:	f040 82c6 	bne.w	8003004 <quant_band_stereo+0x8c4>
   qalloc = ec_tell_frac(ec) - tell;
 8002a78:	f005 fc22 	bl	80082c0 <ec_tell_frac>
   *b -= qalloc;
 8002a7c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   qalloc = ec_tell_frac(ec) - tell;
 8002a7e:	1bc0      	subs	r0, r0, r7
   *b -= qalloc;
 8002a80:	1a1b      	subs	r3, r3, r0
 8002a82:	930a      	str	r3, [sp, #40]	; 0x28
   if (N==2)
 8002a84:	f1ba 0f02 	cmp.w	sl, #2
 8002a88:	6a22      	ldr	r2, [r4, #32]
 8002a8a:	f000 82c8 	beq.w	800301e <quant_band_stereo+0x8de>
      *fill &= (1<<B)-1;
 8002a8e:	2301      	movs	r3, #1
      imid = 32767;
 8002a90:	f647 76ff 	movw	r6, #32767	; 0x7fff
   side = iside;
 8002a94:	f04f 0900 	mov.w	r9, #0
      *fill &= (1<<B)-1;
 8002a98:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8002a9a:	e9cd 690b 	strd	r6, r9, [sp, #44]	; 0x2c
 8002a9e:	408b      	lsls	r3, r1
 8002aa0:	9920      	ldr	r1, [sp, #128]	; 0x80
 8002aa2:	3b01      	subs	r3, #1
 8002aa4:	4019      	ands	r1, r3
 8002aa6:	9120      	str	r1, [sp, #128]	; 0x80
      delta = -16384;
 8002aa8:	4b07      	ldr	r3, [pc, #28]	; (8002ac8 <quant_band_stereo+0x388>)
 8002aaa:	e763      	b.n	8002974 <quant_band_stereo+0x234>
   stereo = Y != NULL;
 8002aac:	1c15      	adds	r5, r2, #0
 8002aae:	bf18      	it	ne
 8002ab0:	2501      	movne	r5, #1
 8002ab2:	461a      	mov	r2, r3
 8002ab4:	bb1b      	cbnz	r3, 8002afe <quant_band_stereo+0x3be>
 8002ab6:	460f      	mov	r7, r1
 8002ab8:	6a03      	ldr	r3, [r0, #32]
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
 8002aba:	4e03      	ldr	r6, [pc, #12]	; (8002ac8 <quant_band_stereo+0x388>)
 8002abc:	4691      	mov	r9, r2
 8002abe:	e016      	b.n	8002aee <quant_band_stereo+0x3ae>
 8002ac0:	08014fb0 	.word	0x08014fb0
 8002ac4:	0801649c 	.word	0x0801649c
 8002ac8:	ffffc000 	.word	0xffffc000
            sign = ec_dec_bits(ec, 1);
 8002acc:	2101      	movs	r1, #1
 8002ace:	4640      	mov	r0, r8
 8002ad0:	f005 fed4 	bl	800887c <ec_dec_bits>
         ctx->remaining_bits -= 1<<BITRES;
 8002ad4:	6a23      	ldr	r3, [r4, #32]
      if (ctx->resynth)
 8002ad6:	6862      	ldr	r2, [r4, #4]
         ctx->remaining_bits -= 1<<BITRES;
 8002ad8:	3b08      	subs	r3, #8
 8002ada:	6223      	str	r3, [r4, #32]
      if (ctx->resynth)
 8002adc:	b112      	cbz	r2, 8002ae4 <quant_band_stereo+0x3a4>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
 8002ade:	b158      	cbz	r0, 8002af8 <quant_band_stereo+0x3b8>
 8002ae0:	4632      	mov	r2, r6
 8002ae2:	803a      	strh	r2, [r7, #0]
   } while (++c<1+stereo);
 8002ae4:	45a9      	cmp	r9, r5
 8002ae6:	465f      	mov	r7, fp
 8002ae8:	da4e      	bge.n	8002b88 <quant_band_stereo+0x448>
 8002aea:	f04f 0901 	mov.w	r9, #1
      if (ctx->remaining_bits>=1<<BITRES)
 8002aee:	2b07      	cmp	r3, #7
 8002af0:	dcec      	bgt.n	8002acc <quant_band_stereo+0x38c>
      if (ctx->resynth)
 8002af2:	6862      	ldr	r2, [r4, #4]
 8002af4:	2a00      	cmp	r2, #0
 8002af6:	d0f5      	beq.n	8002ae4 <quant_band_stereo+0x3a4>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
 8002af8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8002afc:	e7f1      	b.n	8002ae2 <quant_band_stereo+0x3a2>
 8002afe:	460e      	mov	r6, r1
   c=0; do {
 8002b00:	2700      	movs	r7, #0
 8002b02:	6a03      	ldr	r3, [r0, #32]
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
 8002b04:	f8df a390 	ldr.w	sl, [pc, #912]	; 8002e98 <quant_band_stereo+0x758>
 8002b08:	e008      	b.n	8002b1c <quant_band_stereo+0x3dc>
      if (ctx->resynth)
 8002b0a:	6862      	ldr	r2, [r4, #4]
 8002b0c:	b112      	cbz	r2, 8002b14 <quant_band_stereo+0x3d4>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
 8002b0e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8002b12:	8032      	strh	r2, [r6, #0]
   } while (++c<1+stereo);
 8002b14:	42bd      	cmp	r5, r7
 8002b16:	465e      	mov	r6, fp
 8002b18:	dd36      	ble.n	8002b88 <quant_band_stereo+0x448>
 8002b1a:	2701      	movs	r7, #1
      if (ctx->remaining_bits>=1<<BITRES)
 8002b1c:	2b07      	cmp	r3, #7
 8002b1e:	ddf4      	ble.n	8002b0a <quant_band_stereo+0x3ca>
            sign = x[0]<0;
 8002b20:	f9b6 9000 	ldrsh.w	r9, [r6]
            ec_enc_bits(ec, sign, 1);
 8002b24:	2201      	movs	r2, #1
 8002b26:	ea4f 71d9 	mov.w	r1, r9, lsr #31
 8002b2a:	4640      	mov	r0, r8
 8002b2c:	f006 f814 	bl	8008b58 <ec_enc_bits>
         ctx->remaining_bits -= 1<<BITRES;
 8002b30:	6a23      	ldr	r3, [r4, #32]
      if (ctx->resynth)
 8002b32:	6862      	ldr	r2, [r4, #4]
         ctx->remaining_bits -= 1<<BITRES;
 8002b34:	3b08      	subs	r3, #8
 8002b36:	6223      	str	r3, [r4, #32]
      if (ctx->resynth)
 8002b38:	2a00      	cmp	r2, #0
 8002b3a:	d0eb      	beq.n	8002b14 <quant_band_stereo+0x3d4>
         x[0] = sign ? -NORM_SCALING : NORM_SCALING;
 8002b3c:	f1b9 0f00 	cmp.w	r9, #0
 8002b40:	dae5      	bge.n	8002b0e <quant_band_stereo+0x3ce>
 8002b42:	4652      	mov	r2, sl
 8002b44:	e7e5      	b.n	8002b12 <quant_band_stereo+0x3d2>
      if (*b>2<<BITRES && ctx->remaining_bits > 2<<BITRES)
 8002b46:	6a23      	ldr	r3, [r4, #32]
 8002b48:	2b10      	cmp	r3, #16
 8002b4a:	dd8e      	ble.n	8002a6a <quant_band_stereo+0x32a>
         if (encode)
 8002b4c:	9b08      	ldr	r3, [sp, #32]
 8002b4e:	2b00      	cmp	r3, #0
 8002b50:	f000 836b 	beq.w	800322a <quant_band_stereo+0xaea>
            ec_enc_bit_logp(ec, inv, 2);
 8002b54:	2202      	movs	r2, #2
 8002b56:	4629      	mov	r1, r5
 8002b58:	4640      	mov	r0, r8
 8002b5a:	9508      	str	r5, [sp, #32]
 8002b5c:	f005 ff40 	bl	80089e0 <ec_enc_bit_logp>
 8002b60:	e785      	b.n	8002a6e <quant_band_stereo+0x32e>
      return -(opus_int32)celt_udiv(-n, d);
 8002b62:	2001      	movs	r0, #1
 8002b64:	2700      	movs	r7, #0
 8002b66:	4655      	mov	r5, sl
 8002b68:	4276      	negs	r6, r6
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8002b6a:	49c9      	ldr	r1, [pc, #804]	; (8002e90 <quant_band_stereo+0x750>)
 8002b6c:	fa26 f000 	lsr.w	r0, r6, r0
 8002b70:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 8002b74:	fba0 0101 	umull	r0, r1, r0, r1
      return q+(n-q*d >= d);
 8002b78:	fb05 6611 	mls	r6, r5, r1, r6
 8002b7c:	42b5      	cmp	r5, r6
 8002b7e:	bf8c      	ite	hi
 8002b80:	460d      	movhi	r5, r1
 8002b82:	1c4d      	addls	r5, r1, #1
      return -(opus_int32)celt_udiv(-n, d);
 8002b84:	426d      	negs	r5, r5
 8002b86:	e610      	b.n	80027aa <quant_band_stereo+0x6a>
   if (lowband_out)
 8002b88:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8002b8a:	2b00      	cmp	r3, #0
 8002b8c:	f000 82f2 	beq.w	8003174 <quant_band_stereo+0xa34>
      return quant_band_n1(ctx, X, Y, b, lowband_out);
 8002b90:	f04f 0801 	mov.w	r8, #1
 8002b94:	461a      	mov	r2, r3
}
 8002b96:	4640      	mov	r0, r8
      lowband_out[0] = SHR16(X[0],4);
 8002b98:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002b9a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8002b9e:	111b      	asrs	r3, r3, #4
 8002ba0:	8013      	strh	r3, [r2, #0]
}
 8002ba2:	b011      	add	sp, #68	; 0x44
 8002ba4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002ba8:	461a      	mov	r2, r3
         cm = quant_band(ctx, Y, N, sbits, B, NULL, LM, NULL, side, NULL, fill>>B);
 8002baa:	2300      	movs	r3, #0
 8002bac:	9206      	str	r2, [sp, #24]
 8002bae:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8002bb0:	f8cd 9010 	str.w	r9, [sp, #16]
 8002bb4:	9202      	str	r2, [sp, #8]
 8002bb6:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8002bb8:	9305      	str	r3, [sp, #20]
 8002bba:	9200      	str	r2, [sp, #0]
 8002bbc:	9303      	str	r3, [sp, #12]
 8002bbe:	9301      	str	r3, [sp, #4]
 8002bc0:	4652      	mov	r2, sl
 8002bc2:	4643      	mov	r3, r8
 8002bc4:	4659      	mov	r1, fp
 8002bc6:	4620      	mov	r0, r4
 8002bc8:	f7ff f92e 	bl	8001e28 <quant_band>
 8002bcc:	4681      	mov	r9, r0
         rebalance = sbits - (rebalance-ctx->remaining_bits);
 8002bce:	6a20      	ldr	r0, [r4, #32]
 8002bd0:	1a3f      	subs	r7, r7, r0
 8002bd2:	eba8 0807 	sub.w	r8, r8, r7
         if (rebalance > 3<<BITRES && itheta!=16384)
 8002bd6:	f1b8 0f18 	cmp.w	r8, #24
 8002bda:	dd06      	ble.n	8002bea <quant_band_stereo+0x4aa>
 8002bdc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002bde:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
            mbits += rebalance - (3<<BITRES);
 8002be2:	bf1c      	itt	ne
 8002be4:	f1a8 0818 	subne.w	r8, r8, #24
 8002be8:	4445      	addne	r5, r8
         cm |= quant_band(ctx, X, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
 8002bea:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8002bee:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8002bf0:	9204      	str	r2, [sp, #16]
 8002bf2:	9306      	str	r3, [sp, #24]
 8002bf4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8002bf6:	4652      	mov	r2, sl
 8002bf8:	9305      	str	r3, [sp, #20]
 8002bfa:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8002bfc:	9909      	ldr	r1, [sp, #36]	; 0x24
 8002bfe:	9303      	str	r3, [sp, #12]
 8002c00:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8002c02:	4620      	mov	r0, r4
 8002c04:	9302      	str	r3, [sp, #8]
 8002c06:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8002c08:	9301      	str	r3, [sp, #4]
 8002c0a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8002c0c:	9300      	str	r3, [sp, #0]
 8002c0e:	462b      	mov	r3, r5
 8002c10:	f7ff f90a 	bl	8001e28 <quant_band>
   if (ctx->resynth)
 8002c14:	6863      	ldr	r3, [r4, #4]
         cm |= quant_band(ctx, X, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
 8002c16:	ea49 0800 	orr.w	r8, r9, r0
   if (ctx->resynth)
 8002c1a:	2b00      	cmp	r3, #0
 8002c1c:	f43f aef7 	beq.w	8002a0e <quant_band_stereo+0x2ce>
static OPUS_INLINE void dual_inner_prod_c(const opus_val16 *x, const opus_val16 *y01, const opus_val16 *y02,
      int N, opus_val32 *xy1, opus_val32 *xy2)
{
   int i;
   opus_val32 xy01=0;
   opus_val32 xy02=0;
 8002c20:	2000      	movs	r0, #0
   for (i=0;i<N;i++)
 8002c22:	f1ba 0f00 	cmp.w	sl, #0
   opus_val32 xy01=0;
 8002c26:	4601      	mov	r1, r0
   for (i=0;i<N;i++)
 8002c28:	dd0f      	ble.n	8002c4a <quant_band_stereo+0x50a>
 8002c2a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002c2c:	f1ab 0202 	sub.w	r2, fp, #2
 8002c30:	eb02 074a 	add.w	r7, r2, sl, lsl #1
 8002c34:	1e9c      	subs	r4, r3, #2
   {
      xy01 = MAC16_16(xy01, x[i], y01[i]);
 8002c36:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
 8002c3a:	f834 5f02 	ldrh.w	r5, [r4, #2]!
   for (i=0;i<N;i++)
 8002c3e:	4297      	cmp	r7, r2
      xy02 = MAC16_16(xy02, x[i], y02[i]);
 8002c40:	fb03 0003 	mla	r0, r3, r3, r0
      xy01 = MAC16_16(xy01, x[i], y01[i]);
 8002c44:	fb13 1105 	smlabb	r1, r3, r5, r1
   for (i=0;i<N;i++)
 8002c48:	d1f5      	bne.n	8002c36 <quant_band_stereo+0x4f6>
   mid2 = SHR16(mid, 1);
 8002c4a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   if (Er < QCONST32(6e-4f, 28) || El < QCONST32(6e-4f, 28))
 8002c4c:	4d91      	ldr	r5, [pc, #580]	; (8002e94 <quant_band_stereo+0x754>)
   mid2 = SHR16(mid, 1);
 8002c4e:	105b      	asrs	r3, r3, #1
   El = MULT16_16(mid2, mid2) + side - 2*xp;
 8002c50:	fb03 0203 	mla	r2, r3, r3, r0
  int rd_hi;
  __asm__(
      "#MULT16_32_Q15\n\t"
      "smull %0, %1, %2, %3\n\t"
      : "=&r"(rd_lo), "=&r"(rd_hi)
      : "%r"(b), "r"(SHL32(a,16))
 8002c54:	0433      	lsls	r3, r6, #16
  __asm__(
 8002c56:	fb81 4003 	smull	r4, r0, r1, r3
 8002c5a:	0083      	lsls	r3, r0, #2
   Er = MULT16_16(mid2, mid2) + side + 2*xp;
 8002c5c:	18d4      	adds	r4, r2, r3
   if (Er < QCONST32(6e-4f, 28) || El < QCONST32(6e-4f, 28))
 8002c5e:	42ac      	cmp	r4, r5
 8002c60:	dd03      	ble.n	8002c6a <quant_band_stereo+0x52a>
   El = MULT16_16(mid2, mid2) + side - 2*xp;
 8002c62:	1ad3      	subs	r3, r2, r3
   if (Er < QCONST32(6e-4f, 28) || El < QCONST32(6e-4f, 28))
 8002c64:	42ab      	cmp	r3, r5
 8002c66:	f300 82e6 	bgt.w	8003236 <quant_band_stereo+0xaf6>
      OPUS_COPY(Y, X, N);
 8002c6a:	9909      	ldr	r1, [sp, #36]	; 0x24
 8002c6c:	ea4f 024a 	mov.w	r2, sl, lsl #1
 8002c70:	4658      	mov	r0, fp
 8002c72:	f011 fa35 	bl	80140e0 <memcpy>
      if (inv)
 8002c76:	9b08      	ldr	r3, [sp, #32]
 8002c78:	2b00      	cmp	r3, #0
 8002c7a:	f43f aec8 	beq.w	8002a0e <quant_band_stereo+0x2ce>
         for (j=0;j<N;j++)
 8002c7e:	f1ba 0f00 	cmp.w	sl, #0
 8002c82:	f77f aec4 	ble.w	8002a0e <quant_band_stereo+0x2ce>
 8002c86:	f1ba 0f00 	cmp.w	sl, #0
 8002c8a:	f10a 33ff 	add.w	r3, sl, #4294967295
 8002c8e:	bfd8      	it	le
 8002c90:	2300      	movle	r3, #0
 8002c92:	ea4f 015b 	mov.w	r1, fp, lsr #1
 8002c96:	f1c1 0100 	rsb	r1, r1, #0
 8002c9a:	f001 0103 	and.w	r1, r1, #3
 8002c9e:	f101 0203 	add.w	r2, r1, #3
 8002ca2:	bfcc      	ite	gt
 8002ca4:	4650      	movgt	r0, sl
 8002ca6:	2001      	movle	r0, #1
 8002ca8:	429a      	cmp	r2, r3
 8002caa:	f200 8338 	bhi.w	800331e <quant_band_stereo+0xbde>
 8002cae:	2900      	cmp	r1, #0
 8002cb0:	f000 8263 	beq.w	800317a <quant_band_stereo+0xa3a>
            Y[j] = -Y[j];
 8002cb4:	f8bb 3000 	ldrh.w	r3, [fp]
 8002cb8:	2901      	cmp	r1, #1
 8002cba:	f1c3 0300 	rsb	r3, r3, #0
 8002cbe:	f8ab 3000 	strh.w	r3, [fp]
 8002cc2:	f000 825a 	beq.w	800317a <quant_band_stereo+0xa3a>
 8002cc6:	f8bb 3002 	ldrh.w	r3, [fp, #2]
 8002cca:	2903      	cmp	r1, #3
 8002ccc:	f1c3 0300 	rsb	r3, r3, #0
 8002cd0:	f8ab 3002 	strh.w	r3, [fp, #2]
 8002cd4:	f040 8320 	bne.w	8003318 <quant_band_stereo+0xbd8>
         for (j=0;j<N;j++)
 8002cd8:	468e      	mov	lr, r1
            Y[j] = -Y[j];
 8002cda:	f8bb 3004 	ldrh.w	r3, [fp, #4]
 8002cde:	425b      	negs	r3, r3
 8002ce0:	f8ab 3004 	strh.w	r3, [fp, #4]
         for (j=0;j<N;j++)
 8002ce4:	2600      	movs	r6, #0
 8002ce6:	1a43      	subs	r3, r0, r1
 8002ce8:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
 8002cec:	9308      	str	r3, [sp, #32]
 8002cee:	ea4f 0993 	mov.w	r9, r3, lsr #2
 8002cf2:	f1a1 0508 	sub.w	r5, r1, #8
            Y[j] = -Y[j];
 8002cf6:	2000      	movs	r0, #0
 8002cf8:	4604      	mov	r4, r0
 8002cfa:	f855 3f08 	ldr.w	r3, [r5, #8]!
 8002cfe:	3601      	adds	r6, #1
 8002d00:	686a      	ldr	r2, [r5, #4]
 8002d02:	425f      	negs	r7, r3
 8002d04:	f1c2 0c00 	rsb	ip, r2, #0
 8002d08:	f3c3 430f 	ubfx	r3, r3, #16, #16
 8002d0c:	f3c2 420f 	ubfx	r2, r2, #16, #16
 8002d10:	4252      	negs	r2, r2
 8002d12:	f36c 040f 	bfi	r4, ip, #0, #16
 8002d16:	f367 000f 	bfi	r0, r7, #0, #16
 8002d1a:	425b      	negs	r3, r3
 8002d1c:	f362 441f 	bfi	r4, r2, #16, #16
 8002d20:	f363 401f 	bfi	r0, r3, #16, #16
 8002d24:	45b1      	cmp	r9, r6
 8002d26:	e9c1 0400 	strd	r0, r4, [r1]
 8002d2a:	f101 0108 	add.w	r1, r1, #8
 8002d2e:	d8e2      	bhi.n	8002cf6 <quant_band_stereo+0x5b6>
 8002d30:	9a08      	ldr	r2, [sp, #32]
 8002d32:	f022 0303 	bic.w	r3, r2, #3
 8002d36:	4293      	cmp	r3, r2
 8002d38:	449e      	add	lr, r3
 8002d3a:	f43f ae68 	beq.w	8002a0e <quant_band_stereo+0x2ce>
 8002d3e:	f83b 301e 	ldrh.w	r3, [fp, lr, lsl #1]
         for (j=0;j<N;j++)
 8002d42:	f10e 0201 	add.w	r2, lr, #1
            Y[j] = -Y[j];
 8002d46:	425b      	negs	r3, r3
         for (j=0;j<N;j++)
 8002d48:	4552      	cmp	r2, sl
            Y[j] = -Y[j];
 8002d4a:	f82b 301e 	strh.w	r3, [fp, lr, lsl #1]
 8002d4e:	ea4f 034e 	mov.w	r3, lr, lsl #1
         for (j=0;j<N;j++)
 8002d52:	f6bf ae5c 	bge.w	8002a0e <quant_band_stereo+0x2ce>
            Y[j] = -Y[j];
 8002d56:	1c98      	adds	r0, r3, #2
 8002d58:	f83b 1000 	ldrh.w	r1, [fp, r0]
         for (j=0;j<N;j++)
 8002d5c:	f10e 0202 	add.w	r2, lr, #2
            Y[j] = -Y[j];
 8002d60:	4249      	negs	r1, r1
         for (j=0;j<N;j++)
 8002d62:	4592      	cmp	sl, r2
            Y[j] = -Y[j];
 8002d64:	f82b 1000 	strh.w	r1, [fp, r0]
         for (j=0;j<N;j++)
 8002d68:	f77f ae51 	ble.w	8002a0e <quant_band_stereo+0x2ce>
            Y[j] = -Y[j];
 8002d6c:	1d18      	adds	r0, r3, #4
 8002d6e:	f83b 1000 	ldrh.w	r1, [fp, r0]
         for (j=0;j<N;j++)
 8002d72:	f10e 0203 	add.w	r2, lr, #3
            Y[j] = -Y[j];
 8002d76:	4249      	negs	r1, r1
         for (j=0;j<N;j++)
 8002d78:	4592      	cmp	sl, r2
            Y[j] = -Y[j];
 8002d7a:	f82b 1000 	strh.w	r1, [fp, r0]
         for (j=0;j<N;j++)
 8002d7e:	f77f ae46 	ble.w	8002a0e <quant_band_stereo+0x2ce>
            Y[j] = -Y[j];
 8002d82:	1d98      	adds	r0, r3, #6
 8002d84:	f83b 1000 	ldrh.w	r1, [fp, r0]
         for (j=0;j<N;j++)
 8002d88:	f10e 0204 	add.w	r2, lr, #4
            Y[j] = -Y[j];
 8002d8c:	4249      	negs	r1, r1
         for (j=0;j<N;j++)
 8002d8e:	4592      	cmp	sl, r2
            Y[j] = -Y[j];
 8002d90:	f82b 1000 	strh.w	r1, [fp, r0]
         for (j=0;j<N;j++)
 8002d94:	f77f ae3b 	ble.w	8002a0e <quant_band_stereo+0x2ce>
            Y[j] = -Y[j];
 8002d98:	f103 0108 	add.w	r1, r3, #8
 8002d9c:	f83b 2001 	ldrh.w	r2, [fp, r1]
         for (j=0;j<N;j++)
 8002da0:	f10e 0e05 	add.w	lr, lr, #5
            Y[j] = -Y[j];
 8002da4:	4252      	negs	r2, r2
         for (j=0;j<N;j++)
 8002da6:	45f2      	cmp	sl, lr
            Y[j] = -Y[j];
 8002da8:	f82b 2001 	strh.w	r2, [fp, r1]
         for (j=0;j<N;j++)
 8002dac:	f77f ae2f 	ble.w	8002a0e <quant_band_stereo+0x2ce>
            Y[j] = -Y[j];
 8002db0:	330a      	adds	r3, #10
 8002db2:	f83b 2003 	ldrh.w	r2, [fp, r3]
 8002db6:	4252      	negs	r2, r2
 8002db8:	f82b 2003 	strh.w	r2, [fp, r3]
 8002dbc:	e627      	b.n	8002a0e <quant_band_stereo+0x2ce>
   qalloc = ec_tell_frac(ec) - tell;
 8002dbe:	4640      	mov	r0, r8
 8002dc0:	f005 fa7e 	bl	80082c0 <ec_tell_frac>
 8002dc4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8002dc6:	1ac0      	subs	r0, r0, r3
   *b -= qalloc;
 8002dc8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8002dca:	1a1b      	subs	r3, r3, r0
 8002dcc:	930a      	str	r3, [sp, #40]	; 0x28
   if (itheta == 0)
 8002dce:	2d00      	cmp	r5, #0
 8002dd0:	f43f ae58 	beq.w	8002a84 <quant_band_stereo+0x344>
   } else if (itheta == 16384)
 8002dd4:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
 8002dd8:	f47f ad50 	bne.w	800287c <quant_band_stereo+0x13c>
      *fill &= ((1<<B)-1)<<B;
 8002ddc:	2101      	movs	r1, #1
 8002dde:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8002de0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8002de2:	fa01 f303 	lsl.w	r3, r1, r3
 8002de6:	3b01      	subs	r3, #1
 8002de8:	4093      	lsls	r3, r2
 8002dea:	9a20      	ldr	r2, [sp, #128]	; 0x80
   if (N==2)
 8002dec:	f1ba 0f02 	cmp.w	sl, #2
      *fill &= ((1<<B)-1)<<B;
 8002df0:	ea03 0302 	and.w	r3, r3, r2
 8002df4:	6a22      	ldr	r2, [r4, #32]
   if (N==2)
 8002df6:	f000 8271 	beq.w	80032dc <quant_band_stereo+0xb9c>
      imid = 0;
 8002dfa:	2100      	movs	r1, #0
      *fill &= ((1<<B)-1)<<B;
 8002dfc:	9320      	str	r3, [sp, #128]	; 0x80
      imid = 0;
 8002dfe:	9108      	str	r1, [sp, #32]
      delta = 16384;
 8002e00:	462b      	mov	r3, r5
   if (N==2)
 8002e02:	460e      	mov	r6, r1
 8002e04:	910b      	str	r1, [sp, #44]	; 0x2c
 8002e06:	f647 79ff 	movw	r9, #32767	; 0x7fff
 8002e0a:	e5b3      	b.n	8002974 <quant_band_stereo+0x234>
      t = EC_ILOG(d&-d);
 8002e0c:	426a      	negs	r2, r5
 8002e0e:	402a      	ands	r2, r5
 8002e10:	fab2 f282 	clz	r2, r2
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8002e14:	4b1e      	ldr	r3, [pc, #120]	; (8002e90 <quant_band_stereo+0x750>)
      t = EC_ILOG(d&-d);
 8002e16:	f1c2 0220 	rsb	r2, r2, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8002e1a:	fa25 f102 	lsr.w	r1, r5, r2
 8002e1e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8002e22:	3a01      	subs	r2, #1
 8002e24:	fa26 f202 	lsr.w	r2, r6, r2
 8002e28:	fba2 2303 	umull	r2, r3, r2, r3
      return q+(n-q*d >= d);
 8002e2c:	fb05 6613 	mls	r6, r5, r3, r6
 8002e30:	42b5      	cmp	r5, r6
 8002e32:	bf8c      	ite	hi
 8002e34:	461d      	movhi	r5, r3
 8002e36:	1c5d      	addls	r5, r3, #1
 8002e38:	e4ef      	b.n	800281a <quant_band_stereo+0xda>
      itheta = stereo_itheta(X, Y, stereo, N, ctx->arch);
 8002e3a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002e3c:	4653      	mov	r3, sl
 8002e3e:	9200      	str	r2, [sp, #0]
 8002e40:	4659      	mov	r1, fp
 8002e42:	2201      	movs	r2, #1
 8002e44:	9809      	ldr	r0, [sp, #36]	; 0x24
 8002e46:	f009 f855 	bl	800bef4 <stereo_itheta>
 8002e4a:	4606      	mov	r6, r0
   tell = ec_tell_frac(ec);
 8002e4c:	4640      	mov	r0, r8
 8002e4e:	f005 fa37 	bl	80082c0 <ec_tell_frac>
         if (!stereo || ctx->theta_round == 0)
 8002e52:	6b22      	ldr	r2, [r4, #48]	; 0x30
   tell = ec_tell_frac(ec);
 8002e54:	900b      	str	r0, [sp, #44]	; 0x2c
 8002e56:	fb05 f306 	mul.w	r3, r5, r6
         if (!stereo || ctx->theta_round == 0)
 8002e5a:	2a00      	cmp	r2, #0
 8002e5c:	f040 8147 	bne.w	80030ee <quant_band_stereo+0x9ae>
            itheta = (itheta*(opus_int32)qn+8192)>>14;
 8002e60:	f503 5600 	add.w	r6, r3, #8192	; 0x2000
 8002e64:	13b6      	asrs	r6, r6, #14
      if (stereo && N>2)
 8002e66:	f1ba 0f02 	cmp.w	sl, #2
 8002e6a:	f340 8139 	ble.w	80030e0 <quant_band_stereo+0x9a0>
         int x0 = qn/2;
 8002e6e:	107f      	asrs	r7, r7, #1
         int ft = p0*(x0+1) + x0;
 8002e70:	1c7a      	adds	r2, r7, #1
 8002e72:	eb02 0242 	add.w	r2, r2, r2, lsl #1
            ec_encode(ec,x<=x0?p0*x:(x-1-x0)+(x0+1)*p0,x<=x0?p0*(x+1):(x-x0)+(x0+1)*p0,ft);
 8002e76:	42b7      	cmp	r7, r6
         int ft = p0*(x0+1) + x0;
 8002e78:	eb07 0302 	add.w	r3, r7, r2
            ec_encode(ec,x<=x0?p0*x:(x-1-x0)+(x0+1)*p0,x<=x0?p0*(x+1):(x-x0)+(x0+1)*p0,ft);
 8002e7c:	f2c0 817f 	blt.w	800317e <quant_band_stereo+0xa3e>
 8002e80:	eb06 0146 	add.w	r1, r6, r6, lsl #1
 8002e84:	1cca      	adds	r2, r1, #3
 8002e86:	4640      	mov	r0, r8
 8002e88:	f005 fd1c 	bl	80088c4 <ec_encode>
 8002e8c:	e4bd      	b.n	800280a <quant_band_stereo+0xca>
 8002e8e:	bf00      	nop
 8002e90:	0801649c 	.word	0x0801649c
 8002e94:	00027524 	.word	0x00027524
 8002e98:	ffffc000 	.word	0xffffc000
      itheta = stereo_itheta(X, Y, stereo, N, ctx->arch);
 8002e9c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002e9e:	4653      	mov	r3, sl
 8002ea0:	9200      	str	r2, [sp, #0]
 8002ea2:	4659      	mov	r1, fp
 8002ea4:	2201      	movs	r2, #1
 8002ea6:	9809      	ldr	r0, [sp, #36]	; 0x24
 8002ea8:	f009 f824 	bl	800bef4 <stereo_itheta>
 8002eac:	4605      	mov	r5, r0
   tell = ec_tell_frac(ec);
 8002eae:	4640      	mov	r0, r8
 8002eb0:	f005 fa06 	bl	80082c0 <ec_tell_frac>
         inv = itheta > 8192 && !ctx->disable_inv;
 8002eb4:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
   tell = ec_tell_frac(ec);
 8002eb8:	4607      	mov	r7, r0
         inv = itheta > 8192 && !ctx->disable_inv;
 8002eba:	f340 81a9 	ble.w	8003210 <quant_band_stereo+0xad0>
 8002ebe:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002ec0:	930b      	str	r3, [sp, #44]	; 0x2c
 8002ec2:	2b00      	cmp	r3, #0
 8002ec4:	f040 81a4 	bne.w	8003210 <quant_band_stereo+0xad0>
            for (j=0;j<N;j++)
 8002ec8:	f1ba 0f00 	cmp.w	sl, #0
 8002ecc:	f340 808f 	ble.w	8002fee <quant_band_stereo+0x8ae>
 8002ed0:	ea4f 015b 	mov.w	r1, fp, lsr #1
 8002ed4:	4249      	negs	r1, r1
 8002ed6:	f001 0103 	and.w	r1, r1, #3
 8002eda:	1cca      	adds	r2, r1, #3
 8002edc:	f10a 33ff 	add.w	r3, sl, #4294967295
 8002ee0:	429a      	cmp	r2, r3
 8002ee2:	f200 8226 	bhi.w	8003332 <quant_band_stereo+0xbf2>
 8002ee6:	b1b9      	cbz	r1, 8002f18 <quant_band_stereo+0x7d8>
               Y[j] = -Y[j];
 8002ee8:	f8bb 3000 	ldrh.w	r3, [fp]
 8002eec:	2901      	cmp	r1, #1
 8002eee:	f1c3 0300 	rsb	r3, r3, #0
 8002ef2:	f8ab 3000 	strh.w	r3, [fp]
 8002ef6:	f000 8217 	beq.w	8003328 <quant_band_stereo+0xbe8>
 8002efa:	f8bb 3002 	ldrh.w	r3, [fp, #2]
 8002efe:	2903      	cmp	r1, #3
 8002f00:	f1c3 0300 	rsb	r3, r3, #0
 8002f04:	f8ab 3002 	strh.w	r3, [fp, #2]
 8002f08:	f040 8210 	bne.w	800332c <quant_band_stereo+0xbec>
 8002f0c:	f8bb 3004 	ldrh.w	r3, [fp, #4]
            for (j=0;j<N;j++)
 8002f10:	910b      	str	r1, [sp, #44]	; 0x2c
               Y[j] = -Y[j];
 8002f12:	425b      	negs	r3, r3
 8002f14:	f8ab 3004 	strh.w	r3, [fp, #4]
 8002f18:	ebaa 0301 	sub.w	r3, sl, r1
 8002f1c:	930c      	str	r3, [sp, #48]	; 0x30
 8002f1e:	089b      	lsrs	r3, r3, #2
 8002f20:	e9cd 840e 	strd	r8, r4, [sp, #56]	; 0x38
            for (j=0;j<N;j++)
 8002f24:	f04f 0c00 	mov.w	ip, #0
 8002f28:	461c      	mov	r4, r3
 8002f2a:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
 8002f2e:	f1a1 0608 	sub.w	r6, r1, #8
               Y[j] = -Y[j];
 8002f32:	2000      	movs	r0, #0
 8002f34:	4605      	mov	r5, r0
 8002f36:	f856 3f08 	ldr.w	r3, [r6, #8]!
 8002f3a:	f10c 0c01 	add.w	ip, ip, #1
 8002f3e:	6872      	ldr	r2, [r6, #4]
 8002f40:	f1c3 0e00 	rsb	lr, r3, #0
 8002f44:	f1c2 0800 	rsb	r8, r2, #0
 8002f48:	f3c3 430f 	ubfx	r3, r3, #16, #16
 8002f4c:	f3c2 420f 	ubfx	r2, r2, #16, #16
 8002f50:	4252      	negs	r2, r2
 8002f52:	f368 050f 	bfi	r5, r8, #0, #16
 8002f56:	f36e 000f 	bfi	r0, lr, #0, #16
 8002f5a:	425b      	negs	r3, r3
 8002f5c:	f362 451f 	bfi	r5, r2, #16, #16
 8002f60:	f363 401f 	bfi	r0, r3, #16, #16
 8002f64:	45a4      	cmp	ip, r4
 8002f66:	e9c1 0500 	strd	r0, r5, [r1]
 8002f6a:	f101 0108 	add.w	r1, r1, #8
 8002f6e:	d3e0      	bcc.n	8002f32 <quant_band_stereo+0x7f2>
 8002f70:	e9dd 840e 	ldrd	r8, r4, [sp, #56]	; 0x38
 8002f74:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8002f76:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8002f78:	f022 0303 	bic.w	r3, r2, #3
 8002f7c:	4293      	cmp	r3, r2
 8002f7e:	4419      	add	r1, r3
 8002f80:	d035      	beq.n	8002fee <quant_band_stereo+0x8ae>
 8002f82:	f83b 2011 	ldrh.w	r2, [fp, r1, lsl #1]
            for (j=0;j<N;j++)
 8002f86:	1c4b      	adds	r3, r1, #1
               Y[j] = -Y[j];
 8002f88:	4252      	negs	r2, r2
            for (j=0;j<N;j++)
 8002f8a:	459a      	cmp	sl, r3
               Y[j] = -Y[j];
 8002f8c:	f82b 2011 	strh.w	r2, [fp, r1, lsl #1]
 8002f90:	ea4f 0541 	mov.w	r5, r1, lsl #1
            for (j=0;j<N;j++)
 8002f94:	dd2b      	ble.n	8002fee <quant_band_stereo+0x8ae>
               Y[j] = -Y[j];
 8002f96:	1ca8      	adds	r0, r5, #2
 8002f98:	f83b 1000 	ldrh.w	r1, [fp, r0]
            for (j=0;j<N;j++)
 8002f9c:	1c5a      	adds	r2, r3, #1
               Y[j] = -Y[j];
 8002f9e:	4249      	negs	r1, r1
            for (j=0;j<N;j++)
 8002fa0:	4592      	cmp	sl, r2
               Y[j] = -Y[j];
 8002fa2:	f82b 1000 	strh.w	r1, [fp, r0]
            for (j=0;j<N;j++)
 8002fa6:	dd22      	ble.n	8002fee <quant_band_stereo+0x8ae>
               Y[j] = -Y[j];
 8002fa8:	1d28      	adds	r0, r5, #4
 8002faa:	f83b 1000 	ldrh.w	r1, [fp, r0]
            for (j=0;j<N;j++)
 8002fae:	1c9a      	adds	r2, r3, #2
               Y[j] = -Y[j];
 8002fb0:	4249      	negs	r1, r1
            for (j=0;j<N;j++)
 8002fb2:	4592      	cmp	sl, r2
               Y[j] = -Y[j];
 8002fb4:	f82b 1000 	strh.w	r1, [fp, r0]
            for (j=0;j<N;j++)
 8002fb8:	dd19      	ble.n	8002fee <quant_band_stereo+0x8ae>
               Y[j] = -Y[j];
 8002fba:	1da8      	adds	r0, r5, #6
 8002fbc:	f83b 1000 	ldrh.w	r1, [fp, r0]
            for (j=0;j<N;j++)
 8002fc0:	1cda      	adds	r2, r3, #3
               Y[j] = -Y[j];
 8002fc2:	4249      	negs	r1, r1
            for (j=0;j<N;j++)
 8002fc4:	4592      	cmp	sl, r2
               Y[j] = -Y[j];
 8002fc6:	f82b 1000 	strh.w	r1, [fp, r0]
            for (j=0;j<N;j++)
 8002fca:	dd10      	ble.n	8002fee <quant_band_stereo+0x8ae>
               Y[j] = -Y[j];
 8002fcc:	f105 0108 	add.w	r1, r5, #8
 8002fd0:	f83b 2001 	ldrh.w	r2, [fp, r1]
            for (j=0;j<N;j++)
 8002fd4:	3304      	adds	r3, #4
               Y[j] = -Y[j];
 8002fd6:	4252      	negs	r2, r2
            for (j=0;j<N;j++)
 8002fd8:	459a      	cmp	sl, r3
               Y[j] = -Y[j];
 8002fda:	f82b 2001 	strh.w	r2, [fp, r1]
            for (j=0;j<N;j++)
 8002fde:	dd06      	ble.n	8002fee <quant_band_stereo+0x8ae>
               Y[j] = -Y[j];
 8002fe0:	f105 020a 	add.w	r2, r5, #10
 8002fe4:	f83b 3002 	ldrh.w	r3, [fp, r2]
 8002fe8:	425b      	negs	r3, r3
 8002fea:	f82b 3002 	strh.w	r3, [fp, r2]
         inv = itheta > 8192 && !ctx->disable_inv;
 8002fee:	2501      	movs	r5, #1
 8002ff0:	e10f      	b.n	8003212 <quant_band_stereo+0xad2>
   if (d>256)
 8002ff2:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
      return -(opus_int32)celt_udiv(-n, d);
 8002ff6:	f1c0 0600 	rsb	r6, r0, #0
   if (d>256)
 8002ffa:	f240 817d 	bls.w	80032f8 <quant_band_stereo+0xbb8>
      return n/d;
 8002ffe:	fbb6 f5f1 	udiv	r5, r6, r1
 8003002:	e5bf      	b.n	8002b84 <quant_band_stereo+0x444>
   qalloc = ec_tell_frac(ec) - tell;
 8003004:	f005 f95c 	bl	80082c0 <ec_tell_frac>
   *b -= qalloc;
 8003008:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   qalloc = ec_tell_frac(ec) - tell;
 800300a:	1bc0      	subs	r0, r0, r7
   *b -= qalloc;
 800300c:	1a1b      	subs	r3, r3, r0
 800300e:	930a      	str	r3, [sp, #40]	; 0x28
         inv = 0;
 8003010:	2300      	movs	r3, #0
   if (N==2)
 8003012:	f1ba 0f02 	cmp.w	sl, #2
         inv = 0;
 8003016:	9308      	str	r3, [sp, #32]
 8003018:	6a22      	ldr	r2, [r4, #32]
   if (N==2)
 800301a:	f47f ad38 	bne.w	8002a8e <quant_band_stereo+0x34e>
      iside = 0;
 800301e:	2700      	movs	r7, #0
      imid = 32767;
 8003020:	f647 76ff 	movw	r6, #32767	; 0x7fff
      ctx->remaining_bits -= qalloc+sbits;
 8003024:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8003028:	2501      	movs	r5, #1
 800302a:	1a10      	subs	r0, r2, r0
 800302c:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 8003030:	6220      	str	r0, [r4, #32]
 8003032:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 8003036:	930c      	str	r3, [sp, #48]	; 0x30
      cm = quant_band(ctx, x2, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
 8003038:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800303c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800303e:	9204      	str	r2, [sp, #16]
 8003040:	9306      	str	r3, [sp, #24]
 8003042:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8003044:	2202      	movs	r2, #2
 8003046:	9305      	str	r3, [sp, #20]
 8003048:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800304a:	4649      	mov	r1, r9
 800304c:	9303      	str	r3, [sp, #12]
 800304e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8003050:	4620      	mov	r0, r4
 8003052:	9302      	str	r3, [sp, #8]
 8003054:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8003056:	9301      	str	r3, [sp, #4]
 8003058:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800305a:	9300      	str	r3, [sp, #0]
 800305c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800305e:	f7fe fee3 	bl	8001e28 <quant_band>
      y2[0] = -sign*x2[1];
 8003062:	f8b9 3002 	ldrh.w	r3, [r9, #2]
 8003066:	990c      	ldr	r1, [sp, #48]	; 0x30
      if (ctx->resynth)
 8003068:	6862      	ldr	r2, [r4, #4]
      y2[0] = -sign*x2[1];
 800306a:	fb13 f301 	smulbb	r3, r3, r1
 800306e:	990b      	ldr	r1, [sp, #44]	; 0x2c
      cm = quant_band(ctx, x2, N, mbits, B, lowband, LM, lowband_out, Q15ONE,
 8003070:	4680      	mov	r8, r0
      y2[0] = -sign*x2[1];
 8003072:	800b      	strh	r3, [r1, #0]
      y2[1] = sign*x2[0];
 8003074:	f8b9 3000 	ldrh.w	r3, [r9]
 8003078:	fb13 f505 	smulbb	r5, r3, r5
 800307c:	804d      	strh	r5, [r1, #2]
      if (ctx->resynth)
 800307e:	2a00      	cmp	r2, #0
 8003080:	f43f acc5 	beq.w	8002a0e <quant_band_stereo+0x2ce>
         X[0] = MULT16_16_Q15(mid, X[0]);
 8003084:	9809      	ldr	r0, [sp, #36]	; 0x24
         X[1] = MULT16_16_Q15(mid, X[1]);
 8003086:	f9b0 3002 	ldrsh.w	r3, [r0, #2]
         X[0] = MULT16_16_Q15(mid, X[0]);
 800308a:	f9b0 2000 	ldrsh.w	r2, [r0]
 800308e:	fb06 f202 	mul.w	r2, r6, r2
         X[1] = MULT16_16_Q15(mid, X[1]);
 8003092:	fb06 f603 	mul.w	r6, r6, r3
         X[0] = MULT16_16_Q15(mid, X[0]);
 8003096:	13d3      	asrs	r3, r2, #15
         X[1] = MULT16_16_Q15(mid, X[1]);
 8003098:	13f6      	asrs	r6, r6, #15
         X[0] = MULT16_16_Q15(mid, X[0]);
 800309a:	8003      	strh	r3, [r0, #0]
         X[1] = MULT16_16_Q15(mid, X[1]);
 800309c:	8046      	strh	r6, [r0, #2]
         Y[1] = MULT16_16_Q15(side, Y[1]);
 800309e:	f9bb 2002 	ldrsh.w	r2, [fp, #2]
         Y[0] = MULT16_16_Q15(side, Y[0]);
 80030a2:	f9bb 3000 	ldrsh.w	r3, [fp]
 80030a6:	fb07 f303 	mul.w	r3, r7, r3
         Y[1] = MULT16_16_Q15(side, Y[1]);
 80030aa:	fb07 f702 	mul.w	r7, r7, r2
         Y[0] = MULT16_16_Q15(side, Y[0]);
 80030ae:	13db      	asrs	r3, r3, #15
         Y[1] = MULT16_16_Q15(side, Y[1]);
 80030b0:	13ff      	asrs	r7, r7, #15
         Y[0] = MULT16_16_Q15(side, Y[0]);
 80030b2:	f8ab 3000 	strh.w	r3, [fp]
         Y[1] = MULT16_16_Q15(side, Y[1]);
 80030b6:	f8ab 7002 	strh.w	r7, [fp, #2]
         X[0] = SUB16(tmp,Y[0]);
 80030ba:	8802      	ldrh	r2, [r0, #0]
 80030bc:	1ad3      	subs	r3, r2, r3
 80030be:	8003      	strh	r3, [r0, #0]
         Y[0] = ADD16(tmp,Y[0]);
 80030c0:	f8bb 3000 	ldrh.w	r3, [fp]
         X[1] = SUB16(tmp,Y[1]);
 80030c4:	f8bb 1002 	ldrh.w	r1, [fp, #2]
         Y[0] = ADD16(tmp,Y[0]);
 80030c8:	441a      	add	r2, r3
 80030ca:	f8ab 2000 	strh.w	r2, [fp]
         X[1] = SUB16(tmp,Y[1]);
 80030ce:	8843      	ldrh	r3, [r0, #2]
 80030d0:	1a5a      	subs	r2, r3, r1
 80030d2:	8042      	strh	r2, [r0, #2]
         Y[1] = ADD16(tmp,Y[1]);
 80030d4:	f8bb 2002 	ldrh.w	r2, [fp, #2]
 80030d8:	4413      	add	r3, r2
 80030da:	f8ab 3002 	strh.w	r3, [fp, #2]
 80030de:	e5ca      	b.n	8002c76 <quant_band_stereo+0x536>
            ec_enc_uint(ec, itheta, qn+1);
 80030e0:	1c6a      	adds	r2, r5, #1
 80030e2:	4631      	mov	r1, r6
 80030e4:	4640      	mov	r0, r8
 80030e6:	f005 fce7 	bl	8008ab8 <ec_enc_uint>
 80030ea:	f7ff bb8e 	b.w	800280a <quant_band_stereo+0xca>
            int bias = itheta > 8192 ? 32767/qn : -32767/qn;
 80030ee:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
 80030f2:	bfcc      	ite	gt
 80030f4:	f647 76ff 	movwgt	r6, #32767	; 0x7fff
 80030f8:	4e94      	ldrle	r6, [pc, #592]	; (800334c <quant_band_stereo+0xc0c>)
 80030fa:	fb96 f6f5 	sdiv	r6, r6, r5
            down = IMIN(qn-1, IMAX(0, (itheta*(opus_int32)qn + bias)>>14));
 80030fe:	441e      	add	r6, r3
 8003100:	13b6      	asrs	r6, r6, #14
 8003102:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
 8003106:	42ae      	cmp	r6, r5
 8003108:	bfa8      	it	ge
 800310a:	f105 36ff 	addge.w	r6, r5, #4294967295
            if (ctx->theta_round < 0)
 800310e:	2a00      	cmp	r2, #0
               itheta = down+1;
 8003110:	bfa8      	it	ge
 8003112:	3601      	addge	r6, #1
 8003114:	e6a7      	b.n	8002e66 <quant_band_stereo+0x726>
      if (itheta != 0 && itheta != 16384)
 8003116:	2d00      	cmp	r5, #0
 8003118:	f000 8104 	beq.w	8003324 <quant_band_stereo+0xbe4>
      mbits -= sbits;
 800311c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      ctx->remaining_bits -= qalloc+sbits;
 800311e:	3008      	adds	r0, #8
 8003120:	1a10      	subs	r0, r2, r0
      mbits -= sbits;
 8003122:	3b08      	subs	r3, #8
      x2 = c ? Y : X;
 8003124:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
      ctx->remaining_bits -= qalloc+sbits;
 8003128:	6220      	str	r0, [r4, #32]
      mbits -= sbits;
 800312a:	930a      	str	r3, [sp, #40]	; 0x28
      x2 = c ? Y : X;
 800312c:	f340 8109 	ble.w	8003342 <quant_band_stereo+0xc02>
 8003130:	46d9      	mov	r9, fp
 8003132:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003134:	930b      	str	r3, [sp, #44]	; 0x2c
         if (encode)
 8003136:	9b08      	ldr	r3, [sp, #32]
 8003138:	2b00      	cmp	r3, #0
 800313a:	d057      	beq.n	80031ec <quant_band_stereo+0xaac>
            sign = x2[0]*y2[1] - x2[1]*y2[0] < 0;
 800313c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800313e:	f8b9 5000 	ldrh.w	r5, [r9]
 8003142:	8851      	ldrh	r1, [r2, #2]
 8003144:	f8b9 3002 	ldrh.w	r3, [r9, #2]
 8003148:	8812      	ldrh	r2, [r2, #0]
 800314a:	fb15 f501 	smulbb	r5, r5, r1
 800314e:	fb13 f302 	smulbb	r3, r3, r2
 8003152:	1aed      	subs	r5, r5, r3
 8003154:	0fed      	lsrs	r5, r5, #31
            ec_enc_bits(ec, sign, 1);
 8003156:	4629      	mov	r1, r5
 8003158:	006d      	lsls	r5, r5, #1
 800315a:	f1c5 0501 	rsb	r5, r5, #1
 800315e:	4640      	mov	r0, r8
 8003160:	2201      	movs	r2, #1
 8003162:	f005 fcf9 	bl	8008b58 <ec_enc_bits>
 8003166:	426b      	negs	r3, r5
 8003168:	b29b      	uxth	r3, r3
 800316a:	930c      	str	r3, [sp, #48]	; 0x30
 800316c:	2300      	movs	r3, #0
 800316e:	b2ad      	uxth	r5, r5
 8003170:	9308      	str	r3, [sp, #32]
 8003172:	e761      	b.n	8003038 <quant_band_stereo+0x8f8>
      return quant_band_n1(ctx, X, Y, b, lowband_out);
 8003174:	f04f 0801 	mov.w	r8, #1
 8003178:	e449      	b.n	8002a0e <quant_band_stereo+0x2ce>
         for (j=0;j<N;j++)
 800317a:	468e      	mov	lr, r1
 800317c:	e5b2      	b.n	8002ce4 <quant_band_stereo+0x5a4>
            ec_encode(ec,x<=x0?p0*x:(x-1-x0)+(x0+1)*p0,x<=x0?p0*(x+1):(x-x0)+(x0+1)*p0,ft);
 800317e:	1e71      	subs	r1, r6, #1
 8003180:	1bc9      	subs	r1, r1, r7
 8003182:	1bf7      	subs	r7, r6, r7
 8003184:	4411      	add	r1, r2
 8003186:	443a      	add	r2, r7
 8003188:	e67d      	b.n	8002e86 <quant_band_stereo+0x746>
            intensity_stereo(m, X, Y, bandE, i, N);
 800318a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800318c:	f8d9 0008 	ldr.w	r0, [r9, #8]
 8003190:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003192:	9200      	str	r2, [sp, #0]
 8003194:	9909      	ldr	r1, [sp, #36]	; 0x24
 8003196:	465a      	mov	r2, fp
 8003198:	f8cd a004 	str.w	sl, [sp, #4]
 800319c:	f7fe f96a 	bl	8001474 <intensity_stereo.isra.2>
   qalloc = ec_tell_frac(ec) - tell;
 80031a0:	4640      	mov	r0, r8
 80031a2:	f005 f88d 	bl	80082c0 <ec_tell_frac>
 80031a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   int inv=0;
 80031a8:	9508      	str	r5, [sp, #32]
   qalloc = ec_tell_frac(ec) - tell;
 80031aa:	1ac0      	subs	r0, r0, r3
   *b -= qalloc;
 80031ac:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 80031ae:	1a1b      	subs	r3, r3, r0
 80031b0:	930a      	str	r3, [sp, #40]	; 0x28
 80031b2:	e467      	b.n	8002a84 <quant_band_stereo+0x344>
         int x0 = qn/2;
 80031b4:	107f      	asrs	r7, r7, #1
         int ft = p0*(x0+1) + x0;
 80031b6:	1c7e      	adds	r6, r7, #1
 80031b8:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 80031bc:	18bb      	adds	r3, r7, r2
            fs=ec_decode(ec,ft);
 80031be:	4619      	mov	r1, r3
 80031c0:	4640      	mov	r0, r8
         int ft = p0*(x0+1) + x0;
 80031c2:	920e      	str	r2, [sp, #56]	; 0x38
            fs=ec_decode(ec,ft);
 80031c4:	930c      	str	r3, [sp, #48]	; 0x30
 80031c6:	f005 f8fd 	bl	80083c4 <ec_decode>
            if (fs<(x0+1)*p0)
 80031ca:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80031cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80031ce:	4282      	cmp	r2, r0
 80031d0:	dc18      	bgt.n	8003204 <quant_band_stereo+0xac4>
               x=x0+1+(fs-(x0+1)*p0);
 80031d2:	1a81      	subs	r1, r0, r2
 80031d4:	440e      	add	r6, r1
            ec_dec_update(ec,x<=x0?p0*x:(x-1-x0)+(x0+1)*p0,x<=x0?p0*(x+1):(x-x0)+(x0+1)*p0,ft);
 80031d6:	42b7      	cmp	r7, r6
 80031d8:	f2c0 8098 	blt.w	800330c <quant_band_stereo+0xbcc>
 80031dc:	eb06 0146 	add.w	r1, r6, r6, lsl #1
 80031e0:	1cca      	adds	r2, r1, #3
 80031e2:	4640      	mov	r0, r8
 80031e4:	f005 f930 	bl	8008448 <ec_dec_update>
 80031e8:	f7ff bb0f 	b.w	800280a <quant_band_stereo+0xca>
            sign = ec_dec_bits(ec, 1);
 80031ec:	4640      	mov	r0, r8
 80031ee:	2101      	movs	r1, #1
 80031f0:	f005 fb44 	bl	800887c <ec_dec_bits>
 80031f4:	0045      	lsls	r5, r0, #1
 80031f6:	f1c5 0501 	rsb	r5, r5, #1
 80031fa:	426b      	negs	r3, r5
 80031fc:	b29b      	uxth	r3, r3
 80031fe:	930c      	str	r3, [sp, #48]	; 0x30
 8003200:	b2ad      	uxth	r5, r5
 8003202:	e719      	b.n	8003038 <quant_band_stereo+0x8f8>
               x=fs/p0;
 8003204:	4e52      	ldr	r6, [pc, #328]	; (8003350 <quant_band_stereo+0xc10>)
 8003206:	fb86 1600 	smull	r1, r6, r6, r0
 800320a:	eba6 76e0 	sub.w	r6, r6, r0, asr #31
 800320e:	e7e2      	b.n	80031d6 <quant_band_stereo+0xa96>
         inv = itheta > 8192 && !ctx->disable_inv;
 8003210:	2500      	movs	r5, #0
         intensity_stereo(m, X, Y, bandE, i, N);
 8003212:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8003214:	f8d9 0008 	ldr.w	r0, [r9, #8]
 8003218:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800321a:	9200      	str	r2, [sp, #0]
 800321c:	f8cd a004 	str.w	sl, [sp, #4]
 8003220:	465a      	mov	r2, fp
 8003222:	9909      	ldr	r1, [sp, #36]	; 0x24
 8003224:	f7fe f926 	bl	8001474 <intensity_stereo.isra.2>
 8003228:	e41c      	b.n	8002a64 <quant_band_stereo+0x324>
            inv = ec_dec_bit_logp(ec, 2);
 800322a:	2102      	movs	r1, #2
 800322c:	4640      	mov	r0, r8
 800322e:	f005 f95b 	bl	80084e8 <ec_dec_bit_logp>
 8003232:	9008      	str	r0, [sp, #32]
 8003234:	e41b      	b.n	8002a6e <quant_band_stereo+0x32e>
   return EC_ILOG(x)-1;
 8003236:	fab3 fc83 	clz	ip, r3
   kl = celt_ilog2(El)>>1;
 800323a:	f1cc 0c1f 	rsb	ip, ip, #31
 800323e:	ea4f 056c 	mov.w	r5, ip, asr #1
   t = VSHR32(El, (kl-7)<<1);
 8003242:	1fe8      	subs	r0, r5, #7
 8003244:	fab4 f784 	clz	r7, r4
 8003248:	0040      	lsls	r0, r0, #1
   lgain = celt_rsqrt_norm(t);
 800324a:	fa43 f000 	asr.w	r0, r3, r0
 800324e:	f006 fb03 	bl	8009858 <celt_rsqrt_norm>
   kr = celt_ilog2(Er)>>1;
 8003252:	f1c7 071f 	rsb	r7, r7, #31
 8003256:	107f      	asrs	r7, r7, #1
   lgain = celt_rsqrt_norm(t);
 8003258:	4681      	mov	r9, r0
   t = VSHR32(Er, (kr-7)<<1);
 800325a:	1ff8      	subs	r0, r7, #7
 800325c:	0040      	lsls	r0, r0, #1
   rgain = celt_rsqrt_norm(t);
 800325e:	fa44 f000 	asr.w	r0, r4, r0
 8003262:	f006 faf9 	bl	8009858 <celt_rsqrt_norm>
   for (j=0;j<N;j++)
 8003266:	f1ba 0f00 	cmp.w	sl, #0
 800326a:	f77f abd0 	ble.w	8002a0e <quant_band_stereo+0x2ce>
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
 800326e:	f04f 0e01 	mov.w	lr, #1
 8003272:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003274:	eb05 0c0e 	add.w	ip, r5, lr
 8003278:	1e9c      	subs	r4, r3, #2
 800327a:	fa0e f30c 	lsl.w	r3, lr, ip
 800327e:	105b      	asrs	r3, r3, #1
 8003280:	eb04 024a 	add.w	r2, r4, sl, lsl #1
 8003284:	f1ab 0502 	sub.w	r5, fp, #2
 8003288:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 800328c:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 8003290:	4690      	mov	r8, r2
 8003292:	469b      	mov	fp, r3
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
 8003294:	4477      	add	r7, lr
 8003296:	fa0e fe07 	lsl.w	lr, lr, r7
 800329a:	ea4f 0e6e 	mov.w	lr, lr, asr #1
      l = MULT16_16_P15(mid, X[j]);
 800329e:	f934 3f02 	ldrsh.w	r3, [r4, #2]!
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
 80032a2:	f835 1f02 	ldrh.w	r1, [r5, #2]!
      l = MULT16_16_P15(mid, X[j]);
 80032a6:	fb06 f303 	mul.w	r3, r6, r3
 80032aa:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
 80032ae:	f3c3 33cf 	ubfx	r3, r3, #15, #16
 80032b2:	1a5a      	subs	r2, r3, r1
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
 80032b4:	440b      	add	r3, r1
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
 80032b6:	fb19 b202 	smlabb	r2, r9, r2, fp
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
 80032ba:	fb10 e303 	smlabb	r3, r0, r3, lr
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
 80032be:	fa42 f20c 	asr.w	r2, r2, ip
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
 80032c2:	413b      	asrs	r3, r7
   for (j=0;j<N;j++)
 80032c4:	45a0      	cmp	r8, r4
      X[j] = EXTRACT16(PSHR32(MULT16_16(lgain, SUB16(l,r)), kl+1));
 80032c6:	8022      	strh	r2, [r4, #0]
      Y[j] = EXTRACT16(PSHR32(MULT16_16(rgain, ADD16(l,r)), kr+1));
 80032c8:	802b      	strh	r3, [r5, #0]
   for (j=0;j<N;j++)
 80032ca:	d1e8      	bne.n	800329e <quant_band_stereo+0xb5e>
 80032cc:	e9dd 8b09 	ldrd	r8, fp, [sp, #36]	; 0x24
      if (inv)
 80032d0:	9b08      	ldr	r3, [sp, #32]
 80032d2:	2b00      	cmp	r3, #0
 80032d4:	f47f acd7 	bne.w	8002c86 <quant_band_stereo+0x546>
 80032d8:	f7ff bb99 	b.w	8002a0e <quant_band_stereo+0x2ce>
      ctx->remaining_bits -= qalloc+sbits;
 80032dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80032de:	2600      	movs	r6, #0
 80032e0:	930b      	str	r3, [sp, #44]	; 0x2c
 80032e2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80032e6:	1a12      	subs	r2, r2, r0
 80032e8:	9608      	str	r6, [sp, #32]
 80032ea:	6222      	str	r2, [r4, #32]
 80032ec:	460d      	mov	r5, r1
 80032ee:	46d9      	mov	r9, fp
 80032f0:	930c      	str	r3, [sp, #48]	; 0x30
 80032f2:	f647 77ff 	movw	r7, #32767	; 0x7fff
 80032f6:	e69f      	b.n	8003038 <quant_band_stereo+0x8f8>
 80032f8:	4248      	negs	r0, r1
 80032fa:	4008      	ands	r0, r1
 80032fc:	fab0 f080 	clz	r0, r0
 8003300:	f1c0 0020 	rsb	r0, r0, #32
 8003304:	fa21 f700 	lsr.w	r7, r1, r0
 8003308:	3801      	subs	r0, #1
 800330a:	e42e      	b.n	8002b6a <quant_band_stereo+0x42a>
            ec_dec_update(ec,x<=x0?p0*x:(x-1-x0)+(x0+1)*p0,x<=x0?p0*(x+1):(x-x0)+(x0+1)*p0,ft);
 800330c:	1e71      	subs	r1, r6, #1
 800330e:	1bc9      	subs	r1, r1, r7
 8003310:	1bf7      	subs	r7, r6, r7
 8003312:	4411      	add	r1, r2
 8003314:	443a      	add	r2, r7
 8003316:	e764      	b.n	80031e2 <quant_band_stereo+0xaa2>
         for (j=0;j<N;j++)
 8003318:	f04f 0e02 	mov.w	lr, #2
 800331c:	e4e2      	b.n	8002ce4 <quant_band_stereo+0x5a4>
 800331e:	f04f 0e00 	mov.w	lr, #0
 8003322:	e50c      	b.n	8002d3e <quant_band_stereo+0x5fe>
 8003324:	9508      	str	r5, [sp, #32]
 8003326:	e67d      	b.n	8003024 <quant_band_stereo+0x8e4>
            for (j=0;j<N;j++)
 8003328:	910b      	str	r1, [sp, #44]	; 0x2c
 800332a:	e5f5      	b.n	8002f18 <quant_band_stereo+0x7d8>
 800332c:	2302      	movs	r3, #2
 800332e:	930b      	str	r3, [sp, #44]	; 0x2c
 8003330:	e5f2      	b.n	8002f18 <quant_band_stereo+0x7d8>
               Y[j] = -Y[j];
 8003332:	f8bb 3000 	ldrh.w	r3, [fp]
 8003336:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8003338:	425b      	negs	r3, r3
 800333a:	f8ab 3000 	strh.w	r3, [fp]
            for (j=0;j<N;j++)
 800333e:	2301      	movs	r3, #1
 8003340:	e629      	b.n	8002f96 <quant_band_stereo+0x856>
      x2 = c ? Y : X;
 8003342:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 8003346:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 800334a:	e6f4      	b.n	8003136 <quant_band_stereo+0x9f6>
 800334c:	ffff8001 	.word	0xffff8001
 8003350:	55555556 	.word	0x55555556

08003354 <celt_lcg_rand>:
   return 1664525 * seed + 1013904223;
 8003354:	4a02      	ldr	r2, [pc, #8]	; (8003360 <celt_lcg_rand+0xc>)
 8003356:	4b03      	ldr	r3, [pc, #12]	; (8003364 <celt_lcg_rand+0x10>)
}
 8003358:	fb02 3000 	mla	r0, r2, r0, r3
 800335c:	4770      	bx	lr
 800335e:	bf00      	nop
 8003360:	0019660d 	.word	0x0019660d
 8003364:	3c6ef35f 	.word	0x3c6ef35f

08003368 <denormalise_bands>:
{
 8003368:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800336c:	b083      	sub	sp, #12
 800336e:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
   const opus_int16 *eBands = m->eBands;
 8003372:	6986      	ldr	r6, [r0, #24]
   N = M*m->shortMdctSize;
 8003374:	f8d0 a024 	ldr.w	sl, [r0, #36]	; 0x24
   bound = M*eBands[end];
 8003378:	f936 0018 	ldrsh.w	r0, [r6, r8, lsl #1]
{
 800337c:	e9dd 750e 	ldrd	r7, r5, [sp, #56]	; 0x38
   if (downsample!=1)
 8003380:	2d01      	cmp	r5, #1
{
 8003382:	4614      	mov	r4, r2
   N = M*m->shortMdctSize;
 8003384:	fb0a fa07 	mul.w	sl, sl, r7
   bound = M*eBands[end];
 8003388:	fb07 f200 	mul.w	r2, r7, r0
{
 800338c:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8003390:	9810      	ldr	r0, [sp, #64]	; 0x40
   if (downsample!=1)
 8003392:	d004      	beq.n	800339e <denormalise_bands+0x36>
      bound = IMIN(bound, N/downsample);
 8003394:	fb9a f5f5 	sdiv	r5, sl, r5
 8003398:	42aa      	cmp	r2, r5
 800339a:	bfa8      	it	ge
 800339c:	462a      	movge	r2, r5
   if (silence)
 800339e:	2800      	cmp	r0, #0
 80033a0:	f040 8087 	bne.w	80034b2 <denormalise_bands+0x14a>
 80033a4:	ebaa 0a02 	sub.w	sl, sl, r2
 80033a8:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80033ac:	9200      	str	r2, [sp, #0]
 80033ae:	eb06 024b 	add.w	r2, r6, fp, lsl #1
   x = X+M*eBands[start];
 80033b2:	f9b2 9000 	ldrsh.w	r9, [r2]
 80033b6:	fb07 f909 	mul.w	r9, r7, r9
   for (i=0;i<M*eBands[start];i++)
 80033ba:	f1b9 0f00 	cmp.w	r9, #0
   x = X+M*eBands[start];
 80033be:	eb01 0549 	add.w	r5, r1, r9, lsl #1
   for (i=0;i<M*eBands[start];i++)
 80033c2:	dd09      	ble.n	80033d8 <denormalise_bands+0x70>
      *f++ = 0;
 80033c4:	ea4f 0989 	mov.w	r9, r9, lsl #2
 80033c8:	4620      	mov	r0, r4
 80033ca:	464a      	mov	r2, r9
 80033cc:	2100      	movs	r1, #0
 80033ce:	9301      	str	r3, [sp, #4]
 80033d0:	f010 feaa 	bl	8014128 <memset>
 80033d4:	9b01      	ldr	r3, [sp, #4]
 80033d6:	444c      	add	r4, r9
   for (i=start;i<end;i++)
 80033d8:	45c3      	cmp	fp, r8
 80033da:	da4c      	bge.n	8003476 <denormalise_bands+0x10e>
 80033dc:	ea4f 014b 	mov.w	r1, fp, lsl #1
 80033e0:	4a3c      	ldr	r2, [pc, #240]	; (80034d4 <denormalise_bands+0x16c>)
 80033e2:	eb06 0848 	add.w	r8, r6, r8, lsl #1
 80033e6:	440e      	add	r6, r1
 80033e8:	3902      	subs	r1, #2
 80033ea:	440b      	add	r3, r1
 80033ec:	4493      	add	fp, r2
      lg = SATURATE16(ADD32(bandLogE[i], SHL32((opus_val32)eMeans[i],6)));
 80033ee:	f933 2f02 	ldrsh.w	r2, [r3, #2]!
 80033f2:	f91b 0f01 	ldrsb.w	r0, [fp, #1]!
      j=M*eBands[i];
 80033f6:	f9b6 1000 	ldrsh.w	r1, [r6]
      lg = SATURATE16(ADD32(bandLogE[i], SHL32((opus_val32)eMeans[i],6)));
 80033fa:	eb02 1280 	add.w	r2, r2, r0, lsl #6
      band_end = M*eBands[i+1];
 80033fe:	f936 cf02 	ldrsh.w	ip, [r6, #2]!
      lg = SATURATE16(ADD32(bandLogE[i], SHL32((opus_val32)eMeans[i],6)));
 8003402:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
      j=M*eBands[i];
 8003406:	fb07 f101 	mul.w	r1, r7, r1
      band_end = M*eBands[i+1];
 800340a:	fb07 fc0c 	mul.w	ip, r7, ip
      lg = SATURATE16(ADD32(bandLogE[i], SHL32((opus_val32)eMeans[i],6)));
 800340e:	da3b      	bge.n	8003488 <denormalise_bands+0x120>
 8003410:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
 8003414:	db4a      	blt.n	80034ac <denormalise_bands+0x144>
 8003416:	b212      	sxth	r2, r2
      shift = 16-(lg>>DB_SHIFT);
 8003418:	ea4f 2ea2 	mov.w	lr, r2, asr #10
 800341c:	f1ce 0e10 	rsb	lr, lr, #16
      if (shift>31)
 8003420:	f1be 0f1f 	cmp.w	lr, #31
 8003424:	dc42      	bgt.n	80034ac <denormalise_bands+0x144>
 8003426:	f242 70dc 	movw	r0, #10204	; 0x27dc
 800342a:	f643 19e3 	movw	r9, #14819	; 0x39e3
 800342e:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8003432:	0112      	lsls	r2, r2, #4
 8003434:	fb00 f002 	mul.w	r0, r0, r2
 8003438:	eb09 30d0 	add.w	r0, r9, r0, lsr #15
 800343c:	f645 1914 	movw	r9, #22804	; 0x5914
 8003440:	fb02 f000 	mul.w	r0, r2, r0
 8003444:	eb09 30d0 	add.w	r0, r9, r0, lsr #15
 8003448:	fb02 f200 	mul.w	r2, r2, r0
 800344c:	f643 70ff 	movw	r0, #16383	; 0x3fff
      if (shift<0)
 8003450:	f1be 0f00 	cmp.w	lr, #0
 8003454:	eb00 30d2 	add.w	r0, r0, r2, lsr #15
 8003458:	b202      	sxth	r2, r0
 800345a:	db30      	blt.n	80034be <denormalise_bands+0x156>
            *f++ = SHR32(MULT16_16(*x++, g), shift);
 800345c:	f935 2b02 	ldrsh.w	r2, [r5], #2
         } while (++j<band_end);
 8003460:	3101      	adds	r1, #1
            *f++ = SHR32(MULT16_16(*x++, g), shift);
 8003462:	fb00 f202 	mul.w	r2, r0, r2
         } while (++j<band_end);
 8003466:	458c      	cmp	ip, r1
            *f++ = SHR32(MULT16_16(*x++, g), shift);
 8003468:	fa42 f20e 	asr.w	r2, r2, lr
 800346c:	f844 2b04 	str.w	r2, [r4], #4
         } while (++j<band_end);
 8003470:	dcf4      	bgt.n	800345c <denormalise_bands+0xf4>
   for (i=start;i<end;i++)
 8003472:	4546      	cmp	r6, r8
 8003474:	d1bb      	bne.n	80033ee <denormalise_bands+0x86>
   OPUS_CLEAR(&freq[bound], N-bound);
 8003476:	2100      	movs	r1, #0
 8003478:	9800      	ldr	r0, [sp, #0]
 800347a:	ea4f 028a 	mov.w	r2, sl, lsl #2
}
 800347e:	b003      	add	sp, #12
 8003480:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   OPUS_CLEAR(&freq[bound], N-bound);
 8003484:	f010 be50 	b.w	8014128 <memset>
 8003488:	f04f 0e02 	mov.w	lr, #2
 800348c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
            *f++ = SHL32(MULT16_16(*x++, g), -shift);
 8003490:	f935 2b02 	ldrsh.w	r2, [r5], #2
         } while (++j<band_end);
 8003494:	3101      	adds	r1, #1
            *f++ = SHL32(MULT16_16(*x++, g), -shift);
 8003496:	fb00 f202 	mul.w	r2, r0, r2
         } while (++j<band_end);
 800349a:	458c      	cmp	ip, r1
            *f++ = SHL32(MULT16_16(*x++, g), -shift);
 800349c:	fa02 f20e 	lsl.w	r2, r2, lr
 80034a0:	f844 2b04 	str.w	r2, [r4], #4
         } while (++j<band_end);
 80034a4:	dcf4      	bgt.n	8003490 <denormalise_bands+0x128>
   for (i=start;i<end;i++)
 80034a6:	4546      	cmp	r6, r8
 80034a8:	d1a1      	bne.n	80033ee <denormalise_bands+0x86>
 80034aa:	e7e4      	b.n	8003476 <denormalise_bands+0x10e>
 80034ac:	2000      	movs	r0, #0
         shift=0;
 80034ae:	4686      	mov	lr, r0
 80034b0:	e7d4      	b.n	800345c <denormalise_bands+0xf4>
      start = end = 0;
 80034b2:	f04f 0800 	mov.w	r8, #0
 80034b6:	9400      	str	r4, [sp, #0]
 80034b8:	46c3      	mov	fp, r8
 80034ba:	4632      	mov	r2, r6
 80034bc:	e779      	b.n	80033b2 <denormalise_bands+0x4a>
 80034be:	f1be 3fff 	cmp.w	lr, #4294967295
 80034c2:	bf0d      	iteet	eq
 80034c4:	4610      	moveq	r0, r2
 80034c6:	f44f 4080 	movne.w	r0, #16384	; 0x4000
 80034ca:	f04f 0e02 	movne.w	lr, #2
 80034ce:	f04f 0e01 	moveq.w	lr, #1
 80034d2:	e7dd      	b.n	8003490 <denormalise_bands+0x128>
 80034d4:	080166c7 	.word	0x080166c7

080034d8 <anti_collapse>:
{
 80034d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80034dc:	b08f      	sub	sp, #60	; 0x3c
   for (i=start;i<end;i++)
 80034de:	e9dd 451a 	ldrd	r4, r5, [sp, #104]	; 0x68
 80034e2:	42ac      	cmp	r4, r5
{
 80034e4:	9e20      	ldr	r6, [sp, #128]	; 0x80
   for (i=start;i<end;i++)
 80034e6:	f280 8184 	bge.w	80037f2 <anti_collapse+0x31a>
 80034ea:	9003      	str	r0, [sp, #12]
 80034ec:	4620      	mov	r0, r4
 80034ee:	9c18      	ldr	r4, [sp, #96]	; 0x60
 80034f0:	9108      	str	r1, [sp, #32]
 80034f2:	fb04 2200 	mla	r2, r4, r0, r2
         for (k=0;k<1<<LM;k++)
 80034f6:	2101      	movs	r1, #1
 80034f8:	920b      	str	r2, [sp, #44]	; 0x2c
 80034fa:	4602      	mov	r2, r0
 80034fc:	461d      	mov	r5, r3
 80034fe:	9302      	str	r3, [sp, #8]
 8003500:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
 8003504:	981f      	ldr	r0, [sp, #124]	; 0x7c
 8003506:	440a      	add	r2, r1
 8003508:	3b01      	subs	r3, #1
 800350a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 800350e:	fa02 f301 	lsl.w	r3, r2, r1
 8003512:	fa01 f905 	lsl.w	r9, r1, r5
 8003516:	4619      	mov	r1, r3
   return 1664525 * seed + 1013904223;
 8003518:	4fbc      	ldr	r7, [pc, #752]	; (800380c <anti_collapse+0x334>)
 800351a:	f8df 82fc 	ldr.w	r8, [pc, #764]	; 8003818 <anti_collapse+0x340>
 800351e:	920d      	str	r2, [sp, #52]	; 0x34
 8003520:	900c      	str	r0, [sp, #48]	; 0x30
 8003522:	930a      	str	r3, [sp, #40]	; 0x28
      N0 = m->eBands[i+1]-m->eBands[i];
 8003524:	9b03      	ldr	r3, [sp, #12]
 8003526:	1e8a      	subs	r2, r1, #2
 8003528:	699b      	ldr	r3, [r3, #24]
 800352a:	9206      	str	r2, [sp, #24]
 800352c:	5e5c      	ldrsh	r4, [r3, r1]
 800352e:	5e9a      	ldrsh	r2, [r3, r2]
      depth = celt_udiv(1+pulses[i], (m->eBands[i+1]-m->eBands[i]))>>LM;
 8003530:	990c      	ldr	r1, [sp, #48]	; 0x30
      N0 = m->eBands[i+1]-m->eBands[i];
 8003532:	1aa4      	subs	r4, r4, r2
      depth = celt_udiv(1+pulses[i], (m->eBands[i+1]-m->eBands[i]))>>LM;
 8003534:	f851 3f04 	ldr.w	r3, [r1, #4]!
   if (d>256)
 8003538:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 800353c:	910c      	str	r1, [sp, #48]	; 0x30
 800353e:	f103 0301 	add.w	r3, r3, #1
 8003542:	f240 813a 	bls.w	80037ba <anti_collapse+0x2e2>
      return n/d;
 8003546:	fbb3 f3f4 	udiv	r3, r3, r4
 800354a:	9a02      	ldr	r2, [sp, #8]
 800354c:	40d3      	lsrs	r3, r2
      thresh32 = SHR32(celt_exp2(-SHL16(depth, 10-BITRES)),1);
 800354e:	4ab0      	ldr	r2, [pc, #704]	; (8003810 <anti_collapse+0x338>)
 8003550:	ea02 13c3 	and.w	r3, r2, r3, lsl #7
 8003554:	425b      	negs	r3, r3
 8003556:	b29b      	uxth	r3, r3
/** Base-2 exponential approximation (2^x). (Q10 input, Q16 output) */
static OPUS_INLINE opus_val32 celt_exp2(opus_val16 x)
{
   int integer;
   opus_val16 frac;
   integer = SHR16(x,10);
 8003558:	f343 2285 	sbfx	r2, r3, #10, #6
   if (integer>14)
 800355c:	2a0e      	cmp	r2, #14
 800355e:	f300 8145 	bgt.w	80037ec <anti_collapse+0x314>
      return 0x7f000000;
   else if (integer < -15)
 8003562:	f112 0f0f 	cmn.w	r2, #15
 8003566:	f2c0 813f 	blt.w	80037e8 <anti_collapse+0x310>
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 800356a:	f242 75dc 	movw	r5, #10204	; 0x27dc
 800356e:	f643 10e3 	movw	r0, #14819	; 0x39e3
 8003572:	f645 1114 	movw	r1, #22804	; 0x5914
      return 0;
   frac = celt_exp2_frac(x-SHL16(integer,10));
   return VSHR32(EXTEND32(frac), -integer-2);
 8003576:	f06f 0e01 	mvn.w	lr, #1
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 800357a:	f643 7aff 	movw	sl, #16383	; 0x3fff
   frac = celt_exp2_frac(x-SHL16(integer,10));
 800357e:	fa1f fc82 	uxth.w	ip, r2
 8003582:	eba3 238c 	sub.w	r3, r3, ip, lsl #10
   frac = SHL16(x, 4);
 8003586:	f343 030b 	sbfx	r3, r3, #0, #12
 800358a:	011b      	lsls	r3, r3, #4
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 800358c:	fb13 f505 	smulbb	r5, r3, r5
 8003590:	eb00 30e5 	add.w	r0, r0, r5, asr #15
 8003594:	fb10 f003 	smulbb	r0, r0, r3
 8003598:	eb01 31e0 	add.w	r1, r1, r0, asr #15
 800359c:	fb11 f303 	smulbb	r3, r1, r3
   return VSHR32(EXTEND32(frac), -integer-2);
 80035a0:	ebae 0e02 	sub.w	lr, lr, r2
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 80035a4:	eb0a 3ae3 	add.w	sl, sl, r3, asr #15
   return VSHR32(EXTEND32(frac), -integer-2);
 80035a8:	f1be 0f00 	cmp.w	lr, #0
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 80035ac:	fa0f fa8a 	sxth.w	sl, sl
   return VSHR32(EXTEND32(frac), -integer-2);
 80035b0:	f340 8122 	ble.w	80037f8 <anti_collapse+0x320>
 80035b4:	fa4a fa0e 	asr.w	sl, sl, lr
 80035b8:	ea4f 036a 	mov.w	r3, sl, asr #1
         t = N0<<LM;
 80035bc:	9a02      	ldr	r2, [sp, #8]
         sqrt_1 = celt_rsqrt_norm(t);
 80035be:	2000      	movs	r0, #0
         t = N0<<LM;
 80035c0:	fa04 f102 	lsl.w	r1, r4, r2
   return EC_ILOG(x)-1;
 80035c4:	fab1 f281 	clz	r2, r1
         shift = celt_ilog2(t)>>1;
 80035c8:	f1c2 021f 	rsb	r2, r2, #31
 80035cc:	1052      	asrs	r2, r2, #1
         sqrt_1 = celt_rsqrt_norm(t);
 80035ce:	9000      	str	r0, [sp, #0]
         t = SHL32(t, (7-shift)<<1);
 80035d0:	f1c2 0007 	rsb	r0, r2, #7
 80035d4:	0040      	lsls	r0, r0, #1
         t = N0<<LM;
 80035d6:	9109      	str	r1, [sp, #36]	; 0x24
         shift = celt_ilog2(t)>>1;
 80035d8:	9205      	str	r2, [sp, #20]
         sqrt_1 = celt_rsqrt_norm(t);
 80035da:	fa01 f000 	lsl.w	r0, r1, r0
 80035de:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80035e2:	fb83 5201 	smull	r5, r2, r3, r1
  );
  /*We intentionally don't OR in the high bit of rd_lo for speed.*/
  return SHL32(rd_hi,1);
 80035e6:	0053      	lsls	r3, r2, #1
      thresh = MULT16_32_Q15(QCONST16(0.5f, 15), MIN32(32767,thresh32));
 80035e8:	b21a      	sxth	r2, r3
      c=0; do
 80035ea:	2300      	movs	r3, #0
      thresh = MULT16_32_Q15(QCONST16(0.5f, 15), MIN32(32767,thresh32));
 80035ec:	9204      	str	r2, [sp, #16]
      c=0; do
 80035ee:	9301      	str	r3, [sp, #4]
         sqrt_1 = celt_rsqrt_norm(t);
 80035f0:	f006 f932 	bl	8009858 <celt_rsqrt_norm>
 80035f4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80035f6:	9007      	str	r0, [sp, #28]
         prev1 = prev1logE[c*m->nbEBands+i];
 80035f8:	9b03      	ldr	r3, [sp, #12]
 80035fa:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 80035fc:	6899      	ldr	r1, [r3, #8]
 80035fe:	9b01      	ldr	r3, [sp, #4]
 8003600:	fb03 2201 	mla	r2, r3, r1, r2
 8003604:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8003606:	f933 c012 	ldrsh.w	ip, [r3, r2, lsl #1]
         prev2 = prev2logE[c*m->nbEBands+i];
 800360a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800360c:	f933 0012 	ldrsh.w	r0, [r3, r2, lsl #1]
         if (C==1)
 8003610:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8003612:	2b01      	cmp	r3, #1
 8003614:	d10d      	bne.n	8003632 <anti_collapse+0x15a>
            prev1 = MAX16(prev1,prev1logE[m->nbEBands+i]);
 8003616:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8003618:	4419      	add	r1, r3
 800361a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800361c:	f933 e011 	ldrsh.w	lr, [r3, r1, lsl #1]
            prev2 = MAX16(prev2,prev2logE[m->nbEBands+i]);
 8003620:	9b1e      	ldr	r3, [sp, #120]	; 0x78
            prev1 = MAX16(prev1,prev1logE[m->nbEBands+i]);
 8003622:	45f4      	cmp	ip, lr
            prev2 = MAX16(prev2,prev2logE[m->nbEBands+i]);
 8003624:	f933 3011 	ldrsh.w	r3, [r3, r1, lsl #1]
            prev1 = MAX16(prev1,prev1logE[m->nbEBands+i]);
 8003628:	bfb8      	it	lt
 800362a:	46f4      	movlt	ip, lr
            prev2 = MAX16(prev2,prev2logE[m->nbEBands+i]);
 800362c:	4298      	cmp	r0, r3
 800362e:	bfb8      	it	lt
 8003630:	4618      	movlt	r0, r3
         Ediff = EXTEND32(logE[c*m->nbEBands+i])-EXTEND32(MIN16(prev1,prev2));
 8003632:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8003634:	4584      	cmp	ip, r0
 8003636:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 800363a:	bfd4      	ite	le
 800363c:	eba3 030c 	suble.w	r3, r3, ip
 8003640:	1a1b      	subgt	r3, r3, r0
         if (Ediff < 16384)
 8003642:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8003646:	f280 80ad 	bge.w	80037a4 <anti_collapse+0x2cc>
         Ediff = MAX32(0, Ediff);
 800364a:	ea23 72e3 	bic.w	r2, r3, r3, asr #31
            opus_val32 r32 = SHR32(celt_exp2(-EXTRACT16(Ediff)),1);
 800364e:	4252      	negs	r2, r2
 8003650:	b292      	uxth	r2, r2
   integer = SHR16(x,10);
 8003652:	f342 2185 	sbfx	r1, r2, #10, #6
   else if (integer < -15)
 8003656:	f111 0f10 	cmn.w	r1, #16
 800365a:	f000 80a3 	beq.w	80037a4 <anti_collapse+0x2cc>
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 800365e:	f242 7edc 	movw	lr, #10204	; 0x27dc
 8003662:	f643 10e3 	movw	r0, #14819	; 0x39e3
 8003666:	f645 1314 	movw	r3, #22804	; 0x5914
   return VSHR32(EXTEND32(frac), -integer-2);
 800366a:	f06f 0c01 	mvn.w	ip, #1
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 800366e:	f643 7bff 	movw	fp, #16383	; 0x3fff
   frac = celt_exp2_frac(x-SHL16(integer,10));
 8003672:	fa1f fa81 	uxth.w	sl, r1
 8003676:	eba2 228a 	sub.w	r2, r2, sl, lsl #10
   frac = SHL16(x, 4);
 800367a:	f342 020b 	sbfx	r2, r2, #0, #12
 800367e:	0112      	lsls	r2, r2, #4
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 8003680:	fb12 fe0e 	smulbb	lr, r2, lr
 8003684:	eb00 30ee 	add.w	r0, r0, lr, asr #15
 8003688:	fb10 f002 	smulbb	r0, r0, r2
 800368c:	eb03 33e0 	add.w	r3, r3, r0, asr #15
 8003690:	fb13 f302 	smulbb	r3, r3, r2
   return VSHR32(EXTEND32(frac), -integer-2);
 8003694:	ebac 0c01 	sub.w	ip, ip, r1
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 8003698:	eb0b 33e3 	add.w	r3, fp, r3, asr #15
   return VSHR32(EXTEND32(frac), -integer-2);
 800369c:	f1bc 0f00 	cmp.w	ip, #0
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 80036a0:	b21b      	sxth	r3, r3
   return VSHR32(EXTEND32(frac), -integer-2);
 80036a2:	f340 8081 	ble.w	80037a8 <anti_collapse+0x2d0>
 80036a6:	fa43 f30c 	asr.w	r3, r3, ip
 80036aa:	f023 0301 	bic.w	r3, r3, #1
         if (LM==3)
 80036ae:	9a02      	ldr	r2, [sp, #8]
 80036b0:	2a03      	cmp	r2, #3
 80036b2:	d10a      	bne.n	80036ca <anti_collapse+0x1f2>
            r = MULT16_16_Q14(23170, MIN32(23169, r));
 80036b4:	f645 2281 	movw	r2, #23169	; 0x5a81
 80036b8:	4293      	cmp	r3, r2
 80036ba:	bfa8      	it	ge
 80036bc:	4613      	movge	r3, r2
 80036be:	f645 2282 	movw	r2, #23170	; 0x5a82
 80036c2:	fb13 f302 	smulbb	r3, r3, r2
 80036c6:	f343 338f 	sbfx	r3, r3, #14, #16
         r = SHR16(MIN16(thresh, r),1);
 80036ca:	9a04      	ldr	r2, [sp, #16]
 80036cc:	4293      	cmp	r3, r2
 80036ce:	bfa8      	it	ge
 80036d0:	4613      	movge	r3, r2
 80036d2:	f343 0c4e 	sbfx	ip, r3, #1, #15
         r = SHR32(MULT16_16_Q15(sqrt_1, r),shift);
 80036d6:	9b07      	ldr	r3, [sp, #28]
         X = X_+c*size+(m->eBands[i]<<LM);
 80036d8:	9a06      	ldr	r2, [sp, #24]
         r = SHR32(MULT16_16_Q15(sqrt_1, r),shift);
 80036da:	fb03 fc0c 	mul.w	ip, r3, ip
         X = X_+c*size+(m->eBands[i]<<LM);
 80036de:	9b03      	ldr	r3, [sp, #12]
         r = SHR32(MULT16_16_Q15(sqrt_1, r),shift);
 80036e0:	ea4f 3cec 	mov.w	ip, ip, asr #15
         X = X_+c*size+(m->eBands[i]<<LM);
 80036e4:	699b      	ldr	r3, [r3, #24]
         for (k=0;k<1<<LM;k++)
 80036e6:	f1b9 0f00 	cmp.w	r9, #0
         X = X_+c*size+(m->eBands[i]<<LM);
 80036ea:	5e98      	ldrsh	r0, [r3, r2]
         r = SHR32(MULT16_16_Q15(sqrt_1, r),shift);
 80036ec:	9b05      	ldr	r3, [sp, #20]
 80036ee:	fa4c fc03 	asr.w	ip, ip, r3
         X = X_+c*size+(m->eBands[i]<<LM);
 80036f2:	9b02      	ldr	r3, [sp, #8]
         r = SHR32(MULT16_16_Q15(sqrt_1, r),shift);
 80036f4:	fa0f fb8c 	sxth.w	fp, ip
         X = X_+c*size+(m->eBands[i]<<LM);
 80036f8:	fa00 f003 	lsl.w	r0, r0, r3
 80036fc:	9b00      	ldr	r3, [sp, #0]
 80036fe:	4418      	add	r0, r3
 8003700:	9b08      	ldr	r3, [sp, #32]
 8003702:	eb03 0040 	add.w	r0, r3, r0, lsl #1
         for (k=0;k<1<<LM;k++)
 8003706:	dd29      	ble.n	800375c <anti_collapse+0x284>
         int renormalize=0;
 8003708:	2100      	movs	r1, #0
                  X[(j<<LM)+k] = (seed&0x8000 ? r : -r);
 800370a:	f1cc 0c00 	rsb	ip, ip, #0
         for (k=0;k<1<<LM;k++)
 800370e:	460a      	mov	r2, r1
 8003710:	e002      	b.n	8003718 <anti_collapse+0x240>
 8003712:	3201      	adds	r2, #1
 8003714:	454a      	cmp	r2, r9
 8003716:	d01a      	beq.n	800374e <anti_collapse+0x276>
            if (!(collapse_masks[i*C+c]&1<<k))
 8003718:	782b      	ldrb	r3, [r5, #0]
 800371a:	4113      	asrs	r3, r2
 800371c:	f013 0301 	ands.w	r3, r3, #1
 8003720:	d1f7      	bne.n	8003712 <anti_collapse+0x23a>
               for (j=0;j<N0;j++)
 8003722:	2c00      	cmp	r4, #0
 8003724:	dd0f      	ble.n	8003746 <anti_collapse+0x26e>
 8003726:	4619      	mov	r1, r3
   return 1664525 * seed + 1013904223;
 8003728:	fb07 8606 	mla	r6, r7, r6, r8
                  X[(j<<LM)+k] = (seed&0x8000 ? r : -r);
 800372c:	eb01 0a02 	add.w	sl, r1, r2
 8003730:	f416 4f00 	tst.w	r6, #32768	; 0x8000
 8003734:	46d6      	mov	lr, sl
               for (j=0;j<N0;j++)
 8003736:	f103 0301 	add.w	r3, r3, #1
                  X[(j<<LM)+k] = (seed&0x8000 ? r : -r);
 800373a:	d12c      	bne.n	8003796 <anti_collapse+0x2be>
               for (j=0;j<N0;j++)
 800373c:	42a3      	cmp	r3, r4
                  X[(j<<LM)+k] = (seed&0x8000 ? r : -r);
 800373e:	f820 c01a 	strh.w	ip, [r0, sl, lsl #1]
 8003742:	4449      	add	r1, r9
               for (j=0;j<N0;j++)
 8003744:	d1f0      	bne.n	8003728 <anti_collapse+0x250>
               renormalize = 1;
 8003746:	2101      	movs	r1, #1
         for (k=0;k<1<<LM;k++)
 8003748:	3201      	adds	r2, #1
 800374a:	454a      	cmp	r2, r9
 800374c:	d1e4      	bne.n	8003718 <anti_collapse+0x240>
         if (renormalize)
 800374e:	b129      	cbz	r1, 800375c <anti_collapse+0x284>
            renormalise_vector(X, N0<<LM, Q15ONE, arch);
 8003750:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8003752:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8003756:	9909      	ldr	r1, [sp, #36]	; 0x24
 8003758:	f008 fb88 	bl	800be6c <renormalise_vector>
 800375c:	9a00      	ldr	r2, [sp, #0]
 800375e:	9919      	ldr	r1, [sp, #100]	; 0x64
      } while (++c<C);
 8003760:	9b01      	ldr	r3, [sp, #4]
 8003762:	440a      	add	r2, r1
 8003764:	9200      	str	r2, [sp, #0]
 8003766:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8003768:	3301      	adds	r3, #1
 800376a:	429a      	cmp	r2, r3
 800376c:	9301      	str	r3, [sp, #4]
 800376e:	f105 0501 	add.w	r5, r5, #1
 8003772:	f73f af41 	bgt.w	80035f8 <anti_collapse+0x120>
 8003776:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8003778:	3302      	adds	r3, #2
 800377a:	930a      	str	r3, [sp, #40]	; 0x28
 800377c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800377e:	4413      	add	r3, r2
   for (i=start;i<end;i++)
 8003780:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8003782:	930b      	str	r3, [sp, #44]	; 0x2c
 8003784:	4611      	mov	r1, r2
 8003786:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003788:	4299      	cmp	r1, r3
 800378a:	931a      	str	r3, [sp, #104]	; 0x68
 800378c:	d031      	beq.n	80037f2 <anti_collapse+0x31a>
 800378e:	3301      	adds	r3, #1
 8003790:	930d      	str	r3, [sp, #52]	; 0x34
 8003792:	990a      	ldr	r1, [sp, #40]	; 0x28
 8003794:	e6c6      	b.n	8003524 <anti_collapse+0x4c>
               for (j=0;j<N0;j++)
 8003796:	429c      	cmp	r4, r3
                  X[(j<<LM)+k] = (seed&0x8000 ? r : -r);
 8003798:	f820 b01a 	strh.w	fp, [r0, sl, lsl #1]
 800379c:	4449      	add	r1, r9
               for (j=0;j<N0;j++)
 800379e:	d1c3      	bne.n	8003728 <anti_collapse+0x250>
               renormalize = 1;
 80037a0:	2101      	movs	r1, #1
 80037a2:	e7d1      	b.n	8003748 <anti_collapse+0x270>
            r = 0;
 80037a4:	2300      	movs	r3, #0
 80037a6:	e782      	b.n	80036ae <anti_collapse+0x1d6>
 80037a8:	3102      	adds	r1, #2
 80037aa:	408b      	lsls	r3, r1
 80037ac:	105b      	asrs	r3, r3, #1
 80037ae:	455b      	cmp	r3, fp
 80037b0:	bfa8      	it	ge
 80037b2:	465b      	movge	r3, fp
 80037b4:	005b      	lsls	r3, r3, #1
 80037b6:	b21b      	sxth	r3, r3
 80037b8:	e779      	b.n	80036ae <anti_collapse+0x1d6>
      t = EC_ILOG(d&-d);
 80037ba:	4262      	negs	r2, r4
 80037bc:	4022      	ands	r2, r4
 80037be:	fab2 f282 	clz	r2, r2
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 80037c2:	4814      	ldr	r0, [pc, #80]	; (8003814 <anti_collapse+0x33c>)
      t = EC_ILOG(d&-d);
 80037c4:	f1c2 0220 	rsb	r2, r2, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 80037c8:	fa24 f102 	lsr.w	r1, r4, r2
 80037cc:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
 80037d0:	1e50      	subs	r0, r2, #1
 80037d2:	fa23 f000 	lsr.w	r0, r3, r0
 80037d6:	fba0 0101 	umull	r0, r1, r0, r1
      return q+(n-q*d >= d);
 80037da:	fb04 3311 	mls	r3, r4, r1, r3
 80037de:	429c      	cmp	r4, r3
 80037e0:	bf8c      	ite	hi
 80037e2:	460b      	movhi	r3, r1
 80037e4:	1c4b      	addls	r3, r1, #1
 80037e6:	e6b0      	b.n	800354a <anti_collapse+0x72>
   else if (integer < -15)
 80037e8:	2300      	movs	r3, #0
 80037ea:	e6e7      	b.n	80035bc <anti_collapse+0xe4>
   if (integer>14)
 80037ec:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80037f0:	e6e4      	b.n	80035bc <anti_collapse+0xe4>
}
 80037f2:	b00f      	add	sp, #60	; 0x3c
 80037f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80037f8:	f647 71ff 	movw	r1, #32767	; 0x7fff
   return VSHR32(EXTEND32(frac), -integer-2);
 80037fc:	3202      	adds	r2, #2
 80037fe:	fa0a f202 	lsl.w	r2, sl, r2
 8003802:	1053      	asrs	r3, r2, #1
 8003804:	428b      	cmp	r3, r1
 8003806:	bfa8      	it	ge
 8003808:	460b      	movge	r3, r1
 800380a:	e6d7      	b.n	80035bc <anti_collapse+0xe4>
 800380c:	0019660d 	.word	0x0019660d
 8003810:	007fff80 	.word	0x007fff80
 8003814:	0801649c 	.word	0x0801649c
 8003818:	3c6ef35f 	.word	0x3c6ef35f

0800381c <quant_all_bands>:
      celt_norm *X_, celt_norm *Y_, unsigned char *collapse_masks,
      const celt_ener *bandE, int *pulses, int shortBlocks, int spread,
      int dual_stereo, int intensity, int *tf_res, opus_int32 total_bits,
      opus_int32 balance, ec_ctx *ec, int LM, int codedBands,
      opus_uint32 *seed, int complexity, int arch, int disable_inv)
{
 800381c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003820:	f2ad 6df4 	subw	sp, sp, #1780	; 0x6f4
 8003824:	469a      	mov	sl, r3
   int i;
   opus_int32 remaining_bits;
   const opus_int16 * OPUS_RESTRICT eBands = m->eBands;
 8003826:	698b      	ldr	r3, [r1, #24]
{
 8003828:	af08      	add	r7, sp, #32
   const opus_int16 * OPUS_RESTRICT eBands = m->eBands;
 800382a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
   celt_norm *lowband_scratch;
   int B;
   int M;
   int lowband_offset;
   int update_lowband = 1;
   int C = Y_ != NULL ? 2 : 1;
 800382e:	f8d7 36fc 	ldr.w	r3, [r7, #1788]	; 0x6fc
{
 8003832:	f8d7 970c 	ldr.w	r9, [r7, #1804]	; 0x70c
 8003836:	f8d7 872c 	ldr.w	r8, [r7, #1836]	; 0x72c
   int C = Y_ != NULL ? 2 : 1;
 800383a:	2b00      	cmp	r3, #0
 800383c:	f001 8098 	beq.w	8004970 <quant_all_bands+0x1154>
   int norm_offset;
   int theta_rdo = encode && Y_!=NULL && !dual_stereo && complexity>=8;
 8003840:	2800      	cmp	r0, #0
 8003842:	f040 8227 	bne.w	8003c94 <quant_all_bands+0x478>
   int C = Y_ != NULL ? 2 : 1;
 8003846:	2302      	movs	r3, #2
 8003848:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
#ifdef RESYNTH
   int resynth = 1;
#else
   int resynth = !encode || theta_rdo;
 800384c:	2301      	movs	r3, #1
   int theta_rdo = encode && Y_!=NULL && !dual_stereo && complexity>=8;
 800384e:	64b8      	str	r0, [r7, #72]	; 0x48
   int resynth = !encode || theta_rdo;
 8003850:	67fb      	str	r3, [r7, #124]	; 0x7c
#endif
   struct band_ctx ctx;
   SAVE_STACK;

   M = 1<<LM;
   B = shortBlocks ? M : 1;
 8003852:	f1b9 0f00 	cmp.w	r9, #0
 8003856:	f000 8231 	beq.w	8003cbc <quant_all_bands+0x4a0>
   M = 1<<LM;
 800385a:	2401      	movs	r4, #1
 800385c:	fa04 f308 	lsl.w	r3, r4, r8
 8003860:	42a3      	cmp	r3, r4
 8003862:	bfd4      	ite	le
 8003864:	f04f 0900 	movle.w	r9, #0
 8003868:	f04f 0901 	movgt.w	r9, #1
 800386c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
   norm_offset = M*eBands[start];
   /* No need to allocate norm for the last band because we don't need an
      output in that band. */
   ALLOC(_norm, C*(M*eBands[m->nbEBands-1]-norm_offset), celt_norm);
 8003870:	688c      	ldr	r4, [r1, #8]
   norm_offset = M*eBands[start];
 8003872:	f8d7 6090 	ldr.w	r6, [r7, #144]	; 0x90
   ALLOC(_norm, C*(M*eBands[m->nbEBands-1]-norm_offset), celt_norm);
 8003876:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
 800387a:	3c01      	subs	r4, #1
   norm_offset = M*eBands[start];
 800387c:	f936 5012 	ldrsh.w	r5, [r6, r2, lsl #1]
   ALLOC(_norm, C*(M*eBands[m->nbEBands-1]-norm_offset), celt_norm);
 8003880:	f936 c014 	ldrsh.w	ip, [r6, r4, lsl #1]
   norm_offset = M*eBands[start];
 8003884:	fa05 f308 	lsl.w	r3, r5, r8
   ALLOC(_norm, C*(M*eBands[m->nbEBands-1]-norm_offset), celt_norm);
 8003888:	fa0c f608 	lsl.w	r6, ip, r8
 800388c:	1af5      	subs	r5, r6, r3
   norm_offset = M*eBands[start];
 800388e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
   ALLOC(_norm, C*(M*eBands[m->nbEBands-1]-norm_offset), celt_norm);
 8003892:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8003896:	0064      	lsls	r4, r4, #1
 8003898:	fb03 fe05 	mul.w	lr, r3, r5
 800389c:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80038a0:	f10e 0e08 	add.w	lr, lr, #8
 80038a4:	f02e 0e07 	bic.w	lr, lr, #7
 80038a8:	ebad 0d0e 	sub.w	sp, sp, lr
 80038ac:	ab08      	add	r3, sp, #32
 80038ae:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
   norm_offset = M*eBands[start];
 80038b2:	0053      	lsls	r3, r2, #1
 80038b4:	647b      	str	r3, [r7, #68]	; 0x44
   norm = _norm;
   norm2 = norm + M*eBands[m->nbEBands-1]-norm_offset;
 80038b6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80038ba:	eb03 0545 	add.w	r5, r3, r5, lsl #1
 80038be:	667d      	str	r5, [r7, #100]	; 0x64
   norm_offset = M*eBands[start];
 80038c0:	f8d7 5090 	ldr.w	r5, [r7, #144]	; 0x90
   norm2 = norm + M*eBands[m->nbEBands-1]-norm_offset;
 80038c4:	469e      	mov	lr, r3
   norm_offset = M*eBands[start];
 80038c6:	0053      	lsls	r3, r2, #1
 80038c8:	18eb      	adds	r3, r5, r3
 80038ca:	65bb      	str	r3, [r7, #88]	; 0x58

   /* For decoding, we can use the last band as scratch space because we don't need that
      scratch space for the last band and we don't care about the data there until we're
      decoding the last band. */
   if (encode && resynth)
 80038cc:	2800      	cmp	r0, #0
 80038ce:	f000 874b 	beq.w	8004768 <quant_all_bands+0xf4c>
 80038d2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80038d4:	2b00      	cmp	r3, #0
 80038d6:	f000 8747 	beq.w	8004768 <quant_all_bands+0xf4c>
      resynth_alloc = M*(eBands[m->nbEBands]-eBands[m->nbEBands-1]);
 80038da:	442c      	add	r4, r5
 80038dc:	f9b4 4002 	ldrsh.w	r4, [r4, #2]
 80038e0:	eba4 040c 	sub.w	r4, r4, ip
 80038e4:	fa04 f408 	lsl.w	r4, r4, r8
   else
      resynth_alloc = ALLOC_NONE;
   ALLOC(_lowband_scratch, resynth_alloc, celt_norm);
 80038e8:	0064      	lsls	r4, r4, #1
 80038ea:	3408      	adds	r4, #8
 80038ec:	f024 0507 	bic.w	r5, r4, #7
 80038f0:	ebad 0d05 	sub.w	sp, sp, r5
 80038f4:	ab08      	add	r3, sp, #32
 80038f6:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
   ctx.seed = *seed;
   ctx.spread = spread;
   ctx.arch = arch;
   ctx.disable_inv = disable_inv;
   ctx.resynth = resynth;
   ctx.theta_round = 0;
 80038fa:	2500      	movs	r5, #0
   ALLOC(X_save, resynth_alloc, celt_norm);
 80038fc:	f024 0407 	bic.w	r4, r4, #7
 8003900:	ebad 0d04 	sub.w	sp, sp, r4
 8003904:	ab08      	add	r3, sp, #32
   ALLOC(Y_save, resynth_alloc, celt_norm);
 8003906:	ebad 0d04 	sub.w	sp, sp, r4
   ALLOC(X_save, resynth_alloc, celt_norm);
 800390a:	643b      	str	r3, [r7, #64]	; 0x40
   ALLOC(Y_save, resynth_alloc, celt_norm);
 800390c:	ab08      	add	r3, sp, #32
   ALLOC(X_save2, resynth_alloc, celt_norm);
 800390e:	ebad 0d04 	sub.w	sp, sp, r4
   ALLOC(Y_save, resynth_alloc, celt_norm);
 8003912:	63fb      	str	r3, [r7, #60]	; 0x3c
   ALLOC(X_save2, resynth_alloc, celt_norm);
 8003914:	ab08      	add	r3, sp, #32
 8003916:	637b      	str	r3, [r7, #52]	; 0x34
   ctx.seed = *seed;
 8003918:	f8d7 3734 	ldr.w	r3, [r7, #1844]	; 0x734
   ALLOC(Y_save2, resynth_alloc, celt_norm);
 800391c:	ebad 0d04 	sub.w	sp, sp, r4
   ctx.seed = *seed;
 8003920:	681e      	ldr	r6, [r3, #0]
   ALLOC(Y_save2, resynth_alloc, celt_norm);
 8003922:	ab08      	add	r3, sp, #32
   ALLOC(norm_save2, resynth_alloc, celt_norm);
 8003924:	ebad 0d04 	sub.w	sp, sp, r4
   ALLOC(Y_save2, resynth_alloc, celt_norm);
 8003928:	633b      	str	r3, [r7, #48]	; 0x30
   ALLOC(norm_save2, resynth_alloc, celt_norm);
 800392a:	ab08      	add	r3, sp, #32
 800392c:	62fb      	str	r3, [r7, #44]	; 0x2c
   ctx.bandE = bandE;
 800392e:	f8d7 3704 	ldr.w	r3, [r7, #1796]	; 0x704
   /* Avoid injecting noise in the first band on transients. */
   ctx.avoid_split_noise = B > 1;
   for (i=start;i<end;i++)
 8003932:	4552      	cmp	r2, sl
   ctx.bandE = bandE;
 8003934:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
   ctx.ec = ec;
 8003938:	f8d7 3728 	ldr.w	r3, [r7, #1832]	; 0x728
   ctx.theta_round = 0;
 800393c:	f8c7 5150 	str.w	r5, [r7, #336]	; 0x150
   ctx.ec = ec;
 8003940:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
   ctx.intensity = intensity;
 8003944:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
   ctx.encode = encode;
 8003948:	f8c7 0120 	str.w	r0, [r7, #288]	; 0x120
   ctx.intensity = intensity;
 800394c:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
   ctx.spread = spread;
 8003950:	f8d7 3710 	ldr.w	r3, [r7, #1808]	; 0x710
   ctx.m = m;
 8003954:	f8c7 1128 	str.w	r1, [r7, #296]	; 0x128
   ctx.spread = spread;
 8003958:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
   ctx.arch = arch;
 800395c:	f8d7 373c 	ldr.w	r3, [r7, #1852]	; 0x73c
   ctx.avoid_split_noise = B > 1;
 8003960:	f8c7 9158 	str.w	r9, [r7, #344]	; 0x158
   ctx.arch = arch;
 8003964:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
   ctx.disable_inv = disable_inv;
 8003968:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
   ctx.seed = *seed;
 800396c:	f8c7 6148 	str.w	r6, [r7, #328]	; 0x148
   ctx.disable_inv = disable_inv;
 8003970:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
   ctx.resynth = resynth;
 8003974:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8003976:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
   for (i=start;i<end;i++)
 800397a:	f280 8283 	bge.w	8003e84 <quant_all_bands+0x668>
 800397e:	4654      	mov	r4, sl
 8003980:	f8c7 a060 	str.w	sl, [r7, #96]	; 0x60
         } while (++fold_i<fold_end);
      }
      /* Otherwise, we'll be using the LCG to fold, so all blocks will (almost
         always) be non-zero. */
      else
         x_cm = y_cm = (1<<B)-1;
 8003984:	f04f 0a01 	mov.w	sl, #1
 8003988:	67b9      	str	r1, [r7, #120]	; 0x78
 800398a:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
 800398e:	f8c7 2080 	str.w	r2, [r7, #128]	; 0x80
 8003992:	fa0a f301 	lsl.w	r3, sl, r1
 8003996:	1e59      	subs	r1, r3, #1
 8003998:	65f9      	str	r1, [r7, #92]	; 0x5c
 800399a:	1e63      	subs	r3, r4, #1
   n1 = M*(eBands[start+1]-eBands[start]);
 800399c:	eb02 010a 	add.w	r1, r2, sl
 80039a0:	f8c7 1084 	str.w	r1, [r7, #132]	; 0x84
 80039a4:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 80039a8:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80039aa:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
 80039ae:	1c88      	adds	r0, r1, #2
 80039b0:	429a      	cmp	r2, r3
   n2 = M*(eBands[start+2]-eBands[start+1]);
 80039b2:	f101 0104 	add.w	r1, r1, #4
   n1 = M*(eBands[start+1]-eBands[start]);
 80039b6:	62b8      	str	r0, [r7, #40]	; 0x28
   n2 = M*(eBands[start+2]-eBands[start+1]);
 80039b8:	6279      	str	r1, [r7, #36]	; 0x24
 80039ba:	f2c0 8284 	blt.w	8003ec6 <quant_all_bands+0x6aa>
 80039be:	4616      	mov	r6, r2
         x_cm = y_cm = (1<<B)-1;
 80039c0:	f8c7 50b4 	str.w	r5, [r7, #180]	; 0xb4
 80039c4:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 80039c8:	1c73      	adds	r3, r6, #1
 80039ca:	4611      	mov	r1, r2
 80039cc:	fb01 f103 	mul.w	r1, r1, r3
 80039d0:	66fb      	str	r3, [r7, #108]	; 0x6c
 80039d2:	f8d7 0700 	ldr.w	r0, [r7, #1792]	; 0x700
 80039d6:	fb06 f302 	mul.w	r3, r6, r2
 80039da:	6539      	str	r1, [r7, #80]	; 0x50
 80039dc:	1841      	adds	r1, r0, r1
 80039de:	6739      	str	r1, [r7, #112]	; 0x70
 80039e0:	f8d7 1708 	ldr.w	r1, [r7, #1800]	; 0x708
 80039e4:	657b      	str	r3, [r7, #84]	; 0x54
 80039e6:	00b3      	lsls	r3, r6, #2
 80039e8:	1f1a      	subs	r2, r3, #4
 80039ea:	18cb      	adds	r3, r1, r3
 80039ec:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 80039f0:	f8d7 371c 	ldr.w	r3, [r7, #1820]	; 0x71c
 80039f4:	f8d7 b724 	ldr.w	fp, [r7, #1828]	; 0x724
 80039f8:	4413      	add	r3, r2
 80039fa:	677b      	str	r3, [r7, #116]	; 0x74
 80039fc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8003a00:	4644      	mov	r4, r8
 8003a02:	eb03 0346 	add.w	r3, r3, r6, lsl #1
 8003a06:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8003a0a:	f8d7 3730 	ldr.w	r3, [r7, #1840]	; 0x730
 8003a0e:	1b9b      	subs	r3, r3, r6
 8003a10:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8003a14:	e0fb      	b.n	8003c0e <quant_all_bands+0x3f2>
         curr_balance = celt_sudiv(balance, IMIN(3, codedBands-i));
 8003a16:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8003a1a:	2b03      	cmp	r3, #3
 8003a1c:	bfa8      	it	ge
 8003a1e:	2303      	movge	r3, #3
   if (n<0)
 8003a20:	f1bb 0f00 	cmp.w	fp, #0
 8003a24:	f2c0 821c 	blt.w	8003e60 <quant_all_bands+0x644>
   if (d>256)
 8003a28:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003a2c:	f240 8234 	bls.w	8003e98 <quant_all_bands+0x67c>
      return n/d;
 8003a30:	fbbb f3f3 	udiv	r3, fp, r3
         b = IMAX(0, IMIN(16383, IMIN(remaining_bits+1,pulses[i]+curr_balance)));
 8003a34:	f643 72ff 	movw	r2, #16383	; 0x3fff
 8003a38:	4295      	cmp	r5, r2
 8003a3a:	bfa8      	it	ge
 8003a3c:	4615      	movge	r5, r2
 8003a3e:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8003a42:	6812      	ldr	r2, [r2, #0]
 8003a44:	4413      	add	r3, r2
 8003a46:	429d      	cmp	r5, r3
 8003a48:	bfa8      	it	ge
 8003a4a:	461d      	movge	r5, r3
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 8003a4c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8003a4e:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
 8003a52:	2b00      	cmp	r3, #0
 8003a54:	f000 8117 	beq.w	8003c86 <quant_all_bands+0x46a>
 8003a58:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8003a5c:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8003a5e:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
 8003a62:	f9b2 2000 	ldrsh.w	r2, [r2]
 8003a66:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
 8003a6a:	40a3      	lsls	r3, r4
 8003a6c:	1a5b      	subs	r3, r3, r1
 8003a6e:	40a2      	lsls	r2, r4
 8003a70:	429a      	cmp	r2, r3
 8003a72:	f340 81d7 	ble.w	8003e24 <quant_all_bands+0x608>
 8003a76:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8003a7a:	42b3      	cmp	r3, r6
 8003a7c:	f000 8735 	beq.w	80048ea <quant_all_bands+0x10ce>
      tf_change = tf_res[i];
 8003a80:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8003a82:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8003a86:	677a      	str	r2, [r7, #116]	; 0x74
      if (i>=m->effEBands)
 8003a88:	6fba      	ldr	r2, [r7, #120]	; 0x78
      ctx.tf_change = tf_change;
 8003a8a:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
      if (i>=m->effEBands)
 8003a8e:	68d2      	ldr	r2, [r2, #12]
 8003a90:	42b2      	cmp	r2, r6
 8003a92:	f300 8117 	bgt.w	8003cc4 <quant_all_bands+0x4a8>
         X=norm;
 8003a96:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
 8003a9a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8003a9e:	468c      	mov	ip, r1
 8003aa0:	f8d7 06fc 	ldr.w	r0, [r7, #1788]	; 0x6fc
 8003aa4:	66ba      	str	r2, [r7, #104]	; 0x68
 8003aa6:	2800      	cmp	r0, #0
 8003aa8:	bf18      	it	ne
 8003aaa:	4694      	movne	ip, r2
 8003aac:	2200      	movs	r2, #0
 8003aae:	f8c7 c098 	str.w	ip, [r7, #152]	; 0x98
 8003ab2:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
      if (last && !theta_rdo)
 8003ab6:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8003aba:	42b2      	cmp	r2, r6
 8003abc:	f000 87d2 	beq.w	8004a64 <quant_all_bands+0x1248>
      if (lowband_offset != 0 && (spread!=SPREAD_AGGRESSIVE || B>1 || tf_change<0))
 8003ac0:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8003ac4:	b162      	cbz	r2, 8003ae0 <quant_all_bands+0x2c4>
 8003ac6:	f8d7 2710 	ldr.w	r2, [r7, #1808]	; 0x710
 8003aca:	2a03      	cmp	r2, #3
 8003acc:	f040 80ff 	bne.w	8003cce <quant_all_bands+0x4b2>
 8003ad0:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8003ad4:	2a01      	cmp	r2, #1
 8003ad6:	f300 80fa 	bgt.w	8003cce <quant_all_bands+0x4b2>
 8003ada:	2b00      	cmp	r3, #0
 8003adc:	f2c0 80f7 	blt.w	8003cce <quant_all_bands+0x4b2>

      if (dual_stereo && i==intensity)
 8003ae0:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
 8003ae4:	2b00      	cmp	r3, #0
 8003ae6:	f000 8161 	beq.w	8003dac <quant_all_bands+0x590>
 8003aea:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
 8003aee:	42b3      	cmp	r3, r6
 8003af0:	f001 8011 	beq.w	8004b16 <quant_all_bands+0x12fa>
            for (j=0;j<M*eBands[i]-norm_offset;j++)
               norm[j] = HALF32(norm[j]+norm2[j]);
      }
      if (dual_stereo)
      {
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8003af4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8003af6:	f06f 0901 	mvn.w	r9, #1
 8003afa:	4613      	mov	r3, r2
 8003afc:	64fa      	str	r2, [r7, #76]	; 0x4c
      int effective_lowband=-1;
 8003afe:	f04f 38ff 	mov.w	r8, #4294967295
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8003b02:	2200      	movs	r2, #0
 8003b04:	ea4f 0a65 	mov.w	sl, r5, asr #1
 8003b08:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
 8003b0c:	42b1      	cmp	r1, r6
 8003b0e:	f001 8019 	beq.w	8004b44 <quant_all_bands+0x1328>
 8003b12:	f647 71ff 	movw	r1, #32767	; 0x7fff
 8003b16:	9306      	str	r3, [sp, #24]
 8003b18:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
               effective_lowband != -1 ? norm+effective_lowband : NULL, LM,
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
 8003b1c:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8003b20:	e9cd 1304 	strd	r1, r3, [sp, #16]
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
 8003b24:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8003b28:	6eb9      	ldr	r1, [r7, #104]	; 0x68
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
 8003b2a:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8003b2e:	9201      	str	r2, [sp, #4]
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
 8003b30:	40a3      	lsls	r3, r4
 8003b32:	1a1b      	subs	r3, r3, r0
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8003b34:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 8003b38:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8003b3c:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8003b40:	e9cd 4302 	strd	r4, r3, [sp, #8]
 8003b44:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8003b48:	f507 7090 	add.w	r0, r7, #288	; 0x120
 8003b4c:	9300      	str	r3, [sp, #0]
 8003b4e:	4653      	mov	r3, sl
 8003b50:	f7fe f96a 	bl	8001e28 <quant_band>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 8003b54:	f1b8 3fff 	cmp.w	r8, #4294967295
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8003b58:	4606      	mov	r6, r0
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 8003b5a:	f000 819b 	beq.w	8003e94 <quant_all_bands+0x678>
 8003b5e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8003b60:	eb03 0209 	add.w	r2, r3, r9
               effective_lowband != -1 ? norm2+effective_lowband : NULL, LM,
               last?NULL:norm2+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, y_cm);
 8003b64:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8003b68:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 8003b6c:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
 8003b70:	40a3      	lsls	r3, r4
 8003b72:	1a5b      	subs	r3, r3, r1
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 8003b74:	6e79      	ldr	r1, [r7, #100]	; 0x64
 8003b76:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8003b7a:	f647 70ff 	movw	r0, #32767	; 0x7fff
 8003b7e:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8003b80:	e9cd 4302 	strd	r4, r3, [sp, #8]
 8003b84:	9106      	str	r1, [sp, #24]
 8003b86:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8003b8a:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 8003b8e:	9201      	str	r2, [sp, #4]
 8003b90:	9105      	str	r1, [sp, #20]
 8003b92:	9300      	str	r3, [sp, #0]
 8003b94:	9004      	str	r0, [sp, #16]
 8003b96:	4653      	mov	r3, sl
 8003b98:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
 8003b9c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8003ba0:	f507 7090 	add.w	r0, r7, #288	; 0x120
 8003ba4:	f7fe f940 	bl	8001e28 <quant_band>
                  effective_lowband != -1 ? norm+effective_lowband : NULL, LM,
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
         }
         y_cm = x_cm;
      }
      collapse_masks[i*C+0] = (unsigned char)x_cm;
 8003ba8:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8003baa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003bac:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8003bae:	1ad3      	subs	r3, r2, r3
 8003bb0:	545e      	strb	r6, [r3, r1]
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
      balance += pulses[i] + tell;
 8003bb2:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
 8003bb6:	f802 0c01 	strb.w	r0, [r2, #-1]
      balance += pulses[i] + tell;
 8003bba:	f851 3b04 	ldr.w	r3, [r1], #4
 8003bbe:	f8c7 108c 	str.w	r1, [r7, #140]	; 0x8c

      /* Update the folding position only as long as we have 1 bit/sample depth. */
      update_lowband = b>(N<<BITRES);
 8003bc2:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
 8003bc6:	ebb5 0fc1 	cmp.w	r5, r1, lsl #3
      balance += pulses[i] + tell;
 8003bca:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
      update_lowband = b>(N<<BITRES);
 8003bce:	bfc8      	it	gt
 8003bd0:	f04f 0a01 	movgt.w	sl, #1
      balance += pulses[i] + tell;
 8003bd4:	4419      	add	r1, r3
 8003bd6:	460b      	mov	r3, r1
      /* We only need to avoid noise on a split for the first band. After that, we
         have folding. */
      ctx.avoid_split_noise = 0;
 8003bd8:	f04f 0100 	mov.w	r1, #0
 8003bdc:	f8c7 1158 	str.w	r1, [r7, #344]	; 0x158
 8003be0:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
      balance += pulses[i] + tell;
 8003be4:	449b      	add	fp, r3
 8003be6:	f101 31ff 	add.w	r1, r1, #4294967295
 8003bea:	f8c7 1088 	str.w	r1, [r7, #136]	; 0x88
 8003bee:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
 8003bf2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8003bf4:	440a      	add	r2, r1
 8003bf6:	673a      	str	r2, [r7, #112]	; 0x70
   for (i=start;i<end;i++)
 8003bf8:	6e3a      	ldr	r2, [r7, #96]	; 0x60
      update_lowband = b>(N<<BITRES);
 8003bfa:	bfd8      	it	le
 8003bfc:	f04f 0a00 	movle.w	sl, #0
   for (i=start;i<end;i++)
 8003c00:	4611      	mov	r1, r2
 8003c02:	4299      	cmp	r1, r3
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
 8003c04:	461e      	mov	r6, r3
   for (i=start;i<end;i++)
 8003c06:	f340 813b 	ble.w	8003e80 <quant_all_bands+0x664>
 8003c0a:	3301      	adds	r3, #1
 8003c0c:	66fb      	str	r3, [r7, #108]	; 0x6c
      X = X_+M*eBands[i];
 8003c0e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8003c12:	f933 2b02 	ldrsh.w	r2, [r3], #2
      ctx.i = i;
 8003c16:	f8c7 612c 	str.w	r6, [r7, #300]	; 0x12c
      X = X_+M*eBands[i];
 8003c1a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
      if (Y_!=NULL)
 8003c1e:	f8d7 36fc 	ldr.w	r3, [r7, #1788]	; 0x6fc
      X = X_+M*eBands[i];
 8003c22:	fa02 f804 	lsl.w	r8, r2, r4
 8003c26:	ea4f 0848 	mov.w	r8, r8, lsl #1
      if (Y_!=NULL)
 8003c2a:	2b00      	cmp	r3, #0
 8003c2c:	f000 80f7 	beq.w	8003e1e <quant_all_bands+0x602>
         Y = Y_+M*eBands[i];
 8003c30:	4443      	add	r3, r8
 8003c32:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
      N = M*eBands[i+1]-M*eBands[i];
 8003c36:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
      tell = ec_tell_frac(ec);
 8003c3a:	f8d7 0728 	ldr.w	r0, [r7, #1832]	; 0x728
      N = M*eBands[i+1]-M*eBands[i];
 8003c3e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8003c42:	1a9b      	subs	r3, r3, r2
 8003c44:	40a3      	lsls	r3, r4
 8003c46:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
      tell = ec_tell_frac(ec);
 8003c4a:	f004 fb39 	bl	80082c0 <ec_tell_frac>
      if (i != start)
 8003c4e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
      tell = ec_tell_frac(ec);
 8003c52:	f8c7 0094 	str.w	r0, [r7, #148]	; 0x94
      if (i != start)
 8003c56:	42b3      	cmp	r3, r6
         balance -= tell;
 8003c58:	bf18      	it	ne
 8003c5a:	4603      	movne	r3, r0
      remaining_bits = total_bits-tell-1;
 8003c5c:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
         balance -= tell;
 8003c60:	bf18      	it	ne
 8003c62:	ebab 0b03 	subne.w	fp, fp, r3
      remaining_bits = total_bits-tell-1;
 8003c66:	f8d7 3720 	ldr.w	r3, [r7, #1824]	; 0x720
 8003c6a:	1a9d      	subs	r5, r3, r2
 8003c6c:	1e6b      	subs	r3, r5, #1
      ctx.remaining_bits = remaining_bits;
 8003c6e:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
      if (i <= codedBands-1)
 8003c72:	f8d7 3730 	ldr.w	r3, [r7, #1840]	; 0x730
 8003c76:	42b3      	cmp	r3, r6
 8003c78:	f73f aecd 	bgt.w	8003a16 <quant_all_bands+0x1fa>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 8003c7c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
         b = 0;
 8003c7e:	2500      	movs	r5, #0
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 8003c80:	2b00      	cmp	r3, #0
 8003c82:	f47f aee9 	bne.w	8003a58 <quant_all_bands+0x23c>
      if (i == start+1)
 8003c86:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8003c8a:	42b3      	cmp	r3, r6
 8003c8c:	f47f aef8 	bne.w	8003a80 <quant_all_bands+0x264>
 8003c90:	f000 be38 	b.w	8004904 <quant_all_bands+0x10e8>
   int theta_rdo = encode && Y_!=NULL && !dual_stereo && complexity>=8;
 8003c94:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
 8003c98:	2b00      	cmp	r3, #0
 8003c9a:	f040 867e 	bne.w	800499a <quant_all_bands+0x117e>
 8003c9e:	f8d7 3738 	ldr.w	r3, [r7, #1848]	; 0x738
 8003ca2:	2b07      	cmp	r3, #7
 8003ca4:	f340 868b 	ble.w	80049be <quant_all_bands+0x11a2>
 8003ca8:	2301      	movs	r3, #1
   int C = Y_ != NULL ? 2 : 1;
 8003caa:	2402      	movs	r4, #2
   int theta_rdo = encode && Y_!=NULL && !dual_stereo && complexity>=8;
 8003cac:	64bb      	str	r3, [r7, #72]	; 0x48
   int C = Y_ != NULL ? 2 : 1;
 8003cae:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
   int resynth = !encode || theta_rdo;
 8003cb2:	67fb      	str	r3, [r7, #124]	; 0x7c
   B = shortBlocks ? M : 1;
 8003cb4:	f1b9 0f00 	cmp.w	r9, #0
 8003cb8:	f47f adcf 	bne.w	800385a <quant_all_bands+0x3e>
 8003cbc:	2301      	movs	r3, #1
 8003cbe:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8003cc2:	e5d5      	b.n	8003870 <quant_all_bands+0x54>
      X = X_+M*eBands[i];
 8003cc4:	f8d7 26f8 	ldr.w	r2, [r7, #1784]	; 0x6f8
 8003cc8:	4442      	add	r2, r8
 8003cca:	66ba      	str	r2, [r7, #104]	; 0x68
 8003ccc:	e6f3      	b.n	8003ab6 <quant_all_bands+0x29a>
         effective_lowband = IMAX(0, M*eBands[lowband_offset]-norm_offset-N);
 8003cce:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8003cd2:	f8d7 00b4 	ldr.w	r0, [r7, #180]	; 0xb4
 8003cd6:	461a      	mov	r2, r3
 8003cd8:	f932 8010 	ldrsh.w	r8, [r2, r0, lsl #1]
 8003cdc:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8003ce0:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8003ce4:	fa08 f804 	lsl.w	r8, r8, r4
 8003ce8:	eba8 0803 	sub.w	r8, r8, r3
 8003cec:	eba8 0802 	sub.w	r8, r8, r2
 8003cf0:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8003cf4:	0041      	lsls	r1, r0, #1
 8003cf6:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
 8003cfa:	eb03 0c08 	add.w	ip, r3, r8
 8003cfe:	eb02 0e01 	add.w	lr, r2, r1
 8003d02:	e000      	b.n	8003d06 <quant_all_bands+0x4ea>
         while(M*eBands[--fold_start] > effective_lowband+norm_offset);
 8003d04:	4618      	mov	r0, r3
 8003d06:	f93e 2d02 	ldrsh.w	r2, [lr, #-2]!
 8003d0a:	1e43      	subs	r3, r0, #1
 8003d0c:	40a2      	lsls	r2, r4
 8003d0e:	4594      	cmp	ip, r2
 8003d10:	dbf8      	blt.n	8003d04 <quant_all_bands+0x4e8>
 8003d12:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8003d16:	3902      	subs	r1, #2
 8003d18:	4411      	add	r1, r2
         while(++fold_end < i && M*eBands[fold_end] < effective_lowband+norm_offset+N);
 8003d1a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8003d1e:	4494      	add	ip, r2
         fold_end = lowband_offset-1;
 8003d20:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8003d24:	3a01      	subs	r2, #1
 8003d26:	e005      	b.n	8003d34 <quant_all_bands+0x518>
         while(++fold_end < i && M*eBands[fold_end] < effective_lowband+norm_offset+N);
 8003d28:	f931 ef02 	ldrsh.w	lr, [r1, #2]!
 8003d2c:	fa0e fe04 	lsl.w	lr, lr, r4
 8003d30:	45e6      	cmp	lr, ip
 8003d32:	da02      	bge.n	8003d3a <quant_all_bands+0x51e>
 8003d34:	3201      	adds	r2, #1
 8003d36:	4296      	cmp	r6, r2
 8003d38:	dcf6      	bgt.n	8003d28 <quant_all_bands+0x50c>
         while(M*eBands[--fold_start] > effective_lowband+norm_offset);
 8003d3a:	f04f 0e00 	mov.w	lr, #0
 8003d3e:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
 8003d42:	46f4      	mov	ip, lr
 8003d44:	fb00 f001 	mul.w	r0, r0, r1
 8003d48:	f8d7 1700 	ldr.w	r1, [r7, #1792]	; 0x700
 8003d4c:	f8c7 472c 	str.w	r4, [r7, #1836]	; 0x72c
 8003d50:	eb01 0900 	add.w	r9, r1, r0
 8003d54:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
 8003d58:	f8d7 40b8 	ldr.w	r4, [r7, #184]	; 0xb8
 8003d5c:	1a41      	subs	r1, r0, r1
 8003d5e:	468a      	mov	sl, r1
 8003d60:	4649      	mov	r1, r9
 8003d62:	64fe      	str	r6, [r7, #76]	; 0x4c
           x_cm |= collapse_masks[fold_i*C+0];
 8003d64:	1a0e      	subs	r6, r1, r0
 8003d66:	f816 900a 	ldrb.w	r9, [r6, sl]
           y_cm |= collapse_masks[fold_i*C+C-1];
 8003d6a:	3301      	adds	r3, #1
 8003d6c:	f811 6c01 	ldrb.w	r6, [r1, #-1]
         } while (++fold_i<fold_end);
 8003d70:	429a      	cmp	r2, r3
           x_cm |= collapse_masks[fold_i*C+0];
 8003d72:	ea4c 0c09 	orr.w	ip, ip, r9
           y_cm |= collapse_masks[fold_i*C+C-1];
 8003d76:	ea4e 0e06 	orr.w	lr, lr, r6
 8003d7a:	4421      	add	r1, r4
         } while (++fold_i<fold_end);
 8003d7c:	dcf2      	bgt.n	8003d64 <quant_all_bands+0x548>
      if (dual_stereo && i==intensity)
 8003d7e:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
 8003d82:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
 8003d84:	f8d7 472c 	ldr.w	r4, [r7, #1836]	; 0x72c
 8003d88:	2b00      	cmp	r3, #0
 8003d8a:	d058      	beq.n	8003e3e <quant_all_bands+0x622>
 8003d8c:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
 8003d90:	42b3      	cmp	r3, r6
 8003d92:	f000 86c5 	beq.w	8004b20 <quant_all_bands+0x1304>
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8003d96:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
               effective_lowband != -1 ? norm+effective_lowband : NULL, LM,
 8003d9a:	ea4f 0948 	mov.w	r9, r8, lsl #1
 8003d9e:	f8c7 e04c 	str.w	lr, [r7, #76]	; 0x4c
 8003da2:	4663      	mov	r3, ip
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8003da4:	444a      	add	r2, r9
 8003da6:	ea4f 0a65 	mov.w	sl, r5, asr #1
 8003daa:	e6ad      	b.n	8003b08 <quant_all_bands+0x2ec>
         if (Y!=NULL)
 8003dac:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8003db0:	2b00      	cmp	r3, #0
 8003db2:	f000 85ee 	beq.w	8004992 <quant_all_bands+0x1176>
               ctx.theta_round = 0;
 8003db6:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
         x_cm = y_cm = (1<<B)-1;
 8003dba:	f8d7 c05c 	ldr.w	ip, [r7, #92]	; 0x5c
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8003dbe:	461a      	mov	r2, r3
         x_cm = y_cm = (1<<B)-1;
 8003dc0:	46e6      	mov	lr, ip
               ctx.theta_round = 0;
 8003dc2:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8003dc6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8003dca:	42b3      	cmp	r3, r6
 8003dcc:	f000 86da 	beq.w	8004b84 <quant_all_bands+0x1368>
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, x_cm|y_cm);
 8003dd0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8003dd4:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 8003dd8:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
 8003ddc:	40a3      	lsls	r3, r4
 8003dde:	1a5b      	subs	r3, r3, r1
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8003de0:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8003de4:	eb01 0343 	add.w	r3, r1, r3, lsl #1
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, x_cm|y_cm);
 8003de8:	ea4c 010e 	orr.w	r1, ip, lr
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8003dec:	9106      	str	r1, [sp, #24]
 8003dee:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 8003df2:	e9cd 2402 	strd	r2, r4, [sp, #8]
 8003df6:	e9cd 3104 	strd	r3, r1, [sp, #16]
 8003dfa:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8003dfe:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8003e02:	e9cd 5300 	strd	r5, r3, [sp]
 8003e06:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8003e08:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8003e0c:	f507 7090 	add.w	r0, r7, #288	; 0x120
 8003e10:	f7fe fc96 	bl	8002740 <quant_band_stereo>
 8003e14:	2300      	movs	r3, #0
 8003e16:	4606      	mov	r6, r0
 8003e18:	f8c7 3714 	str.w	r3, [r7, #1812]	; 0x714
 8003e1c:	e6c4      	b.n	8003ba8 <quant_all_bands+0x38c>
         Y = NULL;
 8003e1e:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8003e22:	e708      	b.n	8003c36 <quant_all_bands+0x41a>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 8003e24:	f1ba 0f00 	cmp.w	sl, #0
 8003e28:	f000 8543 	beq.w	80048b2 <quant_all_bands+0x1096>
      if (i == start+1)
 8003e2c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 8003e30:	f8c7 60b4 	str.w	r6, [r7, #180]	; 0xb4
      if (i == start+1)
 8003e34:	42b3      	cmp	r3, r6
 8003e36:	f47f ae23 	bne.w	8003a80 <quant_all_bands+0x264>
 8003e3a:	f000 bd63 	b.w	8004904 <quant_all_bands+0x10e8>
         if (Y!=NULL)
 8003e3e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8003e42:	2b00      	cmp	r3, #0
 8003e44:	f000 84d2 	beq.w	80047ec <quant_all_bands+0xfd0>
               ctx.theta_round = 0;
 8003e48:	2300      	movs	r3, #0
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8003e4a:	f1b8 3fff 	cmp.w	r8, #4294967295
               ctx.theta_round = 0;
 8003e4e:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8003e52:	bf16      	itet	ne
 8003e54:	f8d7 30ac 	ldrne.w	r3, [r7, #172]	; 0xac
 8003e58:	2200      	moveq	r2, #0
 8003e5a:	eb03 0248 	addne.w	r2, r3, r8, lsl #1
 8003e5e:	e7b2      	b.n	8003dc6 <quant_all_bands+0x5aa>
   if (d>256)
 8003e60:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
      return -(opus_int32)celt_udiv(-n, d);
 8003e64:	f1cb 0200 	rsb	r2, fp, #0
   if (d>256)
 8003e68:	f240 84f2 	bls.w	8004850 <quant_all_bands+0x1034>
      return n/d;
 8003e6c:	fbb2 f3f3 	udiv	r3, r2, r3
      return -(opus_int32)celt_udiv(-n, d);
 8003e70:	425b      	negs	r3, r3
 8003e72:	e5df      	b.n	8003a34 <quant_all_bands+0x218>
 8003e74:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8003e76:	46aa      	mov	sl, r5
 8003e78:	429e      	cmp	r6, r3
 8003e7a:	46a0      	mov	r8, r4
 8003e7c:	f6ff ada2 	blt.w	80039c4 <quant_all_bands+0x1a8>
 8003e80:	f8d7 6148 	ldr.w	r6, [r7, #328]	; 0x148
   }
   *seed = ctx.seed;
 8003e84:	f8d7 3734 	ldr.w	r3, [r7, #1844]	; 0x734

   RESTORE_STACK;
}
 8003e88:	f207 67d4 	addw	r7, r7, #1748	; 0x6d4
   *seed = ctx.seed;
 8003e8c:	601e      	str	r6, [r3, #0]
}
 8003e8e:	46bd      	mov	sp, r7
 8003e90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 8003e94:	2200      	movs	r2, #0
 8003e96:	e665      	b.n	8003b64 <quant_all_bands+0x348>
      t = EC_ILOG(d&-d);
 8003e98:	425a      	negs	r2, r3
 8003e9a:	401a      	ands	r2, r3
 8003e9c:	fab2 f282 	clz	r2, r2
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8003ea0:	48d7      	ldr	r0, [pc, #860]	; (8004200 <quant_all_bands+0x9e4>)
      t = EC_ILOG(d&-d);
 8003ea2:	f1c2 0220 	rsb	r2, r2, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8003ea6:	fa23 f102 	lsr.w	r1, r3, r2
 8003eaa:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
 8003eae:	1e50      	subs	r0, r2, #1
 8003eb0:	fa2b f000 	lsr.w	r0, fp, r0
 8003eb4:	fba0 0101 	umull	r0, r1, r0, r1
      return q+(n-q*d >= d);
 8003eb8:	fb03 b211 	mls	r2, r3, r1, fp
 8003ebc:	429a      	cmp	r2, r3
 8003ebe:	bf34      	ite	cc
 8003ec0:	460b      	movcc	r3, r1
 8003ec2:	1c4b      	addcs	r3, r1, #1
 8003ec4:	e5b6      	b.n	8003a34 <quant_all_bands+0x218>
 8003ec6:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8003eca:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
         x_cm = y_cm = (1<<B)-1;
 8003ece:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
 8003ed2:	4619      	mov	r1, r3
 8003ed4:	4613      	mov	r3, r2
 8003ed6:	fb01 f303 	mul.w	r3, r1, r3
 8003eda:	f8d7 1718 	ldr.w	r1, [r7, #1816]	; 0x718
 8003ede:	657b      	str	r3, [r7, #84]	; 0x54
 8003ee0:	42a1      	cmp	r1, r4
 8003ee2:	bfa8      	it	ge
 8003ee4:	4621      	movge	r1, r4
 8003ee6:	64f9      	str	r1, [r7, #76]	; 0x4c
 8003ee8:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8003eea:	f8d7 471c 	ldr.w	r4, [r7, #1820]	; 0x71c
 8003eee:	f8c7 10bc 	str.w	r1, [r7, #188]	; 0xbc
 8003ef2:	4611      	mov	r1, r2
 8003ef4:	4602      	mov	r2, r0
 8003ef6:	fb01 f202 	mul.w	r2, r1, r2
 8003efa:	653a      	str	r2, [r7, #80]	; 0x50
 8003efc:	0082      	lsls	r2, r0, #2
 8003efe:	1f11      	subs	r1, r2, #4
 8003f00:	1861      	adds	r1, r4, r1
 8003f02:	6739      	str	r1, [r7, #112]	; 0x70
 8003f04:	f8d7 1708 	ldr.w	r1, [r7, #1800]	; 0x708
   lowband_offset = 0;
 8003f08:	f8c7 50b4 	str.w	r5, [r7, #180]	; 0xb4
 8003f0c:	188a      	adds	r2, r1, r2
 8003f0e:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
 8003f12:	f8d7 2700 	ldr.w	r2, [r7, #1792]	; 0x700
         x_cm = y_cm = (1<<B)-1;
 8003f16:	4606      	mov	r6, r0
 8003f18:	18d3      	adds	r3, r2, r3
 8003f1a:	677b      	str	r3, [r7, #116]	; 0x74
 8003f1c:	f8d7 3730 	ldr.w	r3, [r7, #1840]	; 0x730
 8003f20:	4655      	mov	r5, sl
 8003f22:	1a1b      	subs	r3, r3, r0
 8003f24:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 8003f28:	4644      	mov	r4, r8
 8003f2a:	e0e9      	b.n	8004100 <quant_all_bands+0x8e4>
         curr_balance = celt_sudiv(balance, IMIN(3, codedBands-i));
 8003f2c:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
   if (n<0)
 8003f30:	f8d7 3724 	ldr.w	r3, [r7, #1828]	; 0x724
 8003f34:	2903      	cmp	r1, #3
 8003f36:	bfa8      	it	ge
 8003f38:	2103      	movge	r1, #3
 8003f3a:	2b00      	cmp	r3, #0
 8003f3c:	f2c0 83ec 	blt.w	8004718 <quant_all_bands+0xefc>
   if (d>256)
 8003f40:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8003f44:	f240 83f4 	bls.w	8004730 <quant_all_bands+0xf14>
      return n/d;
 8003f48:	fbb3 f1f1 	udiv	r1, r3, r1
         b = IMAX(0, IMIN(16383, IMIN(remaining_bits+1,pulses[i]+curr_balance)));
 8003f4c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8003f50:	681b      	ldr	r3, [r3, #0]
 8003f52:	4419      	add	r1, r3
 8003f54:	4288      	cmp	r0, r1
 8003f56:	4603      	mov	r3, r0
 8003f58:	bfa8      	it	ge
 8003f5a:	460b      	movge	r3, r1
 8003f5c:	f383 030e 	usat	r3, #14, r3
 8003f60:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 8003f64:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8003f66:	2b00      	cmp	r3, #0
 8003f68:	f000 8108 	beq.w	800417c <quant_all_bands+0x960>
 8003f6c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8003f70:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8003f72:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
 8003f76:	f9b2 2000 	ldrsh.w	r2, [r2]
 8003f7a:	40a3      	lsls	r3, r4
 8003f7c:	eba3 030b 	sub.w	r3, r3, fp
 8003f80:	40a2      	lsls	r2, r4
 8003f82:	4293      	cmp	r3, r2
 8003f84:	f280 81e4 	bge.w	8004350 <quant_all_bands+0xb34>
 8003f88:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8003f8c:	429e      	cmp	r6, r3
 8003f8e:	f000 84e6 	beq.w	800495e <quant_all_bands+0x1142>
      tf_change = tf_res[i];
 8003f92:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8003f94:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8003f98:	673a      	str	r2, [r7, #112]	; 0x70
      if (i>=m->effEBands)
 8003f9a:	6fba      	ldr	r2, [r7, #120]	; 0x78
      ctx.tf_change = tf_change;
 8003f9c:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
      if (i>=m->effEBands)
 8003fa0:	68d2      	ldr	r2, [r2, #12]
 8003fa2:	42b2      	cmp	r2, r6
 8003fa4:	f340 811a 	ble.w	80041dc <quant_all_bands+0x9c0>
      X = X_+M*eBands[i];
 8003fa8:	f8d7 26f8 	ldr.w	r2, [r7, #1784]	; 0x6f8
 8003fac:	4442      	add	r2, r8
 8003fae:	66fa      	str	r2, [r7, #108]	; 0x6c
      if (last && !theta_rdo)
 8003fb0:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8003fb4:	4296      	cmp	r6, r2
 8003fb6:	f000 855f 	beq.w	8004a78 <quant_all_bands+0x125c>
      if (lowband_offset != 0 && (spread!=SPREAD_AGGRESSIVE || B>1 || tf_change<0))
 8003fba:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8003fbe:	b162      	cbz	r2, 8003fda <quant_all_bands+0x7be>
 8003fc0:	f8d7 2710 	ldr.w	r2, [r7, #1808]	; 0x710
 8003fc4:	2a03      	cmp	r2, #3
 8003fc6:	f040 811d 	bne.w	8004204 <quant_all_bands+0x9e8>
 8003fca:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8003fce:	2a01      	cmp	r2, #1
 8003fd0:	f300 8118 	bgt.w	8004204 <quant_all_bands+0x9e8>
 8003fd4:	2b00      	cmp	r3, #0
 8003fd6:	f2c0 8115 	blt.w	8004204 <quant_all_bands+0x9e8>
      if (dual_stereo && i==intensity)
 8003fda:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
 8003fde:	2b00      	cmp	r3, #0
 8003fe0:	f000 8176 	beq.w	80042d0 <quant_all_bands+0xab4>
 8003fe4:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
 8003fe8:	42b3      	cmp	r3, r6
 8003fea:	f000 8580 	beq.w	8004aee <quant_all_bands+0x12d2>
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8003fee:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8003ff0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8003ff4:	66ba      	str	r2, [r7, #104]	; 0x68
 8003ff6:	105d      	asrs	r5, r3, #1
 8003ff8:	f06f 0901 	mvn.w	r9, #1
 8003ffc:	4613      	mov	r3, r2
      int effective_lowband=-1;
 8003ffe:	f04f 38ff 	mov.w	r8, #4294967295
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8004002:	2200      	movs	r2, #0
 8004004:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
 8004008:	428e      	cmp	r6, r1
 800400a:	f000 8550 	beq.w	8004aae <quant_all_bands+0x1292>
 800400e:	f647 71ff 	movw	r1, #32767	; 0x7fff
 8004012:	9306      	str	r3, [sp, #24]
 8004014:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
 8004018:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
         x_cm = quant_band(&ctx, X, N, b/2, B,
 800401c:	e9cd 1304 	strd	r1, r3, [sp, #16]
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
 8004020:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8004024:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
 8004026:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
         x_cm = quant_band(&ctx, X, N, b/2, B,
 800402a:	9201      	str	r2, [sp, #4]
               last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm);
 800402c:	40a3      	lsls	r3, r4
 800402e:	1a1b      	subs	r3, r3, r0
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8004030:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 8004034:	465a      	mov	r2, fp
 8004036:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 800403a:	e9cd 4302 	strd	r4, r3, [sp, #8]
 800403e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8004042:	f507 7090 	add.w	r0, r7, #288	; 0x120
 8004046:	9300      	str	r3, [sp, #0]
 8004048:	462b      	mov	r3, r5
 800404a:	f7fd feed 	bl	8001e28 <quant_band>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 800404e:	f1b8 3fff 	cmp.w	r8, #4294967295
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8004052:	4682      	mov	sl, r0
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 8004054:	f000 836a 	beq.w	800472c <quant_all_bands+0xf10>
 8004058:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800405a:	eb03 0209 	add.w	r2, r3, r9
               last?NULL:norm2+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, y_cm);
 800405e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8004062:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 8004066:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
 800406a:	40a3      	lsls	r3, r4
 800406c:	1a5b      	subs	r3, r3, r1
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 800406e:	6e79      	ldr	r1, [r7, #100]	; 0x64
 8004070:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8004074:	f647 70ff 	movw	r0, #32767	; 0x7fff
 8004078:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 800407a:	e9cd 4302 	strd	r4, r3, [sp, #8]
 800407e:	9106      	str	r1, [sp, #24]
 8004080:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8004084:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 8004088:	9201      	str	r2, [sp, #4]
 800408a:	9105      	str	r1, [sp, #20]
 800408c:	9300      	str	r3, [sp, #0]
 800408e:	9004      	str	r0, [sp, #16]
 8004090:	462b      	mov	r3, r5
 8004092:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
 8004096:	465a      	mov	r2, fp
 8004098:	f507 7090 	add.w	r0, r7, #288	; 0x120
 800409c:	f7fd fec4 	bl	8001e28 <quant_band>
      collapse_masks[i*C+0] = (unsigned char)x_cm;
 80040a0:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80040a2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80040a4:	6d39      	ldr	r1, [r7, #80]	; 0x50
 80040a6:	1ad3      	subs	r3, r2, r3
 80040a8:	f803 a001 	strb.w	sl, [r3, r1]
      balance += pulses[i] + tell;
 80040ac:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
 80040b0:	f802 0c01 	strb.w	r0, [r2, #-1]
      balance += pulses[i] + tell;
 80040b4:	f851 3b04 	ldr.w	r3, [r1], #4
      collapse_masks[i*C+C-1] = (unsigned char)y_cm;
 80040b8:	3601      	adds	r6, #1
      balance += pulses[i] + tell;
 80040ba:	f8c7 1088 	str.w	r1, [r7, #136]	; 0x88
      update_lowband = b>(N<<BITRES);
 80040be:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
 80040c2:	ebb1 0fcb 	cmp.w	r1, fp, lsl #3
      balance += pulses[i] + tell;
 80040c6:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
      update_lowband = b>(N<<BITRES);
 80040ca:	bfc8      	it	gt
 80040cc:	2501      	movgt	r5, #1
      balance += pulses[i] + tell;
 80040ce:	440b      	add	r3, r1
      ctx.avoid_split_noise = 0;
 80040d0:	f04f 0100 	mov.w	r1, #0
 80040d4:	f8c7 1158 	str.w	r1, [r7, #344]	; 0x158
 80040d8:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
      update_lowband = b>(N<<BITRES);
 80040dc:	bfd8      	it	le
 80040de:	2500      	movle	r5, #0
 80040e0:	3901      	subs	r1, #1
 80040e2:	f8c7 108c 	str.w	r1, [r7, #140]	; 0x8c
 80040e6:	f8d7 10b8 	ldr.w	r1, [r7, #184]	; 0xb8
 80040ea:	440a      	add	r2, r1
 80040ec:	677a      	str	r2, [r7, #116]	; 0x74
      balance += pulses[i] + tell;
 80040ee:	f8d7 2724 	ldr.w	r2, [r7, #1828]	; 0x724
 80040f2:	441a      	add	r2, r3
   for (i=start;i<end;i++)
 80040f4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
      balance += pulses[i] + tell;
 80040f6:	f8c7 2724 	str.w	r2, [r7, #1828]	; 0x724
   for (i=start;i<end;i++)
 80040fa:	429e      	cmp	r6, r3
 80040fc:	f6bf aeba 	bge.w	8003e74 <quant_all_bands+0x658>
      X = X_+M*eBands[i];
 8004100:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8004104:	f933 2b02 	ldrsh.w	r2, [r3], #2
      ctx.i = i;
 8004108:	f8c7 612c 	str.w	r6, [r7, #300]	; 0x12c
      X = X_+M*eBands[i];
 800410c:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
      if (Y_!=NULL)
 8004110:	f8d7 36fc 	ldr.w	r3, [r7, #1788]	; 0x6fc
      X = X_+M*eBands[i];
 8004114:	fa02 f804 	lsl.w	r8, r2, r4
 8004118:	ea4f 0848 	mov.w	r8, r8, lsl #1
      if (Y_!=NULL)
 800411c:	2b00      	cmp	r3, #0
 800411e:	f000 8114 	beq.w	800434a <quant_all_bands+0xb2e>
         Y = Y_+M*eBands[i];
 8004122:	4443      	add	r3, r8
 8004124:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
      N = M*eBands[i+1]-M*eBands[i];
 8004128:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
      tell = ec_tell_frac(ec);
 800412c:	f8d7 0728 	ldr.w	r0, [r7, #1832]	; 0x728
      N = M*eBands[i+1]-M*eBands[i];
 8004130:	f9b3 3000 	ldrsh.w	r3, [r3]
 8004134:	1a9b      	subs	r3, r3, r2
 8004136:	fa03 fb04 	lsl.w	fp, r3, r4
      tell = ec_tell_frac(ec);
 800413a:	f004 f8c1 	bl	80082c0 <ec_tell_frac>
      if (i != start)
 800413e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
      tell = ec_tell_frac(ec);
 8004142:	f8c7 0094 	str.w	r0, [r7, #148]	; 0x94
      if (i != start)
 8004146:	42b3      	cmp	r3, r6
 8004148:	d004      	beq.n	8004154 <quant_all_bands+0x938>
         balance -= tell;
 800414a:	f8d7 3724 	ldr.w	r3, [r7, #1828]	; 0x724
 800414e:	1a1b      	subs	r3, r3, r0
 8004150:	f8c7 3724 	str.w	r3, [r7, #1828]	; 0x724
      remaining_bits = total_bits-tell-1;
 8004154:	f8d7 3720 	ldr.w	r3, [r7, #1824]	; 0x720
 8004158:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 800415c:	1a98      	subs	r0, r3, r2
 800415e:	1e43      	subs	r3, r0, #1
      ctx.remaining_bits = remaining_bits;
 8004160:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
      if (i <= codedBands-1)
 8004164:	f8d7 3730 	ldr.w	r3, [r7, #1840]	; 0x730
 8004168:	42b3      	cmp	r3, r6
 800416a:	f73f aedf 	bgt.w	8003f2c <quant_all_bands+0x710>
         b = 0;
 800416e:	2300      	movs	r3, #0
 8004170:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 8004174:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8004176:	2b00      	cmp	r3, #0
 8004178:	f47f aef8 	bne.w	8003f6c <quant_all_bands+0x750>
      if (i == start+1)
 800417c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8004180:	429e      	cmp	r6, r3
 8004182:	f47f af06 	bne.w	8003f92 <quant_all_bands+0x776>
         special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
 8004186:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   n2 = M*(eBands[start+2]-eBands[start+1]);
 8004188:	6a78      	ldr	r0, [r7, #36]	; 0x24
         special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
 800418a:	699a      	ldr	r2, [r3, #24]
   n1 = M*(eBands[start+1]-eBands[start]);
 800418c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800418e:	5ed1      	ldrsh	r1, [r2, r3]
 8004190:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8004192:	5ed3      	ldrsh	r3, [r2, r3]
   n2 = M*(eBands[start+2]-eBands[start+1]);
 8004194:	5e12      	ldrsh	r2, [r2, r0]
   n1 = M*(eBands[start+1]-eBands[start]);
 8004196:	1acb      	subs	r3, r1, r3
   n2 = M*(eBands[start+2]-eBands[start+1]);
 8004198:	1a52      	subs	r2, r2, r1
   n1 = M*(eBands[start+1]-eBands[start]);
 800419a:	40a3      	lsls	r3, r4
   n2 = M*(eBands[start+2]-eBands[start+1]);
 800419c:	40a2      	lsls	r2, r4
   OPUS_COPY(&norm[n1], &norm[2*n1 - n2], n2-n1);
 800419e:	ea4f 0943 	mov.w	r9, r3, lsl #1
 80041a2:	1ad3      	subs	r3, r2, r3
 80041a4:	005d      	lsls	r5, r3, #1
 80041a6:	eba9 0202 	sub.w	r2, r9, r2
 80041aa:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80041ae:	ea4f 0a42 	mov.w	sl, r2, lsl #1
 80041b2:	eb03 010a 	add.w	r1, r3, sl
 80041b6:	eb03 0009 	add.w	r0, r3, r9
 80041ba:	462a      	mov	r2, r5
 80041bc:	f00f ff90 	bl	80140e0 <memcpy>
   if (dual_stereo)
 80041c0:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
 80041c4:	2b00      	cmp	r3, #0
 80041c6:	f43f aee4 	beq.w	8003f92 <quant_all_bands+0x776>
      OPUS_COPY(&norm2[n1], &norm2[2*n1 - n2], n2-n1);
 80041ca:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80041cc:	462a      	mov	r2, r5
 80041ce:	eb03 010a 	add.w	r1, r3, sl
 80041d2:	eb03 0009 	add.w	r0, r3, r9
 80041d6:	f00f ff83 	bl	80140e0 <memcpy>
 80041da:	e6da      	b.n	8003f92 <quant_all_bands+0x776>
            Y = norm;
 80041dc:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
 80041e0:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 80041e4:	460d      	mov	r5, r1
 80041e6:	f8d7 06fc 	ldr.w	r0, [r7, #1788]	; 0x6fc
 80041ea:	66fa      	str	r2, [r7, #108]	; 0x6c
 80041ec:	2800      	cmp	r0, #0
 80041ee:	bf18      	it	ne
 80041f0:	4615      	movne	r5, r2
 80041f2:	2200      	movs	r2, #0
 80041f4:	f8c7 50b0 	str.w	r5, [r7, #176]	; 0xb0
 80041f8:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
 80041fc:	e6d8      	b.n	8003fb0 <quant_all_bands+0x794>
 80041fe:	bf00      	nop
 8004200:	0801649c 	.word	0x0801649c
         effective_lowband = IMAX(0, M*eBands[lowband_offset]-norm_offset-N);
 8004204:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8004208:	f8d7 00b4 	ldr.w	r0, [r7, #180]	; 0xb4
 800420c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8004210:	f932 8010 	ldrsh.w	r8, [r2, r0, lsl #1]
 8004214:	0041      	lsls	r1, r0, #1
 8004216:	fa08 f804 	lsl.w	r8, r8, r4
 800421a:	eba8 0803 	sub.w	r8, r8, r3
 800421e:	eba8 080b 	sub.w	r8, r8, fp
 8004222:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
 8004226:	eb03 0508 	add.w	r5, r3, r8
 800422a:	eb02 0c01 	add.w	ip, r2, r1
         while(M*eBands[--fold_start] > effective_lowband+norm_offset);
 800422e:	e000      	b.n	8004232 <quant_all_bands+0xa16>
 8004230:	4618      	mov	r0, r3
 8004232:	f93c 2d02 	ldrsh.w	r2, [ip, #-2]!
 8004236:	1e43      	subs	r3, r0, #1
 8004238:	40a2      	lsls	r2, r4
 800423a:	42aa      	cmp	r2, r5
 800423c:	dcf8      	bgt.n	8004230 <quant_all_bands+0xa14>
 800423e:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8004242:	3902      	subs	r1, #2
 8004244:	4411      	add	r1, r2
         fold_end = lowband_offset-1;
 8004246:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
         while(++fold_end < i && M*eBands[fold_end] < effective_lowband+norm_offset+N);
 800424a:	445d      	add	r5, fp
         fold_end = lowband_offset-1;
 800424c:	3a01      	subs	r2, #1
         while(++fold_end < i && M*eBands[fold_end] < effective_lowband+norm_offset+N);
 800424e:	e005      	b.n	800425c <quant_all_bands+0xa40>
 8004250:	f931 cf02 	ldrsh.w	ip, [r1, #2]!
 8004254:	fa0c fc04 	lsl.w	ip, ip, r4
 8004258:	45ac      	cmp	ip, r5
 800425a:	da02      	bge.n	8004262 <quant_all_bands+0xa46>
 800425c:	3201      	adds	r2, #1
 800425e:	42b2      	cmp	r2, r6
 8004260:	dbf6      	blt.n	8004250 <quant_all_bands+0xa34>
         while(M*eBands[--fold_start] > effective_lowband+norm_offset);
 8004262:	2100      	movs	r1, #0
 8004264:	4689      	mov	r9, r1
 8004266:	f8d7 50b8 	ldr.w	r5, [r7, #184]	; 0xb8
 800426a:	468c      	mov	ip, r1
 800426c:	fb05 f000 	mul.w	r0, r5, r0
 8004270:	f8d7 1700 	ldr.w	r1, [r7, #1792]	; 0x700
 8004274:	eba0 0a05 	sub.w	sl, r0, r5
 8004278:	eb01 0e00 	add.w	lr, r1, r0
 800427c:	464d      	mov	r5, r9
 800427e:	4671      	mov	r1, lr
 8004280:	f8c7 472c 	str.w	r4, [r7, #1836]	; 0x72c
 8004284:	f8d7 40b8 	ldr.w	r4, [r7, #184]	; 0xb8
           x_cm |= collapse_masks[fold_i*C+0];
 8004288:	eba1 0e00 	sub.w	lr, r1, r0
 800428c:	f81e 900a 	ldrb.w	r9, [lr, sl]
           y_cm |= collapse_masks[fold_i*C+C-1];
 8004290:	3301      	adds	r3, #1
 8004292:	f811 ec01 	ldrb.w	lr, [r1, #-1]
         } while (++fold_i<fold_end);
 8004296:	4293      	cmp	r3, r2
           x_cm |= collapse_masks[fold_i*C+0];
 8004298:	ea4c 0c09 	orr.w	ip, ip, r9
           y_cm |= collapse_masks[fold_i*C+C-1];
 800429c:	ea45 050e 	orr.w	r5, r5, lr
 80042a0:	4421      	add	r1, r4
         } while (++fold_i<fold_end);
 80042a2:	dbf1      	blt.n	8004288 <quant_all_bands+0xa6c>
      if (dual_stereo && i==intensity)
 80042a4:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
 80042a8:	66bd      	str	r5, [r7, #104]	; 0x68
 80042aa:	f8d7 472c 	ldr.w	r4, [r7, #1836]	; 0x72c
 80042ae:	2b00      	cmp	r3, #0
 80042b0:	d059      	beq.n	8004366 <quant_all_bands+0xb4a>
 80042b2:	f8d7 3718 	ldr.w	r3, [r7, #1816]	; 0x718
 80042b6:	42b3      	cmp	r3, r6
 80042b8:	f000 841e 	beq.w	8004af8 <quant_all_bands+0x12dc>
         x_cm = quant_band(&ctx, X, N, b/2, B,
 80042bc:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 80042c0:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
               effective_lowband != -1 ? norm+effective_lowband : NULL, LM,
 80042c4:	ea4f 0948 	mov.w	r9, r8, lsl #1
 80042c8:	4663      	mov	r3, ip
         x_cm = quant_band(&ctx, X, N, b/2, B,
 80042ca:	444a      	add	r2, r9
 80042cc:	104d      	asrs	r5, r1, #1
 80042ce:	e699      	b.n	8004004 <quant_all_bands+0x7e8>
         if (Y!=NULL)
 80042d0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80042d4:	2b00      	cmp	r3, #0
 80042d6:	f000 8357 	beq.w	8004988 <quant_all_bands+0x116c>
            if (theta_rdo && i < intensity)
 80042da:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80042dc:	2a00      	cmp	r2, #0
 80042de:	f040 824c 	bne.w	800477a <quant_all_bands+0xf5e>
         x_cm = y_cm = (1<<B)-1;
 80042e2:	f8d7 c05c 	ldr.w	ip, [r7, #92]	; 0x5c
               ctx.theta_round = 0;
 80042e6:	f8c7 2150 	str.w	r2, [r7, #336]	; 0x150
         x_cm = y_cm = (1<<B)-1;
 80042ea:	f8c7 c068 	str.w	ip, [r7, #104]	; 0x68
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 80042ee:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80042f2:	429e      	cmp	r6, r3
 80042f4:	f000 8449 	beq.w	8004b8a <quant_all_bands+0x136e>
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, x_cm|y_cm);
 80042f8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80042fc:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 8004300:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
 8004304:	40a3      	lsls	r3, r4
 8004306:	1a5b      	subs	r3, r3, r1
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8004308:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 800430c:	eb01 0343 	add.w	r3, r1, r3, lsl #1
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, x_cm|y_cm);
 8004310:	6eb9      	ldr	r1, [r7, #104]	; 0x68
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8004312:	e9cd 2402 	strd	r2, r4, [sp, #8]
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, x_cm|y_cm);
 8004316:	ea4c 0501 	orr.w	r5, ip, r1
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 800431a:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 800431e:	9506      	str	r5, [sp, #24]
 8004320:	e9cd 3104 	strd	r3, r1, [sp, #16]
 8004324:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8004328:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800432c:	9301      	str	r3, [sp, #4]
 800432e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8004332:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 8004334:	9300      	str	r3, [sp, #0]
 8004336:	f507 7090 	add.w	r0, r7, #288	; 0x120
 800433a:	465b      	mov	r3, fp
 800433c:	f7fe fa00 	bl	8002740 <quant_band_stereo>
 8004340:	2300      	movs	r3, #0
 8004342:	4682      	mov	sl, r0
 8004344:	f8c7 3714 	str.w	r3, [r7, #1812]	; 0x714
 8004348:	e6aa      	b.n	80040a0 <quant_all_bands+0x884>
         Y = NULL;
 800434a:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 800434e:	e6eb      	b.n	8004128 <quant_all_bands+0x90c>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 8004350:	2d00      	cmp	r5, #0
 8004352:	f000 82bc 	beq.w	80048ce <quant_all_bands+0x10b2>
      if (i == start+1)
 8004356:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800435a:	f8c7 60b4 	str.w	r6, [r7, #180]	; 0xb4
 800435e:	429e      	cmp	r6, r3
 8004360:	f47f ae17 	bne.w	8003f92 <quant_all_bands+0x776>
 8004364:	e70f      	b.n	8004186 <quant_all_bands+0x96a>
         if (Y!=NULL)
 8004366:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800436a:	2b00      	cmp	r3, #0
 800436c:	f000 820c 	beq.w	8004788 <quant_all_bands+0xf6c>
            if (theta_rdo && i < intensity)
 8004370:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004372:	2b00      	cmp	r3, #0
 8004374:	f000 81c5 	beq.w	8004702 <quant_all_bands+0xee6>
               compute_channel_weights(bandE[i], bandE[i+m->nbEBands], w);
 8004378:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800437a:	f8d7 2704 	ldr.w	r2, [r7, #1796]	; 0x704
 800437e:	689b      	ldr	r3, [r3, #8]
 8004380:	f8d7 1704 	ldr.w	r1, [r7, #1796]	; 0x704
 8004384:	4433      	add	r3, r6
 8004386:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 800438a:	f852 2026 	ldr.w	r2, [r2, r6, lsl #2]
   Ex = ADD32(Ex, minE/3);
 800438e:	4ba8      	ldr	r3, [pc, #672]	; (8004630 <quant_all_bands+0xe14>)
   minE = MIN32(Ex, Ey);
 8004390:	428a      	cmp	r2, r1
 8004392:	4610      	mov	r0, r2
 8004394:	bfa8      	it	ge
 8004396:	4608      	movge	r0, r1
   Ex = ADD32(Ex, minE/3);
 8004398:	fb83 5300 	smull	r5, r3, r3, r0
 800439c:	eba3 73e0 	sub.w	r3, r3, r0, asr #31
   Ey = ADD32(Ey, minE/3);
 80043a0:	4419      	add	r1, r3
   Ex = ADD32(Ex, minE/3);
 80043a2:	441a      	add	r2, r3
   shift = celt_ilog2(EPSILON+MAX32(Ex, Ey))-14;
 80043a4:	428a      	cmp	r2, r1
 80043a6:	4613      	mov	r3, r2
 80043a8:	bfb8      	it	lt
 80043aa:	460b      	movlt	r3, r1
 80043ac:	3301      	adds	r3, #1
   return EC_ILOG(x)-1;
 80043ae:	fab3 f383 	clz	r3, r3
 80043b2:	f1c3 031f 	rsb	r3, r3, #31
 80043b6:	f1a3 000e 	sub.w	r0, r3, #14
   w[0] = VSHR32(Ex, shift);
 80043ba:	2800      	cmp	r0, #0
 80043bc:	f340 82f5 	ble.w	80049aa <quant_all_bands+0x118e>
 80043c0:	4102      	asrs	r2, r0
 80043c2:	b213      	sxth	r3, r2
   w[1] = VSHR32(Ey, shift);
 80043c4:	4101      	asrs	r1, r0
   w[0] = VSHR32(Ex, shift);
 80043c6:	61fb      	str	r3, [r7, #28]
   w[1] = VSHR32(Ey, shift);
 80043c8:	b20b      	sxth	r3, r1
 80043ca:	61bb      	str	r3, [r7, #24]
               ec_save = *ec;
 80043cc:	f8d7 3728 	ldr.w	r3, [r7, #1832]	; 0x728
 80043d0:	f107 0ac0 	add.w	sl, r7, #192	; 0xc0
 80043d4:	461d      	mov	r5, r3
 80043d6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80043d8:	e8aa 000f 	stmia.w	sl!, {r0, r1, r2, r3}
 80043dc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80043de:	e8aa 000f 	stmia.w	sl!, {r0, r1, r2, r3}
 80043e2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80043e6:	f8d7 5728 	ldr.w	r5, [r7, #1832]	; 0x728
               ctx_save = ctx;
 80043ea:	f507 7eae 	add.w	lr, r7, #348	; 0x15c
               ec_save = *ec;
 80043ee:	682d      	ldr	r5, [r5, #0]
               ctx_save = ctx;
 80043f0:	f507 7990 	add.w	r9, r7, #288	; 0x120
               ec_save = *ec;
 80043f4:	e88a 000f 	stmia.w	sl, {r0, r1, r2, r3}
               ctx_save = ctx;
 80043f8:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
               ec_save = *ec;
 80043fc:	617d      	str	r5, [r7, #20]
 80043fe:	f8d7 5728 	ldr.w	r5, [r7, #1832]	; 0x728
               ctx_save = ctx;
 8004402:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8004406:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
 800440a:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 800440e:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
 8004412:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8004416:	e899 0007 	ldmia.w	r9, {r0, r1, r2}
               OPUS_COPY(X_save, X, N);
 800441a:	ea4f 034b 	mov.w	r3, fp, lsl #1
 800441e:	4699      	mov	r9, r3
               ec_save = *ec;
 8004420:	686d      	ldr	r5, [r5, #4]
               OPUS_COPY(X_save, X, N);
 8004422:	63bb      	str	r3, [r7, #56]	; 0x38
               ec_save = *ec;
 8004424:	613d      	str	r5, [r7, #16]
 8004426:	f8d7 5728 	ldr.w	r5, [r7, #1832]	; 0x728
 800442a:	69ad      	ldr	r5, [r5, #24]
 800442c:	60fd      	str	r5, [r7, #12]
               ctx_save = ctx;
 800442e:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
               OPUS_COPY(X_save, X, N);
 8004432:	461a      	mov	r2, r3
               cm = x_cm|y_cm;
 8004434:	6ebb      	ldr	r3, [r7, #104]	; 0x68
               OPUS_COPY(X_save, X, N);
 8004436:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
               cm = x_cm|y_cm;
 8004438:	ea43 050c 	orr.w	r5, r3, ip
               OPUS_COPY(X_save, X, N);
 800443c:	6c38      	ldr	r0, [r7, #64]	; 0x40
               cm = x_cm|y_cm;
 800443e:	623d      	str	r5, [r7, #32]
               OPUS_COPY(X_save, X, N);
 8004440:	f00f fe4e 	bl	80140e0 <memcpy>
               OPUS_COPY(Y_save, Y, N);
 8004444:	464a      	mov	r2, r9
 8004446:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
 800444a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800444c:	f00f fe48 	bl	80140e0 <memcpy>
               ctx.theta_round = -1;
 8004450:	f04f 33ff 	mov.w	r3, #4294967295
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8004454:	4598      	cmp	r8, r3
               ctx.theta_round = -1;
 8004456:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 800445a:	bf0e      	itee	eq
 800445c:	2300      	moveq	r3, #0
 800445e:	f8d7 30ac 	ldrne.w	r3, [r7, #172]	; 0xac
 8004462:	eb03 0348 	addne.w	r3, r3, r8, lsl #1
 8004466:	66bb      	str	r3, [r7, #104]	; 0x68
 8004468:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800446c:	429e      	cmp	r6, r3
 800446e:	f000 83da 	beq.w	8004c26 <quant_all_bands+0x140a>
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, cm);
 8004472:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8004476:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 800447a:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
 800447e:	40a3      	lsls	r3, r4
 8004480:	1a9b      	subs	r3, r3, r2
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8004482:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8004486:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800448a:	6a3a      	ldr	r2, [r7, #32]
 800448c:	69fd      	ldr	r5, [r7, #28]
 800448e:	9206      	str	r2, [sp, #24]
 8004490:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8004494:	f8d7 806c 	ldr.w	r8, [r7, #108]	; 0x6c
 8004498:	e9cd 3204 	strd	r3, r2, [sp, #16]
 800449c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800449e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 80044a2:	9302      	str	r3, [sp, #8]
 80044a4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80044a8:	9403      	str	r4, [sp, #12]
 80044aa:	9301      	str	r3, [sp, #4]
 80044ac:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80044b0:	4641      	mov	r1, r8
 80044b2:	9300      	str	r3, [sp, #0]
 80044b4:	f507 7090 	add.w	r0, r7, #288	; 0x120
 80044b8:	465b      	mov	r3, fp
 80044ba:	042d      	lsls	r5, r5, #16
 80044bc:	61fd      	str	r5, [r7, #28]
 80044be:	f7fe f93f 	bl	8002740 <quant_band_stereo>
static OPUS_INLINE opus_val32 celt_inner_prod_c(const opus_val16 *x,
      const opus_val16 *y, int N)
{
   int i;
   opus_val32 xy=0;
   for (i=0;i<N;i++)
 80044c2:	f1bb 0f00 	cmp.w	fp, #0
 80044c6:	6078      	str	r0, [r7, #4]
   opus_val32 xy=0;
 80044c8:	f04f 0200 	mov.w	r2, #0
   for (i=0;i<N;i++)
 80044cc:	f340 82e7 	ble.w	8004a9e <quant_all_bands+0x1282>
 80044d0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80044d2:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80044d4:	3b02      	subs	r3, #2
 80044d6:	eb03 0c01 	add.w	ip, r3, r1
 80044da:	f1a8 0102 	sub.w	r1, r8, #2
      xy = MAC16_16(xy, x[i], y[i]);
 80044de:	f833 5f02 	ldrh.w	r5, [r3, #2]!
 80044e2:	f831 0f02 	ldrh.w	r0, [r1, #2]!
   for (i=0;i<N;i++)
 80044e6:	4563      	cmp	r3, ip
      xy = MAC16_16(xy, x[i], y[i]);
 80044e8:	fb15 2200 	smlabb	r2, r5, r0, r2
   for (i=0;i<N;i++)
 80044ec:	d1f7      	bne.n	80044de <quant_all_bands+0xcc2>
   opus_val32 xy=0;
 80044ee:	f04f 0900 	mov.w	r9, #0
  __asm__(
 80044f2:	69f9      	ldr	r1, [r7, #28]
 80044f4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80044f6:	4608      	mov	r0, r1
 80044f8:	fb82 1a00 	smull	r1, sl, r2, r0
 80044fc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80044fe:	3b02      	subs	r3, #2
 8004500:	189d      	adds	r5, r3, r2
 8004502:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
  return SHL32(rd_hi,1);
 8004506:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
 800450a:	3a02      	subs	r2, #2
      xy = MAC16_16(xy, x[i], y[i]);
 800450c:	f833 0f02 	ldrh.w	r0, [r3, #2]!
 8004510:	f832 1f02 	ldrh.w	r1, [r2, #2]!
   for (i=0;i<N;i++)
 8004514:	429d      	cmp	r5, r3
      xy = MAC16_16(xy, x[i], y[i]);
 8004516:	fb10 9901 	smlabb	r9, r0, r1, r9
   for (i=0;i<N;i++)
 800451a:	d1f7      	bne.n	800450c <quant_all_bands+0xcf0>
               ec_save2 = *ec;
 800451c:	f8d7 8728 	ldr.w	r8, [r7, #1832]	; 0x728
 8004520:	f107 0ef0 	add.w	lr, r7, #240	; 0xf0
 8004524:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 8004528:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 800452c:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 8004530:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8004534:	e898 000f 	ldmia.w	r8, {r0, r1, r2, r3}
               ctx_save2 = ctx;
 8004538:	f507 75cc 	add.w	r5, r7, #408	; 0x198
 800453c:	f507 7c90 	add.w	ip, r7, #288	; 0x120
               ec_save2 = *ec;
 8004540:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
               ctx_save2 = ctx;
 8004544:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004548:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800454a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800454e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8004550:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004554:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8004556:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
      : "%r"(b), "r"(SHL32(a,16))
 800455a:	69bb      	ldr	r3, [r7, #24]
               OPUS_COPY(X_save2, X, N);
 800455c:	f8d7 8038 	ldr.w	r8, [r7, #56]	; 0x38
 8004560:	041b      	lsls	r3, r3, #16
               ctx_save2 = ctx;
 8004562:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  __asm__(
 8004566:	469c      	mov	ip, r3
               OPUS_COPY(X_save2, X, N);
 8004568:	4642      	mov	r2, r8
 800456a:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
      : "%r"(b), "r"(SHL32(a,16))
 800456c:	60bb      	str	r3, [r7, #8]
 800456e:	6b78      	ldr	r0, [r7, #52]	; 0x34
  __asm__(
 8004570:	fb89 530c 	smull	r5, r3, r9, ip
               dist0 = MULT16_32_Q15(w[0], celt_inner_prod(X_save, X, N, arch)) + MULT16_32_Q15(w[1], celt_inner_prod(Y_save, Y, N, arch));
 8004574:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
 8004578:	61bb      	str	r3, [r7, #24]
               OPUS_COPY(X_save2, X, N);
 800457a:	f00f fdb1 	bl	80140e0 <memcpy>
               OPUS_COPY(Y_save2, Y, N);
 800457e:	4642      	mov	r2, r8
 8004580:	f8d7 10b0 	ldr.w	r1, [r7, #176]	; 0xb0
 8004584:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8004586:	f00f fdab 	bl	80140e0 <memcpy>
               if (!last)
 800458a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800458e:	429e      	cmp	r6, r3
 8004590:	d00f      	beq.n	80045b2 <quant_all_bands+0xd96>
                  OPUS_COPY(norm_save2, norm+M*eBands[i]-norm_offset, N);
 8004592:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8004596:	4642      	mov	r2, r8
 8004598:	f933 1c02 	ldrsh.w	r1, [r3, #-2]
 800459c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80045a0:	40a1      	lsls	r1, r4
 80045a2:	1ac9      	subs	r1, r1, r3
 80045a4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80045a8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80045aa:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 80045ae:	f00f fd97 	bl	80140e0 <memcpy>
               bytes_buf = ec_save.buf+nstart_bytes;
 80045b2:	68fb      	ldr	r3, [r7, #12]
               save_bytes = nend_bytes-nstart_bytes;
 80045b4:	693a      	ldr	r2, [r7, #16]
               bytes_buf = ec_save.buf+nstart_bytes;
 80045b6:	6979      	ldr	r1, [r7, #20]
               save_bytes = nend_bytes-nstart_bytes;
 80045b8:	eba2 0903 	sub.w	r9, r2, r3
               bytes_buf = ec_save.buf+nstart_bytes;
 80045bc:	4419      	add	r1, r3
               OPUS_COPY(bytes_save, bytes_buf, save_bytes);
 80045be:	464a      	mov	r2, r9
 80045c0:	f507 70ea 	add.w	r0, r7, #468	; 0x1d4
               bytes_buf = ec_save.buf+nstart_bytes;
 80045c4:	6179      	str	r1, [r7, #20]
               OPUS_COPY(bytes_save, bytes_buf, save_bytes);
 80045c6:	f00f fd8b 	bl	80140e0 <memcpy>
               *ec = ec_save;
 80045ca:	f8d7 8728 	ldr.w	r8, [r7, #1832]	; 0x728
 80045ce:	f107 0ec0 	add.w	lr, r7, #192	; 0xc0
 80045d2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80045d6:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
 80045da:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80045de:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
 80045e2:	e89e 000f 	ldmia.w	lr, {r0, r1, r2, r3}
               ctx = ctx_save;
 80045e6:	f507 75ae 	add.w	r5, r7, #348	; 0x15c
 80045ea:	f507 7c90 	add.w	ip, r7, #288	; 0x120
               *ec = ec_save;
 80045ee:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}
               ctx = ctx_save;
 80045f2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80045f4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80045f8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80045fa:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80045fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004600:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8004604:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
               OPUS_COPY(X, X_save, N);
 8004608:	6bbd      	ldr	r5, [r7, #56]	; 0x38
               ctx = ctx_save;
 800460a:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
               OPUS_COPY(X, X_save, N);
 800460e:	462a      	mov	r2, r5
 8004610:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8004612:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 8004614:	f00f fd64 	bl	80140e0 <memcpy>
               OPUS_COPY(Y, Y_save, N);
 8004618:	462a      	mov	r2, r5
 800461a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800461c:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
 8004620:	f00f fd5e 	bl	80140e0 <memcpy>
               if (i == start+1)
 8004624:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8004628:	429e      	cmp	r6, r3
 800462a:	f000 8300 	beq.w	8004c2e <quant_all_bands+0x1412>
 800462e:	e001      	b.n	8004634 <quant_all_bands+0xe18>
 8004630:	55555556 	.word	0x55555556
               ctx.theta_round = 1;
 8004634:	2301      	movs	r3, #1
 8004636:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 800463a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800463e:	429e      	cmp	r6, r3
 8004640:	f000 82f3 	beq.w	8004c2a <quant_all_bands+0x140e>
                     last?NULL:norm+M*eBands[i]-norm_offset, lowband_scratch, cm);
 8004644:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8004648:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 800464c:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
 8004650:	40a3      	lsls	r3, r4
 8004652:	1a9b      	subs	r3, r3, r2
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8004654:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8004658:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800465c:	6a3a      	ldr	r2, [r7, #32]
 800465e:	6efd      	ldr	r5, [r7, #108]	; 0x6c
 8004660:	9206      	str	r2, [sp, #24]
 8004662:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8004666:	9403      	str	r4, [sp, #12]
 8004668:	e9cd 3204 	strd	r3, r2, [sp, #16]
 800466c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800466e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8004672:	9302      	str	r3, [sp, #8]
 8004674:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8004678:	4629      	mov	r1, r5
 800467a:	9301      	str	r3, [sp, #4]
 800467c:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8004680:	f507 7090 	add.w	r0, r7, #288	; 0x120
 8004684:	9300      	str	r3, [sp, #0]
 8004686:	465b      	mov	r3, fp
 8004688:	f7fe f85a 	bl	8002740 <quant_band_stereo>
 800468c:	f1bb 0f00 	cmp.w	fp, #0
 8004690:	4682      	mov	sl, r0
   opus_val32 xy=0;
 8004692:	f04f 0200 	mov.w	r2, #0
   for (i=0;i<N;i++)
 8004696:	f340 81fb 	ble.w	8004a90 <quant_all_bands+0x1274>
 800469a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800469c:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800469e:	3b02      	subs	r3, #2
 80046a0:	eb03 0c01 	add.w	ip, r3, r1
 80046a4:	1ea9      	subs	r1, r5, #2
      xy = MAC16_16(xy, x[i], y[i]);
 80046a6:	f833 5f02 	ldrh.w	r5, [r3, #2]!
 80046aa:	f831 0f02 	ldrh.w	r0, [r1, #2]!
   for (i=0;i<N;i++)
 80046ae:	459c      	cmp	ip, r3
      xy = MAC16_16(xy, x[i], y[i]);
 80046b0:	fb15 2200 	smlabb	r2, r5, r0, r2
   for (i=0;i<N;i++)
 80046b4:	d1f7      	bne.n	80046a6 <quant_all_bands+0xe8a>
 80046b6:	69f9      	ldr	r1, [r7, #28]
 80046b8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80046ba:	4608      	mov	r0, r1
 80046bc:	fb82 1e00 	smull	r1, lr, r2, r0
 80046c0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80046c2:	3b02      	subs	r3, #2
 80046c4:	eb03 0c02 	add.w	ip, r3, r2
 80046c8:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
  return SHL32(rd_hi,1);
 80046cc:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80046d0:	1e91      	subs	r1, r2, #2
   opus_val32 xy=0;
 80046d2:	2200      	movs	r2, #0
      xy = MAC16_16(xy, x[i], y[i]);
 80046d4:	f833 5f02 	ldrh.w	r5, [r3, #2]!
 80046d8:	f831 0f02 	ldrh.w	r0, [r1, #2]!
   for (i=0;i<N;i++)
 80046dc:	4563      	cmp	r3, ip
      xy = MAC16_16(xy, x[i], y[i]);
 80046de:	fb15 2200 	smlabb	r2, r5, r0, r2
   for (i=0;i<N;i++)
 80046e2:	d1f7      	bne.n	80046d4 <quant_all_bands+0xeb8>
  __asm__(
 80046e4:	68bb      	ldr	r3, [r7, #8]
 80046e6:	4618      	mov	r0, r3
 80046e8:	fb82 1300 	smull	r1, r3, r2, r0
               dist1 = MULT16_32_Q15(w[0], celt_inner_prod(X_save, X, N, arch)) + MULT16_32_Q15(w[1], celt_inner_prod(Y_save, Y, N, arch));
 80046ec:	eb0e 0e43 	add.w	lr, lr, r3, lsl #1
               if (dist0 >= dist1) {
 80046f0:	69bb      	ldr	r3, [r7, #24]
 80046f2:	4573      	cmp	r3, lr
 80046f4:	f280 816c 	bge.w	80049d0 <quant_all_bands+0x11b4>
            {
 80046f8:	2300      	movs	r3, #0
 80046fa:	4650      	mov	r0, sl
 80046fc:	f8c7 3714 	str.w	r3, [r7, #1812]	; 0x714
 8004700:	e4ce      	b.n	80040a0 <quant_all_bands+0x884>
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8004702:	f1b8 3fff 	cmp.w	r8, #4294967295
               ctx.theta_round = 0;
 8004706:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 800470a:	bf16      	itet	ne
 800470c:	f8d7 30ac 	ldrne.w	r3, [r7, #172]	; 0xac
 8004710:	461a      	moveq	r2, r3
 8004712:	eb03 0248 	addne.w	r2, r3, r8, lsl #1
 8004716:	e5ea      	b.n	80042ee <quant_all_bands+0xad2>
   if (d>256)
 8004718:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
      return -(opus_int32)celt_udiv(-n, d);
 800471c:	f1c3 0c00 	rsb	ip, r3, #0
   if (d>256)
 8004720:	f240 80af 	bls.w	8004882 <quant_all_bands+0x1066>
      return n/d;
 8004724:	fbbc f1f1 	udiv	r1, ip, r1
      return -(opus_int32)celt_udiv(-n, d);
 8004728:	4249      	negs	r1, r1
 800472a:	e40f      	b.n	8003f4c <quant_all_bands+0x730>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 800472c:	2200      	movs	r2, #0
 800472e:	e496      	b.n	800405e <quant_all_bands+0x842>
      t = EC_ILOG(d&-d);
 8004730:	424b      	negs	r3, r1
 8004732:	400b      	ands	r3, r1
 8004734:	fab3 f383 	clz	r3, r3
 8004738:	f1c3 0e20 	rsb	lr, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800473c:	4bd3      	ldr	r3, [pc, #844]	; (8004a8c <quant_all_bands+0x1270>)
 800473e:	fa21 f20e 	lsr.w	r2, r1, lr
 8004742:	f853 c022 	ldr.w	ip, [r3, r2, lsl #2]
 8004746:	f8d7 3724 	ldr.w	r3, [r7, #1828]	; 0x724
 800474a:	f10e 32ff 	add.w	r2, lr, #4294967295
 800474e:	fa23 f202 	lsr.w	r2, r3, r2
 8004752:	fba2 9a0c 	umull	r9, sl, r2, ip
      return q+(n-q*d >= d);
 8004756:	fb01 321a 	mls	r2, r1, sl, r3
 800475a:	428a      	cmp	r2, r1
 800475c:	bf34      	ite	cc
 800475e:	4651      	movcc	r1, sl
 8004760:	f10a 0101 	addcs.w	r1, sl, #1
 8004764:	f7ff bbf2 	b.w	8003f4c <quant_all_bands+0x730>
      lowband_scratch = X_+M*eBands[m->nbEBands-1];
 8004768:	f8d7 36f8 	ldr.w	r3, [r7, #1784]	; 0x6f8
 800476c:	240a      	movs	r4, #10
 800476e:	eb03 0346 	add.w	r3, r3, r6, lsl #1
 8004772:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8004776:	f7ff b8c0 	b.w	80038fa <quant_all_bands+0xde>
         x_cm = y_cm = (1<<B)-1;
 800477a:	f8d7 c05c 	ldr.w	ip, [r7, #92]	; 0x5c
      int effective_lowband=-1;
 800477e:	f04f 38ff 	mov.w	r8, #4294967295
         x_cm = y_cm = (1<<B)-1;
 8004782:	f8c7 c068 	str.w	ip, [r7, #104]	; 0x68
 8004786:	e5f7      	b.n	8004378 <quant_all_bands+0xb5c>
            x_cm = quant_band(&ctx, X, N, b, B,
 8004788:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800478c:	eb03 0248 	add.w	r2, r3, r8, lsl #1
 8004790:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8004794:	429e      	cmp	r6, r3
 8004796:	f000 8244 	beq.w	8004c22 <quant_all_bands+0x1406>
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
 800479a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800479e:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 80047a2:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
 80047a6:	40a3      	lsls	r3, r4
 80047a8:	1a5b      	subs	r3, r3, r1
            x_cm = quant_band(&ctx, X, N, b, B,
 80047aa:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 80047ae:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 80047b2:	f647 70ff 	movw	r0, #32767	; 0x7fff
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
 80047b6:	6eb9      	ldr	r1, [r7, #104]	; 0x68
            x_cm = quant_band(&ctx, X, N, b, B,
 80047b8:	e9cd 4302 	strd	r4, r3, [sp, #8]
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
 80047bc:	ea4c 0501 	orr.w	r5, ip, r1
            x_cm = quant_band(&ctx, X, N, b, B,
 80047c0:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80047c4:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 80047c8:	9201      	str	r2, [sp, #4]
 80047ca:	9105      	str	r1, [sp, #20]
 80047cc:	9300      	str	r3, [sp, #0]
 80047ce:	9004      	str	r0, [sp, #16]
 80047d0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80047d4:	9506      	str	r5, [sp, #24]
 80047d6:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 80047d8:	465a      	mov	r2, fp
 80047da:	f507 7090 	add.w	r0, r7, #288	; 0x120
 80047de:	f7fd fb23 	bl	8001e28 <quant_band>
 80047e2:	2300      	movs	r3, #0
 80047e4:	4682      	mov	sl, r0
 80047e6:	f8c7 3714 	str.w	r3, [r7, #1812]	; 0x714
 80047ea:	e459      	b.n	80040a0 <quant_all_bands+0x884>
 80047ec:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80047f0:	eb03 0348 	add.w	r3, r3, r8, lsl #1
 80047f4:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80047f8:	42b2      	cmp	r2, r6
 80047fa:	f000 81c9 	beq.w	8004b90 <quant_all_bands+0x1374>
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
 80047fe:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8004802:	f932 1c02 	ldrsh.w	r1, [r2, #-2]
 8004806:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 800480a:	40a1      	lsls	r1, r4
 800480c:	1a89      	subs	r1, r1, r2
            x_cm = quant_band(&ctx, X, N, b, B,
 800480e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 8004812:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8004816:	f647 72ff 	movw	r2, #32767	; 0x7fff
                  last?NULL:norm+M*eBands[i]-norm_offset, Q15ONE, lowband_scratch, x_cm|y_cm);
 800481a:	ea4c 000e 	orr.w	r0, ip, lr
            x_cm = quant_band(&ctx, X, N, b, B,
 800481e:	9006      	str	r0, [sp, #24]
 8004820:	9301      	str	r3, [sp, #4]
 8004822:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 8004826:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800482a:	9005      	str	r0, [sp, #20]
 800482c:	e9cd 4102 	strd	r4, r1, [sp, #8]
 8004830:	9300      	str	r3, [sp, #0]
 8004832:	9204      	str	r2, [sp, #16]
 8004834:	462b      	mov	r3, r5
 8004836:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8004838:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800483c:	f507 7090 	add.w	r0, r7, #288	; 0x120
 8004840:	f7fd faf2 	bl	8001e28 <quant_band>
 8004844:	2300      	movs	r3, #0
 8004846:	4606      	mov	r6, r0
 8004848:	f8c7 3714 	str.w	r3, [r7, #1812]	; 0x714
 800484c:	f7ff b9ac 	b.w	8003ba8 <quant_all_bands+0x38c>
      t = EC_ILOG(d&-d);
 8004850:	4259      	negs	r1, r3
 8004852:	4019      	ands	r1, r3
 8004854:	fab1 f181 	clz	r1, r1
 8004858:	f1c1 0c20 	rsb	ip, r1, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800485c:	498b      	ldr	r1, [pc, #556]	; (8004a8c <quant_all_bands+0x1270>)
 800485e:	fa23 f00c 	lsr.w	r0, r3, ip
 8004862:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 8004866:	f10c 31ff 	add.w	r1, ip, #4294967295
 800486a:	fa22 f101 	lsr.w	r1, r2, r1
 800486e:	fba1 0100 	umull	r0, r1, r1, r0
      return q+(n-q*d >= d);
 8004872:	fb03 2211 	mls	r2, r3, r1, r2
 8004876:	429a      	cmp	r2, r3
 8004878:	bf34      	ite	cc
 800487a:	460b      	movcc	r3, r1
 800487c:	1c4b      	addcs	r3, r1, #1
 800487e:	f7ff baf7 	b.w	8003e70 <quant_all_bands+0x654>
      t = EC_ILOG(d&-d);
 8004882:	424b      	negs	r3, r1
 8004884:	400b      	ands	r3, r1
 8004886:	fab3 f383 	clz	r3, r3
 800488a:	f1c3 0e20 	rsb	lr, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800488e:	4b7f      	ldr	r3, [pc, #508]	; (8004a8c <quant_all_bands+0x1270>)
 8004890:	fa21 f20e 	lsr.w	r2, r1, lr
 8004894:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8004898:	f10e 33ff 	add.w	r3, lr, #4294967295
 800489c:	fa2c f303 	lsr.w	r3, ip, r3
 80048a0:	fba3 2302 	umull	r2, r3, r3, r2
      return q+(n-q*d >= d);
 80048a4:	fb01 cc13 	mls	ip, r1, r3, ip
 80048a8:	458c      	cmp	ip, r1
 80048aa:	bf34      	ite	cc
 80048ac:	4619      	movcc	r1, r3
 80048ae:	1c59      	addcs	r1, r3, #1
 80048b0:	e73a      	b.n	8004728 <quant_all_bands+0xf0c>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 80048b2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80048b6:	461a      	mov	r2, r3
 80048b8:	2b00      	cmp	r3, #0
 80048ba:	bf08      	it	eq
 80048bc:	4632      	moveq	r2, r6
      if (i == start+1)
 80048be:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 80048c2:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
      if (i == start+1)
 80048c6:	42b3      	cmp	r3, r6
 80048c8:	f47f a8da 	bne.w	8003a80 <quant_all_bands+0x264>
 80048cc:	e01a      	b.n	8004904 <quant_all_bands+0x10e8>
 80048ce:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80048d2:	461a      	mov	r2, r3
 80048d4:	2b00      	cmp	r3, #0
 80048d6:	bf08      	it	eq
 80048d8:	4632      	moveq	r2, r6
 80048da:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80048de:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
 80048e2:	429e      	cmp	r6, r3
 80048e4:	f47f ab55 	bne.w	8003f92 <quant_all_bands+0x776>
 80048e8:	e44d      	b.n	8004186 <quant_all_bands+0x96a>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 80048ea:	f1ba 0f00 	cmp.w	sl, #0
 80048ee:	f040 8126 	bne.w	8004b3e <quant_all_bands+0x1322>
 80048f2:	4619      	mov	r1, r3
 80048f4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80048f8:	461a      	mov	r2, r3
 80048fa:	2b00      	cmp	r3, #0
 80048fc:	bf08      	it	eq
 80048fe:	460a      	moveq	r2, r1
 8004900:	f8c7 20b4 	str.w	r2, [r7, #180]	; 0xb4
         special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
 8004904:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   n2 = M*(eBands[start+2]-eBands[start+1]);
 8004906:	6a78      	ldr	r0, [r7, #36]	; 0x24
         special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
 8004908:	699a      	ldr	r2, [r3, #24]
   n1 = M*(eBands[start+1]-eBands[start]);
 800490a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800490c:	5ed1      	ldrsh	r1, [r2, r3]
 800490e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8004910:	5ed3      	ldrsh	r3, [r2, r3]
   n2 = M*(eBands[start+2]-eBands[start+1]);
 8004912:	5e12      	ldrsh	r2, [r2, r0]
   n1 = M*(eBands[start+1]-eBands[start]);
 8004914:	1acb      	subs	r3, r1, r3
   n2 = M*(eBands[start+2]-eBands[start+1]);
 8004916:	1a52      	subs	r2, r2, r1
   n1 = M*(eBands[start+1]-eBands[start]);
 8004918:	40a3      	lsls	r3, r4
   n2 = M*(eBands[start+2]-eBands[start+1]);
 800491a:	40a2      	lsls	r2, r4
   OPUS_COPY(&norm[n1], &norm[2*n1 - n2], n2-n1);
 800491c:	ea4f 0a43 	mov.w	sl, r3, lsl #1
 8004920:	1ad3      	subs	r3, r2, r3
 8004922:	ea4f 0943 	mov.w	r9, r3, lsl #1
 8004926:	ebaa 0202 	sub.w	r2, sl, r2
 800492a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800492e:	0052      	lsls	r2, r2, #1
 8004930:	1899      	adds	r1, r3, r2
 8004932:	66ba      	str	r2, [r7, #104]	; 0x68
 8004934:	eb03 000a 	add.w	r0, r3, sl
 8004938:	464a      	mov	r2, r9
 800493a:	f00f fbd1 	bl	80140e0 <memcpy>
   if (dual_stereo)
 800493e:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
 8004942:	2b00      	cmp	r3, #0
 8004944:	f43f a89c 	beq.w	8003a80 <quant_all_bands+0x264>
      OPUS_COPY(&norm2[n1], &norm2[2*n1 - n2], n2-n1);
 8004948:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800494a:	464a      	mov	r2, r9
 800494c:	4619      	mov	r1, r3
 800494e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8004950:	4419      	add	r1, r3
 8004952:	eb03 000a 	add.w	r0, r3, sl
 8004956:	f00f fbc3 	bl	80140e0 <memcpy>
 800495a:	f7ff b891 	b.w	8003a80 <quant_all_bands+0x264>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 800495e:	b925      	cbnz	r5, 800496a <quant_all_bands+0x114e>
 8004960:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8004964:	2b00      	cmp	r3, #0
 8004966:	f47f ac09 	bne.w	800417c <quant_all_bands+0x960>
 800496a:	f8c7 60b4 	str.w	r6, [r7, #180]	; 0xb4
 800496e:	e40a      	b.n	8004186 <quant_all_bands+0x96a>
   int theta_rdo = encode && Y_!=NULL && !dual_stereo && complexity>=8;
 8004970:	fab0 f380 	clz	r3, r0
   int C = Y_ != NULL ? 2 : 1;
 8004974:	2401      	movs	r4, #1
   int theta_rdo = encode && Y_!=NULL && !dual_stereo && complexity>=8;
 8004976:	095b      	lsrs	r3, r3, #5
 8004978:	67fb      	str	r3, [r7, #124]	; 0x7c
   int resynth = !encode || theta_rdo;
 800497a:	f8d7 36fc 	ldr.w	r3, [r7, #1788]	; 0x6fc
   int C = Y_ != NULL ? 2 : 1;
 800497e:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
   int resynth = !encode || theta_rdo;
 8004982:	64bb      	str	r3, [r7, #72]	; 0x48
 8004984:	f7fe bf65 	b.w	8003852 <quant_all_bands+0x36>
         x_cm = y_cm = (1<<B)-1;
 8004988:	6dfd      	ldr	r5, [r7, #92]	; 0x5c
 800498a:	461a      	mov	r2, r3
 800498c:	46ac      	mov	ip, r5
 800498e:	66bd      	str	r5, [r7, #104]	; 0x68
 8004990:	e6fe      	b.n	8004790 <quant_all_bands+0xf74>
 8004992:	f8d7 e05c 	ldr.w	lr, [r7, #92]	; 0x5c
 8004996:	46f4      	mov	ip, lr
 8004998:	e72c      	b.n	80047f4 <quant_all_bands+0xfd8>
 800499a:	2300      	movs	r3, #0
   int C = Y_ != NULL ? 2 : 1;
 800499c:	2402      	movs	r4, #2
 800499e:	64bb      	str	r3, [r7, #72]	; 0x48
 80049a0:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
   int resynth = !encode || theta_rdo;
 80049a4:	67fb      	str	r3, [r7, #124]	; 0x7c
 80049a6:	f7fe bf54 	b.w	8003852 <quant_all_bands+0x36>
   w[0] = VSHR32(Ex, shift);
 80049aa:	f1c3 030e 	rsb	r3, r3, #14
 80049ae:	409a      	lsls	r2, r3
   w[1] = VSHR32(Ey, shift);
 80049b0:	fa01 f303 	lsl.w	r3, r1, r3
   w[0] = VSHR32(Ex, shift);
 80049b4:	b212      	sxth	r2, r2
   w[1] = VSHR32(Ey, shift);
 80049b6:	b21b      	sxth	r3, r3
   w[0] = VSHR32(Ex, shift);
 80049b8:	61fa      	str	r2, [r7, #28]
   w[1] = VSHR32(Ey, shift);
 80049ba:	61bb      	str	r3, [r7, #24]
 80049bc:	e506      	b.n	80043cc <quant_all_bands+0xbb0>
 80049be:	f8d7 3714 	ldr.w	r3, [r7, #1812]	; 0x714
 80049c2:	64bb      	str	r3, [r7, #72]	; 0x48
   int resynth = !encode || theta_rdo;
 80049c4:	67fb      	str	r3, [r7, #124]	; 0x7c
   int C = Y_ != NULL ? 2 : 1;
 80049c6:	2302      	movs	r3, #2
 80049c8:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 80049cc:	f7fe bf41 	b.w	8003852 <quant_all_bands+0x36>
                  *ec = ec_save2;
 80049d0:	f8d7 8728 	ldr.w	r8, [r7, #1832]	; 0x728
 80049d4:	f107 0cf0 	add.w	ip, r7, #240	; 0xf0
 80049d8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80049dc:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
 80049e0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80049e4:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
 80049e8:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
                  ctx = ctx_save2;
 80049ec:	f507 75cc 	add.w	r5, r7, #408	; 0x198
 80049f0:	f507 7e90 	add.w	lr, r7, #288	; 0x120
                  *ec = ec_save2;
 80049f4:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}
                  ctx = ctx_save2;
 80049f8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80049fa:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80049fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004a00:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8004a04:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004a06:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8004a0a:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
                  OPUS_COPY(X, X_save2, N);
 8004a0e:	6bbd      	ldr	r5, [r7, #56]	; 0x38
                  ctx = ctx_save2;
 8004a10:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
                  OPUS_COPY(X, X_save2, N);
 8004a14:	462a      	mov	r2, r5
 8004a16:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8004a18:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 8004a1a:	f00f fb61 	bl	80140e0 <memcpy>
                  OPUS_COPY(Y, Y_save2, N);
 8004a1e:	462a      	mov	r2, r5
 8004a20:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8004a22:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
 8004a26:	f00f fb5b 	bl	80140e0 <memcpy>
                  if (!last)
 8004a2a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8004a2e:	429e      	cmp	r6, r3
 8004a30:	d00f      	beq.n	8004a52 <quant_all_bands+0x1236>
                     OPUS_COPY(norm+M*eBands[i]-norm_offset, norm_save2, N);
 8004a32:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8004a36:	462a      	mov	r2, r5
 8004a38:	f933 0c02 	ldrsh.w	r0, [r3, #-2]
 8004a3c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8004a40:	40a0      	lsls	r0, r4
 8004a42:	1ac0      	subs	r0, r0, r3
 8004a44:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8004a48:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004a4a:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 8004a4e:	f00f fb47 	bl	80140e0 <memcpy>
                  OPUS_COPY(bytes_buf, bytes_save, save_bytes);
 8004a52:	464a      	mov	r2, r9
 8004a54:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
 8004a58:	6978      	ldr	r0, [r7, #20]
 8004a5a:	f00f fb41 	bl	80140e0 <memcpy>
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8004a5e:	f8d7 a004 	ldr.w	sl, [r7, #4]
 8004a62:	e649      	b.n	80046f8 <quant_all_bands+0xedc>
         lowband_scratch = NULL;
 8004a64:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8004a66:	2a00      	cmp	r2, #0
 8004a68:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8004a6c:	bf08      	it	eq
 8004a6e:	2200      	moveq	r2, #0
 8004a70:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
 8004a74:	f7ff b824 	b.w	8003ac0 <quant_all_bands+0x2a4>
 8004a78:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8004a7a:	2a00      	cmp	r2, #0
 8004a7c:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8004a80:	bf08      	it	eq
 8004a82:	2200      	moveq	r2, #0
 8004a84:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
 8004a88:	f7ff ba97 	b.w	8003fba <quant_all_bands+0x79e>
 8004a8c:	0801649c 	.word	0x0801649c
 8004a90:	69fb      	ldr	r3, [r7, #28]
 8004a92:	4619      	mov	r1, r3
 8004a94:	fb82 3e01 	smull	r3, lr, r2, r1
  return SHL32(rd_hi,1);
 8004a98:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8004a9c:	e622      	b.n	80046e4 <quant_all_bands+0xec8>
  __asm__(
 8004a9e:	69fb      	ldr	r3, [r7, #28]
   opus_val32 xy=0;
 8004aa0:	4691      	mov	r9, r2
 8004aa2:	4619      	mov	r1, r3
 8004aa4:	fb82 3a01 	smull	r3, sl, r2, r1
  return SHL32(rd_hi,1);
 8004aa8:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
 8004aac:	e536      	b.n	800451c <quant_all_bands+0xd00>
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8004aae:	9306      	str	r3, [sp, #24]
 8004ab0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8004ab4:	f647 70ff 	movw	r0, #32767	; 0x7fff
 8004ab8:	9305      	str	r3, [sp, #20]
 8004aba:	2300      	movs	r3, #0
 8004abc:	e9cd 4302 	strd	r4, r3, [sp, #8]
 8004ac0:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8004ac4:	9201      	str	r2, [sp, #4]
 8004ac6:	9300      	str	r3, [sp, #0]
 8004ac8:	9004      	str	r0, [sp, #16]
 8004aca:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 8004acc:	462b      	mov	r3, r5
 8004ace:	465a      	mov	r2, fp
 8004ad0:	f507 7090 	add.w	r0, r7, #288	; 0x120
 8004ad4:	f7fd f9a8 	bl	8001e28 <quant_band>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 8004ad8:	f1b8 3fff 	cmp.w	r8, #4294967295
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8004adc:	4682      	mov	sl, r0
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 8004ade:	f000 80be 	beq.w	8004c5e <quant_all_bands+0x1442>
 8004ae2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8004ae4:	eb03 0209 	add.w	r2, r3, r9
 8004ae8:	2300      	movs	r3, #0
 8004aea:	f7ff bac3 	b.w	8004074 <quant_all_bands+0x858>
         x_cm = y_cm = (1<<B)-1;
 8004aee:	6dfd      	ldr	r5, [r7, #92]	; 0x5c
      int effective_lowband=-1;
 8004af0:	f04f 38ff 	mov.w	r8, #4294967295
         x_cm = y_cm = (1<<B)-1;
 8004af4:	46ac      	mov	ip, r5
 8004af6:	66bd      	str	r5, [r7, #104]	; 0x68
         if (resynth)
 8004af8:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8004afa:	2b00      	cmp	r3, #0
 8004afc:	d14a      	bne.n	8004b94 <quant_all_bands+0x1378>
         if (Y!=NULL)
 8004afe:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8004b02:	2b00      	cmp	r3, #0
 8004b04:	f47f ac34 	bne.w	8004370 <quant_all_bands+0xb54>
            x_cm = quant_band(&ctx, X, N, b, B,
 8004b08:	f1b8 3fff 	cmp.w	r8, #4294967295
 8004b0c:	f47f ae3c 	bne.w	8004788 <quant_all_bands+0xf6c>
 8004b10:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8004b14:	e63c      	b.n	8004790 <quant_all_bands+0xf74>
         x_cm = y_cm = (1<<B)-1;
 8004b16:	f8d7 e05c 	ldr.w	lr, [r7, #92]	; 0x5c
      int effective_lowband=-1;
 8004b1a:	f04f 38ff 	mov.w	r8, #4294967295
         x_cm = y_cm = (1<<B)-1;
 8004b1e:	46f4      	mov	ip, lr
         if (resynth)
 8004b20:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8004b22:	2b00      	cmp	r3, #0
 8004b24:	d15a      	bne.n	8004bdc <quant_all_bands+0x13c0>
         if (Y!=NULL)
 8004b26:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8004b2a:	2b00      	cmp	r3, #0
 8004b2c:	f47f a98c 	bne.w	8003e48 <quant_all_bands+0x62c>
            x_cm = quant_band(&ctx, X, N, b, B,
 8004b30:	f1b8 3fff 	cmp.w	r8, #4294967295
 8004b34:	f47f ae5a 	bne.w	80047ec <quant_all_bands+0xfd0>
 8004b38:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8004b3c:	e65a      	b.n	80047f4 <quant_all_bands+0xfd8>
      if (resynth && (M*eBands[i]-N >= M*eBands[start] || i==start+1) && (update_lowband || lowband_offset==0))
 8004b3e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8004b42:	e6df      	b.n	8004904 <quant_all_bands+0x10e8>
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8004b44:	9306      	str	r3, [sp, #24]
 8004b46:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8004b4a:	f647 70ff 	movw	r0, #32767	; 0x7fff
 8004b4e:	9305      	str	r3, [sp, #20]
 8004b50:	2300      	movs	r3, #0
 8004b52:	e9cd 4302 	strd	r4, r3, [sp, #8]
 8004b56:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8004b5a:	9201      	str	r2, [sp, #4]
 8004b5c:	9300      	str	r3, [sp, #0]
 8004b5e:	9004      	str	r0, [sp, #16]
 8004b60:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8004b62:	4653      	mov	r3, sl
 8004b64:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8004b68:	f507 7090 	add.w	r0, r7, #288	; 0x120
 8004b6c:	f7fd f95c 	bl	8001e28 <quant_band>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 8004b70:	f1b8 3fff 	cmp.w	r8, #4294967295
         x_cm = quant_band(&ctx, X, N, b/2, B,
 8004b74:	4606      	mov	r6, r0
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 8004b76:	d076      	beq.n	8004c66 <quant_all_bands+0x144a>
 8004b78:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8004b7a:	eb03 0209 	add.w	r2, r3, r9
 8004b7e:	2300      	movs	r3, #0
 8004b80:	f7fe bffb 	b.w	8003b7a <quant_all_bands+0x35e>
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8004b84:	2300      	movs	r3, #0
 8004b86:	f7ff b92f 	b.w	8003de8 <quant_all_bands+0x5cc>
 8004b8a:	2300      	movs	r3, #0
 8004b8c:	f7ff bbc0 	b.w	8004310 <quant_all_bands+0xaf4>
            x_cm = quant_band(&ctx, X, N, b, B,
 8004b90:	2100      	movs	r1, #0
 8004b92:	e640      	b.n	8004816 <quant_all_bands+0xffa>
            for (j=0;j<M*eBands[i]-norm_offset;j++)
 8004b94:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8004b98:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8004b9c:	f933 3c02 	ldrsh.w	r3, [r3, #-2]
 8004ba0:	40a3      	lsls	r3, r4
 8004ba2:	1a9b      	subs	r3, r3, r2
 8004ba4:	2b00      	cmp	r3, #0
 8004ba6:	ddaa      	ble.n	8004afe <quant_all_bands+0x12e2>
 8004ba8:	2000      	movs	r0, #0
 8004baa:	6e7d      	ldr	r5, [r7, #100]	; 0x64
 8004bac:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8004bb0:	f1a5 0e02 	sub.w	lr, r5, #2
 8004bb4:	f8d7 90bc 	ldr.w	r9, [r7, #188]	; 0xbc
 8004bb8:	6ebd      	ldr	r5, [r7, #104]	; 0x68
 8004bba:	3902      	subs	r1, #2
               norm[j] = HALF32(norm[j]+norm2[j]);
 8004bbc:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
 8004bc0:	f93e af02 	ldrsh.w	sl, [lr, #2]!
            for (j=0;j<M*eBands[i]-norm_offset;j++)
 8004bc4:	3001      	adds	r0, #1
               norm[j] = HALF32(norm[j]+norm2[j]);
 8004bc6:	4453      	add	r3, sl
 8004bc8:	105b      	asrs	r3, r3, #1
 8004bca:	800b      	strh	r3, [r1, #0]
            for (j=0;j<M*eBands[i]-norm_offset;j++)
 8004bcc:	f939 3c02 	ldrsh.w	r3, [r9, #-2]
 8004bd0:	40a3      	lsls	r3, r4
 8004bd2:	1a9b      	subs	r3, r3, r2
 8004bd4:	4283      	cmp	r3, r0
 8004bd6:	dcf1      	bgt.n	8004bbc <quant_all_bands+0x13a0>
 8004bd8:	66bd      	str	r5, [r7, #104]	; 0x68
 8004bda:	e790      	b.n	8004afe <quant_all_bands+0x12e2>
 8004bdc:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8004be0:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 8004be4:	f932 3c02 	ldrsh.w	r3, [r2, #-2]
 8004be8:	40a3      	lsls	r3, r4
 8004bea:	1a5b      	subs	r3, r3, r1
 8004bec:	2b00      	cmp	r3, #0
 8004bee:	dd9a      	ble.n	8004b26 <quant_all_bands+0x130a>
 8004bf0:	2100      	movs	r1, #0
 8004bf2:	4692      	mov	sl, r2
 8004bf4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8004bf8:	1e98      	subs	r0, r3, #2
 8004bfa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8004bfc:	f1a3 0902 	sub.w	r9, r3, #2
               norm[j] = HALF32(norm[j]+norm2[j]);
 8004c00:	f939 2f02 	ldrsh.w	r2, [r9, #2]!
 8004c04:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
            for (j=0;j<M*eBands[i]-norm_offset;j++)
 8004c08:	3101      	adds	r1, #1
               norm[j] = HALF32(norm[j]+norm2[j]);
 8004c0a:	4413      	add	r3, r2
 8004c0c:	105b      	asrs	r3, r3, #1
 8004c0e:	8003      	strh	r3, [r0, #0]
            for (j=0;j<M*eBands[i]-norm_offset;j++)
 8004c10:	f93a 3c02 	ldrsh.w	r3, [sl, #-2]
 8004c14:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8004c18:	40a3      	lsls	r3, r4
 8004c1a:	1a9b      	subs	r3, r3, r2
 8004c1c:	4299      	cmp	r1, r3
 8004c1e:	dbef      	blt.n	8004c00 <quant_all_bands+0x13e4>
 8004c20:	e781      	b.n	8004b26 <quant_all_bands+0x130a>
            x_cm = quant_band(&ctx, X, N, b, B,
 8004c22:	2300      	movs	r3, #0
 8004c24:	e5c5      	b.n	80047b2 <quant_all_bands+0xf96>
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8004c26:	2300      	movs	r3, #0
 8004c28:	e42f      	b.n	800448a <quant_all_bands+0xc6e>
               x_cm = quant_band_stereo(&ctx, X, Y, N, b, B,
 8004c2a:	2300      	movs	r3, #0
 8004c2c:	e516      	b.n	800465c <quant_all_bands+0xe40>
                  special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
 8004c2e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   n2 = M*(eBands[start+2]-eBands[start+1]);
 8004c30:	6a78      	ldr	r0, [r7, #36]	; 0x24
                  special_hybrid_folding(m, norm, norm2, start, M, dual_stereo);
 8004c32:	699a      	ldr	r2, [r3, #24]
   n1 = M*(eBands[start+1]-eBands[start]);
 8004c34:	6abb      	ldr	r3, [r7, #40]	; 0x28
   OPUS_COPY(&norm[n1], &norm[2*n1 - n2], n2-n1);
 8004c36:	f8d7 50ac 	ldr.w	r5, [r7, #172]	; 0xac
   n1 = M*(eBands[start+1]-eBands[start]);
 8004c3a:	5ed1      	ldrsh	r1, [r2, r3]
 8004c3c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8004c3e:	5ed3      	ldrsh	r3, [r2, r3]
   n2 = M*(eBands[start+2]-eBands[start+1]);
 8004c40:	5e12      	ldrsh	r2, [r2, r0]
   n1 = M*(eBands[start+1]-eBands[start]);
 8004c42:	1acb      	subs	r3, r1, r3
 8004c44:	40a3      	lsls	r3, r4
   n2 = M*(eBands[start+2]-eBands[start+1]);
 8004c46:	1a52      	subs	r2, r2, r1
 8004c48:	40a2      	lsls	r2, r4
   OPUS_COPY(&norm[n1], &norm[2*n1 - n2], n2-n1);
 8004c4a:	0058      	lsls	r0, r3, #1
 8004c4c:	1ad3      	subs	r3, r2, r3
 8004c4e:	1a82      	subs	r2, r0, r2
 8004c50:	eb05 0142 	add.w	r1, r5, r2, lsl #1
 8004c54:	4428      	add	r0, r5
 8004c56:	005a      	lsls	r2, r3, #1
 8004c58:	f00f fa42 	bl	80140e0 <memcpy>
 8004c5c:	e4ea      	b.n	8004634 <quant_all_bands+0xe18>
         y_cm = quant_band(&ctx, Y, N, b/2, B,
 8004c5e:	2200      	movs	r2, #0
 8004c60:	4613      	mov	r3, r2
 8004c62:	f7ff ba07 	b.w	8004074 <quant_all_bands+0x858>
 8004c66:	2200      	movs	r2, #0
 8004c68:	4613      	mov	r3, r2
 8004c6a:	f7fe bf86 	b.w	8003b7a <quant_all_bands+0x35e>
 8004c6e:	bf00      	nop

08004c70 <comb_filter>:

#ifndef OVERRIDE_comb_filter
void comb_filter(opus_val32 *y, opus_val32 *x, int T0, int T1, int N,
      opus_val16 g0, opus_val16 g1, int tapset0, int tapset1,
      const opus_val16 *window, int overlap, int arch)
{
 8004c70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004c74:	b097      	sub	sp, #92	; 0x5c
 8004c76:	9c20      	ldr	r4, [sp, #128]	; 0x80
 8004c78:	e9dd 7623 	ldrd	r7, r6, [sp, #140]	; 0x8c
 8004c7c:	9601      	str	r6, [sp, #4]
 8004c7e:	9e25      	ldr	r6, [sp, #148]	; 0x94
 8004c80:	9413      	str	r4, [sp, #76]	; 0x4c
 8004c82:	9602      	str	r6, [sp, #8]
 8004c84:	f9bd 4088 	ldrsh.w	r4, [sp, #136]	; 0x88
 8004c88:	9e26      	ldr	r6, [sp, #152]	; 0x98
 8004c8a:	f9bd 5084 	ldrsh.w	r5, [sp, #132]	; 0x84
 8004c8e:	9011      	str	r0, [sp, #68]	; 0x44
 8004c90:	910f      	str	r1, [sp, #60]	; 0x3c
 8004c92:	940d      	str	r4, [sp, #52]	; 0x34
 8004c94:	960e      	str	r6, [sp, #56]	; 0x38
   static const opus_val16 gains[3][3] = {
         {QCONST16(0.3066406250f, 15), QCONST16(0.2170410156f, 15), QCONST16(0.1296386719f, 15)},
         {QCONST16(0.4638671875f, 15), QCONST16(0.2680664062f, 15), QCONST16(0.f, 15)},
         {QCONST16(0.7998046875f, 15), QCONST16(0.1000976562f, 15), QCONST16(0.f, 15)}};

   if (g0==0 && g1==0)
 8004c96:	b95d      	cbnz	r5, 8004cb0 <comb_filter+0x40>
 8004c98:	b954      	cbnz	r4, 8004cb0 <comb_filter+0x40>
   {
      /* OPT: Happens to work without the OPUS_MOVE(), but only because the current encoder already copies x to y */
      if (x!=y)
 8004c9a:	4281      	cmp	r1, r0
 8004c9c:	4686      	mov	lr, r0
 8004c9e:	f000 81dc 	beq.w	800505a <comb_filter+0x3ea>
         OPUS_MOVE(y, x, N);
 8004ca2:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 8004ca4:	00a2      	lsls	r2, r4, #2
      return;
   }

   /* Compute the part with the constant filter. */
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
}
 8004ca6:	b017      	add	sp, #92	; 0x5c
 8004ca8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
         OPUS_MOVE(y+overlap, x+overlap, N-overlap);
 8004cac:	f00f ba23 	b.w	80140f6 <memmove>
   T1 = IMAX(T1, COMBFILTER_MINPERIOD);
 8004cb0:	2b0f      	cmp	r3, #15
 8004cb2:	bfb8      	it	lt
 8004cb4:	230f      	movlt	r3, #15
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
 8004cb6:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   T1 = IMAX(T1, COMBFILTER_MINPERIOD);
 8004cba:	461e      	mov	r6, r3
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
 8004cbc:	f8df 93c4 	ldr.w	r9, [pc, #964]	; 8005084 <comb_filter+0x414>
   T1 = IMAX(T1, COMBFILTER_MINPERIOD);
 8004cc0:	9303      	str	r3, [sp, #12]
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
 8004cc2:	eb07 0c47 	add.w	ip, r7, r7, lsl #1
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
 8004cc6:	9b01      	ldr	r3, [sp, #4]
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
 8004cc8:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 8004ccc:	eb09 040c 	add.w	r4, r9, ip
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
 8004cd0:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 8004cd4:	0040      	lsls	r0, r0, #1
   g01 = MULT16_16_P15(g0, gains[tapset0][1]);
 8004cd6:	f8b4 e002 	ldrh.w	lr, [r4, #2]
   g02 = MULT16_16_P15(g0, gains[tapset0][2]);
 8004cda:	88a4      	ldrh	r4, [r4, #4]
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
 8004cdc:	eb09 0800 	add.w	r8, r9, r0
 8004ce0:	f839 a000 	ldrh.w	sl, [r9, r0]
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
 8004ce4:	f839 c00c 	ldrh.w	ip, [r9, ip]
   g11 = MULT16_16_P15(g1, gains[tapset1][1]);
 8004ce8:	f8b8 0002 	ldrh.w	r0, [r8, #2]
   g02 = MULT16_16_P15(g0, gains[tapset0][2]);
 8004cec:	fb15 1904 	smlabb	r9, r5, r4, r1
   g12 = MULT16_16_P15(g1, gains[tapset1][2]);
 8004cf0:	f8b8 8004 	ldrh.w	r8, [r8, #4]
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
 8004cf4:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   g01 = MULT16_16_P15(g0, gains[tapset0][1]);
 8004cf6:	fb15 1e0e 	smlabb	lr, r5, lr, r1
   g11 = MULT16_16_P15(g1, gains[tapset1][1]);
 8004cfa:	fb14 1000 	smlabb	r0, r4, r0, r1
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
 8004cfe:	fb14 1a0a 	smlabb	sl, r4, sl, r1
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
 8004d02:	fb15 1c0c 	smlabb	ip, r5, ip, r1
   g12 = MULT16_16_P15(g1, gains[tapset1][2]);
 8004d06:	fb14 1108 	smlabb	r1, r4, r8, r1
   x1 = x[-T1+1];
 8004d0a:	ebc6 7886 	rsb	r8, r6, r6, lsl #30
 8004d0e:	ea4f 0488 	mov.w	r4, r8, lsl #2
   x3 = x[-T1-1];
 8004d12:	9410      	str	r4, [sp, #64]	; 0x40
   x1 = x[-T1+1];
 8004d14:	1d23      	adds	r3, r4, #4
   x3 = x[-T1-1];
 8004d16:	1f26      	subs	r6, r4, #4
   x4 = x[-T1-2];
 8004d18:	9c10      	ldr	r4, [sp, #64]	; 0x40
   x3 = x[-T1-1];
 8004d1a:	9612      	str	r6, [sp, #72]	; 0x48
   x4 = x[-T1-2];
 8004d1c:	f1a4 0608 	sub.w	r6, r4, #8
 8004d20:	4634      	mov	r4, r6
 8004d22:	9615      	str	r6, [sp, #84]	; 0x54
   g01 = MULT16_16_P15(g0, gains[tapset0][1]);
 8004d24:	f34e 36cf 	sbfx	r6, lr, #15, #16
 8004d28:	960a      	str	r6, [sp, #40]	; 0x28
   g02 = MULT16_16_P15(g0, gains[tapset0][2]);
 8004d2a:	f349 36cf 	sbfx	r6, r9, #15, #16
   g12 = MULT16_16_P15(g1, gains[tapset1][2]);
 8004d2e:	f341 31cf 	sbfx	r1, r1, #15, #16
   g02 = MULT16_16_P15(g0, gains[tapset0][2]);
 8004d32:	960b      	str	r6, [sp, #44]	; 0x2c
   g00 = MULT16_16_P15(g0, gains[tapset0][0]);
 8004d34:	f34c 36cf 	sbfx	r6, ip, #15, #16
 8004d38:	9609      	str	r6, [sp, #36]	; 0x24
   g12 = MULT16_16_P15(g1, gains[tapset1][2]);
 8004d3a:	9108      	str	r1, [sp, #32]
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
 8004d3c:	f34a 36cf 	sbfx	r6, sl, #15, #16
   x1 = x[-T1+1];
 8004d40:	990f      	ldr	r1, [sp, #60]	; 0x3c
   g10 = MULT16_16_P15(g1, gains[tapset1][0]);
 8004d42:	9606      	str	r6, [sp, #24]
   g11 = MULT16_16_P15(g1, gains[tapset1][1]);
 8004d44:	f340 36cf 	sbfx	r6, r0, #15, #16
   x3 = x[-T1-1];
 8004d48:	9812      	ldr	r0, [sp, #72]	; 0x48
   x1 = x[-T1+1];
 8004d4a:	9314      	str	r3, [sp, #80]	; 0x50
 8004d4c:	f851 9003 	ldr.w	r9, [r1, r3]
   if (g0==g1 && T0==T1 && tapset0==tapset1)
 8004d50:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   T0 = IMAX(T0, COMBFILTER_MINPERIOD);
 8004d52:	2a0f      	cmp	r2, #15
   x3 = x[-T1-1];
 8004d54:	f851 e000 	ldr.w	lr, [r1, r0]
   x4 = x[-T1-2];
 8004d58:	5908      	ldr	r0, [r1, r4]
   x2 = x[-T1  ];
 8004d5a:	9c10      	ldr	r4, [sp, #64]	; 0x40
   T0 = IMAX(T0, COMBFILTER_MINPERIOD);
 8004d5c:	bfb8      	it	lt
 8004d5e:	220f      	movlt	r2, #15
   if (g0==g1 && T0==T1 && tapset0==tapset1)
 8004d60:	429d      	cmp	r5, r3
   g11 = MULT16_16_P15(g1, gains[tapset1][1]);
 8004d62:	9607      	str	r6, [sp, #28]
   x2 = x[-T1  ];
 8004d64:	f851 b004 	ldr.w	fp, [r1, r4]
   if (g0==g1 && T0==T1 && tapset0==tapset1)
 8004d68:	f000 817a 	beq.w	8005060 <comb_filter+0x3f0>
   for (i=0;i<overlap;i++)
 8004d6c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8004d6e:	2b00      	cmp	r3, #0
 8004d70:	f340 8181 	ble.w	8005076 <comb_filter+0x406>
 8004d74:	9b02      	ldr	r3, [sp, #8]
 8004d76:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 8004d7a:	f1a3 0a02 	sub.w	sl, r3, #2
 8004d7e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8004d80:	4606      	mov	r6, r0
 8004d82:	eb03 0482 	add.w	r4, r3, r2, lsl #2
 8004d86:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8004d88:	eb0a 0242 	add.w	r2, sl, r2, lsl #1
 8004d8c:	920c      	str	r2, [sp, #48]	; 0x30
 8004d8e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8004d90:	189a      	adds	r2, r3, r2
 8004d92:	3b04      	subs	r3, #4
 8004d94:	9303      	str	r3, [sp, #12]
 8004d96:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8004d98:	9204      	str	r2, [sp, #16]
 8004d9a:	3b04      	subs	r3, #4
 8004d9c:	e9cd 9301 	strd	r9, r3, [sp, #4]
 8004da0:	46d1      	mov	r9, sl
 8004da2:	e003      	b.n	8004dac <comb_filter+0x13c>
 8004da4:	46de      	mov	lr, fp
 8004da6:	f8dd b004 	ldr.w	fp, [sp, #4]
      x1=x0;
 8004daa:	9001      	str	r0, [sp, #4]
      f = MULT16_16_Q15(window[i],window[i]);
 8004dac:	f939 3f02 	ldrsh.w	r3, [r9, #2]!
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
 8004db0:	9909      	ldr	r1, [sp, #36]	; 0x24
      f = MULT16_16_Q15(window[i],window[i]);
 8004db2:	fb03 f303 	mul.w	r3, r3, r3
 8004db6:	13db      	asrs	r3, r3, #15
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
 8004db8:	f5c3 42ff 	rsb	r2, r3, #32640	; 0x7f80
 8004dbc:	327f      	adds	r2, #127	; 0x7f
 8004dbe:	b212      	sxth	r2, r2
 8004dc0:	fb02 f501 	mul.w	r5, r2, r1
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
 8004dc4:	990a      	ldr	r1, [sp, #40]	; 0x28
      : "%r"(b), "r"(SHL32(a,16))
 8004dc6:	f345 35cf 	sbfx	r5, r5, #15, #16
 8004dca:	fb02 f001 	mul.w	r0, r2, r1
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
 8004dce:	990b      	ldr	r1, [sp, #44]	; 0x2c
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
 8004dd0:	f8d4 8000 	ldr.w	r8, [r4]
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
 8004dd4:	fb02 f201 	mul.w	r2, r2, r1
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
 8004dd8:	9903      	ldr	r1, [sp, #12]
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
 8004dda:	9205      	str	r2, [sp, #20]
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
 8004ddc:	f851 af04 	ldr.w	sl, [r1, #4]!
 8004de0:	042d      	lsls	r5, r5, #16
 8004de2:	9103      	str	r1, [sp, #12]
  __asm__(
 8004de4:	fb88 2c05 	smull	r2, ip, r8, r5
               + MULT16_32_Q15(MULT16_16_Q15(f,g10),x2)
 8004de8:	9906      	ldr	r1, [sp, #24]
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
 8004dea:	9a07      	ldr	r2, [sp, #28]
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
 8004dec:	f854 7f04 	ldr.w	r7, [r4, #4]!
      f = MULT16_16_Q15(window[i],window[i]);
 8004df0:	b21b      	sxth	r3, r3
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
 8004df2:	fb03 f802 	mul.w	r8, r3, r2
               + MULT16_32_Q15(MULT16_16_Q15(f,g10),x2)
 8004df6:	fb03 f101 	mul.w	r1, r3, r1
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
 8004dfa:	9a08      	ldr	r2, [sp, #32]
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
 8004dfc:	f854 5c08 	ldr.w	r5, [r4, #-8]
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
 8004e00:	fb03 f302 	mul.w	r3, r3, r2
      : "%r"(b), "r"(SHL32(a,16))
 8004e04:	f340 30cf 	sbfx	r0, r0, #15, #16
 8004e08:	9a05      	ldr	r2, [sp, #20]
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g00),x[i-T0])
 8004e0a:	eb0a 0c4c 	add.w	ip, sl, ip, lsl #1
 8004e0e:	0400      	lsls	r0, r0, #16
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
 8004e10:	442f      	add	r7, r5
  __asm__(
 8004e12:	fb87 5a00 	smull	r5, sl, r7, r0
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
 8004e16:	6865      	ldr	r5, [r4, #4]
 8004e18:	f854 0c0c 	ldr.w	r0, [r4, #-12]
      : "%r"(b), "r"(SHL32(a,16))
 8004e1c:	f342 32cf 	sbfx	r2, r2, #15, #16
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g01),ADD32(x[i-T0+1],x[i-T0-1]))
 8004e20:	eb0c 0c4a 	add.w	ip, ip, sl, lsl #1
 8004e24:	f341 31cf 	sbfx	r1, r1, #15, #16
 8004e28:	0412      	lsls	r2, r2, #16
               + MULT16_32_Q15(MULT16_16_Q15((Q15ONE-f),g02),ADD32(x[i-T0+2],x[i-T0-2]))
 8004e2a:	4428      	add	r0, r5
 8004e2c:	0409      	lsls	r1, r1, #16
  __asm__(
 8004e2e:	fb80 7502 	smull	r7, r5, r0, r2
 8004e32:	eb0c 0c45 	add.w	ip, ip, r5, lsl #1
 8004e36:	fb8b 2501 	smull	r2, r5, fp, r1
      x0=x[i-T1+2];
 8004e3a:	9a04      	ldr	r2, [sp, #16]
               + MULT16_32_Q15(MULT16_16_Q15(f,g10),x2)
 8004e3c:	eb0c 0c45 	add.w	ip, ip, r5, lsl #1
      x0=x[i-T1+2];
 8004e40:	f852 0f04 	ldr.w	r0, [r2, #4]!
      : "%r"(b), "r"(SHL32(a,16))
 8004e44:	f348 38cf 	sbfx	r8, r8, #15, #16
 8004e48:	9204      	str	r2, [sp, #16]
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
 8004e4a:	9a01      	ldr	r2, [sp, #4]
 8004e4c:	f343 33cf 	sbfx	r3, r3, #15, #16
 8004e50:	eb02 010e 	add.w	r1, r2, lr
 8004e54:	041b      	lsls	r3, r3, #16
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
 8004e56:	4406      	add	r6, r0
 8004e58:	ea4f 4808 	mov.w	r8, r8, lsl #16
  __asm__(
 8004e5c:	fb81 5208 	smull	r5, r2, r1, r8
               + MULT16_32_Q15(MULT16_16_Q15(f,g11),ADD32(x1,x3))
 8004e60:	eb0c 0c42 	add.w	ip, ip, r2, lsl #1
 8004e64:	fb86 1203 	smull	r1, r2, r6, r3
      y[i] = SATURATE(y[i], SIG_SAT);
 8004e68:	4b84      	ldr	r3, [pc, #528]	; (800507c <comb_filter+0x40c>)
               + MULT16_32_Q15(MULT16_16_Q15(f,g12),ADD32(x0,x4));
 8004e6a:	eb0c 0242 	add.w	r2, ip, r2, lsl #1
      y[i] = SATURATE(y[i], SIG_SAT);
 8004e6e:	429a      	cmp	r2, r3
 8004e70:	bfb8      	it	lt
 8004e72:	461a      	movlt	r2, r3
 8004e74:	4b82      	ldr	r3, [pc, #520]	; (8005080 <comb_filter+0x410>)
 8004e76:	4676      	mov	r6, lr
 8004e78:	429a      	cmp	r2, r3
 8004e7a:	bfa8      	it	ge
 8004e7c:	461a      	movge	r2, r3
 8004e7e:	9b02      	ldr	r3, [sp, #8]
 8004e80:	f843 2f04 	str.w	r2, [r3, #4]!
 8004e84:	9302      	str	r3, [sp, #8]
   for (i=0;i<overlap;i++)
 8004e86:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004e88:	454b      	cmp	r3, r9
 8004e8a:	d18b      	bne.n	8004da4 <comb_filter+0x134>
 8004e8c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   if (g1==0)
 8004e8e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8004e90:	b992      	cbnz	r2, 8004eb8 <comb_filter+0x248>
      if (x!=y)
 8004e92:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8004e94:	9c11      	ldr	r4, [sp, #68]	; 0x44
 8004e96:	42a3      	cmp	r3, r4
 8004e98:	f000 80df 	beq.w	800505a <comb_filter+0x3ea>
         OPUS_MOVE(y+overlap, x+overlap, N-overlap);
 8004e9c:	990e      	ldr	r1, [sp, #56]	; 0x38
 8004e9e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8004ea0:	0088      	lsls	r0, r1, #2
 8004ea2:	4403      	add	r3, r0
 8004ea4:	4404      	add	r4, r0
 8004ea6:	1a52      	subs	r2, r2, r1
 8004ea8:	4620      	mov	r0, r4
 8004eaa:	4619      	mov	r1, r3
 8004eac:	0092      	lsls	r2, r2, #2
}
 8004eae:	b017      	add	sp, #92	; 0x5c
 8004eb0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
         OPUS_MOVE(y+overlap, x+overlap, N-overlap);
 8004eb4:	f00f b91f 	b.w	80140f6 <memmove>
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
 8004eb8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8004eba:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 8004ebe:	4462      	add	r2, ip
 8004ec0:	4617      	mov	r7, r2
 8004ec2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   x2 = SHL32(x[-T], 1);
 8004ec4:	9d10      	ldr	r5, [sp, #64]	; 0x40
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
 8004ec6:	1ad3      	subs	r3, r2, r3
   x4 = SHL32(x[-T-2], 1);
 8004ec8:	9a15      	ldr	r2, [sp, #84]	; 0x54
   for (i=0;i<N-4;i+=5)
 8004eca:	3b04      	subs	r3, #4
   x4 = SHL32(x[-T-2], 1);
 8004ecc:	58b9      	ldr	r1, [r7, r2]
   x3 = SHL32(x[-T-1], 1);
 8004ece:	9a12      	ldr	r2, [sp, #72]	; 0x48
   x2 = SHL32(x[-T], 1);
 8004ed0:	5978      	ldr	r0, [r7, r5]
   x3 = SHL32(x[-T-1], 1);
 8004ed2:	58bc      	ldr	r4, [r7, r2]
   x1 = SHL32(x[-T+1], 1);
 8004ed4:	9a14      	ldr	r2, [sp, #80]	; 0x50
   for (i=0;i<N-4;i+=5)
 8004ed6:	2b00      	cmp	r3, #0
   x1 = SHL32(x[-T+1], 1);
 8004ed8:	58ba      	ldr	r2, [r7, r2]
   for (i=0;i<N-4;i+=5)
 8004eda:	9305      	str	r3, [sp, #20]
   x1 = SHL32(x[-T+1], 1);
 8004edc:	ea4f 0e42 	mov.w	lr, r2, lsl #1
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
 8004ee0:	9a11      	ldr	r2, [sp, #68]	; 0x44
   x4 = SHL32(x[-T-2], 1);
 8004ee2:	ea4f 0141 	mov.w	r1, r1, lsl #1
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
 8004ee6:	4462      	add	r2, ip
   x3 = SHL32(x[-T-1], 1);
 8004ee8:	ea4f 0444 	mov.w	r4, r4, lsl #1
   comb_filter_const(y+i, x+i, T1, N-i, g10, g11, g12, arch);
 8004eec:	4694      	mov	ip, r2
   x2 = SHL32(x[-T], 1);
 8004eee:	ea4f 0040 	mov.w	r0, r0, lsl #1
 8004ef2:	eb07 0605 	add.w	r6, r7, r5
   for (i=0;i<N-4;i+=5)
 8004ef6:	f340 80b0 	ble.w	800505a <comb_filter+0x3ea>
 8004efa:	2300      	movs	r3, #0
 8004efc:	9304      	str	r3, [sp, #16]
      : "%r"(b),"r"(SHL32(a,16))
 8004efe:	9b06      	ldr	r3, [sp, #24]
 8004f00:	46f0      	mov	r8, lr
 8004f02:	ea4f 4a03 	mov.w	sl, r3, lsl #16
 8004f06:	46d3      	mov	fp, sl
 8004f08:	4635      	mov	r5, r6
 8004f0a:	9b07      	ldr	r3, [sp, #28]
 8004f0c:	9601      	str	r6, [sp, #4]
 8004f0e:	041b      	lsls	r3, r3, #16
 8004f10:	9302      	str	r3, [sp, #8]
 8004f12:	9b08      	ldr	r3, [sp, #32]
 8004f14:	041b      	lsls	r3, r3, #16
 8004f16:	9303      	str	r3, [sp, #12]
      x0=SHL32(x[i-T+2],1);
 8004f18:	68ab      	ldr	r3, [r5, #8]
      t = MAC16_32_Q16(x[i], g10, x2);
 8004f1a:	683a      	ldr	r2, [r7, #0]
  __asm__(
 8004f1c:	fb80 e50b 	smull	lr, r5, r0, fp
 8004f20:	9e02      	ldr	r6, [sp, #8]
      x0=SHL32(x[i-T+2],1);
 8004f22:	ea4f 0e43 	mov.w	lr, r3, lsl #1
      t = MAC16_32_Q16(x[i], g10, x2);
 8004f26:	442a      	add	r2, r5
      t = MAC16_32_Q16(t, g11, ADD32(x1,x3));
 8004f28:	eb04 0508 	add.w	r5, r4, r8
 8004f2c:	fb85 9306 	smull	r9, r3, r5, r6
 8004f30:	9d03      	ldr	r5, [sp, #12]
      t = MAC16_32_Q16(t, g12, ADD32(x0,x4));
 8004f32:	4471      	add	r1, lr
      t = MAC16_32_Q16(t, g11, ADD32(x1,x3));
 8004f34:	441a      	add	r2, r3
 8004f36:	46a9      	mov	r9, r5
 8004f38:	fb81 5309 	smull	r5, r3, r1, r9
      t = SATURATE(t, SIG_SAT);
 8004f3c:	494f      	ldr	r1, [pc, #316]	; (800507c <comb_filter+0x40c>)
      t = MAC16_32_Q16(t, g12, ADD32(x0,x4));
 8004f3e:	441a      	add	r2, r3
      t = SATURATE(t, SIG_SAT);
 8004f40:	428a      	cmp	r2, r1
 8004f42:	bfb8      	it	lt
 8004f44:	460a      	movlt	r2, r1
 8004f46:	fb88 350b 	smull	r3, r5, r8, fp
 8004f4a:	fb8e 390b 	smull	r3, r9, lr, fp
      y[i] = t;
 8004f4e:	494c      	ldr	r1, [pc, #304]	; (8005080 <comb_filter+0x410>)
 8004f50:	3714      	adds	r7, #20
 8004f52:	428a      	cmp	r2, r1
 8004f54:	bfa8      	it	ge
 8004f56:	460a      	movge	r2, r1
 8004f58:	f8cc 2000 	str.w	r2, [ip]
      x4=SHL32(x[i-T+3],1);
 8004f5c:	9a01      	ldr	r2, [sp, #4]
      t = MAC16_32_Q16(x[i+1], g10, x1);
 8004f5e:	f857 3c10 	ldr.w	r3, [r7, #-16]
      x4=SHL32(x[i-T+3],1);
 8004f62:	68d1      	ldr	r1, [r2, #12]
      t = MAC16_32_Q16(x[i+1], g10, x1);
 8004f64:	442b      	add	r3, r5
      t = MAC16_32_Q16(t, g11, ADD32(x0,x2));
 8004f66:	eb00 050e 	add.w	r5, r0, lr
 8004f6a:	fb85 a206 	smull	sl, r2, r5, r6
 8004f6e:	9d03      	ldr	r5, [sp, #12]
      x4=SHL32(x[i-T+3],1);
 8004f70:	0049      	lsls	r1, r1, #1
      t = MAC16_32_Q16(t, g11, ADD32(x0,x2));
 8004f72:	4413      	add	r3, r2
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
 8004f74:	440c      	add	r4, r1
 8004f76:	462e      	mov	r6, r5
 8004f78:	fb84 5206 	smull	r5, r2, r4, r6
      t = SATURATE(t, SIG_SAT);
 8004f7c:	4c3f      	ldr	r4, [pc, #252]	; (800507c <comb_filter+0x40c>)
      t = MAC16_32_Q16(t, g12, ADD32(x4,x3));
 8004f7e:	4413      	add	r3, r2
      t = SATURATE(t, SIG_SAT);
 8004f80:	42a3      	cmp	r3, r4
 8004f82:	bfb8      	it	lt
 8004f84:	4623      	movlt	r3, r4
 8004f86:	fb81 2a0b 	smull	r2, sl, r1, fp
      y[i+1] = t;
 8004f8a:	4c3d      	ldr	r4, [pc, #244]	; (8005080 <comb_filter+0x410>)
      t = MAC16_32_Q16(t, g11, ADD32(x4,x1));
 8004f8c:	eb01 0208 	add.w	r2, r1, r8
      y[i+1] = t;
 8004f90:	42a3      	cmp	r3, r4
 8004f92:	bfa8      	it	ge
 8004f94:	4623      	movge	r3, r4
 8004f96:	f8cc 3004 	str.w	r3, [ip, #4]
      x3=SHL32(x[i-T+4],1);
 8004f9a:	9b01      	ldr	r3, [sp, #4]
      t = MAC16_32_Q16(x[i+2], g10, x0);
 8004f9c:	f857 5c0c 	ldr.w	r5, [r7, #-12]
      x3=SHL32(x[i-T+4],1);
 8004fa0:	691c      	ldr	r4, [r3, #16]
      t = MAC16_32_Q16(x[i+2], g10, x0);
 8004fa2:	444d      	add	r5, r9
      x3=SHL32(x[i-T+4],1);
 8004fa4:	0064      	lsls	r4, r4, #1
 8004fa6:	9e02      	ldr	r6, [sp, #8]
 8004fa8:	fb82 9306 	smull	r9, r3, r2, r6
      t = MAC16_32_Q16(t, g11, ADD32(x4,x1));
 8004fac:	441d      	add	r5, r3
      t = MAC16_32_Q16(t, g12, ADD32(x3,x2));
 8004fae:	1903      	adds	r3, r0, r4
 8004fb0:	9803      	ldr	r0, [sp, #12]
 8004fb2:	fb83 2900 	smull	r2, r9, r3, r0
      t = SATURATE(t, SIG_SAT);
 8004fb6:	4a31      	ldr	r2, [pc, #196]	; (800507c <comb_filter+0x40c>)
      t = MAC16_32_Q16(t, g12, ADD32(x3,x2));
 8004fb8:	444d      	add	r5, r9
      t = SATURATE(t, SIG_SAT);
 8004fba:	4295      	cmp	r5, r2
 8004fbc:	bfb8      	it	lt
 8004fbe:	4615      	movlt	r5, r2
 8004fc0:	fb84 390b 	smull	r3, r9, r4, fp
      y[i+2] = t;
 8004fc4:	482e      	ldr	r0, [pc, #184]	; (8005080 <comb_filter+0x410>)
 8004fc6:	f10c 0c14 	add.w	ip, ip, #20
 8004fca:	4285      	cmp	r5, r0
 8004fcc:	bfa8      	it	ge
 8004fce:	4605      	movge	r5, r0
      x2=SHL32(x[i-T+5],1);
 8004fd0:	9801      	ldr	r0, [sp, #4]
      y[i+2] = t;
 8004fd2:	f84c 5c0c 	str.w	r5, [ip, #-12]
      t = MAC16_32_Q16(x[i+3], g10, x4);
 8004fd6:	f857 2c08 	ldr.w	r2, [r7, #-8]
      x2=SHL32(x[i-T+5],1);
 8004fda:	6943      	ldr	r3, [r0, #20]
      t = MAC16_32_Q16(t, g11, ADD32(x3,x0));
 8004fdc:	eb0e 0504 	add.w	r5, lr, r4
      x2=SHL32(x[i-T+5],1);
 8004fe0:	0058      	lsls	r0, r3, #1
      t = MAC16_32_Q16(x[i+3], g10, x4);
 8004fe2:	4452      	add	r2, sl
 8004fe4:	fb85 a306 	smull	sl, r3, r5, r6
 8004fe8:	9d03      	ldr	r5, [sp, #12]
      t = MAC16_32_Q16(t, g11, ADD32(x3,x0));
 8004fea:	441a      	add	r2, r3
 8004fec:	462e      	mov	r6, r5
      t = MAC16_32_Q16(t, g12, ADD32(x2,x1));
 8004fee:	eb00 0308 	add.w	r3, r0, r8
 8004ff2:	fb83 5a06 	smull	r5, sl, r3, r6
      t = SATURATE(t, SIG_SAT);
 8004ff6:	4d21      	ldr	r5, [pc, #132]	; (800507c <comb_filter+0x40c>)
      t = MAC16_32_Q16(t, g12, ADD32(x2,x1));
 8004ff8:	4452      	add	r2, sl
      t = SATURATE(t, SIG_SAT);
 8004ffa:	42aa      	cmp	r2, r5
 8004ffc:	bfb8      	it	lt
 8004ffe:	462a      	movlt	r2, r5
      y[i+3] = t;
 8005000:	4b1f      	ldr	r3, [pc, #124]	; (8005080 <comb_filter+0x410>)
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
 8005002:	180d      	adds	r5, r1, r0
      y[i+3] = t;
 8005004:	429a      	cmp	r2, r3
 8005006:	bfa8      	it	ge
 8005008:	461a      	movge	r2, r3
      x1=SHL32(x[i-T+6],1);
 800500a:	9b01      	ldr	r3, [sp, #4]
      y[i+3] = t;
 800500c:	f84c 2c08 	str.w	r2, [ip, #-8]
      x1=SHL32(x[i-T+6],1);
 8005010:	699b      	ldr	r3, [r3, #24]
      t = MAC16_32_Q16(x[i+4], g10, x3);
 8005012:	f857 2c04 	ldr.w	r2, [r7, #-4]
      x1=SHL32(x[i-T+6],1);
 8005016:	ea4f 0843 	mov.w	r8, r3, lsl #1
 800501a:	9b02      	ldr	r3, [sp, #8]
      t = MAC16_32_Q16(x[i+4], g10, x3);
 800501c:	444a      	add	r2, r9
 800501e:	461e      	mov	r6, r3
 8005020:	fb85 9306 	smull	r9, r3, r5, r6
 8005024:	9d03      	ldr	r5, [sp, #12]
      t = MAC16_32_Q16(t, g11, ADD32(x2,x4));
 8005026:	441a      	add	r2, r3
      t = MAC16_32_Q16(t, g12, ADD32(x1,x0));
 8005028:	44c6      	add	lr, r8
 800502a:	462e      	mov	r6, r5
 800502c:	fb8e 5306 	smull	r5, r3, lr, r6
      t = SATURATE(t, SIG_SAT);
 8005030:	4d12      	ldr	r5, [pc, #72]	; (800507c <comb_filter+0x40c>)
      t = MAC16_32_Q16(t, g12, ADD32(x1,x0));
 8005032:	441a      	add	r2, r3
      t = SATURATE(t, SIG_SAT);
 8005034:	42aa      	cmp	r2, r5
 8005036:	bfb8      	it	lt
 8005038:	462a      	movlt	r2, r5
      y[i+4] = t;
 800503a:	4b11      	ldr	r3, [pc, #68]	; (8005080 <comb_filter+0x410>)
 800503c:	9d01      	ldr	r5, [sp, #4]
 800503e:	429a      	cmp	r2, r3
 8005040:	bfa8      	it	ge
 8005042:	461a      	movge	r2, r3
   for (i=0;i<N-4;i+=5)
 8005044:	9b04      	ldr	r3, [sp, #16]
      y[i+4] = t;
 8005046:	f84c 2c04 	str.w	r2, [ip, #-4]
   for (i=0;i<N-4;i+=5)
 800504a:	9a05      	ldr	r2, [sp, #20]
 800504c:	3305      	adds	r3, #5
 800504e:	3514      	adds	r5, #20
 8005050:	4293      	cmp	r3, r2
 8005052:	9304      	str	r3, [sp, #16]
 8005054:	9501      	str	r5, [sp, #4]
 8005056:	f6ff af5f 	blt.w	8004f18 <comb_filter+0x2a8>
}
 800505a:	b017      	add	sp, #92	; 0x5c
 800505c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (g0==g1 && T0==T1 && tapset0==tapset1)
 8005060:	9b03      	ldr	r3, [sp, #12]
 8005062:	429a      	cmp	r2, r3
 8005064:	f47f ae82 	bne.w	8004d6c <comb_filter+0xfc>
 8005068:	9b01      	ldr	r3, [sp, #4]
 800506a:	429f      	cmp	r7, r3
 800506c:	f47f ae7e 	bne.w	8004d6c <comb_filter+0xfc>
      overlap=0;
 8005070:	2300      	movs	r3, #0
 8005072:	930e      	str	r3, [sp, #56]	; 0x38
 8005074:	e70b      	b.n	8004e8e <comb_filter+0x21e>
   for (i=0;i<overlap;i++)
 8005076:	2300      	movs	r3, #0
 8005078:	e709      	b.n	8004e8e <comb_filter+0x21e>
 800507a:	bf00      	nop
 800507c:	ee1e5d00 	.word	0xee1e5d00
 8005080:	11e1a300 	.word	0x11e1a300
 8005084:	08015038 	.word	0x08015038

08005088 <init_caps>:
      {0, -2, 0, -3,    3, 0, 1,-1}, /* 20 ms */
};


void init_caps(const CELTMode *m,int *cap,int LM,int C)
{
 8005088:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   int i;
   for (i=0;i<m->nbEBands;i++)
 800508c:	6884      	ldr	r4, [r0, #8]
 800508e:	2c00      	cmp	r4, #0
 8005090:	dd20      	ble.n	80050d4 <init_caps+0x4c>
 8005092:	2600      	movs	r6, #0
   {
      int N;
      N=(m->eBands[i+1]-m->eBands[i])<<LM;
      cap[i] = (m->cache.caps[m->nbEBands*(2*LM+C-1)+i]+64)*C*N>>2;
 8005094:	eb03 0c42 	add.w	ip, r3, r2, lsl #1
 8005098:	f8d0 e060 	ldr.w	lr, [r0, #96]	; 0x60
 800509c:	6987      	ldr	r7, [r0, #24]
 800509e:	3904      	subs	r1, #4
 80050a0:	f10c 3cff 	add.w	ip, ip, #4294967295
 80050a4:	fb04 e40c 	mla	r4, r4, ip, lr
 80050a8:	5da5      	ldrb	r5, [r4, r6]
      N=(m->eBands[i+1]-m->eBands[i])<<LM;
 80050aa:	f9b7 8000 	ldrsh.w	r8, [r7]
      cap[i] = (m->cache.caps[m->nbEBands*(2*LM+C-1)+i]+64)*C*N>>2;
 80050ae:	3540      	adds	r5, #64	; 0x40
      N=(m->eBands[i+1]-m->eBands[i])<<LM;
 80050b0:	f9b7 4002 	ldrsh.w	r4, [r7, #2]
      cap[i] = (m->cache.caps[m->nbEBands*(2*LM+C-1)+i]+64)*C*N>>2;
 80050b4:	fb03 f505 	mul.w	r5, r3, r5
      N=(m->eBands[i+1]-m->eBands[i])<<LM;
 80050b8:	eba4 0408 	sub.w	r4, r4, r8
 80050bc:	4094      	lsls	r4, r2
      cap[i] = (m->cache.caps[m->nbEBands*(2*LM+C-1)+i]+64)*C*N>>2;
 80050be:	fb04 f405 	mul.w	r4, r4, r5
 80050c2:	10a4      	asrs	r4, r4, #2
 80050c4:	f841 4f04 	str.w	r4, [r1, #4]!
   for (i=0;i<m->nbEBands;i++)
 80050c8:	6884      	ldr	r4, [r0, #8]
 80050ca:	3601      	adds	r6, #1
 80050cc:	42b4      	cmp	r4, r6
 80050ce:	f107 0702 	add.w	r7, r7, #2
 80050d2:	dce7      	bgt.n	80050a4 <init_caps+0x1c>
   }
}
 80050d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080050d8 <deemphasis>:
#ifndef RESYNTH
static
#endif
void deemphasis(celt_sig *in[], opus_val16 *pcm, int N, int C, int downsample, const opus_val16 *coef,
      celt_sig *mem, int accum)
{
 80050d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80050dc:	b08b      	sub	sp, #44	; 0x2c
 80050de:	af00      	add	r7, sp, #0
 80050e0:	61fb      	str	r3, [r7, #28]
   opus_val16 coef0;
   VARDECL(celt_sig, scratch);
   SAVE_STACK;
#ifndef CUSTOM_MODES
   /* Short version for common case. */
   if (downsample == 1 && C == 2 && !accum)
 80050e2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
{
 80050e4:	6d7c      	ldr	r4, [r7, #84]	; 0x54
   if (downsample == 1 && C == 2 && !accum)
 80050e6:	2b01      	cmp	r3, #1
{
 80050e8:	e9c7 1205 	strd	r1, r2, [r7, #20]
 80050ec:	f9b4 4000 	ldrsh.w	r4, [r4]
 80050f0:	f8c7 d000 	str.w	sp, [r7]
   if (downsample == 1 && C == 2 && !accum)
 80050f4:	f000 8108 	beq.w	8005308 <deemphasis+0x230>
   int apply_downsampling=0;
 80050f8:	2100      	movs	r1, #0

static OPUS_INLINE opus_val16 SIG2WORD16_generic(celt_sig x)
{
   x = PSHR32(x, SIG_SHIFT);
   x = MAX32(x, -32768);
   x = MIN32(x, 32767);
 80050fa:	f647 79ff 	movw	r9, #32767	; 0x7fff
   celt_assert(accum==0);
#endif
   ALLOC(scratch, N, celt_sig);
   coef0 = coef[0];
   Nd = N/downsample;
   c=0; do {
 80050fe:	468e      	mov	lr, r1
   ALLOC(scratch, N, celt_sig);
 8005100:	69bd      	ldr	r5, [r7, #24]
   x = MAX32(x, -32768);
 8005102:	4ea7      	ldr	r6, [pc, #668]	; (80053a0 <deemphasis+0x2c8>)
 8005104:	00ab      	lsls	r3, r5, #2
 8005106:	f103 020a 	add.w	r2, r3, #10
 800510a:	3b04      	subs	r3, #4
 800510c:	613b      	str	r3, [r7, #16]
 800510e:	69fb      	ldr	r3, [r7, #28]
 8005110:	f022 0207 	bic.w	r2, r2, #7
 8005114:	ebad 0d02 	sub.w	sp, sp, r2
 8005118:	ea4f 0843 	mov.w	r8, r3, lsl #1
   Nd = N/downsample;
 800511c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800511e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005120:	fb95 fbf2 	sdiv	fp, r5, r2
 8005124:	009b      	lsls	r3, r3, #2
 8005126:	1f02      	subs	r2, r0, #4
   int apply_downsampling=0;
 8005128:	6239      	str	r1, [r7, #32]
   ALLOC(scratch, N, celt_sig);
 800512a:	f8c7 d00c 	str.w	sp, [r7, #12]
      : "%r"(b), "r"(SHL32(a,16))
 800512e:	0424      	lsls	r4, r4, #16
 8005130:	627a      	str	r2, [r7, #36]	; 0x24
 8005132:	60bb      	str	r3, [r7, #8]
      int j;
      celt_sig * OPUS_RESTRICT x;
      opus_val16  * OPUS_RESTRICT y;
      celt_sig m = mem[c];
 8005134:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8005136:	f853 202e 	ldr.w	r2, [r3, lr, lsl #2]
      x =in[c];
 800513a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800513c:	f853 5f04 	ldr.w	r5, [r3, #4]!
 8005140:	627b      	str	r3, [r7, #36]	; 0x24
            scratch[j] = tmp;
         }
         apply_downsampling=1;
      } else
#endif
      if (downsample>1)
 8005142:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8005144:	2b01      	cmp	r3, #1
 8005146:	dd54      	ble.n	80051f2 <deemphasis+0x11a>
      {
         /* Shortcut for the standard (non-custom modes) case */
         for (j=0;j<N;j++)
 8005148:	69bb      	ldr	r3, [r7, #24]
 800514a:	2b00      	cmp	r3, #0
 800514c:	dd0f      	ble.n	800516e <deemphasis+0x96>
 800514e:	693b      	ldr	r3, [r7, #16]
 8005150:	1f29      	subs	r1, r5, #4
 8005152:	441d      	add	r5, r3
 8005154:	68fb      	ldr	r3, [r7, #12]
 8005156:	1f18      	subs	r0, r3, #4
         {
            celt_sig tmp = x[j] + VERY_SMALL + m;
 8005158:	f851 3f04 	ldr.w	r3, [r1, #4]!
 800515c:	4413      	add	r3, r2
         for (j=0;j<N;j++)
 800515e:	428d      	cmp	r5, r1
  __asm__(
 8005160:	fb83 c204 	smull	ip, r2, r3, r4
            m = MULT16_32_Q15(coef0, tmp);
            scratch[j] = tmp;
 8005164:	f840 3f04 	str.w	r3, [r0, #4]!
  return SHL32(rd_hi,1);
 8005168:	ea4f 0242 	mov.w	r2, r2, lsl #1
         for (j=0;j<N;j++)
 800516c:	d1f4      	bne.n	8005158 <deemphasis+0x80>
               m = MULT16_32_Q15(coef0, tmp);
               y[j*C] = SCALEOUT(SIG2WORD16(tmp));
            }
         }
      }
      mem[c] = m;
 800516e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8005170:	f843 202e 	str.w	r2, [r3, lr, lsl #2]

      if (apply_downsampling)
      {
         /* Perform down-sampling */
#ifdef FIXED_POINT
         if (accum)
 8005174:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8005176:	2b00      	cmp	r3, #0
 8005178:	f000 80aa 	beq.w	80052d0 <deemphasis+0x1f8>
         {
            for (j=0;j<Nd;j++)
 800517c:	f1bb 0f00 	cmp.w	fp, #0
 8005180:	dd2a      	ble.n	80051d8 <deemphasis+0x100>
 8005182:	697b      	ldr	r3, [r7, #20]
 8005184:	68fd      	ldr	r5, [r7, #12]
 8005186:	2000      	movs	r0, #0
 8005188:	eb03 014e 	add.w	r1, r3, lr, lsl #1
 800518c:	f8d7 c008 	ldr.w	ip, [r7, #8]
 8005190:	e009      	b.n	80051a6 <deemphasis+0xce>

#define ABS16(x) ((x) < 0 ? (-(x)) : (x))
#define ABS32(x) ((x) < 0 ? (-(x)) : (x))

static OPUS_INLINE opus_int16 SAT16(opus_int32 x) {
   return x > 32767 ? 32767 : x < -32768 ? -32768 : (opus_int16)x;
 8005192:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8005196:	db5b      	blt.n	8005250 <deemphasis+0x178>
 8005198:	b21b      	sxth	r3, r3
 800519a:	3001      	adds	r0, #1
 800519c:	4583      	cmp	fp, r0
               y[j*C] = SAT16(ADD32(y[j*C], SCALEOUT(SIG2WORD16(scratch[j*downsample]))));
 800519e:	800b      	strh	r3, [r1, #0]
 80051a0:	4465      	add	r5, ip
 80051a2:	4441      	add	r1, r8
            for (j=0;j<Nd;j++)
 80051a4:	d018      	beq.n	80051d8 <deemphasis+0x100>
   x = PSHR32(x, SIG_SHIFT);
 80051a6:	682b      	ldr	r3, [r5, #0]
               y[j*C] = SAT16(ADD32(y[j*C], SCALEOUT(SIG2WORD16(scratch[j*downsample]))));
 80051a8:	f9b1 2000 	ldrsh.w	r2, [r1]
 80051ac:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80051b0:	131b      	asrs	r3, r3, #12
   x = MAX32(x, -32768);
 80051b2:	42b3      	cmp	r3, r6
 80051b4:	bfb8      	it	lt
 80051b6:	4633      	movlt	r3, r6
 80051b8:	454b      	cmp	r3, r9
 80051ba:	bfd4      	ite	le
 80051bc:	18d3      	addle	r3, r2, r3
 80051be:	eb02 0309 	addgt.w	r3, r2, r9
 80051c2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80051c6:	dbe4      	blt.n	8005192 <deemphasis+0xba>
 80051c8:	f647 73ff 	movw	r3, #32767	; 0x7fff
            for (j=0;j<Nd;j++)
 80051cc:	3001      	adds	r0, #1
 80051ce:	4583      	cmp	fp, r0
               y[j*C] = SAT16(ADD32(y[j*C], SCALEOUT(SIG2WORD16(scratch[j*downsample]))));
 80051d0:	800b      	strh	r3, [r1, #0]
 80051d2:	4465      	add	r5, ip
 80051d4:	4441      	add	r1, r8
            for (j=0;j<Nd;j++)
 80051d6:	d1e6      	bne.n	80051a6 <deemphasis+0xce>
         } else
#endif
         {
            for (j=0;j<Nd;j++)
 80051d8:	2301      	movs	r3, #1
 80051da:	623b      	str	r3, [r7, #32]
               y[j*C] = SCALEOUT(SIG2WORD16(scratch[j*downsample]));
         }
      }
   } while (++c<C);
 80051dc:	69fb      	ldr	r3, [r7, #28]
 80051de:	f10e 0e01 	add.w	lr, lr, #1
 80051e2:	4573      	cmp	r3, lr
 80051e4:	dca6      	bgt.n	8005134 <deemphasis+0x5c>
 80051e6:	f8d7 d000 	ldr.w	sp, [r7]
   RESTORE_STACK;
}
 80051ea:	372c      	adds	r7, #44	; 0x2c
 80051ec:	46bd      	mov	sp, r7
 80051ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         if (accum)
 80051f2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80051f4:	bb73      	cbnz	r3, 8005254 <deemphasis+0x17c>
            for (j=0;j<N;j++)
 80051f6:	69bb      	ldr	r3, [r7, #24]
 80051f8:	2b00      	cmp	r3, #0
 80051fa:	dd1a      	ble.n	8005232 <deemphasis+0x15a>
 80051fc:	693b      	ldr	r3, [r7, #16]
 80051fe:	f1a5 0c04 	sub.w	ip, r5, #4
 8005202:	441d      	add	r5, r3
 8005204:	697b      	ldr	r3, [r7, #20]
 8005206:	eb03 004e 	add.w	r0, r3, lr, lsl #1
               celt_sig tmp = x[j] + VERY_SMALL + m;
 800520a:	f85c 3f04 	ldr.w	r3, [ip, #4]!
 800520e:	441a      	add	r2, r3
   x = PSHR32(x, SIG_SHIFT);
 8005210:	f502 6300 	add.w	r3, r2, #2048	; 0x800
 8005214:	131b      	asrs	r3, r3, #12
   x = MAX32(x, -32768);
 8005216:	42b3      	cmp	r3, r6
 8005218:	bfb8      	it	lt
 800521a:	4633      	movlt	r3, r6
  __asm__(
 800521c:	fb82 a104 	smull	sl, r1, r2, r4
   x = MIN32(x, 32767);
 8005220:	454b      	cmp	r3, r9
 8005222:	bfa8      	it	ge
 8005224:	464b      	movge	r3, r9
            for (j=0;j<N;j++)
 8005226:	4565      	cmp	r5, ip
   return EXTRACT16(x);
 8005228:	8003      	strh	r3, [r0, #0]
  return SHL32(rd_hi,1);
 800522a:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800522e:	4440      	add	r0, r8
 8005230:	d1eb      	bne.n	800520a <deemphasis+0x132>
      mem[c] = m;
 8005232:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8005234:	f843 202e 	str.w	r2, [r3, lr, lsl #2]
      if (apply_downsampling)
 8005238:	6a3b      	ldr	r3, [r7, #32]
 800523a:	2b00      	cmp	r3, #0
 800523c:	d148      	bne.n	80052d0 <deemphasis+0x1f8>
            for (j=0;j<Nd;j++)
 800523e:	2300      	movs	r3, #0
 8005240:	623b      	str	r3, [r7, #32]
   } while (++c<C);
 8005242:	69fb      	ldr	r3, [r7, #28]
 8005244:	f10e 0e01 	add.w	lr, lr, #1
 8005248:	4573      	cmp	r3, lr
 800524a:	f73f af73 	bgt.w	8005134 <deemphasis+0x5c>
 800524e:	e7ca      	b.n	80051e6 <deemphasis+0x10e>
 8005250:	4633      	mov	r3, r6
 8005252:	e7a2      	b.n	800519a <deemphasis+0xc2>
            for (j=0;j<N;j++)
 8005254:	69bb      	ldr	r3, [r7, #24]
 8005256:	2b00      	cmp	r3, #0
 8005258:	dd31      	ble.n	80052be <deemphasis+0x1e6>
 800525a:	693b      	ldr	r3, [r7, #16]
 800525c:	f1a5 0a04 	sub.w	sl, r5, #4
 8005260:	441d      	add	r5, r3
 8005262:	697b      	ldr	r3, [r7, #20]
 8005264:	f8c7 e004 	str.w	lr, [r7, #4]
 8005268:	eb03 0c4e 	add.w	ip, r3, lr, lsl #1
 800526c:	e008      	b.n	8005280 <deemphasis+0x1a8>
 800526e:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8005272:	db2b      	blt.n	80052cc <deemphasis+0x1f4>
 8005274:	b21b      	sxth	r3, r3
 8005276:	4555      	cmp	r5, sl
               y[j*C] = SAT16(ADD32(y[j*C], SCALEOUT(SIG2WORD16(tmp))));
 8005278:	f8ac 3000 	strh.w	r3, [ip]
 800527c:	44c4      	add	ip, r8
            for (j=0;j<N;j++)
 800527e:	d01c      	beq.n	80052ba <deemphasis+0x1e2>
               celt_sig tmp = x[j] + m + VERY_SMALL;
 8005280:	f85a 1f04 	ldr.w	r1, [sl, #4]!
               y[j*C] = SAT16(ADD32(y[j*C], SCALEOUT(SIG2WORD16(tmp))));
 8005284:	f9bc 3000 	ldrsh.w	r3, [ip]
               celt_sig tmp = x[j] + m + VERY_SMALL;
 8005288:	440a      	add	r2, r1
   x = PSHR32(x, SIG_SHIFT);
 800528a:	f502 6100 	add.w	r1, r2, #2048	; 0x800
 800528e:	1309      	asrs	r1, r1, #12
   x = MAX32(x, -32768);
 8005290:	42b1      	cmp	r1, r6
 8005292:	bfb8      	it	lt
 8005294:	4631      	movlt	r1, r6
  __asm__(
 8005296:	fb82 e004 	smull	lr, r0, r2, r4
               y[j*C] = SAT16(ADD32(y[j*C], SCALEOUT(SIG2WORD16(tmp))));
 800529a:	4549      	cmp	r1, r9
 800529c:	bfd4      	ite	le
 800529e:	185b      	addle	r3, r3, r1
 80052a0:	444b      	addgt	r3, r9
 80052a2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  return SHL32(rd_hi,1);
 80052a6:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80052aa:	dbe0      	blt.n	800526e <deemphasis+0x196>
 80052ac:	f647 73ff 	movw	r3, #32767	; 0x7fff
            for (j=0;j<N;j++)
 80052b0:	4555      	cmp	r5, sl
               y[j*C] = SAT16(ADD32(y[j*C], SCALEOUT(SIG2WORD16(tmp))));
 80052b2:	f8ac 3000 	strh.w	r3, [ip]
 80052b6:	44c4      	add	ip, r8
            for (j=0;j<N;j++)
 80052b8:	d1e2      	bne.n	8005280 <deemphasis+0x1a8>
 80052ba:	f8d7 e004 	ldr.w	lr, [r7, #4]
      mem[c] = m;
 80052be:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80052c0:	f843 202e 	str.w	r2, [r3, lr, lsl #2]
      if (apply_downsampling)
 80052c4:	6a3b      	ldr	r3, [r7, #32]
 80052c6:	2b00      	cmp	r3, #0
 80052c8:	d0b9      	beq.n	800523e <deemphasis+0x166>
 80052ca:	e757      	b.n	800517c <deemphasis+0xa4>
 80052cc:	4633      	mov	r3, r6
 80052ce:	e7d2      	b.n	8005276 <deemphasis+0x19e>
            for (j=0;j<Nd;j++)
 80052d0:	f1bb 0f00 	cmp.w	fp, #0
 80052d4:	dd80      	ble.n	80051d8 <deemphasis+0x100>
 80052d6:	2100      	movs	r1, #0
 80052d8:	697b      	ldr	r3, [r7, #20]
 80052da:	68f8      	ldr	r0, [r7, #12]
 80052dc:	68bd      	ldr	r5, [r7, #8]
 80052de:	eb03 024e 	add.w	r2, r3, lr, lsl #1
   x = PSHR32(x, SIG_SHIFT);
 80052e2:	6803      	ldr	r3, [r0, #0]
 80052e4:	3101      	adds	r1, #1
 80052e6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80052ea:	131b      	asrs	r3, r3, #12
   x = MAX32(x, -32768);
 80052ec:	42b3      	cmp	r3, r6
 80052ee:	bfb8      	it	lt
 80052f0:	4633      	movlt	r3, r6
   x = MIN32(x, 32767);
 80052f2:	454b      	cmp	r3, r9
 80052f4:	bfa8      	it	ge
 80052f6:	464b      	movge	r3, r9
 80052f8:	458b      	cmp	fp, r1
   return EXTRACT16(x);
 80052fa:	8013      	strh	r3, [r2, #0]
 80052fc:	4428      	add	r0, r5
 80052fe:	4442      	add	r2, r8
 8005300:	d1ef      	bne.n	80052e2 <deemphasis+0x20a>
 8005302:	2301      	movs	r3, #1
 8005304:	623b      	str	r3, [r7, #32]
 8005306:	e769      	b.n	80051dc <deemphasis+0x104>
   if (downsample == 1 && C == 2 && !accum)
 8005308:	69fb      	ldr	r3, [r7, #28]
 800530a:	2b02      	cmp	r3, #2
 800530c:	f47f aef4 	bne.w	80050f8 <deemphasis+0x20>
 8005310:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8005312:	2b00      	cmp	r3, #0
 8005314:	f47f aef0 	bne.w	80050f8 <deemphasis+0x20>
 8005318:	4616      	mov	r6, r2
 800531a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   for (j=0;j<N;j++)
 800531c:	2e00      	cmp	r6, #0
 800531e:	6819      	ldr	r1, [r3, #0]
   x1=in[1];
 8005320:	6845      	ldr	r5, [r0, #4]
   m1 = mem[1];
 8005322:	685a      	ldr	r2, [r3, #4]
   for (j=0;j<N;j++)
 8005324:	dd35      	ble.n	8005392 <deemphasis+0x2ba>
   x = MIN32(x, 32767);
 8005326:	f647 7aff 	movw	sl, #32767	; 0x7fff
 800532a:	6803      	ldr	r3, [r0, #0]
 800532c:	f8d7 c014 	ldr.w	ip, [r7, #20]
   x = MAX32(x, -32768);
 8005330:	f8df 906c 	ldr.w	r9, [pc, #108]	; 80053a0 <deemphasis+0x2c8>
 8005334:	f1a3 0804 	sub.w	r8, r3, #4
 8005338:	eb0c 0b86 	add.w	fp, ip, r6, lsl #2
      : "%r"(b), "r"(SHL32(a,16))
 800533c:	0423      	lsls	r3, r4, #16
 800533e:	f1a5 0e04 	sub.w	lr, r5, #4
      tmp0 = x0[j] + VERY_SMALL + m0;
 8005342:	f858 4f04 	ldr.w	r4, [r8, #4]!
      tmp1 = x1[j] + VERY_SMALL + m1;
 8005346:	f85e 5f04 	ldr.w	r5, [lr, #4]!
      tmp0 = x0[j] + VERY_SMALL + m0;
 800534a:	440c      	add	r4, r1
      tmp1 = x1[j] + VERY_SMALL + m1;
 800534c:	4415      	add	r5, r2
   x = PSHR32(x, SIG_SHIFT);
 800534e:	f504 6000 	add.w	r0, r4, #2048	; 0x800
 8005352:	1300      	asrs	r0, r0, #12
 8005354:	f505 6200 	add.w	r2, r5, #2048	; 0x800
 8005358:	1312      	asrs	r2, r2, #12
   x = MAX32(x, -32768);
 800535a:	4548      	cmp	r0, r9
 800535c:	bfb8      	it	lt
 800535e:	4648      	movlt	r0, r9
  __asm__(
 8005360:	fb84 6103 	smull	r6, r1, r4, r3
 8005364:	fb85 6403 	smull	r6, r4, r5, r3
 8005368:	454a      	cmp	r2, r9
 800536a:	bfb8      	it	lt
 800536c:	464a      	movlt	r2, r9
   x = MIN32(x, 32767);
 800536e:	4550      	cmp	r0, sl
 8005370:	bfa8      	it	ge
 8005372:	4650      	movge	r0, sl
 8005374:	4552      	cmp	r2, sl
 8005376:	bfa8      	it	ge
 8005378:	4652      	movge	r2, sl
   return EXTRACT16(x);
 800537a:	f8ac 0000 	strh.w	r0, [ip]
 800537e:	f8ac 2002 	strh.w	r2, [ip, #2]
 8005382:	f10c 0c04 	add.w	ip, ip, #4
   for (j=0;j<N;j++)
 8005386:	45dc      	cmp	ip, fp
  return SHL32(rd_hi,1);
 8005388:	ea4f 0141 	mov.w	r1, r1, lsl #1
 800538c:	ea4f 0244 	mov.w	r2, r4, lsl #1
 8005390:	d1d7      	bne.n	8005342 <deemphasis+0x26a>
   mem[0] = m0;
 8005392:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   mem[1] = m1;
 8005394:	e9c3 1200 	strd	r1, r2, [r3]
 8005398:	f8d7 d000 	ldr.w	sp, [r7]
 800539c:	e725      	b.n	80051ea <deemphasis+0x112>
 800539e:	bf00      	nop
 80053a0:	ffff8000 	.word	0xffff8000

080053a4 <celt_synthesis>:
#endif
void celt_synthesis(const CELTMode *mode, celt_norm *X, celt_sig * out_syn[],
                    opus_val16 *oldBandE, int start, int effEnd, int C, int CC,
                    int isTransient, int LM, int downsample,
                    int silence, int arch)
{
 80053a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80053a8:	b095      	sub	sp, #84	; 0x54
 80053aa:	4681      	mov	r9, r0

   overlap = mode->overlap;
   nbEBands = mode->nbEBands;
   N = mode->shortMdctSize<<LM;
   ALLOC(freq, N, celt_sig); /**< Interleaved signal MDCTs */
   M = 1<<LM;
 80053ac:	f04f 0c01 	mov.w	ip, #1
   N = mode->shortMdctSize<<LM;
 80053b0:	6a44      	ldr	r4, [r0, #36]	; 0x24
{
 80053b2:	af06      	add	r7, sp, #24
 80053b4:	e9d7 061c 	ldrd	r0, r6, [r7, #112]	; 0x70
   N = mode->shortMdctSize<<LM;
 80053b8:	fa04 f506 	lsl.w	r5, r4, r6
   ALLOC(freq, N, celt_sig); /**< Interleaved signal MDCTs */
 80053bc:	60bd      	str	r5, [r7, #8]
 80053be:	00ad      	lsls	r5, r5, #2
 80053c0:	607d      	str	r5, [r7, #4]
 80053c2:	350a      	adds	r5, #10
 80053c4:	f025 0507 	bic.w	r5, r5, #7
 80053c8:	ebad 0d05 	sub.w	sp, sp, r5
{
 80053cc:	469a      	mov	sl, r3
   ALLOC(freq, N, celt_sig); /**< Interleaved signal MDCTs */
 80053ce:	ab06      	add	r3, sp, #24
 80053d0:	61fb      	str	r3, [r7, #28]
   overlap = mode->overlap;
 80053d2:	f8d9 3004 	ldr.w	r3, [r9, #4]
{
 80053d6:	460d      	mov	r5, r1
   overlap = mode->overlap;
 80053d8:	633b      	str	r3, [r7, #48]	; 0x30
   M = 1<<LM;
 80053da:	fa0c f306 	lsl.w	r3, ip, r6
 80053de:	61bb      	str	r3, [r7, #24]
 80053e0:	f8d9 301c 	ldr.w	r3, [r9, #28]
{
 80053e4:	60fa      	str	r2, [r7, #12]
   nbEBands = mode->nbEBands;
 80053e6:	f8d9 8008 	ldr.w	r8, [r9, #8]
 80053ea:	637b      	str	r3, [r7, #52]	; 0x34

   if (isTransient)
 80053ec:	2800      	cmp	r0, #0
 80053ee:	d179      	bne.n	80054e4 <celt_synthesis+0x140>
      NB = mode->shortMdctSize;
      shift = mode->maxLM;
   } else {
      B = 1;
      NB = mode->shortMdctSize<<LM;
      shift = mode->maxLM-LM;
 80053f0:	1b9b      	subs	r3, r3, r6
 80053f2:	637b      	str	r3, [r7, #52]	; 0x34
   }

   if (CC==2&&C==1)
 80053f4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
      B = 1;
 80053f6:	46e3      	mov	fp, ip
   if (CC==2&&C==1)
 80053f8:	2b02      	cmp	r3, #2
   N = mode->shortMdctSize<<LM;
 80053fa:	68bc      	ldr	r4, [r7, #8]
   if (CC==2&&C==1)
 80053fc:	d077      	beq.n	80054ee <celt_synthesis+0x14a>
      OPUS_COPY(freq2, freq, N);
      for (b=0;b<B;b++)
         clt_mdct_backward(&mode->mdct, &freq2[b], out_syn[0]+NB*b, mode->window, overlap, shift, B, arch);
      for (b=0;b<B;b++)
         clt_mdct_backward(&mode->mdct, &freq[b], out_syn[1]+NB*b, mode->window, overlap, shift, B, arch);
   } else if (CC==1&&C==2)
 80053fe:	2b01      	cmp	r3, #1
 8005400:	f000 80d2 	beq.w	80055a8 <celt_synthesis+0x204>
      for (b=0;b<B;b++)
 8005404:	2300      	movs	r3, #0
 8005406:	623b      	str	r3, [r7, #32]
 8005408:	ea4f 0348 	mov.w	r3, r8, lsl #1
 800540c:	617b      	str	r3, [r7, #20]
 800540e:	68bb      	ldr	r3, [r7, #8]
 8005410:	68fe      	ldr	r6, [r7, #12]
 8005412:	005b      	lsls	r3, r3, #1
 8005414:	613b      	str	r3, [r7, #16]
 8005416:	69fb      	ldr	r3, [r7, #28]
 8005418:	e9c7 5a09 	strd	r5, sl, [r7, #36]	; 0x24
 800541c:	eb03 038b 	add.w	r3, r3, fp, lsl #2
 8005420:	ea4f 0a84 	mov.w	sl, r4, lsl #2
 8005424:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005426:	f109 0838 	add.w	r8, r9, #56	; 0x38
      for (b=0;b<B;b++)
         clt_mdct_backward(&mode->mdct, &freq[b], out_syn[0]+NB*b, mode->window, overlap, shift, B, arch);
   } else {
      /* Normal case (mono or stereo) */
      c=0; do {
         denormalise_bands(mode, X+c*N, freq, oldBandE+c*nbEBands, start, effEnd, M,
 800542a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800542c:	69fc      	ldr	r4, [r7, #28]
 800542e:	9304      	str	r3, [sp, #16]
 8005430:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8005432:	4622      	mov	r2, r4
 8005434:	9303      	str	r3, [sp, #12]
 8005436:	69bb      	ldr	r3, [r7, #24]
 8005438:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800543a:	9302      	str	r3, [sp, #8]
 800543c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800543e:	4648      	mov	r0, r9
 8005440:	9301      	str	r3, [sp, #4]
 8005442:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8005444:	9300      	str	r3, [sp, #0]
 8005446:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005448:	f7fd ff8e 	bl	8003368 <denormalise_bands>
               downsample, silence);
         for (b=0;b<B;b++)
 800544c:	f1bb 0f00 	cmp.w	fp, #0
 8005450:	dd15      	ble.n	800547e <celt_synthesis+0xda>
 8005452:	2500      	movs	r5, #0
            clt_mdct_backward(&mode->mdct, &freq[b], out_syn[c]+NB*b, mode->window, overlap, shift, B, arch);
 8005454:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8005458:	f8d9 3034 	ldr.w	r3, [r9, #52]	; 0x34
 800545c:	6832      	ldr	r2, [r6, #0]
 800545e:	e9cd b102 	strd	fp, r1, [sp, #8]
 8005462:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8005464:	442a      	add	r2, r5
 8005466:	9101      	str	r1, [sp, #4]
 8005468:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800546a:	4640      	mov	r0, r8
 800546c:	9100      	str	r1, [sp, #0]
 800546e:	4621      	mov	r1, r4
 8005470:	f004 fb1c 	bl	8009aac <clt_mdct_backward_c>
         for (b=0;b<B;b++)
 8005474:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005476:	3404      	adds	r4, #4
 8005478:	42a3      	cmp	r3, r4
 800547a:	4455      	add	r5, sl
 800547c:	d1ea      	bne.n	8005454 <celt_synthesis+0xb0>
 800547e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005480:	6939      	ldr	r1, [r7, #16]
      } while (++c<CC);
 8005482:	6a3b      	ldr	r3, [r7, #32]
 8005484:	440a      	add	r2, r1
 8005486:	627a      	str	r2, [r7, #36]	; 0x24
 8005488:	6979      	ldr	r1, [r7, #20]
 800548a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800548c:	3301      	adds	r3, #1
 800548e:	440a      	add	r2, r1
 8005490:	62ba      	str	r2, [r7, #40]	; 0x28
 8005492:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8005494:	623b      	str	r3, [r7, #32]
 8005496:	429a      	cmp	r2, r3
 8005498:	f106 0604 	add.w	r6, r6, #4
 800549c:	dcc5      	bgt.n	800542a <celt_synthesis+0x86>
 800549e:	68bb      	ldr	r3, [r7, #8]
 80054a0:	2b00      	cmp	r3, #0
 80054a2:	dd1b      	ble.n	80054dc <celt_synthesis+0x138>
 80054a4:	687b      	ldr	r3, [r7, #4]
 80054a6:	1f18      	subs	r0, r3, #4
         for (b=0;b<B;b++)
 80054a8:	2600      	movs	r6, #0
 80054aa:	68fb      	ldr	r3, [r7, #12]
   }
   /* Saturate IMDCT output so that we can't overflow in the pitch postfilter
      or in the */
   c=0; do {
      for (i=0;i<N;i++)
         out_syn[c][i] = SATURATE(out_syn[c][i], SIG_SAT);
 80054ac:	4d72      	ldr	r5, [pc, #456]	; (8005678 <celt_synthesis+0x2d4>)
 80054ae:	4c73      	ldr	r4, [pc, #460]	; (800567c <celt_synthesis+0x2d8>)
 80054b0:	f8d7 e06c 	ldr.w	lr, [r7, #108]	; 0x6c
 80054b4:	f1a3 0c04 	sub.w	ip, r3, #4
 80054b8:	f85c 1f04 	ldr.w	r1, [ip, #4]!
 80054bc:	1f0a      	subs	r2, r1, #4
 80054be:	4401      	add	r1, r0
 80054c0:	f852 3f04 	ldr.w	r3, [r2, #4]!
 80054c4:	42ab      	cmp	r3, r5
 80054c6:	bfb8      	it	lt
 80054c8:	462b      	movlt	r3, r5
 80054ca:	42a3      	cmp	r3, r4
 80054cc:	bfa8      	it	ge
 80054ce:	4623      	movge	r3, r4
      for (i=0;i<N;i++)
 80054d0:	4291      	cmp	r1, r2
         out_syn[c][i] = SATURATE(out_syn[c][i], SIG_SAT);
 80054d2:	6013      	str	r3, [r2, #0]
      for (i=0;i<N;i++)
 80054d4:	d1f4      	bne.n	80054c0 <celt_synthesis+0x11c>
   } while (++c<CC);
 80054d6:	3601      	adds	r6, #1
 80054d8:	45b6      	cmp	lr, r6
 80054da:	dced      	bgt.n	80054b8 <celt_synthesis+0x114>
   RESTORE_STACK;
}
 80054dc:	373c      	adds	r7, #60	; 0x3c
 80054de:	46bd      	mov	sp, r7
 80054e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (CC==2&&C==1)
 80054e4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
      B = M;
 80054e6:	f8d7 b018 	ldr.w	fp, [r7, #24]
   if (CC==2&&C==1)
 80054ea:	2b02      	cmp	r3, #2
 80054ec:	d187      	bne.n	80053fe <celt_synthesis+0x5a>
 80054ee:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80054f0:	2b01      	cmp	r3, #1
 80054f2:	d187      	bne.n	8005404 <celt_synthesis+0x60>
      denormalise_bands(mode, X, freq, oldBandE, start, effEnd, M,
 80054f4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80054f6:	69fe      	ldr	r6, [r7, #28]
 80054f8:	9304      	str	r3, [sp, #16]
 80054fa:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80054fc:	4629      	mov	r1, r5
 80054fe:	9303      	str	r3, [sp, #12]
 8005500:	69bb      	ldr	r3, [r7, #24]
 8005502:	4632      	mov	r2, r6
 8005504:	9302      	str	r3, [sp, #8]
 8005506:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8005508:	4648      	mov	r0, r9
 800550a:	9301      	str	r3, [sp, #4]
 800550c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800550e:	9300      	str	r3, [sp, #0]
 8005510:	4653      	mov	r3, sl
 8005512:	f7fd ff29 	bl	8003368 <denormalise_bands>
      freq2 = out_syn[1]+overlap/2;
 8005516:	68fa      	ldr	r2, [r7, #12]
 8005518:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800551a:	6855      	ldr	r5, [r2, #4]
 800551c:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 8005520:	105b      	asrs	r3, r3, #1
 8005522:	eb05 0583 	add.w	r5, r5, r3, lsl #2
      OPUS_COPY(freq2, freq, N);
 8005526:	4628      	mov	r0, r5
 8005528:	687a      	ldr	r2, [r7, #4]
 800552a:	4631      	mov	r1, r6
 800552c:	f00e fdd8 	bl	80140e0 <memcpy>
      for (b=0;b<B;b++)
 8005530:	f1bb 0f00 	cmp.w	fp, #0
 8005534:	ddb3      	ble.n	800549e <celt_synthesis+0xfa>
 8005536:	2600      	movs	r6, #0
 8005538:	ea4f 038b 	mov.w	r3, fp, lsl #2
 800553c:	ea4f 0a84 	mov.w	sl, r4, lsl #2
 8005540:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005542:	18ec      	adds	r4, r5, r3
 8005544:	f109 0838 	add.w	r8, r9, #56	; 0x38
         clt_mdct_backward(&mode->mdct, &freq2[b], out_syn[0]+NB*b, mode->window, overlap, shift, B, arch);
 8005548:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 800554c:	68fa      	ldr	r2, [r7, #12]
 800554e:	f8d9 3034 	ldr.w	r3, [r9, #52]	; 0x34
 8005552:	6812      	ldr	r2, [r2, #0]
 8005554:	e9cd b102 	strd	fp, r1, [sp, #8]
 8005558:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800555a:	4432      	add	r2, r6
 800555c:	9101      	str	r1, [sp, #4]
 800555e:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8005560:	4640      	mov	r0, r8
 8005562:	9100      	str	r1, [sp, #0]
 8005564:	4629      	mov	r1, r5
 8005566:	3504      	adds	r5, #4
 8005568:	f004 faa0 	bl	8009aac <clt_mdct_backward_c>
      for (b=0;b<B;b++)
 800556c:	42ac      	cmp	r4, r5
 800556e:	4456      	add	r6, sl
 8005570:	d1ea      	bne.n	8005548 <celt_synthesis+0x1a4>
 8005572:	69fc      	ldr	r4, [r7, #28]
 8005574:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005576:	2600      	movs	r6, #0
 8005578:	4423      	add	r3, r4
 800557a:	461d      	mov	r5, r3
         clt_mdct_backward(&mode->mdct, &freq[b], out_syn[1]+NB*b, mode->window, overlap, shift, B, arch);
 800557c:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8005580:	68fa      	ldr	r2, [r7, #12]
 8005582:	f8d9 3034 	ldr.w	r3, [r9, #52]	; 0x34
 8005586:	6852      	ldr	r2, [r2, #4]
 8005588:	e9cd b102 	strd	fp, r1, [sp, #8]
 800558c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800558e:	4432      	add	r2, r6
 8005590:	9101      	str	r1, [sp, #4]
 8005592:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8005594:	4640      	mov	r0, r8
 8005596:	9100      	str	r1, [sp, #0]
 8005598:	4621      	mov	r1, r4
 800559a:	3404      	adds	r4, #4
 800559c:	f004 fa86 	bl	8009aac <clt_mdct_backward_c>
      for (b=0;b<B;b++)
 80055a0:	42a5      	cmp	r5, r4
 80055a2:	4456      	add	r6, sl
 80055a4:	d1ea      	bne.n	800557c <celt_synthesis+0x1d8>
 80055a6:	e77a      	b.n	800549e <celt_synthesis+0xfa>
   } else if (CC==1&&C==2)
 80055a8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80055aa:	2b02      	cmp	r3, #2
 80055ac:	f47f af2a 	bne.w	8005404 <celt_synthesis+0x60>
      freq2 = out_syn[0]+overlap/2;
 80055b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
      denormalise_bands(mode, X, freq, oldBandE, start, effEnd, M,
 80055b2:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
      freq2 = out_syn[0]+overlap/2;
 80055b4:	eb03 76d3 	add.w	r6, r3, r3, lsr #31
 80055b8:	68fb      	ldr	r3, [r7, #12]
      denormalise_bands(mode, X, freq, oldBandE, start, effEnd, M,
 80055ba:	6e79      	ldr	r1, [r7, #100]	; 0x64
      freq2 = out_syn[0]+overlap/2;
 80055bc:	681b      	ldr	r3, [r3, #0]
      denormalise_bands(mode, X, freq, oldBandE, start, effEnd, M,
 80055be:	9204      	str	r2, [sp, #16]
 80055c0:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80055c2:	9101      	str	r1, [sp, #4]
 80055c4:	9203      	str	r2, [sp, #12]
 80055c6:	6e39      	ldr	r1, [r7, #96]	; 0x60
 80055c8:	69ba      	ldr	r2, [r7, #24]
      freq2 = out_syn[0]+overlap/2;
 80055ca:	1076      	asrs	r6, r6, #1
      denormalise_bands(mode, X, freq, oldBandE, start, effEnd, M,
 80055cc:	9202      	str	r2, [sp, #8]
 80055ce:	9100      	str	r1, [sp, #0]
      freq2 = out_syn[0]+overlap/2;
 80055d0:	eb03 0686 	add.w	r6, r3, r6, lsl #2
      denormalise_bands(mode, X, freq, oldBandE, start, effEnd, M,
 80055d4:	69fa      	ldr	r2, [r7, #28]
 80055d6:	4653      	mov	r3, sl
 80055d8:	4629      	mov	r1, r5
 80055da:	4648      	mov	r0, r9
 80055dc:	f7fd fec4 	bl	8003368 <denormalise_bands>
      denormalise_bands(mode, X+N, freq2, oldBandE+nbEBands, start, effEnd, M,
 80055e0:	69ba      	ldr	r2, [r7, #24]
 80055e2:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 80055e4:	9202      	str	r2, [sp, #8]
 80055e6:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80055e8:	9104      	str	r1, [sp, #16]
 80055ea:	9201      	str	r2, [sp, #4]
 80055ec:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80055ee:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 80055f0:	9200      	str	r2, [sp, #0]
 80055f2:	68ba      	ldr	r2, [r7, #8]
 80055f4:	9103      	str	r1, [sp, #12]
 80055f6:	eb0a 0348 	add.w	r3, sl, r8, lsl #1
 80055fa:	eb05 0142 	add.w	r1, r5, r2, lsl #1
 80055fe:	4648      	mov	r0, r9
 8005600:	4632      	mov	r2, r6
 8005602:	f7fd feb1 	bl	8003368 <denormalise_bands>
      for (i=0;i<N;i++)
 8005606:	68ba      	ldr	r2, [r7, #8]
 8005608:	2a00      	cmp	r2, #0
 800560a:	dd31      	ble.n	8005670 <celt_synthesis+0x2cc>
 800560c:	687a      	ldr	r2, [r7, #4]
 800560e:	69fb      	ldr	r3, [r7, #28]
 8005610:	1f10      	subs	r0, r2, #4
 8005612:	3e04      	subs	r6, #4
 8005614:	1819      	adds	r1, r3, r0
 8005616:	1f1a      	subs	r2, r3, #4
         freq[i] = ADD32(HALF32(freq[i]), HALF32(freq2[i]));
 8005618:	f856 3f04 	ldr.w	r3, [r6, #4]!
 800561c:	f852 5f04 	ldr.w	r5, [r2, #4]!
 8005620:	105b      	asrs	r3, r3, #1
 8005622:	eb03 0365 	add.w	r3, r3, r5, asr #1
      for (i=0;i<N;i++)
 8005626:	428a      	cmp	r2, r1
         freq[i] = ADD32(HALF32(freq[i]), HALF32(freq2[i]));
 8005628:	6013      	str	r3, [r2, #0]
      for (i=0;i<N;i++)
 800562a:	d1f5      	bne.n	8005618 <celt_synthesis+0x274>
      for (b=0;b<B;b++)
 800562c:	f1bb 0f00 	cmp.w	fp, #0
 8005630:	f77f af3a 	ble.w	80054a8 <celt_synthesis+0x104>
      for (b=0;b<B;b++)
 8005634:	f04f 0800 	mov.w	r8, #0
 8005638:	69fe      	ldr	r6, [r7, #28]
 800563a:	00a5      	lsls	r5, r4, #2
 800563c:	f109 0a38 	add.w	sl, r9, #56	; 0x38
 8005640:	eb06 048b 	add.w	r4, r6, fp, lsl #2
         clt_mdct_backward(&mode->mdct, &freq[b], out_syn[0]+NB*b, mode->window, overlap, shift, B, arch);
 8005644:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8005648:	68fa      	ldr	r2, [r7, #12]
 800564a:	f8d9 3034 	ldr.w	r3, [r9, #52]	; 0x34
 800564e:	6812      	ldr	r2, [r2, #0]
 8005650:	e9cd b102 	strd	fp, r1, [sp, #8]
 8005654:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8005656:	4442      	add	r2, r8
 8005658:	9101      	str	r1, [sp, #4]
 800565a:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800565c:	4650      	mov	r0, sl
 800565e:	9100      	str	r1, [sp, #0]
 8005660:	4631      	mov	r1, r6
 8005662:	3604      	adds	r6, #4
 8005664:	f004 fa22 	bl	8009aac <clt_mdct_backward_c>
      for (b=0;b<B;b++)
 8005668:	42b4      	cmp	r4, r6
 800566a:	44a8      	add	r8, r5
 800566c:	d1ea      	bne.n	8005644 <celt_synthesis+0x2a0>
 800566e:	e716      	b.n	800549e <celt_synthesis+0xfa>
 8005670:	f1bb 0f00 	cmp.w	fp, #0
 8005674:	dcde      	bgt.n	8005634 <celt_synthesis+0x290>
 8005676:	e731      	b.n	80054dc <celt_synthesis+0x138>
 8005678:	ee1e5d00 	.word	0xee1e5d00
 800567c:	11e1a300 	.word	0x11e1a300

08005680 <celt_decode_lost>:
   RESTORE_STACK;
   return pitch_index;
}

static void celt_decode_lost(CELTDecoder * OPUS_RESTRICT st, int N, int LM)
{
 8005680:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005684:	f6ad 1d74 	subw	sp, sp, #2420	; 0x974
   int loss_count;
   int noise_based;
   const opus_int16 *eBands;
   SAVE_STACK;

   mode = st->mode;
 8005688:	4603      	mov	r3, r0
{
 800568a:	4606      	mov	r6, r0
 800568c:	af0a      	add	r7, sp, #40	; 0x28
 800568e:	f8c7 009c 	str.w	r0, [r7, #156]	; 0x9c
 8005692:	f8c7 1084 	str.w	r1, [r7, #132]	; 0x84
   mode = st->mode;
 8005696:	f853 0b58 	ldr.w	r0, [r3], #88
   overlap = mode->overlap;
   eBands = mode->eBands;

   c=0; do {
      decode_mem[c] = st->_decode_mem + c*(DECODE_BUFFER_SIZE+overlap);
      out_syn[c] = decode_mem[c]+DECODE_BUFFER_SIZE-N;
 800569a:	ebc1 7181 	rsb	r1, r1, r1, lsl #30
 800569e:	0089      	lsls	r1, r1, #2
   const int C = st->channels;
 80056a0:	68b6      	ldr	r6, [r6, #8]
   overlap = mode->overlap;
 80056a2:	6845      	ldr	r5, [r0, #4]
      out_syn[c] = decode_mem[c]+DECODE_BUFFER_SIZE-N;
 80056a4:	f501 5400 	add.w	r4, r1, #8192	; 0x2000
 80056a8:	1919      	adds	r1, r3, r4
   } while (++c<C);
 80056aa:	2e01      	cmp	r6, #1
{
 80056ac:	f8c7 2094 	str.w	r2, [r7, #148]	; 0x94
   mode = st->mode;
 80056b0:	67b8      	str	r0, [r7, #120]	; 0x78
      out_syn[c] = decode_mem[c]+DECODE_BUFFER_SIZE-N;
 80056b2:	f8c7 4090 	str.w	r4, [r7, #144]	; 0x90
   overlap = mode->overlap;
 80056b6:	66fd      	str	r5, [r7, #108]	; 0x6c
   const int C = st->channels;
 80056b8:	f8c7 608c 	str.w	r6, [r7, #140]	; 0x8c
      out_syn[c] = decode_mem[c]+DECODE_BUFFER_SIZE-N;
 80056bc:	f8c7 10ac 	str.w	r1, [r7, #172]	; 0xac
 80056c0:	f505 6200 	add.w	r2, r5, #2048	; 0x800
   nbEBands = mode->nbEBands;
 80056c4:	f8d0 8008 	ldr.w	r8, [r0, #8]
   eBands = mode->eBands;
 80056c8:	f8d0 a018 	ldr.w	sl, [r0, #24]
      decode_mem[c] = st->_decode_mem + c*(DECODE_BUFFER_SIZE+overlap);
 80056cc:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   } while (++c<C);
 80056d0:	dd06      	ble.n	80056e0 <celt_decode_lost+0x60>
      decode_mem[c] = st->_decode_mem + c*(DECODE_BUFFER_SIZE+overlap);
 80056d2:	eb03 0182 	add.w	r1, r3, r2, lsl #2
      out_syn[c] = decode_mem[c]+DECODE_BUFFER_SIZE-N;
 80056d6:	1908      	adds	r0, r1, r4
      decode_mem[c] = st->_decode_mem + c*(DECODE_BUFFER_SIZE+overlap);
 80056d8:	f8c7 10a8 	str.w	r1, [r7, #168]	; 0xa8
      out_syn[c] = decode_mem[c]+DECODE_BUFFER_SIZE-N;
 80056dc:	f8c7 00b0 	str.w	r0, [r7, #176]	; 0xb0
   lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+overlap)*C);
 80056e0:	f8d7 408c 	ldr.w	r4, [r7, #140]	; 0x8c
   oldBandE = lpc+C*LPC_ORDER;
   oldLogE = oldBandE + 2*nbEBands;
   oldLogE2 = oldLogE + 2*nbEBands;
   backgroundLogE = oldLogE2  + 2*nbEBands;

   loss_count = st->loss_count;
 80056e4:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
   lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+overlap)*C);
 80056e8:	fb02 f204 	mul.w	r2, r2, r4
 80056ec:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   oldBandE = lpc+C*LPC_ORDER;
 80056f0:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   loss_count = st->loss_count;
 80056f4:	6b48      	ldr	r0, [r1, #52]	; 0x34
   oldBandE = lpc+C*LPC_ORDER;
 80056f6:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 80056fa:	677b      	str	r3, [r7, #116]	; 0x74
   start = st->start;
 80056fc:	694b      	ldr	r3, [r1, #20]
 80056fe:	ea4f 06c8 	mov.w	r6, r8, lsl #3
   noise_based = loss_count >= 5 || start != 0 || st->skip_plc;
 8005702:	2804      	cmp	r0, #4
   loss_count = st->loss_count;
 8005704:	6738      	str	r0, [r7, #112]	; 0x70
   lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+overlap)*C);
 8005706:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
 800570a:	eb06 0688 	add.w	r6, r6, r8, lsl #2
   start = st->start;
 800570e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   noise_based = loss_count >= 5 || start != 0 || st->skip_plc;
 8005712:	dc2b      	bgt.n	800576c <celt_decode_lost+0xec>
 8005714:	2b00      	cmp	r3, #0
 8005716:	f000 810b 	beq.w	8005930 <celt_decode_lost+0x2b0>
#endif
      opus_uint32 seed;
      int end;
      int effEnd;
      opus_val16 decay;
      end = st->end;
 800571a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
#ifdef NORM_ALIASING_HACK
      /* This is an ugly hack that breaks aliasing rules and would be easily broken,
         but it saves almost 4kB of stack. */
      X = (celt_norm*)(out_syn[C-1]+overlap/2);
#else
      ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 800571e:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
      end = st->end;
 8005722:	f8d3 e018 	ldr.w	lr, [r3, #24]
      effEnd = IMAX(start, IMIN(end, mode->effEBands));
 8005726:	6fbb      	ldr	r3, [r7, #120]	; 0x78
      ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 8005728:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
      effEnd = IMAX(start, IMIN(end, mode->effEBands));
 800572c:	68db      	ldr	r3, [r3, #12]
      ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 800572e:	fb02 f201 	mul.w	r2, r2, r1
      effEnd = IMAX(start, IMIN(end, mode->effEBands));
 8005732:	4573      	cmp	r3, lr
 8005734:	bfa8      	it	ge
 8005736:	4673      	movge	r3, lr
 8005738:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
   {
 800573c:	f8c7 d064 	str.w	sp, [r7, #100]	; 0x64
      effEnd = IMAX(start, IMIN(end, mode->effEBands));
 8005740:	428b      	cmp	r3, r1
 8005742:	bfb8      	it	lt
 8005744:	460b      	movlt	r3, r1
 8005746:	67fb      	str	r3, [r7, #124]	; 0x7c
#endif

      /* Energy decay */
      decay = loss_count==0 ? QCONST16(1.5f, DB_SHIFT) : QCONST16(.5f, DB_SHIFT);
 8005748:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800574a:	2b00      	cmp	r3, #0
      ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 800574c:	ea4f 0342 	mov.w	r3, r2, lsl #1
 8005750:	f103 0308 	add.w	r3, r3, #8
 8005754:	f023 0307 	bic.w	r3, r3, #7
 8005758:	ebad 0d03 	sub.w	sp, sp, r3
      decay = loss_count==0 ? QCONST16(1.5f, DB_SHIFT) : QCONST16(.5f, DB_SHIFT);
 800575c:	bf14      	ite	ne
 800575e:	f44f 7500 	movne.w	r5, #512	; 0x200
 8005762:	f44f 65c0 	moveq.w	r5, #1536	; 0x600
      ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 8005766:	f10d 0928 	add.w	r9, sp, #40	; 0x28
 800576a:	e01e      	b.n	80057aa <celt_decode_lost+0x12a>
      effEnd = IMAX(start, IMIN(end, mode->effEBands));
 800576c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
      end = st->end;
 800576e:	f8d1 e018 	ldr.w	lr, [r1, #24]
      effEnd = IMAX(start, IMIN(end, mode->effEBands));
 8005772:	68db      	ldr	r3, [r3, #12]
      ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 8005774:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
      effEnd = IMAX(start, IMIN(end, mode->effEBands));
 8005778:	4573      	cmp	r3, lr
 800577a:	bfa8      	it	ge
 800577c:	4673      	movge	r3, lr
      ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 800577e:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
   {
 8005782:	f8c7 d064 	str.w	sp, [r7, #100]	; 0x64
      ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 8005786:	fb02 f201 	mul.w	r2, r2, r1
 800578a:	0052      	lsls	r2, r2, #1
 800578c:	3208      	adds	r2, #8
 800578e:	f022 0207 	bic.w	r2, r2, #7
 8005792:	ebad 0d02 	sub.w	sp, sp, r2
      effEnd = IMAX(start, IMIN(end, mode->effEBands));
 8005796:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
      ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 800579a:	f44f 7500 	mov.w	r5, #512	; 0x200
      effEnd = IMAX(start, IMIN(end, mode->effEBands));
 800579e:	4293      	cmp	r3, r2
 80057a0:	bfb8      	it	lt
 80057a2:	4613      	movlt	r3, r2
      ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 80057a4:	f10d 0928 	add.w	r9, sp, #40	; 0x28
      effEnd = IMAX(start, IMIN(end, mode->effEBands));
 80057a8:	67fb      	str	r3, [r7, #124]	; 0x7c
      c=0; do
 80057aa:	f04f 0c00 	mov.w	ip, #0
 80057ae:	f8d7 b074 	ldr.w	fp, [r7, #116]	; 0x74
 80057b2:	3e02      	subs	r6, #2
      {
         for (i=start;i<end;i++)
 80057b4:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80057b8:	4573      	cmp	r3, lr
 80057ba:	da15      	bge.n	80057e8 <celt_decode_lost+0x168>
            oldBandE[c*nbEBands+i] = MAX16(backgroundLogE[c*nbEBands+i], oldBandE[c*nbEBands+i] - decay);
 80057bc:	fb08 f40c 	mul.w	r4, r8, ip
 80057c0:	18e1      	adds	r1, r4, r3
 80057c2:	0049      	lsls	r1, r1, #1
 80057c4:	1870      	adds	r0, r6, r1
 80057c6:	4474      	add	r4, lr
 80057c8:	eb0b 0444 	add.w	r4, fp, r4, lsl #1
 80057cc:	4458      	add	r0, fp
 80057ce:	4459      	add	r1, fp
 80057d0:	f9b1 3000 	ldrsh.w	r3, [r1]
 80057d4:	f930 2f02 	ldrsh.w	r2, [r0, #2]!
 80057d8:	1b5b      	subs	r3, r3, r5
 80057da:	4293      	cmp	r3, r2
 80057dc:	bfb8      	it	lt
 80057de:	4613      	movlt	r3, r2
 80057e0:	f821 3b02 	strh.w	r3, [r1], #2
         for (i=start;i<end;i++)
 80057e4:	42a1      	cmp	r1, r4
 80057e6:	d1f3      	bne.n	80057d0 <celt_decode_lost+0x150>
      } while (++c<C);
 80057e8:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 80057ec:	f10c 0301 	add.w	r3, ip, #1
 80057f0:	429a      	cmp	r2, r3
 80057f2:	f04f 0c01 	mov.w	ip, #1
 80057f6:	dcdd      	bgt.n	80057b4 <celt_decode_lost+0x134>
      seed = st->rng;
 80057f8:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
      for (c=0;c<C;c++)
 80057fc:	2a00      	cmp	r2, #0
      seed = st->rng;
 80057fe:	6a9c      	ldr	r4, [r3, #40]	; 0x28
      for (c=0;c<C;c++)
 8005800:	dd52      	ble.n	80058a8 <celt_decode_lost+0x228>
 8005802:	2300      	movs	r3, #0
 8005804:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8005808:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800580c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8005810:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8005812:	eb0a 0242 	add.w	r2, sl, r2, lsl #1
 8005816:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
 800581a:	66ba      	str	r2, [r7, #104]	; 0x68
 800581c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
      {
         for (i=start;i<effEnd;i++)
 8005820:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8005824:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8005826:	4293      	cmp	r3, r2
 8005828:	da2e      	bge.n	8005888 <celt_decode_lost+0x208>
         {
            int j;
            int boffs;
            int blen;
            boffs = N*c+(eBands[i]<<LM);
 800582a:	f8d7 8068 	ldr.w	r8, [r7, #104]	; 0x68
 800582e:	f9b8 3000 	ldrsh.w	r3, [r8]
 8005832:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
            blen = (eBands[i+1]-eBands[i])<<LM;
 8005836:	f938 6f02 	ldrsh.w	r6, [r8, #2]!
            boffs = N*c+(eBands[i]<<LM);
 800583a:	fa03 f502 	lsl.w	r5, r3, r2
            blen = (eBands[i+1]-eBands[i])<<LM;
 800583e:	1af6      	subs	r6, r6, r3
            boffs = N*c+(eBands[i]<<LM);
 8005840:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
            blen = (eBands[i+1]-eBands[i])<<LM;
 8005844:	4096      	lsls	r6, r2
            boffs = N*c+(eBands[i]<<LM);
 8005846:	441d      	add	r5, r3
            for (j=0;j<blen;j++)
 8005848:	2e00      	cmp	r6, #0
 800584a:	ea4f 0a45 	mov.w	sl, r5, lsl #1
 800584e:	dd0d      	ble.n	800586c <celt_decode_lost+0x1ec>
 8005850:	4620      	mov	r0, r4
 8005852:	4435      	add	r5, r6
 8005854:	eb09 0545 	add.w	r5, r9, r5, lsl #1
 8005858:	eb09 0b0a 	add.w	fp, r9, sl
            {
               seed = celt_lcg_rand(seed);
 800585c:	f7fd fd7a 	bl	8003354 <celt_lcg_rand>
               X[boffs+j] = (celt_norm)((opus_int32)seed>>20);
 8005860:	1503      	asrs	r3, r0, #20
 8005862:	f82b 3b02 	strh.w	r3, [fp], #2
            for (j=0;j<blen;j++)
 8005866:	455d      	cmp	r5, fp
 8005868:	d1f8      	bne.n	800585c <celt_decode_lost+0x1dc>
 800586a:	4604      	mov	r4, r0
            }
            renormalise_vector(X+boffs, blen, Q15ONE, st->arch);
 800586c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8005870:	4631      	mov	r1, r6
 8005872:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005874:	eb09 000a 	add.w	r0, r9, sl
 8005878:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800587c:	f006 faf6 	bl	800be6c <renormalise_vector>
         for (i=start;i<effEnd;i++)
 8005880:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8005884:	4598      	cmp	r8, r3
 8005886:	d1d2      	bne.n	800582e <celt_decode_lost+0x1ae>
 8005888:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 800588c:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
      for (c=0;c<C;c++)
 8005890:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8005894:	440a      	add	r2, r1
 8005896:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
 800589a:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 800589e:	3301      	adds	r3, #1
 80058a0:	429a      	cmp	r2, r3
 80058a2:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 80058a6:	d1bb      	bne.n	8005820 <celt_decode_lost+0x1a0>
         }
      }
      st->rng = seed;

      c=0; do {
 80058a8:	2600      	movs	r6, #0
      st->rng = seed;
 80058aa:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
         OPUS_MOVE(decode_mem[c], decode_mem[c]+N,
 80058ae:	6efa      	ldr	r2, [r7, #108]	; 0x6c
      st->rng = seed;
 80058b0:	629c      	str	r4, [r3, #40]	; 0x28
         OPUS_MOVE(decode_mem[c], decode_mem[c]+N,
 80058b2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80058b6:	f8d7 808c 	ldr.w	r8, [r7, #140]	; 0x8c
 80058ba:	f5c3 6400 	rsb	r4, r3, #2048	; 0x800
 80058be:	eb04 0462 	add.w	r4, r4, r2, asr #1
 80058c2:	00a4      	lsls	r4, r4, #2
 80058c4:	009d      	lsls	r5, r3, #2
 80058c6:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
 80058ca:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 80058ce:	4622      	mov	r2, r4
 80058d0:	1941      	adds	r1, r0, r5
 80058d2:	f00e fc10 	bl	80140f6 <memmove>
               DECODE_BUFFER_SIZE-N+(overlap>>1));
      } while (++c<C);
 80058d6:	1c73      	adds	r3, r6, #1
 80058d8:	4598      	cmp	r8, r3
 80058da:	f04f 0601 	mov.w	r6, #1
 80058de:	dcf2      	bgt.n	80058c6 <celt_decode_lost+0x246>

      celt_synthesis(mode, X, out_syn, oldBandE, start, effEnd, C, C, 0, LM, st->downsample, 0, st->arch);
 80058e0:	2500      	movs	r5, #0
 80058e2:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 80058e6:	4649      	mov	r1, r9
 80058e8:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80058ea:	e9cd 5307 	strd	r5, r3, [sp, #28]
 80058ee:	6914      	ldr	r4, [r2, #16]
 80058f0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80058f2:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 80058f4:	9504      	str	r5, [sp, #16]
 80058f6:	9406      	str	r4, [sp, #24]
 80058f8:	f8d7 4094 	ldr.w	r4, [r7, #148]	; 0x94
 80058fc:	f107 02ac 	add.w	r2, r7, #172	; 0xac
 8005900:	9405      	str	r4, [sp, #20]
 8005902:	f8d7 408c 	ldr.w	r4, [r7, #140]	; 0x8c
 8005906:	e9cd 4402 	strd	r4, r4, [sp, #8]
 800590a:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
 800590c:	9401      	str	r4, [sp, #4]
 800590e:	f8d7 4088 	ldr.w	r4, [r7, #136]	; 0x88
 8005912:	9400      	str	r4, [sp, #0]
 8005914:	f7ff fd46 	bl	80053a4 <celt_synthesis>
 8005918:	f8d7 d064 	ldr.w	sp, [r7, #100]	; 0x64
               + MULT16_32_Q15(window[overlap-i-1], etmp[i]);
         }
      } while (++c<C);
   }

   st->loss_count = loss_count+1;
 800591c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800591e:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8005922:	3301      	adds	r3, #1

   RESTORE_STACK;
}
 8005924:	f607 174c 	addw	r7, r7, #2380	; 0x94c
   st->loss_count = loss_count+1;
 8005928:	6353      	str	r3, [r2, #52]	; 0x34
}
 800592a:	46bd      	mov	sp, r7
 800592c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   noise_based = loss_count >= 5 || start != 0 || st->skip_plc;
 8005930:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8005932:	2b00      	cmp	r3, #0
 8005934:	f47f aef1 	bne.w	800571a <celt_decode_lost+0x9a>
   } else {
 8005938:	f8c7 d00c 	str.w	sp, [r7, #12]
 800593c:	f8d1 9024 	ldr.w	r9, [r1, #36]	; 0x24
      if (loss_count == 0)
 8005940:	2800      	cmp	r0, #0
 8005942:	f000 8282 	beq.w	8005e4a <celt_decode_lost+0x7ca>
         pitch_index = st->last_pitch_index;
 8005946:	f246 6366 	movw	r3, #26214	; 0x6666
 800594a:	64bb      	str	r3, [r7, #72]	; 0x48
 800594c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8005950:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005952:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 8005956:	f507 738c 	add.w	r3, r7, #280	; 0x118
 800595a:	677b      	str	r3, [r7, #116]	; 0x74
 800595c:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 8005960:	667b      	str	r3, [r7, #100]	; 0x64
      exc_length = IMIN(2*pitch_index, MAX_PERIOD);
 8005962:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
      window = mode->window;
 8005966:	6fb9      	ldr	r1, [r7, #120]	; 0x78
      exc_length = IMIN(2*pitch_index, MAX_PERIOD);
 8005968:	005e      	lsls	r6, r3, #1
 800596a:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 800596e:	bfa8      	it	ge
 8005970:	f44f 6680 	movge.w	r6, #1024	; 0x400
      c=0; do {
 8005974:	2200      	movs	r2, #0
      ALLOC(etmp, overlap, opus_val32);
 8005976:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
      window = mode->window;
 8005978:	6b49      	ldr	r1, [r1, #52]	; 0x34
            decay_length = exc_length>>1;
 800597a:	1075      	asrs	r5, r6, #1
      window = mode->window;
 800597c:	6339      	str	r1, [r7, #48]	; 0x30
               e = exc[MAX_PERIOD-2*decay_length+i];
 800597e:	64fd      	str	r5, [r7, #76]	; 0x4c
 8005980:	f5c5 7100 	rsb	r1, r5, #512	; 0x200
         for (i=0;i<overlap/2;i++)
 8005984:	4605      	mov	r5, r0
      ALLOC(etmp, overlap, opus_val32);
 8005986:	0083      	lsls	r3, r0, #2
      c=0; do {
 8005988:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
      ALLOC(etmp, overlap, opus_val32);
 800598c:	f103 020a 	add.w	r2, r3, #10
 8005990:	f022 0207 	bic.w	r2, r2, #7
 8005994:	ebad 0d02 	sub.w	sp, sp, r2
         OPUS_MOVE(buf, buf+N, DECODE_BUFFER_SIZE-N);
 8005998:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
         for (i=0;i<overlap/2;i++)
 800599c:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
         OPUS_MOVE(buf, buf+N, DECODE_BUFFER_SIZE-N);
 80059a0:	f5c2 6a00 	rsb	sl, r2, #2048	; 0x800
         extrapolation_len = N+overlap;
 80059a4:	442a      	add	r2, r5
 80059a6:	4615      	mov	r5, r2
         OPUS_MOVE(buf, buf+N, DECODE_BUFFER_SIZE-N);
 80059a8:	4652      	mov	r2, sl
         for (i=0;i<overlap/2;i++)
 80059aa:	1040      	asrs	r0, r0, #1
 80059ac:	6578      	str	r0, [r7, #84]	; 0x54
         OPUS_MOVE(buf, buf+N, DECODE_BUFFER_SIZE-N);
 80059ae:	0090      	lsls	r0, r2, #2
 80059b0:	e9c7 051e 	strd	r0, r5, [r7, #120]	; 0x78
 80059b4:	4628      	mov	r0, r5
      ALLOC(fir_tmp, exc_length, opus_val16);
 80059b6:	0074      	lsls	r4, r6, #1
 80059b8:	63bc      	str	r4, [r7, #56]	; 0x38
 80059ba:	3408      	adds	r4, #8
 80059bc:	f024 0407 	bic.w	r4, r4, #7
 80059c0:	f1a3 0e04 	sub.w	lr, r3, #4
      ALLOC(etmp, overlap, opus_val32);
 80059c4:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 80059c8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
      ALLOC(fir_tmp, exc_length, opus_val16);
 80059ca:	ebad 0d04 	sub.w	sp, sp, r4
 80059ce:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
 80059d0:	eb03 0181 	add.w	r1, r3, r1, lsl #2
            int shift = IMAX(0,2*celt_zlog2(celt_maxabs16(&exc[MAX_PERIOD-exc_length], exc_length))-20);
 80059d4:	663e      	str	r6, [r7, #96]	; 0x60
 80059d6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80059d8:	f5c4 6883 	rsb	r8, r4, #1048	; 0x418
 80059dc:	f5c6 6480 	rsb	r4, r6, #1024	; 0x400
 80059e0:	6b3e      	ldr	r6, [r7, #48]	; 0x30
      ALLOC(etmp, overlap, opus_val32);
 80059e2:	f8c7 c050 	str.w	ip, [r7, #80]	; 0x50
 80059e6:	441a      	add	r2, r3
 80059e8:	f1a6 0c02 	sub.w	ip, r6, #2
 80059ec:	005e      	lsls	r6, r3, #1
 80059ee:	6d3b      	ldr	r3, [r7, #80]	; 0x50
            int shift = IMAX(0,2*celt_zlog2(celt_maxabs16(&exc[MAX_PERIOD-exc_length], exc_length))-20);
 80059f0:	0064      	lsls	r4, r4, #1
 80059f2:	4473      	add	r3, lr
 80059f4:	617b      	str	r3, [r7, #20]
      ALLOC(fir_tmp, exc_length, opus_val16);
 80059f6:	f10d 0e28 	add.w	lr, sp, #40	; 0x28
 80059fa:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80059fc:	f8c7 e034 	str.w	lr, [r7, #52]	; 0x34
 8005a00:	f101 0e30 	add.w	lr, r1, #48	; 0x30
 8005a04:	f8c7 e02c 	str.w	lr, [r7, #44]	; 0x2c
            int shift = IMAX(0,2*celt_zlog2(celt_maxabs16(&exc[MAX_PERIOD-exc_length], exc_length))-20);
 8005a08:	643c      	str	r4, [r7, #64]	; 0x40
 8005a0a:	eb03 0e48 	add.w	lr, r3, r8, lsl #1
            celt_fir(exc+MAX_PERIOD-exc_length, lpc+c*LPC_ORDER,
 8005a0e:	6e3c      	ldr	r4, [r7, #96]	; 0x60
 8005a10:	f8c7 e028 	str.w	lr, [r7, #40]	; 0x28
 8005a14:	f607 1e48 	addw	lr, r7, #2376	; 0x948
 8005a18:	f8c7 c05c 	str.w	ip, [r7, #92]	; 0x5c
 8005a1c:	ebae 0444 	sub.w	r4, lr, r4, lsl #1
 8005a20:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8005a22:	647c      	str	r4, [r7, #68]	; 0x44
 8005a24:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
 8005a26:	f8d7 5084 	ldr.w	r5, [r7, #132]	; 0x84
 8005a2a:	19a3      	adds	r3, r4, r6
 8005a2c:	198e      	adds	r6, r1, r6
 8005a2e:	613b      	str	r3, [r7, #16]
 8005a30:	61be      	str	r6, [r7, #24]
 8005a32:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8005a34:	4450      	add	r0, sl
 8005a36:	eb04 0441 	add.w	r4, r4, r1, lsl #1
 8005a3a:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 8005a3c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8005a40:	3904      	subs	r1, #4
 8005a42:	60b9      	str	r1, [r7, #8]
 8005a44:	0081      	lsls	r1, r0, #2
                  buf[DECODE_BUFFER_SIZE-N+i] = 0;
 8005a46:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8005a48:	66b9      	str	r1, [r7, #104]	; 0x68
 8005a4a:	0091      	lsls	r1, r2, #2
 8005a4c:	6079      	str	r1, [r7, #4]
 8005a4e:	0081      	lsls	r1, r0, #2
 8005a50:	4648      	mov	r0, r9
 8005a52:	6039      	str	r1, [r7, #0]
 8005a54:	ea4f 018a 	mov.w	r1, sl, lsl #2
 8005a58:	6279      	str	r1, [r7, #36]	; 0x24
 8005a5a:	6f7a      	ldr	r2, [r7, #116]	; 0x74
         OPUS_MOVE(buf, buf+N, DECODE_BUFFER_SIZE-N);
 8005a5c:	00a9      	lsls	r1, r5, #2
 8005a5e:	63f9      	str	r1, [r7, #60]	; 0x3c
 8005a60:	469b      	mov	fp, r3
 8005a62:	f5c3 6180 	rsb	r1, r3, #1024	; 0x400
 8005a66:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8005a6a:	61fc      	str	r4, [r7, #28]
 8005a6c:	6239      	str	r1, [r7, #32]
 8005a6e:	f602 042e 	addw	r4, r2, #2094	; 0x82e
 8005a72:	f107 0ae2 	add.w	sl, r7, #226	; 0xe2
         buf = decode_mem[c];
 8005a76:	4619      	mov	r1, r3
 8005a78:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
 8005a7c:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
 8005a80:	f507 728b 	add.w	r2, r7, #278	; 0x116
 8005a84:	f605 719c 	addw	r1, r5, #3996	; 0xf9c
            exc[i-LPC_ORDER] = ROUND16(buf[DECODE_BUFFER_SIZE-MAX_PERIOD-LPC_ORDER+i], SIG_SHIFT);
 8005a88:	f851 3f04 	ldr.w	r3, [r1, #4]!
 8005a8c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005a90:	131b      	asrs	r3, r3, #12
 8005a92:	f822 3f02 	strh.w	r3, [r2, #2]!
         for (i=0;i<MAX_PERIOD+LPC_ORDER;i++)
 8005a96:	4294      	cmp	r4, r2
 8005a98:	d1f6      	bne.n	8005a88 <celt_decode_lost+0x408>
 8005a9a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8005a9e:	005e      	lsls	r6, r3, #1
 8005aa0:	eb06 0803 	add.w	r8, r6, r3
 8005aa4:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8005aa8:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8005aac:	4443      	add	r3, r8
 8005aae:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
         if (loss_count == 0)
 8005ab2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8005ab4:	2b00      	cmp	r3, #0
 8005ab6:	f000 814d 	beq.w	8005d54 <celt_decode_lost+0x6d4>
            celt_fir(exc+MAX_PERIOD-exc_length, lpc+c*LPC_ORDER,
 8005aba:	2318      	movs	r3, #24
 8005abc:	e9cd 3000 	strd	r3, r0, [sp]
 8005ac0:	f8d7 8034 	ldr.w	r8, [r7, #52]	; 0x34
 8005ac4:	6c7e      	ldr	r6, [r7, #68]	; 0x44
 8005ac6:	f8d7 9060 	ldr.w	r9, [r7, #96]	; 0x60
 8005aca:	4642      	mov	r2, r8
 8005acc:	464b      	mov	r3, r9
 8005ace:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8005ad2:	4630      	mov	r0, r6
 8005ad4:	f001 fd5c 	bl	8007590 <celt_fir_c>
            OPUS_COPY(exc+MAX_PERIOD-exc_length, fir_tmp, exc_length);
 8005ad8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8005ada:	4641      	mov	r1, r8
 8005adc:	4630      	mov	r0, r6
 8005ade:	f00e faff 	bl	80140e0 <memcpy>
   for (i=0;i<len;i++)
 8005ae2:	f1bb 0f00 	cmp.w	fp, #0
 8005ae6:	dd21      	ble.n	8005b2c <celt_decode_lost+0x4ac>
 8005ae8:	2300      	movs	r3, #0
 8005aea:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   opus_val16 minval = 0;
 8005aec:	4619      	mov	r1, r3
 8005aee:	f102 0630 	add.w	r6, r2, #48	; 0x30
 8005af2:	6f7a      	ldr	r2, [r7, #116]	; 0x74
   opus_val16 maxval = 0;
 8005af4:	469c      	mov	ip, r3
 8005af6:	4416      	add	r6, r2
   for (i=0;i<len;i++)
 8005af8:	4630      	mov	r0, r6
   opus_val16 maxval = 0;
 8005afa:	46ce      	mov	lr, r9
      maxval = MAX16(maxval, x[i]);
 8005afc:	f930 2b02 	ldrsh.w	r2, [r0], #2
   for (i=0;i<len;i++)
 8005b00:	3301      	adds	r3, #1
      maxval = MAX16(maxval, x[i]);
 8005b02:	4594      	cmp	ip, r2
 8005b04:	bfb8      	it	lt
 8005b06:	4694      	movlt	ip, r2
      minval = MIN16(minval, x[i]);
 8005b08:	4291      	cmp	r1, r2
 8005b0a:	bfa8      	it	ge
 8005b0c:	4611      	movge	r1, r2
   for (i=0;i<len;i++)
 8005b0e:	459e      	cmp	lr, r3
 8005b10:	dcf4      	bgt.n	8005afc <celt_decode_lost+0x47c>
   return MAX32(EXTEND32(maxval),-EXTEND32(minval));
 8005b12:	4248      	negs	r0, r1
 8005b14:	4560      	cmp	r0, ip
 8005b16:	bfb8      	it	lt
 8005b18:	4660      	movlt	r0, ip
   return x <= 0 ? 0 : celt_ilog2(x);
 8005b1a:	b140      	cbz	r0, 8005b2e <celt_decode_lost+0x4ae>
   return EC_ILOG(x)-1;
 8005b1c:	fab0 f380 	clz	r3, r0
 8005b20:	f1c3 031f 	rsb	r3, r3, #31
            int shift = IMAX(0,2*celt_zlog2(celt_maxabs16(&exc[MAX_PERIOD-exc_length], exc_length))-20);
 8005b24:	b29b      	uxth	r3, r3
 8005b26:	2b09      	cmp	r3, #9
 8005b28:	f200 816b 	bhi.w	8005e02 <celt_decode_lost+0x782>
 8005b2c:	2000      	movs	r0, #0
            for (i=0;i<decay_length;i++)
 8005b2e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005b30:	2b00      	cmp	r3, #0
 8005b32:	f340 81b9 	ble.w	8005ea8 <celt_decode_lost+0x828>
            opus_val32 E1=1, E2=1;
 8005b36:	2101      	movs	r1, #1
 8005b38:	468c      	mov	ip, r1
            for (i=0;i<decay_length;i++)
 8005b3a:	f8d7 e02c 	ldr.w	lr, [r7, #44]	; 0x2c
 8005b3e:	6abe      	ldr	r6, [r7, #40]	; 0x28
               e = exc[MAX_PERIOD-2*decay_length+i];
 8005b40:	f93e 3b02 	ldrsh.w	r3, [lr], #2
               e = exc[MAX_PERIOD-decay_length+i];
 8005b44:	f936 2b02 	ldrsh.w	r2, [r6], #2
               E2 += SHR32(MULT16_16(e, e), shift);
 8005b48:	fb03 f303 	mul.w	r3, r3, r3
               E1 += SHR32(MULT16_16(e, e), shift);
 8005b4c:	fb02 f202 	mul.w	r2, r2, r2
               E2 += SHR32(MULT16_16(e, e), shift);
 8005b50:	4103      	asrs	r3, r0
 8005b52:	4419      	add	r1, r3
            for (i=0;i<decay_length;i++)
 8005b54:	f607 1348 	addw	r3, r7, #2376	; 0x948
               E1 += SHR32(MULT16_16(e, e), shift);
 8005b58:	4102      	asrs	r2, r0
            for (i=0;i<decay_length;i++)
 8005b5a:	42b3      	cmp	r3, r6
               E1 += SHR32(MULT16_16(e, e), shift);
 8005b5c:	4494      	add	ip, r2
            for (i=0;i<decay_length;i++)
 8005b5e:	d1ef      	bne.n	8005b40 <celt_decode_lost+0x4c0>
 8005b60:	458c      	cmp	ip, r1
 8005b62:	bfa8      	it	ge
 8005b64:	468c      	movge	ip, r1
 8005b66:	ea4f 006c 	mov.w	r0, ip, asr #1
            decay = celt_sqrt(frac_div32(SHR32(E1, 1), E2));
 8005b6a:	f003 fe05 	bl	8009778 <frac_div32>
 8005b6e:	f003 fea5 	bl	80098bc <celt_sqrt>
         OPUS_MOVE(buf, buf+N, DECODE_BUFFER_SIZE-N);
 8005b72:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005b74:	f8d7 8078 	ldr.w	r8, [r7, #120]	; 0x78
            decay = celt_sqrt(frac_div32(SHR32(E1, 1), E2));
 8005b78:	b206      	sxth	r6, r0
         OPUS_MOVE(buf, buf+N, DECODE_BUFFER_SIZE-N);
 8005b7a:	4642      	mov	r2, r8
 8005b7c:	18e9      	adds	r1, r5, r3
 8005b7e:	4628      	mov	r0, r5
            decay = celt_sqrt(frac_div32(SHR32(E1, 1), E2));
 8005b80:	f8c7 6094 	str.w	r6, [r7, #148]	; 0x94
         OPUS_MOVE(buf, buf+N, DECODE_BUFFER_SIZE-N);
 8005b84:	f00e fab7 	bl	80140f6 <memmove>
         attenuation = MULT16_16_Q15(fade, decay);
 8005b88:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8005b8a:	fb03 f206 	mul.w	r2, r3, r6
         for (i=j=0;i<extrapolation_len;i++,j++)
 8005b8e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
         attenuation = MULT16_16_Q15(fade, decay);
 8005b90:	13d2      	asrs	r2, r2, #15
         for (i=j=0;i<extrapolation_len;i++,j++)
 8005b92:	2b00      	cmp	r3, #0
 8005b94:	f340 8186 	ble.w	8005ea4 <celt_decode_lost+0x824>
 8005b98:	2000      	movs	r0, #0
 8005b9a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8005b9e:	65bc      	str	r4, [r7, #88]	; 0x58
 8005ba0:	f5c3 6980 	rsb	r9, r3, #1024	; 0x400
 8005ba4:	6a3b      	ldr	r3, [r7, #32]
         opus_val32 S1=0;
 8005ba6:	4606      	mov	r6, r0
 8005ba8:	461c      	mov	r4, r3
 8005baa:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8005bac:	eb05 0c08 	add.w	ip, r5, r8
 8005bb0:	4499      	add	r9, r3
 8005bb2:	eb05 0801 	add.w	r8, r5, r1
            if (j >= pitch_index) {
 8005bb6:	4583      	cmp	fp, r0
 8005bb8:	4613      	mov	r3, r2
 8005bba:	dc07      	bgt.n	8005bcc <celt_decode_lost+0x54c>
               attenuation = MULT16_16_Q15(attenuation, decay);
 8005bbc:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
               j -= pitch_index;
 8005bc0:	eba0 000b 	sub.w	r0, r0, fp
               attenuation = MULT16_16_Q15(attenuation, decay);
 8005bc4:	fb03 f302 	mul.w	r3, r3, r2
 8005bc8:	13db      	asrs	r3, r3, #15
 8005bca:	b21a      	sxth	r2, r3
                  SHL32(EXTEND32(MULT16_16_Q15(attenuation,
 8005bcc:	1821      	adds	r1, r4, r0
 8005bce:	f607 1e48 	addw	lr, r7, #2376	; 0x948
 8005bd2:	eb0e 0141 	add.w	r1, lr, r1, lsl #1
 8005bd6:	f5a1 6100 	sub.w	r1, r1, #2048	; 0x800
 8005bda:	f9b1 e000 	ldrsh.w	lr, [r1]
            tmp = ROUND16(
 8005bde:	eb09 0100 	add.w	r1, r9, r0
                  SHL32(EXTEND32(MULT16_16_Q15(attenuation,
 8005be2:	fb03 f30e 	mul.w	r3, r3, lr
 8005be6:	13db      	asrs	r3, r3, #15
 8005be8:	031b      	lsls	r3, r3, #12
            buf[DECODE_BUFFER_SIZE-N+i] =
 8005bea:	f84c 3b04 	str.w	r3, [ip], #4
            tmp = ROUND16(
 8005bee:	f855 3021 	ldr.w	r3, [r5, r1, lsl #2]
         for (i=j=0;i<extrapolation_len;i++,j++)
 8005bf2:	45e0      	cmp	r8, ip
            tmp = ROUND16(
 8005bf4:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005bf8:	f343 330f 	sbfx	r3, r3, #12, #16
            S1 += SHR32(MULT16_16(tmp, tmp), 10);
 8005bfc:	fb03 f303 	mul.w	r3, r3, r3
         for (i=j=0;i<extrapolation_len;i++,j++)
 8005c00:	f100 0001 	add.w	r0, r0, #1
            S1 += SHR32(MULT16_16(tmp, tmp), 10);
 8005c04:	eb06 26a3 	add.w	r6, r6, r3, asr #10
         for (i=j=0;i<extrapolation_len;i++,j++)
 8005c08:	d1d5      	bne.n	8005bb6 <celt_decode_lost+0x536>
 8005c0a:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 8005c0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005c0e:	f107 02b2 	add.w	r2, r7, #178	; 0xb2
 8005c12:	18e9      	adds	r1, r5, r3
               lpc_mem[i] = ROUND16(buf[DECODE_BUFFER_SIZE-N-1-i], SIG_SHIFT);
 8005c14:	f851 3d04 	ldr.w	r3, [r1, #-4]!
 8005c18:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005c1c:	131b      	asrs	r3, r3, #12
 8005c1e:	f822 3f02 	strh.w	r3, [r2, #2]!
            for (i=0;i<LPC_ORDER;i++)
 8005c22:	4592      	cmp	sl, r2
 8005c24:	d1f6      	bne.n	8005c14 <celt_decode_lost+0x594>
            celt_iir(buf+DECODE_BUFFER_SIZE-N, lpc+c*LPC_ORDER,
 8005c26:	2018      	movs	r0, #24
 8005c28:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8005c2c:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8005c30:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005c32:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8005c36:	9000      	str	r0, [sp, #0]
 8005c38:	9302      	str	r3, [sp, #8]
 8005c3a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8005c3c:	18aa      	adds	r2, r5, r2
 8005c3e:	9301      	str	r3, [sp, #4]
 8005c40:	f8d7 807c 	ldr.w	r8, [r7, #124]	; 0x7c
 8005c44:	4610      	mov	r0, r2
 8005c46:	4643      	mov	r3, r8
 8005c48:	f001 fdf6 	bl	8007838 <celt_iir>
            for (i=0; i < extrapolation_len; i++)
 8005c4c:	4643      	mov	r3, r8
 8005c4e:	2b00      	cmp	r3, #0
 8005c50:	dd26      	ble.n	8005ca0 <celt_decode_lost+0x620>
 8005c52:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8005c54:	18e8      	adds	r0, r5, r3
 8005c56:	4684      	mov	ip, r0
 8005c58:	4602      	mov	r2, r0
 8005c5a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8005c5c:	eb05 0803 	add.w	r8, r5, r3
               buf[DECODE_BUFFER_SIZE-N+i] = SATURATE(buf[DECODE_BUFFER_SIZE-N+i], SIG_SAT);
 8005c60:	6813      	ldr	r3, [r2, #0]
 8005c62:	49af      	ldr	r1, [pc, #700]	; (8005f20 <celt_decode_lost+0x8a0>)
 8005c64:	428b      	cmp	r3, r1
 8005c66:	bfb8      	it	lt
 8005c68:	460b      	movlt	r3, r1
 8005c6a:	49ae      	ldr	r1, [pc, #696]	; (8005f24 <celt_decode_lost+0x8a4>)
 8005c6c:	428b      	cmp	r3, r1
 8005c6e:	bfa8      	it	ge
 8005c70:	460b      	movge	r3, r1
 8005c72:	f842 3b04 	str.w	r3, [r2], #4
            for (i=0; i < extrapolation_len; i++)
 8005c76:	4590      	cmp	r8, r2
 8005c78:	d1f2      	bne.n	8005c60 <celt_decode_lost+0x5e0>
            opus_val32 S2=0;
 8005c7a:	2100      	movs	r1, #0
               opus_val16 tmp = ROUND16(buf[DECODE_BUFFER_SIZE-N+i], SIG_SHIFT);
 8005c7c:	f85c 3b04 	ldr.w	r3, [ip], #4
 8005c80:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005c84:	f343 330f 	sbfx	r3, r3, #12, #16
               S2 += SHR32(MULT16_16(tmp, tmp), 10);
 8005c88:	fb03 f303 	mul.w	r3, r3, r3
            for (i=0;i<extrapolation_len;i++)
 8005c8c:	4562      	cmp	r2, ip
               S2 += SHR32(MULT16_16(tmp, tmp), 10);
 8005c8e:	eb01 21a3 	add.w	r1, r1, r3, asr #10
            for (i=0;i<extrapolation_len;i++)
 8005c92:	d1f3      	bne.n	8005c7c <celt_decode_lost+0x5fc>
            if (!(S1 > SHR32(S2,2)))
 8005c94:	ebb6 0fa1 	cmp.w	r6, r1, asr #2
 8005c98:	dd57      	ble.n	8005d4a <celt_decode_lost+0x6ca>
            } else if (S1 < S2)
 8005c9a:	428e      	cmp	r6, r1
 8005c9c:	f2c0 8107 	blt.w	8005eae <celt_decode_lost+0x82e>
         comb_filter(etmp, buf+DECODE_BUFFER_SIZE,
 8005ca0:	2100      	movs	r1, #0
 8005ca2:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 8005ca6:	f8b0 2044 	ldrh.w	r2, [r0, #68]	; 0x44
 8005caa:	6c86      	ldr	r6, [r0, #72]	; 0x48
 8005cac:	4252      	negs	r2, r2
 8005cae:	b212      	sxth	r2, r2
 8005cb0:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8005cb2:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8005cb4:	e9cd 2201 	strd	r2, r2, [sp, #4]
 8005cb8:	e9cd 6603 	strd	r6, r6, [sp, #12]
 8005cbc:	9007      	str	r0, [sp, #28]
 8005cbe:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8005cc0:	e9cd 1105 	strd	r1, r1, [sp, #20]
 8005cc4:	9200      	str	r2, [sp, #0]
 8005cc6:	f8d7 8050 	ldr.w	r8, [r7, #80]	; 0x50
 8005cca:	461a      	mov	r2, r3
 8005ccc:	f505 5100 	add.w	r1, r5, #8192	; 0x2000
 8005cd0:	4640      	mov	r0, r8
 8005cd2:	f7fe ffcd 	bl	8004c70 <comb_filter>
         for (i=0;i<overlap/2;i++)
 8005cd6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005cd8:	2b00      	cmp	r3, #0
 8005cda:	dd22      	ble.n	8005d22 <celt_decode_lost+0x6a2>
 8005cdc:	e9d7 6c05 	ldrd	r6, ip, [r7, #20]
 8005ce0:	f505 55ff 	add.w	r5, r5, #8160	; 0x1fe0
 8005ce4:	f8c7 4094 	str.w	r4, [r7, #148]	; 0x94
 8005ce8:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8005cea:	69fc      	ldr	r4, [r7, #28]
 8005cec:	351c      	adds	r5, #28
 8005cee:	f1a8 0e04 	sub.w	lr, r8, #4
      : "%r"(b), "r"(SHL32(a,16))
 8005cf2:	f930 1f02 	ldrsh.w	r1, [r0, #2]!
 8005cf6:	f93c 2d02 	ldrsh.w	r2, [ip, #-2]!
               MULT16_32_Q15(window[i], etmp[overlap-1-i])
 8005cfa:	f856 3904 	ldr.w	r3, [r6], #-4
 8005cfe:	0409      	lsls	r1, r1, #16
  __asm__(
 8005d00:	fb83 9801 	smull	r9, r8, r3, r1
  return SHL32(rd_hi,1);
 8005d04:	ea4f 0348 	mov.w	r3, r8, lsl #1
  __asm__(
 8005d08:	f85e 1f04 	ldr.w	r1, [lr, #4]!
      : "%r"(b), "r"(SHL32(a,16))
 8005d0c:	0412      	lsls	r2, r2, #16
         for (i=0;i<overlap/2;i++)
 8005d0e:	4284      	cmp	r4, r0
  __asm__(
 8005d10:	fb81 9802 	smull	r9, r8, r1, r2
               + MULT16_32_Q15(window[overlap-i-1], etmp[i]);
 8005d14:	eb03 0348 	add.w	r3, r3, r8, lsl #1
            buf[DECODE_BUFFER_SIZE+i] =
 8005d18:	f845 3f04 	str.w	r3, [r5, #4]!
         for (i=0;i<overlap/2;i++)
 8005d1c:	d1e9      	bne.n	8005cf2 <celt_decode_lost+0x672>
 8005d1e:	f8d7 4094 	ldr.w	r4, [r7, #148]	; 0x94
      } while (++c<C);
 8005d22:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8005d26:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8005d2a:	2b00      	cmp	r3, #0
 8005d2c:	bf0c      	ite	eq
 8005d2e:	2301      	moveq	r3, #1
 8005d30:	2302      	movne	r3, #2
 8005d32:	429a      	cmp	r2, r3
 8005d34:	dd06      	ble.n	8005d44 <celt_decode_lost+0x6c4>
 8005d36:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8005d3a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005d3c:	2301      	movs	r3, #1
 8005d3e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8005d42:	e698      	b.n	8005a76 <celt_decode_lost+0x3f6>
 8005d44:	f8d7 d00c 	ldr.w	sp, [r7, #12]
 8005d48:	e5e8      	b.n	800591c <celt_decode_lost+0x29c>
 8005d4a:	683a      	ldr	r2, [r7, #0]
 8005d4c:	2100      	movs	r1, #0
 8005d4e:	f00e f9eb 	bl	8014128 <memset>
 8005d52:	e7a5      	b.n	8005ca0 <celt_decode_lost+0x620>
            _celt_autocorr(exc, ac, window, overlap,
 8005d54:	2318      	movs	r3, #24
 8005d56:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8005d5a:	e9cd 3200 	strd	r3, r2, [sp]
 8005d5e:	9002      	str	r0, [sp, #8]
 8005d60:	f8d7 9064 	ldr.w	r9, [r7, #100]	; 0x64
 8005d64:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8005d66:	4649      	mov	r1, r9
 8005d68:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8005d6a:	f507 70a4 	add.w	r0, r7, #328	; 0x148
 8005d6e:	f001 ff6f 	bl	8007c50 <_celt_autocorr>
 8005d72:	46cc      	mov	ip, r9
            for (i=1;i<=LPC_ORDER;i++)
 8005d74:	2101      	movs	r1, #1
            ac[0] += SHR32(ac[0],13);
 8005d76:	f8d9 3000 	ldr.w	r3, [r9]
 8005d7a:	eb03 3363 	add.w	r3, r3, r3, asr #13
 8005d7e:	f8c9 3000 	str.w	r3, [r9]
               ac[i] -= MULT16_32_Q15(2*i*i, ac[i]);
 8005d82:	fb11 f201 	smulbb	r2, r1, r1
 8005d86:	f85c 3f04 	ldr.w	r3, [ip, #4]!
            for (i=1;i<=LPC_ORDER;i++)
 8005d8a:	3101      	adds	r1, #1
      : "%r"(b), "r"(SHL32(a,16))
 8005d8c:	0452      	lsls	r2, r2, #17
 8005d8e:	2919      	cmp	r1, #25
  __asm__(
 8005d90:	fb83 e002 	smull	lr, r0, r3, r2
               ac[i] -= MULT16_32_Q15(2*i*i, ac[i]);
 8005d94:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
 8005d98:	f8cc 3000 	str.w	r3, [ip]
            for (i=1;i<=LPC_ORDER;i++)
 8005d9c:	d1f1      	bne.n	8005d82 <celt_decode_lost+0x702>
            _celt_lpc(lpc+c*LPC_ORDER, ac, LPC_ORDER);
 8005d9e:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
 8005da2:	2218      	movs	r2, #24
 8005da4:	6e79      	ldr	r1, [r7, #100]	; 0x64
 8005da6:	f001 fa4f 	bl	8007248 <_celt_lpc>
            if (sum < 65535) break;
 8005daa:	f64f 7cfe 	movw	ip, #65534	; 0xfffe
               tmp = MULT16_16_Q15(QCONST16(.99f,15), tmp);
 8005dae:	f647 60b8 	movw	r0, #32440	; 0x7eb8
               sum += ABS16(lpc[c*LPC_ORDER+i]);
 8005db2:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8005db6:	441e      	add	r6, r3
 8005db8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8005dbc:	eb03 1606 	add.w	r6, r3, r6, lsl #4
 8005dc0:	332e      	adds	r3, #46	; 0x2e
 8005dc2:	3e02      	subs	r6, #2
 8005dc4:	4498      	add	r8, r3
            for (i=1;i<=LPC_ORDER;i++)
 8005dc6:	4632      	mov	r2, r6
            opus_val32 sum=QCONST16(1., SIG_SHIFT);
 8005dc8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
               sum += ABS16(lpc[c*LPC_ORDER+i]);
 8005dcc:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
 8005dd0:	2b00      	cmp	r3, #0
 8005dd2:	bfb8      	it	lt
 8005dd4:	425b      	neglt	r3, r3
            for (i=0;i<LPC_ORDER;i++)
 8005dd6:	4590      	cmp	r8, r2
               sum += ABS16(lpc[c*LPC_ORDER+i]);
 8005dd8:	4419      	add	r1, r3
            for (i=0;i<LPC_ORDER;i++)
 8005dda:	d1f7      	bne.n	8005dcc <celt_decode_lost+0x74c>
            if (sum < 65535) break;
 8005ddc:	4561      	cmp	r1, ip
 8005dde:	dd2d      	ble.n	8005e3c <celt_decode_lost+0x7bc>
 8005de0:	4631      	mov	r1, r6
            opus_val16 tmp=Q15ONE;
 8005de2:	f647 73ff 	movw	r3, #32767	; 0x7fff
               tmp = MULT16_16_Q15(QCONST16(.99f,15), tmp);
 8005de6:	fb13 f300 	smulbb	r3, r3, r0
               lpc[c*LPC_ORDER+i] = MULT16_16_Q15(lpc[c*LPC_ORDER+i], tmp);
 8005dea:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
               tmp = MULT16_16_Q15(QCONST16(.99f,15), tmp);
 8005dee:	13db      	asrs	r3, r3, #15
               lpc[c*LPC_ORDER+i] = MULT16_16_Q15(lpc[c*LPC_ORDER+i], tmp);
 8005df0:	fb03 f202 	mul.w	r2, r3, r2
            for (i=0;i<LPC_ORDER;i++)
 8005df4:	4588      	cmp	r8, r1
               lpc[c*LPC_ORDER+i] = MULT16_16_Q15(lpc[c*LPC_ORDER+i], tmp);
 8005df6:	ea4f 32e2 	mov.w	r2, r2, asr #15
 8005dfa:	800a      	strh	r2, [r1, #0]
               tmp = MULT16_16_Q15(QCONST16(.99f,15), tmp);
 8005dfc:	b21b      	sxth	r3, r3
            for (i=0;i<LPC_ORDER;i++)
 8005dfe:	d1f2      	bne.n	8005de6 <celt_decode_lost+0x766>
 8005e00:	e7e1      	b.n	8005dc6 <celt_decode_lost+0x746>
   for (i=0;i<len;i++)
 8005e02:	2200      	movs	r2, #0
   opus_val16 minval = 0;
 8005e04:	4613      	mov	r3, r2
   opus_val16 maxval = 0;
 8005e06:	4610      	mov	r0, r2
 8005e08:	f8d7 c060 	ldr.w	ip, [r7, #96]	; 0x60
      maxval = MAX16(maxval, x[i]);
 8005e0c:	f936 1b02 	ldrsh.w	r1, [r6], #2
   for (i=0;i<len;i++)
 8005e10:	3201      	adds	r2, #1
      maxval = MAX16(maxval, x[i]);
 8005e12:	4288      	cmp	r0, r1
 8005e14:	bfb8      	it	lt
 8005e16:	4608      	movlt	r0, r1
      minval = MIN16(minval, x[i]);
 8005e18:	428b      	cmp	r3, r1
 8005e1a:	bfa8      	it	ge
 8005e1c:	460b      	movge	r3, r1
   for (i=0;i<len;i++)
 8005e1e:	4594      	cmp	ip, r2
 8005e20:	dcf4      	bgt.n	8005e0c <celt_decode_lost+0x78c>
   return MAX32(EXTEND32(maxval),-EXTEND32(minval));
 8005e22:	425b      	negs	r3, r3
 8005e24:	4298      	cmp	r0, r3
 8005e26:	bfb8      	it	lt
 8005e28:	4618      	movlt	r0, r3
   return x <= 0 ? 0 : celt_ilog2(x);
 8005e2a:	b158      	cbz	r0, 8005e44 <celt_decode_lost+0x7c4>
   return EC_ILOG(x)-1;
 8005e2c:	fab0 f080 	clz	r0, r0
 8005e30:	f1c0 001f 	rsb	r0, r0, #31
 8005e34:	b280      	uxth	r0, r0
 8005e36:	380a      	subs	r0, #10
 8005e38:	0040      	lsls	r0, r0, #1
 8005e3a:	e678      	b.n	8005b2e <celt_decode_lost+0x4ae>
 8005e3c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8005e40:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005e42:	e63a      	b.n	8005aba <celt_decode_lost+0x43a>
   return x <= 0 ? 0 : celt_ilog2(x);
 8005e44:	f06f 0013 	mvn.w	r0, #19
 8005e48:	e671      	b.n	8005b2e <celt_decode_lost+0x4ae>
   pitch_downsample(decode_mem, lp_pitch_buf,
 8005e4a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8005e4e:	461d      	mov	r5, r3
 8005e50:	677b      	str	r3, [r7, #116]	; 0x74
   pitch_search(lp_pitch_buf+(PLC_PITCH_LAG_MAX>>1), lp_pitch_buf,
 8005e52:	f107 04b4 	add.w	r4, r7, #180	; 0xb4
   pitch_downsample(decode_mem, lp_pitch_buf,
 8005e56:	f8cd 9000 	str.w	r9, [sp]
 8005e5a:	4619      	mov	r1, r3
 8005e5c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8005e60:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8005e64:	f107 00a4 	add.w	r0, r7, #164	; 0xa4
   pitch_search(lp_pitch_buf+(PLC_PITCH_LAG_MAX>>1), lp_pitch_buf,
 8005e68:	667c      	str	r4, [r7, #100]	; 0x64
   pitch_downsample(decode_mem, lp_pitch_buf,
 8005e6a:	f003 ffad 	bl	8009dc8 <pitch_downsample>
   pitch_search(lp_pitch_buf+(PLC_PITCH_LAG_MAX>>1), lp_pitch_buf,
 8005e6e:	f8cd 9004 	str.w	r9, [sp, #4]
 8005e72:	f44f 731b 	mov.w	r3, #620	; 0x26c
 8005e76:	f44f 62a6 	mov.w	r2, #1328	; 0x530
 8005e7a:	4629      	mov	r1, r5
 8005e7c:	9400      	str	r4, [sp, #0]
 8005e7e:	f507 707a 	add.w	r0, r7, #1000	; 0x3e8
 8005e82:	f004 fa07 	bl	800a294 <pitch_search>
   pitch_index = PLC_PITCH_LAG_MAX-pitch_index;
 8005e86:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8005e8a:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8005e8e:	f5c3 7334 	rsb	r3, r3, #720	; 0x2d0
 8005e92:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
         st->last_pitch_index = pitch_index = celt_plc_pitch_search(decode_mem, C, st->arch);
 8005e96:	6313      	str	r3, [r2, #48]	; 0x30
 8005e98:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8005e9c:	f8d2 9024 	ldr.w	r9, [r2, #36]	; 0x24
 8005ea0:	64bb      	str	r3, [r7, #72]	; 0x48
 8005ea2:	e55e      	b.n	8005962 <celt_decode_lost+0x2e2>
         opus_val32 S1=0;
 8005ea4:	2600      	movs	r6, #0
 8005ea6:	e6b1      	b.n	8005c0c <celt_decode_lost+0x58c>
            for (i=0;i<decay_length;i++)
 8005ea8:	2000      	movs	r0, #0
            opus_val32 E1=1, E2=1;
 8005eaa:	2101      	movs	r1, #1
 8005eac:	e65d      	b.n	8005b6a <celt_decode_lost+0x4ea>
               opus_val16 ratio = celt_sqrt(frac_div32(SHR32(S1,1)+1,S2+1));
 8005eae:	1070      	asrs	r0, r6, #1
 8005eb0:	3101      	adds	r1, #1
 8005eb2:	3001      	adds	r0, #1
 8005eb4:	f003 fc60 	bl	8009778 <frac_div32>
 8005eb8:	f003 fd00 	bl	80098bc <celt_sqrt>
 8005ebc:	b203      	sxth	r3, r0
 8005ebe:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
               for (i=0;i<overlap;i++)
 8005ec2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8005ec4:	2b00      	cmp	r3, #0
 8005ec6:	dd18      	ble.n	8005efa <celt_decode_lost+0x87a>
 8005ec8:	f647 73ff 	movw	r3, #32767	; 0x7fff
                        - MULT16_16_Q15(window[i], Q15ONE-ratio);
 8005ecc:	4699      	mov	r9, r3
 8005ece:	1a1b      	subs	r3, r3, r0
 8005ed0:	b21a      	sxth	r2, r3
 8005ed2:	4694      	mov	ip, r2
 8005ed4:	68bb      	ldr	r3, [r7, #8]
 8005ed6:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
 8005ed8:	18e8      	adds	r0, r5, r3
 8005eda:	f836 3f02 	ldrh.w	r3, [r6, #2]!
 8005ede:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8005ee2:	fb13 f30c 	smulbb	r3, r3, ip
 8005ee6:	eba9 33e3 	sub.w	r3, r9, r3, asr #15
      : "%r"(b), "r"(SHL32(a,16))
 8005eea:	041b      	lsls	r3, r3, #16
  __asm__(
 8005eec:	fb82 e103 	smull	lr, r1, r2, r3
               for (i=0;i<overlap;i++)
 8005ef0:	693b      	ldr	r3, [r7, #16]
  return SHL32(rd_hi,1);
 8005ef2:	0049      	lsls	r1, r1, #1
 8005ef4:	42b3      	cmp	r3, r6
                  buf[DECODE_BUFFER_SIZE-N+i] =
 8005ef6:	6001      	str	r1, [r0, #0]
               for (i=0;i<overlap;i++)
 8005ef8:	d1ef      	bne.n	8005eda <celt_decode_lost+0x85a>
               for (i=overlap;i<extrapolation_len;i++)
 8005efa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8005efc:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8005efe:	4293      	cmp	r3, r2
 8005f00:	f6bf aece 	bge.w	8005ca0 <celt_decode_lost+0x620>
      : "%r"(b), "r"(SHL32(a,16))
 8005f04:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8005f08:	0419      	lsls	r1, r3, #16
 8005f0a:	687b      	ldr	r3, [r7, #4]
 8005f0c:	18eb      	adds	r3, r5, r3
                        MULT16_32_Q15(ratio, buf[DECODE_BUFFER_SIZE-N+i]);
 8005f0e:	6818      	ldr	r0, [r3, #0]
  __asm__(
 8005f10:	fb80 6201 	smull	r6, r2, r0, r1
  return SHL32(rd_hi,1);
 8005f14:	0052      	lsls	r2, r2, #1
                  buf[DECODE_BUFFER_SIZE-N+i] =
 8005f16:	f843 2b04 	str.w	r2, [r3], #4
               for (i=overlap;i<extrapolation_len;i++)
 8005f1a:	4598      	cmp	r8, r3
 8005f1c:	d1f7      	bne.n	8005f0e <celt_decode_lost+0x88e>
 8005f1e:	e6bf      	b.n	8005ca0 <celt_decode_lost+0x620>
 8005f20:	ee1e5d00 	.word	0xee1e5d00
 8005f24:	11e1a300 	.word	0x11e1a300

08005f28 <celt_decode_with_ec>:

int celt_decode_with_ec(CELTDecoder * OPUS_RESTRICT st, const unsigned char *data,
      int len, opus_val16 * OPUS_RESTRICT pcm, int frame_size, ec_dec *dec, int accum)
{
 8005f28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005f2c:	b0cf      	sub	sp, #316	; 0x13c
   int overlap;
   const opus_int16 *eBands;
   ALLOC_STACK;

   VALIDATE_CELT_DECODER(st);
   mode = st->mode;
 8005f2e:	6804      	ldr	r4, [r0, #0]
{
 8005f30:	af14      	add	r7, sp, #80	; 0x50
   nbEBands = mode->nbEBands;
   overlap = mode->overlap;
 8005f32:	6865      	ldr	r5, [r4, #4]
{
 8005f34:	4688      	mov	r8, r1
   overlap = mode->overlap;
 8005f36:	65bd      	str	r5, [r7, #88]	; 0x58
         frame_size = mode->shortMdctSize<<LM;
   } else {
#else
   {
#endif
      for (LM=0;LM<=mode->maxLM;LM++)
 8005f38:	4625      	mov	r5, r4
   lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+overlap)*CC);
 8005f3a:	6db9      	ldr	r1, [r7, #88]	; 0x58
   int intensity=0;
 8005f3c:	f04f 0a00 	mov.w	sl, #0
   lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+overlap)*CC);
 8005f40:	f501 6900 	add.w	r9, r1, #2048	; 0x800
   nbEBands = mode->nbEBands;
 8005f44:	4629      	mov	r1, r5
 8005f46:	68ad      	ldr	r5, [r5, #8]
      for (LM=0;LM<=mode->maxLM;LM++)
 8005f48:	f8d4 c01c 	ldr.w	ip, [r4, #28]
   nbEBands = mode->nbEBands;
 8005f4c:	f8c7 5080 	str.w	r5, [r7, #128]	; 0x80
   eBands = mode->eBands;
 8005f50:	698d      	ldr	r5, [r1, #24]
   frame_size *= st->downsample;
 8005f52:	6906      	ldr	r6, [r0, #16]
   eBands = mode->eBands;
 8005f54:	65fd      	str	r5, [r7, #92]	; 0x5c
   const int CC = st->channels;
 8005f56:	6885      	ldr	r5, [r0, #8]
      for (LM=0;LM<=mode->maxLM;LM++)
 8005f58:	67fc      	str	r4, [r7, #124]	; 0x7c
   const int CC = st->channels;
 8005f5a:	67bd      	str	r5, [r7, #120]	; 0x78
   int C = st->stream_channels;
 8005f5c:	68c5      	ldr	r5, [r0, #12]
{
 8005f5e:	f8d7 4110 	ldr.w	r4, [r7, #272]	; 0x110
   int C = st->stream_channels;
 8005f62:	f8c7 5084 	str.w	r5, [r7, #132]	; 0x84
   start = st->start;
 8005f66:	6945      	ldr	r5, [r0, #20]
   frame_size *= st->downsample;
 8005f68:	fb06 f604 	mul.w	r6, r6, r4
   start = st->start;
 8005f6c:	f8c7 508c 	str.w	r5, [r7, #140]	; 0x8c
   end = st->end;
 8005f70:	6985      	ldr	r5, [r0, #24]
      for (LM=0;LM<=mode->maxLM;LM++)
 8005f72:	45d4      	cmp	ip, sl
   end = st->end;
 8005f74:	f8c7 5094 	str.w	r5, [r7, #148]	; 0x94
   lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+overlap)*CC);
 8005f78:	f100 0558 	add.w	r5, r0, #88	; 0x58
   frame_size *= st->downsample;
 8005f7c:	657e      	str	r6, [r7, #84]	; 0x54
   lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+overlap)*CC);
 8005f7e:	64fd      	str	r5, [r7, #76]	; 0x4c
   int dual_stereo=0;
 8005f80:	e9c7 aa27 	strd	sl, sl, [r7, #156]	; 0x9c
{
 8005f84:	f8d7 4114 	ldr.w	r4, [r7, #276]	; 0x114
      for (LM=0;LM<=mode->maxLM;LM++)
 8005f88:	db11      	blt.n	8005fae <celt_decode_with_ec+0x86>
         if (mode->shortMdctSize<<LM==frame_size)
 8005f8a:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 8005f8c:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8005f8e:	42b1      	cmp	r1, r6
 8005f90:	f000 8792 	beq.w	8006eb8 <celt_decode_with_ec+0xf90>
 8005f94:	464d      	mov	r5, r9
      for (LM=0;LM<=mode->maxLM;LM++)
 8005f96:	46d6      	mov	lr, sl
 8005f98:	4689      	mov	r9, r1
 8005f9a:	4641      	mov	r1, r8
 8005f9c:	e001      	b.n	8005fa2 <celt_decode_with_ec+0x7a>
         if (mode->shortMdctSize<<LM==frame_size)
 8005f9e:	45c8      	cmp	r8, r9
 8005fa0:	d00b      	beq.n	8005fba <celt_decode_with_ec+0x92>
      for (LM=0;LM<=mode->maxLM;LM++)
 8005fa2:	f10e 0e01 	add.w	lr, lr, #1
 8005fa6:	45e6      	cmp	lr, ip
         if (mode->shortMdctSize<<LM==frame_size)
 8005fa8:	fa06 f80e 	lsl.w	r8, r6, lr
      for (LM=0;LM<=mode->maxLM;LM++)
 8005fac:	ddf7      	ble.n	8005f9e <celt_decode_with_ec+0x76>
            break;
      if (LM>mode->maxLM)
         return OPUS_BAD_ARG;
 8005fae:	f04f 30ff 	mov.w	r0, #4294967295
   if (ec_tell(dec) > 8*len)
      return OPUS_INTERNAL_ERROR;
   if(ec_get_error(dec))
      st->error = 1;
   return frame_size/st->downsample;
}
 8005fb2:	37ec      	adds	r7, #236	; 0xec
 8005fb4:	46bd      	mov	sp, r7
 8005fb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005fba:	2601      	movs	r6, #1
 8005fbc:	46a9      	mov	r9, r5
 8005fbe:	f8c7 8068 	str.w	r8, [r7, #104]	; 0x68
 8005fc2:	4688      	mov	r8, r1
 8005fc4:	fa06 f10e 	lsl.w	r1, r6, lr
 8005fc8:	f8c7 e090 	str.w	lr, [r7, #144]	; 0x90
 8005fcc:	6079      	str	r1, [r7, #4]
   if (len<0 || len>1275 || pcm==NULL)
 8005fce:	f240 46fb 	movw	r6, #1275	; 0x4fb
 8005fd2:	42b2      	cmp	r2, r6
 8005fd4:	d8eb      	bhi.n	8005fae <celt_decode_with_ec+0x86>
 8005fd6:	2b00      	cmp	r3, #0
 8005fd8:	d0e9      	beq.n	8005fae <celt_decode_with_ec+0x86>
      out_syn[c] = decode_mem[c]+DECODE_BUFFER_SIZE-N;
 8005fda:	6eb9      	ldr	r1, [r7, #104]	; 0x68
   } while (++c<CC);
 8005fdc:	6fbd      	ldr	r5, [r7, #120]	; 0x78
      out_syn[c] = decode_mem[c]+DECODE_BUFFER_SIZE-N;
 8005fde:	ebc1 7681 	rsb	r6, r1, r1, lsl #30
 8005fe2:	00b6      	lsls	r6, r6, #2
 8005fe4:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8005fe6:	f506 5600 	add.w	r6, r6, #8192	; 0x2000
 8005fea:	eb01 0c06 	add.w	ip, r1, r6
   } while (++c<CC);
 8005fee:	2d01      	cmp	r5, #1
      decode_mem[c] = st->_decode_mem + c*(DECODE_BUFFER_SIZE+overlap);
 8005ff0:	f8c7 10a8 	str.w	r1, [r7, #168]	; 0xa8
      out_syn[c] = decode_mem[c]+DECODE_BUFFER_SIZE-N;
 8005ff4:	f8c7 c0b0 	str.w	ip, [r7, #176]	; 0xb0
   } while (++c<CC);
 8005ff8:	dd06      	ble.n	8006008 <celt_decode_with_ec+0xe0>
      decode_mem[c] = st->_decode_mem + c*(DECODE_BUFFER_SIZE+overlap);
 8005ffa:	eb01 0c89 	add.w	ip, r1, r9, lsl #2
      out_syn[c] = decode_mem[c]+DECODE_BUFFER_SIZE-N;
 8005ffe:	4466      	add	r6, ip
 8006000:	f8c7 60b4 	str.w	r6, [r7, #180]	; 0xb4
      decode_mem[c] = st->_decode_mem + c*(DECODE_BUFFER_SIZE+overlap);
 8006004:	f8c7 c0ac 	str.w	ip, [r7, #172]	; 0xac
 8006008:	4641      	mov	r1, r8
 800600a:	e9c7 320e 	strd	r3, r2, [r7, #56]	; 0x38
 800600e:	4683      	mov	fp, r0
   if (data == NULL || len<=1)
 8006010:	2900      	cmp	r1, #0
 8006012:	d056      	beq.n	80060c2 <celt_decode_with_ec+0x19a>
 8006014:	2a01      	cmp	r2, #1
 8006016:	dd54      	ble.n	80060c2 <celt_decode_with_ec+0x19a>
   st->skip_plc = st->loss_count != 0;
 8006018:	6b43      	ldr	r3, [r0, #52]	; 0x34
   if (effEnd > mode->effEBands)
 800601a:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
   st->skip_plc = st->loss_count != 0;
 800601c:	3300      	adds	r3, #0
 800601e:	bf18      	it	ne
 8006020:	2301      	movne	r3, #1
   if (effEnd > mode->effEBands)
 8006022:	68d2      	ldr	r2, [r2, #12]
   st->skip_plc = st->loss_count != 0;
 8006024:	6383      	str	r3, [r0, #56]	; 0x38
   if (effEnd > mode->effEBands)
 8006026:	61ba      	str	r2, [r7, #24]
   if (dec == NULL)
 8006028:	2c00      	cmp	r4, #0
 800602a:	f000 8720 	beq.w	8006e6e <celt_decode_with_ec+0xf46>
   lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+overlap)*CC);
 800602e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8006030:	fb03 f209 	mul.w	r2, r3, r9
   oldBandE = lpc+CC*LPC_ORDER;
 8006034:	0059      	lsls	r1, r3, #1
 8006036:	18cb      	adds	r3, r1, r3
 8006038:	011b      	lsls	r3, r3, #4
 800603a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+overlap)*CC);
 800603e:	66fa      	str	r2, [r7, #108]	; 0x6c
   oldBandE = lpc+CC*LPC_ORDER;
 8006040:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006042:	603b      	str	r3, [r7, #0]
 8006044:	18d3      	adds	r3, r2, r3
 8006046:	673b      	str	r3, [r7, #112]	; 0x70
   if (C==1)
 8006048:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   oldBandE = lpc+CC*LPC_ORDER;
 800604c:	64b9      	str	r1, [r7, #72]	; 0x48
   if (C==1)
 800604e:	2b01      	cmp	r3, #1
      for (i=0;i<nbEBands;i++)
 8006050:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   if (C==1)
 8006054:	f000 8631 	beq.w	8006cba <celt_decode_with_ec+0xd92>
 8006058:	009b      	lsls	r3, r3, #2
 800605a:	653b      	str	r3, [r7, #80]	; 0x50
  return _this->nbits_total-EC_ILOG(_this->rng);
 800605c:	69e3      	ldr	r3, [r4, #28]
   tell = ec_tell(dec);
 800605e:	6962      	ldr	r2, [r4, #20]
 8006060:	fab3 f683 	clz	r6, r3
   total_bits = len*8;
 8006064:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006066:	f1c6 0620 	rsb	r6, r6, #32
 800606a:	00db      	lsls	r3, r3, #3
 800606c:	1b96      	subs	r6, r2, r6
   if (tell >= total_bits)
 800606e:	42b3      	cmp	r3, r6
   total_bits = len*8;
 8006070:	663b      	str	r3, [r7, #96]	; 0x60
   if (tell >= total_bits)
 8006072:	f300 85ab 	bgt.w	8006bcc <celt_decode_with_ec+0xca4>
      silence = 1;
 8006076:	2301      	movs	r3, #1
 8006078:	633b      	str	r3, [r7, #48]	; 0x30
      dec->nbits_total+=tell-ec_tell(dec);
 800607a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800607c:	1b9e      	subs	r6, r3, r6
 800607e:	4432      	add	r2, r6
   total_bits = len*8;
 8006080:	461e      	mov	r6, r3
      dec->nbits_total+=tell-ec_tell(dec);
 8006082:	6162      	str	r2, [r4, #20]
   if (start==0 && tell+16 <= total_bits)
 8006084:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8006088:	2b00      	cmp	r3, #0
 800608a:	d13e      	bne.n	800610a <celt_decode_with_ec+0x1e2>
 800608c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800608e:	f106 030f 	add.w	r3, r6, #15
 8006092:	4293      	cmp	r3, r2
 8006094:	f2c0 85fa 	blt.w	8006c8c <celt_decode_with_ec+0xd64>
   postfilter_tapset = 0;
 8006098:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800609c:	3602      	adds	r6, #2
   postfilter_pitch = 0;
 800609e:	e9c7 3308 	strd	r3, r3, [r7, #32]
   postfilter_gain = 0;
 80060a2:	61fb      	str	r3, [r7, #28]
   if (LM > 0 && tell+3 <= total_bits)
 80060a4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80060a8:	2b00      	cmp	r3, #0
 80060aa:	d137      	bne.n	800611c <celt_decode_with_ec+0x1f4>
      isTransient = 0;
 80060ac:	667b      	str	r3, [r7, #100]	; 0x64
      shortBlocks = 0;
 80060ae:	60bb      	str	r3, [r7, #8]
   intra_ener = tell+3<=total_bits ? ec_dec_bit_logp(dec, 3) : 0;
 80060b0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80060b2:	42b3      	cmp	r3, r6
 80060b4:	f340 86bc 	ble.w	8006e30 <celt_decode_with_ec+0xf08>
 80060b8:	2103      	movs	r1, #3
 80060ba:	4620      	mov	r0, r4
 80060bc:	f002 fa14 	bl	80084e8 <ec_dec_bit_logp>
 80060c0:	e033      	b.n	800612a <celt_decode_with_ec+0x202>
      celt_decode_lost(st, N, LM);
 80060c2:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 80060c4:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 80060c8:	4621      	mov	r1, r4
 80060ca:	4658      	mov	r0, fp
 80060cc:	f7ff fad8 	bl	8005680 <celt_decode_lost>
      deemphasis(out_syn, pcm, N, CC, st->downsample, mode->preemph, st->preemph_memD, accum);
 80060d0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80060d2:	3310      	adds	r3, #16
 80060d4:	461a      	mov	r2, r3
 80060d6:	9201      	str	r2, [sp, #4]
 80060d8:	f8d7 1118 	ldr.w	r1, [r7, #280]	; 0x118
 80060dc:	f10b 0350 	add.w	r3, fp, #80	; 0x50
 80060e0:	e9cd 3102 	strd	r3, r1, [sp, #8]
 80060e4:	f8db 0010 	ldr.w	r0, [fp, #16]
 80060e8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80060ea:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80060ec:	4622      	mov	r2, r4
 80060ee:	9000      	str	r0, [sp, #0]
 80060f0:	f107 00b0 	add.w	r0, r7, #176	; 0xb0
 80060f4:	f7fe fff0 	bl	80050d8 <deemphasis>
      return frame_size/st->downsample;
 80060f8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80060fa:	f8db 0010 	ldr.w	r0, [fp, #16]
}
 80060fe:	37ec      	adds	r7, #236	; 0xec
      return frame_size/st->downsample;
 8006100:	fb93 f0f0 	sdiv	r0, r3, r0
}
 8006104:	46bd      	mov	sp, r7
 8006106:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   postfilter_tapset = 0;
 800610a:	2300      	movs	r3, #0
   postfilter_gain = 0;
 800610c:	e9c7 3307 	strd	r3, r3, [r7, #28]
   postfilter_pitch = 0;
 8006110:	627b      	str	r3, [r7, #36]	; 0x24
   if (LM > 0 && tell+3 <= total_bits)
 8006112:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8006116:	3602      	adds	r6, #2
 8006118:	2b00      	cmp	r3, #0
 800611a:	d0c7      	beq.n	80060ac <celt_decode_with_ec+0x184>
 800611c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800611e:	42b3      	cmp	r3, r6
 8006120:	f300 8689 	bgt.w	8006e36 <celt_decode_with_ec+0xf0e>
      isTransient = 0;
 8006124:	2000      	movs	r0, #0
 8006126:	6678      	str	r0, [r7, #100]	; 0x64
      shortBlocks = 0;
 8006128:	60b8      	str	r0, [r7, #8]
   unquant_coarse_energy(mode, start, end, oldBandE,
 800612a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800612e:	9303      	str	r3, [sp, #12]
 8006130:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8006134:	9000      	str	r0, [sp, #0]
 8006136:	e9cd 4301 	strd	r4, r3, [sp, #4]
 800613a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800613c:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8006140:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 8006144:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8006146:	f004 fa0d 	bl	800a564 <unquant_coarse_energy>
 800614a:	69e3      	ldr	r3, [r4, #28]
   ALLOC(tf_res, nbEBands, int);
 800614c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800614e:	fab3 f383 	clz	r3, r3
 8006152:	320a      	adds	r2, #10
 8006154:	6961      	ldr	r1, [r4, #20]
 8006156:	f022 0007 	bic.w	r0, r2, #7
 800615a:	f1c3 0320 	rsb	r3, r3, #32
 800615e:	f8c7 d014 	str.w	sp, [r7, #20]
 8006162:	ebad 0d00 	sub.w	sp, sp, r0
 8006166:	1acd      	subs	r5, r1, r3
 8006168:	a914      	add	r1, sp, #80	; 0x50
 800616a:	643a      	str	r2, [r7, #64]	; 0x40
 800616c:	6479      	str	r1, [r7, #68]	; 0x44
   budget = dec->storage*8;
 800616e:	6862      	ldr	r2, [r4, #4]
   logp = isTransient ? 2 : 4;
 8006170:	6e79      	ldr	r1, [r7, #100]	; 0x64
   tell = ec_tell(dec);
 8006172:	462b      	mov	r3, r5
   budget = dec->storage*8;
 8006174:	00d2      	lsls	r2, r2, #3
   logp = isTransient ? 2 : 4;
 8006176:	2900      	cmp	r1, #0
 8006178:	f000 8514 	beq.w	8006ba4 <celt_decode_with_ec+0xc7c>
 800617c:	2602      	movs	r6, #2
   tf_select_rsv = LM>0 && tell+logp+1<=budget;
 800617e:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
   logp = isTransient ? 2 : 4;
 8006182:	4631      	mov	r1, r6
   tf_select_rsv = LM>0 && tell+logp+1<=budget;
 8006184:	2800      	cmp	r0, #0
 8006186:	f000 8514 	beq.w	8006bb2 <celt_decode_with_ec+0xc8a>
 800618a:	1c68      	adds	r0, r5, #1
 800618c:	4430      	add	r0, r6
 800618e:	4282      	cmp	r2, r0
 8006190:	bf34      	ite	cc
 8006192:	2600      	movcc	r6, #0
 8006194:	2601      	movcs	r6, #1
 8006196:	677e      	str	r6, [r7, #116]	; 0x74
   budget -= tf_select_rsv;
 8006198:	eba2 0906 	sub.w	r9, r2, r6
   for (i=start;i<end;i++)
 800619c:	f8d7 608c 	ldr.w	r6, [r7, #140]	; 0x8c
 80061a0:	46b4      	mov	ip, r6
 80061a2:	f8d7 6094 	ldr.w	r6, [r7, #148]	; 0x94
 80061a6:	45b4      	cmp	ip, r6
 80061a8:	f280 85e0 	bge.w	8006d6c <celt_decode_with_ec+0xe44>
   tf_select_rsv = LM>0 && tell+logp+1<=budget;
 80061ac:	2200      	movs	r2, #0
 80061ae:	6e78      	ldr	r0, [r7, #100]	; 0x64
 80061b0:	469c      	mov	ip, r3
 80061b2:	4290      	cmp	r0, r2
 80061b4:	bf14      	ite	ne
 80061b6:	f04f 0a04 	movne.w	sl, #4
 80061ba:	f04f 0a05 	moveq.w	sl, #5
 80061be:	f8d7 508c 	ldr.w	r5, [r7, #140]	; 0x8c
 80061c2:	6c78      	ldr	r0, [r7, #68]	; 0x44
 80061c4:	f105 4680 	add.w	r6, r5, #1073741824	; 0x40000000
 80061c8:	3e01      	subs	r6, #1
 80061ca:	eb00 0686 	add.w	r6, r0, r6, lsl #2
      if (tell+logp<=budget)
 80061ce:	eb01 000c 	add.w	r0, r1, ip
 80061d2:	4548      	cmp	r0, r9
 80061d4:	f8c7 b034 	str.w	fp, [r7, #52]	; 0x34
   tf_select_rsv = LM>0 && tell+logp+1<=budget;
 80061d8:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
 80061dc:	46d3      	mov	fp, sl
 80061de:	f8d7 8094 	ldr.w	r8, [r7, #148]	; 0x94
 80061e2:	46a2      	mov	sl, r4
 80061e4:	4614      	mov	r4, r2
      if (tell+logp<=budget)
 80061e6:	d909      	bls.n	80061fc <celt_decode_with_ec+0x2d4>
   for (i=start;i<end;i++)
 80061e8:	3501      	adds	r5, #1
 80061ea:	45a8      	cmp	r8, r5
      tf_res[i] = curr;
 80061ec:	f846 4f04 	str.w	r4, [r6, #4]!
   for (i=start;i<end;i++)
 80061f0:	dd1c      	ble.n	800622c <celt_decode_with_ec+0x304>
 80061f2:	4659      	mov	r1, fp
      if (tell+logp<=budget)
 80061f4:	eb01 000c 	add.w	r0, r1, ip
 80061f8:	4548      	cmp	r0, r9
 80061fa:	d8f5      	bhi.n	80061e8 <celt_decode_with_ec+0x2c0>
         curr ^= ec_dec_bit_logp(dec, logp);
 80061fc:	4650      	mov	r0, sl
 80061fe:	f002 f973 	bl	80084e8 <ec_dec_bit_logp>
 8006202:	f8da 101c 	ldr.w	r1, [sl, #28]
         tf_changed |= curr;
 8006206:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800620a:	fab1 fc81 	clz	ip, r1
         curr ^= ec_dec_bit_logp(dec, logp);
 800620e:	4044      	eors	r4, r0
   for (i=start;i<end;i++)
 8006210:	3501      	adds	r5, #1
 8006212:	f8da 1014 	ldr.w	r1, [sl, #20]
 8006216:	f1cc 0c20 	rsb	ip, ip, #32
         tf_changed |= curr;
 800621a:	4323      	orrs	r3, r4
   for (i=start;i<end;i++)
 800621c:	4545      	cmp	r5, r8
         tf_changed |= curr;
 800621e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
      tf_res[i] = curr;
 8006222:	f846 4f04 	str.w	r4, [r6, #4]!
 8006226:	eba1 0c0c 	sub.w	ip, r1, ip
   for (i=start;i<end;i++)
 800622a:	dbe2      	blt.n	80061f2 <celt_decode_with_ec+0x2ca>
   if (tf_select_rsv &&
 800622c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800622e:	4654      	mov	r4, sl
 8006230:	f8d7 b034 	ldr.w	fp, [r7, #52]	; 0x34
 8006234:	b183      	cbz	r3, 8006258 <celt_decode_with_ec+0x330>
     tf_select_table[LM][4*isTransient+0+tf_changed] !=
 8006236:	4a72      	ldr	r2, [pc, #456]	; (8006400 <celt_decode_with_ec+0x4d8>)
 8006238:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800623c:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 8006240:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8006244:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8006246:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800624a:	185a      	adds	r2, r3, r1
   if (tf_select_rsv &&
 800624c:	f992 2002 	ldrsb.w	r2, [r2, #2]
 8006250:	565b      	ldrsb	r3, [r3, r1]
 8006252:	4293      	cmp	r3, r2
 8006254:	f040 8514 	bne.w	8006c80 <celt_decode_with_ec+0xd58>
   tf_select = 0;
 8006258:	2000      	movs	r0, #0
 800625a:	69e3      	ldr	r3, [r4, #28]
 800625c:	6962      	ldr	r2, [r4, #20]
 800625e:	fab3 f383 	clz	r3, r3
 8006262:	f1c3 0320 	rsb	r3, r3, #32
 8006266:	1ad5      	subs	r5, r2, r3
   for (i=start;i<end;i++)
 8006268:	f8d7 6094 	ldr.w	r6, [r7, #148]	; 0x94
 800626c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8006270:	42b3      	cmp	r3, r6
 8006272:	f280 857e 	bge.w	8006d72 <celt_decode_with_ec+0xe4a>
      tf_res[i] = tf_select_table[LM][4*isTransient+2*tf_select+tf_res[i]];
 8006276:	6e79      	ldr	r1, [r7, #100]	; 0x64
 8006278:	4a61      	ldr	r2, [pc, #388]	; (8006400 <celt_decode_with_ec+0x4d8>)
 800627a:	eb00 0141 	add.w	r1, r0, r1, lsl #1
 800627e:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 8006282:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8006286:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
 800628a:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800628c:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8006290:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8006292:	3b01      	subs	r3, #1
 8006294:	eb00 0086 	add.w	r0, r0, r6, lsl #2
 8006298:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800629c:	3804      	subs	r0, #4
 800629e:	f853 2f04 	ldr.w	r2, [r3, #4]!
 80062a2:	568a      	ldrsb	r2, [r1, r2]
   for (i=start;i<end;i++)
 80062a4:	4283      	cmp	r3, r0
      tf_res[i] = tf_select_table[LM][4*isTransient+2*tf_select+tf_res[i]];
 80062a6:	601a      	str	r2, [r3, #0]
   for (i=start;i<end;i++)
 80062a8:	d1f9      	bne.n	800629e <celt_decode_with_ec+0x376>
   if (tell+4 <= total_bits)
 80062aa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80062ac:	3503      	adds	r5, #3
 80062ae:	42ab      	cmp	r3, r5
 80062b0:	f300 8564 	bgt.w	8006d7c <celt_decode_with_ec+0xe54>
   ALLOC(cap, nbEBands, int);
 80062b4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   init_caps(mode,cap,LM,C);
 80062b6:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
   ALLOC(cap, nbEBands, int);
 80062ba:	f023 0507 	bic.w	r5, r3, #7
 80062be:	ebad 0d05 	sub.w	sp, sp, r5
 80062c2:	ab14      	add	r3, sp, #80	; 0x50
   init_caps(mode,cap,LM,C);
 80062c4:	4619      	mov	r1, r3
   ALLOC(cap, nbEBands, int);
 80062c6:	62bb      	str	r3, [r7, #40]	; 0x28
   init_caps(mode,cap,LM,C);
 80062c8:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 80062ca:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80062ce:	f7fe fedb 	bl	8005088 <init_caps>
   ALLOC(offsets, nbEBands, int);
 80062d2:	ebad 0d05 	sub.w	sp, sp, r5
   tell = ec_tell_frac(dec);
 80062d6:	4620      	mov	r0, r4
 80062d8:	f001 fff2 	bl	80082c0 <ec_tell_frac>
   ALLOC(offsets, nbEBands, int);
 80062dc:	ab14      	add	r3, sp, #80	; 0x50
 80062de:	62fb      	str	r3, [r7, #44]	; 0x2c
   total_bits<<=BITRES;
 80062e0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80062e2:	00db      	lsls	r3, r3, #3
 80062e4:	637b      	str	r3, [r7, #52]	; 0x34
   spread_decision = SPREAD_NORMAL;
 80062e6:	2302      	movs	r3, #2
 80062e8:	613b      	str	r3, [r7, #16]
   dynalloc_logp = 6;
 80062ea:	2306      	movs	r3, #6
 80062ec:	677b      	str	r3, [r7, #116]	; 0x74
 80062ee:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80062f2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80062f4:	009a      	lsls	r2, r3, #2
 80062f6:	4411      	add	r1, r2
 80062f8:	f8c7 1088 	str.w	r1, [r7, #136]	; 0x88
 80062fc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   spread_decision = SPREAD_NORMAL;
 80062fe:	f8d7 9034 	ldr.w	r9, [r7, #52]	; 0x34
 8006302:	eb01 0802 	add.w	r8, r1, r2
 8006306:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8006308:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 800630c:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8006310:	469a      	mov	sl, r3
 8006312:	eb02 0241 	add.w	r2, r2, r1, lsl #1
 8006316:	65fa      	str	r2, [r7, #92]	; 0x5c
 8006318:	f8c7 b00c 	str.w	fp, [r7, #12]
      width = C*(eBands[i+1]-eBands[i])<<LM;
 800631c:	f9ba 3000 	ldrsh.w	r3, [sl]
 8006320:	f9ba 1002 	ldrsh.w	r1, [sl, #2]
      while (tell+(dynalloc_loop_logp<<BITRES) < total_bits && boost < cap[i])
 8006324:	6f7a      	ldr	r2, [r7, #116]	; 0x74
      width = C*(eBands[i+1]-eBands[i])<<LM;
 8006326:	1ac9      	subs	r1, r1, r3
 8006328:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
      while (tell+(dynalloc_loop_logp<<BITRES) < total_bits && boost < cap[i])
 800632c:	eb00 05c2 	add.w	r5, r0, r2, lsl #3
      width = C*(eBands[i+1]-eBands[i])<<LM;
 8006330:	fb03 f101 	mul.w	r1, r3, r1
 8006334:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8006338:	f10a 0a02 	add.w	sl, sl, #2
 800633c:	4099      	lsls	r1, r3
      quanta = IMIN(width<<BITRES, IMAX(6<<BITRES, width));
 800633e:	2930      	cmp	r1, #48	; 0x30
 8006340:	460b      	mov	r3, r1
 8006342:	bfb8      	it	lt
 8006344:	2330      	movlt	r3, #48	; 0x30
 8006346:	00c9      	lsls	r1, r1, #3
 8006348:	428b      	cmp	r3, r1
 800634a:	bfa8      	it	ge
 800634c:	460b      	movge	r3, r1
      while (tell+(dynalloc_loop_logp<<BITRES) < total_bits && boost < cap[i])
 800634e:	45a9      	cmp	r9, r5
      quanta = IMIN(width<<BITRES, IMAX(6<<BITRES, width));
 8006350:	469b      	mov	fp, r3
      while (tell+(dynalloc_loop_logp<<BITRES) < total_bits && boost < cap[i])
 8006352:	f340 841f 	ble.w	8006b94 <celt_decode_with_ec+0xc6c>
 8006356:	f8d8 1000 	ldr.w	r1, [r8]
 800635a:	2900      	cmp	r1, #0
 800635c:	f340 841a 	ble.w	8006b94 <celt_decode_with_ec+0xc6c>
 8006360:	4611      	mov	r1, r2
      boost = 0;
 8006362:	2500      	movs	r5, #0
 8006364:	e009      	b.n	800637a <celt_decode_with_ec+0x452>
         total_bits -= quanta;
 8006366:	eba9 090b 	sub.w	r9, r9, fp
      while (tell+(dynalloc_loop_logp<<BITRES) < total_bits && boost < cap[i])
 800636a:	454b      	cmp	r3, r9
         boost += quanta;
 800636c:	445d      	add	r5, fp
      while (tell+(dynalloc_loop_logp<<BITRES) < total_bits && boost < cap[i])
 800636e:	da0f      	bge.n	8006390 <celt_decode_with_ec+0x468>
 8006370:	f8d8 3000 	ldr.w	r3, [r8]
         dynalloc_loop_logp = 1;
 8006374:	2101      	movs	r1, #1
      while (tell+(dynalloc_loop_logp<<BITRES) < total_bits && boost < cap[i])
 8006376:	42ab      	cmp	r3, r5
 8006378:	dd0a      	ble.n	8006390 <celt_decode_with_ec+0x468>
         flag = ec_dec_bit_logp(dec, dynalloc_loop_logp);
 800637a:	4620      	mov	r0, r4
 800637c:	f002 f8b4 	bl	80084e8 <ec_dec_bit_logp>
 8006380:	4606      	mov	r6, r0
         tell = ec_tell_frac(dec);
 8006382:	4620      	mov	r0, r4
 8006384:	f001 ff9c 	bl	80082c0 <ec_tell_frac>
      while (tell+(dynalloc_loop_logp<<BITRES) < total_bits && boost < cap[i])
 8006388:	f100 0308 	add.w	r3, r0, #8
         if (!flag)
 800638c:	2e00      	cmp	r6, #0
 800638e:	d1ea      	bne.n	8006366 <celt_decode_with_ec+0x43e>
      offsets[i] = boost;
 8006390:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
      if (boost>0)
 8006394:	2d00      	cmp	r5, #0
      offsets[i] = boost;
 8006396:	601d      	str	r5, [r3, #0]
      if (boost>0)
 8006398:	dd07      	ble.n	80063aa <celt_decode_with_ec+0x482>
         dynalloc_logp = IMAX(2, dynalloc_logp-1);
 800639a:	6f7e      	ldr	r6, [r7, #116]	; 0x74
 800639c:	2e03      	cmp	r6, #3
 800639e:	bfb8      	it	lt
 80063a0:	2603      	movlt	r6, #3
 80063a2:	1e73      	subs	r3, r6, #1
 80063a4:	677b      	str	r3, [r7, #116]	; 0x74
 80063a6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80063aa:	3304      	adds	r3, #4
 80063ac:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   for (i=start;i<end;i++)
 80063b0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80063b2:	f108 0804 	add.w	r8, r8, #4
 80063b6:	459a      	cmp	sl, r3
 80063b8:	d1b0      	bne.n	800631c <celt_decode_with_ec+0x3f4>
 80063ba:	f8d7 b00c 	ldr.w	fp, [r7, #12]
   ALLOC(fine_quant, nbEBands, int);
 80063be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   alloc_trim = tell+(6<<BITRES) <= total_bits ?
 80063c0:	302f      	adds	r0, #47	; 0x2f
   ALLOC(fine_quant, nbEBands, int);
 80063c2:	f023 0207 	bic.w	r2, r3, #7
 80063c6:	ebad 0d02 	sub.w	sp, sp, r2
 80063ca:	ab14      	add	r3, sp, #80	; 0x50
         ec_dec_icdf(dec, trim_icdf, 7) : 5;
 80063cc:	4548      	cmp	r0, r9
   ALLOC(fine_quant, nbEBands, int);
 80063ce:	65fb      	str	r3, [r7, #92]	; 0x5c
         ec_dec_icdf(dec, trim_icdf, 7) : 5;
 80063d0:	f2c0 84c4 	blt.w	8006d5c <celt_decode_with_ec+0xe34>
 80063d4:	2505      	movs	r5, #5
   bits = (((opus_int32)len*8)<<BITRES) - ec_tell_frac(dec) - 1;
 80063d6:	4620      	mov	r0, r4
 80063d8:	f001 ff72 	bl	80082c0 <ec_tell_frac>
 80063dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80063de:	3b01      	subs	r3, #1
 80063e0:	1a18      	subs	r0, r3, r0
   anti_collapse_rsv = isTransient&&LM>=2&&bits>=((LM+2)<<BITRES) ? (1<<BITRES) : 0;
 80063e2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80063e4:	b17b      	cbz	r3, 8006406 <celt_decode_with_ec+0x4de>
 80063e6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80063ea:	2b01      	cmp	r3, #1
 80063ec:	dd0a      	ble.n	8006404 <celt_decode_with_ec+0x4dc>
 80063ee:	3302      	adds	r3, #2
 80063f0:	ebb0 0fc3 	cmp.w	r0, r3, lsl #3
 80063f4:	db06      	blt.n	8006404 <celt_decode_with_ec+0x4dc>
 80063f6:	2308      	movs	r3, #8
 80063f8:	3808      	subs	r0, #8
 80063fa:	637b      	str	r3, [r7, #52]	; 0x34
 80063fc:	e004      	b.n	8006408 <celt_decode_with_ec+0x4e0>
 80063fe:	bf00      	nop
 8006400:	0801504c 	.word	0x0801504c
 8006404:	2300      	movs	r3, #0
 8006406:	637b      	str	r3, [r7, #52]	; 0x34
   codedBands = clt_compute_allocation(mode, start, end, offsets, cap,
 8006408:	2200      	movs	r2, #0
   ALLOC(pulses, nbEBands, int);
 800640a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   c=0; do {
 800640c:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
   ALLOC(pulses, nbEBands, int);
 8006410:	f023 0307 	bic.w	r3, r3, #7
 8006414:	ebad 0d03 	sub.w	sp, sp, r3
 8006418:	a914      	add	r1, sp, #80	; 0x50
   ALLOC(fine_priority, nbEBands, int);
 800641a:	ebad 0d03 	sub.w	sp, sp, r3
   ALLOC(pulses, nbEBands, int);
 800641e:	6439      	str	r1, [r7, #64]	; 0x40
   codedBands = clt_compute_allocation(mode, start, end, offsets, cap,
 8006420:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006422:	940b      	str	r4, [sp, #44]	; 0x2c
 8006424:	f8d7 6090 	ldr.w	r6, [r7, #144]	; 0x90
 8006428:	f107 0ca0 	add.w	ip, r7, #160	; 0xa0
 800642c:	960a      	str	r6, [sp, #40]	; 0x28
 800642e:	f8d7 6084 	ldr.w	r6, [r7, #132]	; 0x84
 8006432:	f107 0ea4 	add.w	lr, r7, #164	; 0xa4
 8006436:	9609      	str	r6, [sp, #36]	; 0x24
 8006438:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
 800643a:	9004      	str	r0, [sp, #16]
 800643c:	e9cd 1606 	strd	r1, r6, [sp, #24]
 8006440:	9501      	str	r5, [sp, #4]
   ALLOC(fine_priority, nbEBands, int);
 8006442:	a814      	add	r0, sp, #80	; 0x50
   codedBands = clt_compute_allocation(mode, start, end, offsets, cap,
 8006444:	f107 019c 	add.w	r1, r7, #156	; 0x9c
   ALLOC(fine_priority, nbEBands, int);
 8006448:	60f8      	str	r0, [r7, #12]
   codedBands = clt_compute_allocation(mode, start, end, offsets, cap,
 800644a:	6abd      	ldr	r5, [r7, #40]	; 0x28
 800644c:	e9cd 1c02 	strd	r1, ip, [sp, #8]
 8006450:	e9cd 220d 	strd	r2, r2, [sp, #52]	; 0x34
 8006454:	f8cd e014 	str.w	lr, [sp, #20]
 8006458:	920c      	str	r2, [sp, #48]	; 0x30
 800645a:	9008      	str	r0, [sp, #32]
 800645c:	9500      	str	r5, [sp, #0]
 800645e:	f8d7 9094 	ldr.w	r9, [r7, #148]	; 0x94
 8006462:	f8d7 808c 	ldr.w	r8, [r7, #140]	; 0x8c
 8006466:	6ffd      	ldr	r5, [r7, #124]	; 0x7c
 8006468:	464a      	mov	r2, r9
 800646a:	4641      	mov	r1, r8
 800646c:	4628      	mov	r0, r5
 800646e:	f004 fa37 	bl	800a8e0 <clt_compute_allocation>
   unquant_fine_energy(mode, start, end, oldBandE, fine_quant, dec, C);
 8006472:	f8d7 6084 	ldr.w	r6, [r7, #132]	; 0x84
 8006476:	464a      	mov	r2, r9
 8006478:	e9cd 4601 	strd	r4, r6, [sp, #4]
 800647c:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
 800647e:	4641      	mov	r1, r8
 8006480:	9600      	str	r6, [sp, #0]
 8006482:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   codedBands = clt_compute_allocation(mode, start, end, offsets, cap,
 8006484:	4682      	mov	sl, r0
   unquant_fine_energy(mode, start, end, oldBandE, fine_quant, dec, C);
 8006486:	4628      	mov	r0, r5
 8006488:	f004 f990 	bl	800a7ac <unquant_fine_energy>
      OPUS_MOVE(decode_mem[c], decode_mem[c]+N, DECODE_BUFFER_SIZE-N+overlap/2);
 800648c:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800648e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8006490:	f5c2 6500 	rsb	r5, r2, #2048	; 0x800
 8006494:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 8006498:	eb05 0563 	add.w	r5, r5, r3, asr #1
 800649c:	f8d7 6088 	ldr.w	r6, [r7, #136]	; 0x88
 80064a0:	f8d7 9078 	ldr.w	r9, [r7, #120]	; 0x78
 80064a4:	00ad      	lsls	r5, r5, #2
 80064a6:	ea4f 0882 	mov.w	r8, r2, lsl #2
 80064aa:	f107 03e8 	add.w	r3, r7, #232	; 0xe8
 80064ae:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 80064b2:	f853 0c40 	ldr.w	r0, [r3, #-64]
 80064b6:	462a      	mov	r2, r5
 80064b8:	eb00 0108 	add.w	r1, r0, r8
 80064bc:	f00d fe1b 	bl	80140f6 <memmove>
   } while (++c<CC);
 80064c0:	1c73      	adds	r3, r6, #1
 80064c2:	4599      	cmp	r9, r3
 80064c4:	f04f 0601 	mov.w	r6, #1
 80064c8:	dcef      	bgt.n	80064aa <celt_decode_with_ec+0x582>
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
 80064ca:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80064ce:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 80064d2:	461a      	mov	r2, r3
   ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 80064d4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
 80064d6:	fb02 f801 	mul.w	r8, r2, r1
   ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 80064da:	461a      	mov	r2, r3
 80064dc:	460b      	mov	r3, r1
 80064de:	fb02 f303 	mul.w	r3, r2, r3
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
 80064e2:	f108 0207 	add.w	r2, r8, #7
   ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 80064e6:	40b3      	lsls	r3, r6
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
 80064e8:	f022 0207 	bic.w	r2, r2, #7
   ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 80064ec:	3308      	adds	r3, #8
   quant_all_bands(0, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
 80064ee:	2902      	cmp	r1, #2
   ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 80064f0:	f023 0307 	bic.w	r3, r3, #7
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
 80064f4:	ebad 0d02 	sub.w	sp, sp, r2
 80064f8:	aa14      	add	r2, sp, #80	; 0x50
   ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 80064fa:	ebad 0d03 	sub.w	sp, sp, r3
   quant_all_bands(0, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
 80064fe:	bf08      	it	eq
 8006500:	6ebb      	ldreq	r3, [r7, #104]	; 0x68
   ALLOC(X, C*N, celt_norm);   /**< Interleaved normalised MDCTs */
 8006502:	f10d 0950 	add.w	r9, sp, #80	; 0x50
   quant_all_bands(0, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
 8006506:	bf08      	it	eq
 8006508:	eb09 0643 	addeq.w	r6, r9, r3, lsl #1
 800650c:	f04f 0300 	mov.w	r3, #0
 8006510:	f8db 1020 	ldr.w	r1, [fp, #32]
 8006514:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   ALLOC(collapse_masks, C*nbEBands, unsigned char);
 8006516:	62fa      	str	r2, [r7, #44]	; 0x2c
   quant_all_bands(0, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
 8006518:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800651a:	9112      	str	r1, [sp, #72]	; 0x48
 800651c:	f8db 1024 	ldr.w	r1, [fp, #36]	; 0x24
 8006520:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
 8006524:	9111      	str	r1, [sp, #68]	; 0x44
 8006526:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
 800652a:	ebc2 1280 	rsb	r2, r2, r0, lsl #6
 800652e:	f10b 0028 	add.w	r0, fp, #40	; 0x28
 8006532:	e9cd 410c 	strd	r4, r1, [sp, #48]	; 0x30
 8006536:	e9cd 030f 	strd	r0, r3, [sp, #60]	; 0x3c
 800653a:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
 800653e:	bf18      	it	ne
 8006540:	2600      	movne	r6, #0
 8006542:	e9cd 210a 	strd	r2, r1, [sp, #40]	; 0x28
 8006546:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8006548:	9009      	str	r0, [sp, #36]	; 0x24
 800654a:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 800654e:	4618      	mov	r0, r3
 8006550:	9208      	str	r2, [sp, #32]
   oldLogE = oldBandE + 2*nbEBands;
 8006552:	6f3d      	ldr	r5, [r7, #112]	; 0x70
 8006554:	6d39      	ldr	r1, [r7, #80]	; 0x50
   quant_all_bands(0, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
 8006556:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
   oldLogE = oldBandE + 2*nbEBands;
 800655a:	1869      	adds	r1, r5, r1
 800655c:	460d      	mov	r5, r1
   quant_all_bands(0, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
 800655e:	9207      	str	r2, [sp, #28]
 8006560:	9303      	str	r3, [sp, #12]
 8006562:	693b      	ldr	r3, [r7, #16]
 8006564:	9306      	str	r3, [sp, #24]
 8006566:	68bb      	ldr	r3, [r7, #8]
 8006568:	9305      	str	r3, [sp, #20]
 800656a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800656c:	9304      	str	r3, [sp, #16]
 800656e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006570:	f8cd 9000 	str.w	r9, [sp]
 8006574:	e9cd 6201 	strd	r6, r2, [sp, #4]
   oldLogE2 = oldLogE + 2*nbEBands;
 8006578:	462e      	mov	r6, r5
 800657a:	f8c7 5088 	str.w	r5, [r7, #136]	; 0x88
 800657e:	6d3d      	ldr	r5, [r7, #80]	; 0x50
   quant_all_bands(0, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
 8006580:	f8d7 a07c 	ldr.w	sl, [r7, #124]	; 0x7c
   oldLogE2 = oldLogE + 2*nbEBands;
 8006584:	1975      	adds	r5, r6, r5
   quant_all_bands(0, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
 8006586:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 800658a:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800658e:	4651      	mov	r1, sl
   oldLogE2 = oldLogE + 2*nbEBands;
 8006590:	677d      	str	r5, [r7, #116]	; 0x74
   quant_all_bands(0, mode, start, end, X, C==2 ? X+N : NULL, collapse_masks,
 8006592:	f7fd f943 	bl	800381c <quant_all_bands>
   if (anti_collapse_rsv > 0)
 8006596:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8006598:	2a00      	cmp	r2, #0
 800659a:	f040 8329 	bne.w	8006bf0 <celt_decode_with_ec+0xcc8>
 800659e:	69e2      	ldr	r2, [r4, #28]
   unquant_energy_finalise(mode, start, end, oldBandE,
 80065a0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80065a4:	fab2 f282 	clz	r2, r2
 80065a8:	9304      	str	r3, [sp, #16]
 80065aa:	9403      	str	r4, [sp, #12]
 80065ac:	6963      	ldr	r3, [r4, #20]
 80065ae:	f1c2 0220 	rsb	r2, r2, #32
 80065b2:	1a9b      	subs	r3, r3, r2
 80065b4:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80065b6:	1ad3      	subs	r3, r2, r3
 80065b8:	9302      	str	r3, [sp, #8]
 80065ba:	68fb      	ldr	r3, [r7, #12]
 80065bc:	9301      	str	r3, [sp, #4]
 80065be:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80065c0:	9300      	str	r3, [sp, #0]
 80065c2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80065c4:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 80065c8:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 80065cc:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 80065ce:	f004 f923 	bl	800a818 <unquant_energy_finalise>
   if (silence)
 80065d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80065d4:	2b00      	cmp	r3, #0
 80065d6:	d047      	beq.n	8006668 <celt_decode_with_ec+0x740>
      for (i=0;i<C*nbEBands;i++)
 80065d8:	f1b8 0f00 	cmp.w	r8, #0
 80065dc:	dd44      	ble.n	8006668 <celt_decode_with_ec+0x740>
 80065de:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80065e0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80065e2:	f3cb 0540 	ubfx	r5, fp, #1, #1
 80065e6:	4413      	add	r3, r2
 80065e8:	f108 32ff 	add.w	r2, r8, #4294967295
 80065ec:	2a04      	cmp	r2, #4
 80065ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80065f2:	f240 84a7 	bls.w	8006f44 <celt_decode_with_ec+0x101c>
 80065f6:	2d00      	cmp	r5, #0
 80065f8:	f000 835d 	beq.w	8006cb6 <celt_decode_with_ec+0xd8e>
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
 80065fc:	f44f 4210 	mov.w	r2, #36864	; 0x9000
 8006600:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8006602:	6838      	ldr	r0, [r7, #0]
 8006604:	520a      	strh	r2, [r1, r0]
      for (i=0;i<C*nbEBands;i++)
 8006606:	2101      	movs	r1, #1
 8006608:	2200      	movs	r2, #0
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
 800660a:	f04f 2090 	mov.w	r0, #2415955968	; 0x90009000
 800660e:	6efe      	ldr	r6, [r7, #108]	; 0x6c
 8006610:	4433      	add	r3, r6
 8006612:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 8006616:	332c      	adds	r3, #44	; 0x2c
 8006618:	eba8 0505 	sub.w	r5, r8, r5
 800661c:	eb0b 0343 	add.w	r3, fp, r3, lsl #1
 8006620:	086e      	lsrs	r6, r5, #1
 8006622:	3201      	adds	r2, #1
 8006624:	4296      	cmp	r6, r2
 8006626:	f843 0b04 	str.w	r0, [r3], #4
 800662a:	d8fa      	bhi.n	8006622 <celt_decode_with_ec+0x6fa>
 800662c:	f025 0201 	bic.w	r2, r5, #1
 8006630:	4295      	cmp	r5, r2
 8006632:	eb02 0301 	add.w	r3, r2, r1
 8006636:	d017      	beq.n	8006668 <celt_decode_with_ec+0x740>
 8006638:	f44f 4110 	mov.w	r1, #36864	; 0x9000
      for (i=0;i<C*nbEBands;i++)
 800663c:	1c58      	adds	r0, r3, #1
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
 800663e:	6f3d      	ldr	r5, [r7, #112]	; 0x70
      for (i=0;i<C*nbEBands;i++)
 8006640:	4580      	cmp	r8, r0
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
 8006642:	f825 1013 	strh.w	r1, [r5, r3, lsl #1]
 8006646:	ea4f 0243 	mov.w	r2, r3, lsl #1
      for (i=0;i<C*nbEBands;i++)
 800664a:	dd0d      	ble.n	8006668 <celt_decode_with_ec+0x740>
 800664c:	1c98      	adds	r0, r3, #2
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
 800664e:	442a      	add	r2, r5
      for (i=0;i<C*nbEBands;i++)
 8006650:	4580      	cmp	r8, r0
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
 8006652:	8051      	strh	r1, [r2, #2]
      for (i=0;i<C*nbEBands;i++)
 8006654:	dd08      	ble.n	8006668 <celt_decode_with_ec+0x740>
 8006656:	1cd8      	adds	r0, r3, #3
 8006658:	4580      	cmp	r8, r0
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
 800665a:	8091      	strh	r1, [r2, #4]
      for (i=0;i<C*nbEBands;i++)
 800665c:	dd04      	ble.n	8006668 <celt_decode_with_ec+0x740>
 800665e:	3304      	adds	r3, #4
 8006660:	4598      	cmp	r8, r3
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
 8006662:	80d1      	strh	r1, [r2, #6]
      for (i=0;i<C*nbEBands;i++)
 8006664:	dd00      	ble.n	8006668 <celt_decode_with_ec+0x740>
         oldBandE[i] = -QCONST16(28.f,DB_SHIFT);
 8006666:	8111      	strh	r1, [r2, #8]
   celt_synthesis(mode, X, out_syn, oldBandE, start, effEnd,
 8006668:	69bb      	ldr	r3, [r7, #24]
 800666a:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
   c=0; do {
 800666e:	2500      	movs	r5, #0
   celt_synthesis(mode, X, out_syn, oldBandE, start, effEnd,
 8006670:	428b      	cmp	r3, r1
 8006672:	bfa8      	it	ge
 8006674:	460b      	movge	r3, r1
 8006676:	461a      	mov	r2, r3
 8006678:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800667a:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
 800667e:	46a2      	mov	sl, r4
 8006680:	e9cd 1307 	strd	r1, r3, [sp, #28]
 8006684:	f8db 3010 	ldr.w	r3, [fp, #16]
 8006688:	9201      	str	r2, [sp, #4]
 800668a:	9306      	str	r3, [sp, #24]
 800668c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8006690:	4649      	mov	r1, r9
 8006692:	9305      	str	r3, [sp, #20]
 8006694:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006696:	f107 02b0 	add.w	r2, r7, #176	; 0xb0
 800669a:	9304      	str	r3, [sp, #16]
 800669c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800669e:	9303      	str	r3, [sp, #12]
 80066a0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80066a4:	9302      	str	r3, [sp, #8]
 80066a6:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80066aa:	9300      	str	r3, [sp, #0]
 80066ac:	f8d7 807c 	ldr.w	r8, [r7, #124]	; 0x7c
 80066b0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80066b2:	4640      	mov	r0, r8
 80066b4:	f7fe fe76 	bl	80053a4 <celt_synthesis>
 80066b8:	6dbc      	ldr	r4, [r7, #88]	; 0x58
      st->postfilter_period_old=IMAX(st->postfilter_period_old, COMBFILTER_MINPERIOD);
 80066ba:	e9db 320f 	ldrd	r3, r2, [fp, #60]	; 0x3c
      st->postfilter_period=IMAX(st->postfilter_period, COMBFILTER_MINPERIOD);
 80066be:	2b0f      	cmp	r3, #15
 80066c0:	bfb8      	it	lt
 80066c2:	230f      	movlt	r3, #15
      st->postfilter_period_old=IMAX(st->postfilter_period_old, COMBFILTER_MINPERIOD);
 80066c4:	2a0f      	cmp	r2, #15
 80066c6:	bfb8      	it	lt
 80066c8:	220f      	movlt	r2, #15
      comb_filter(out_syn[c], out_syn[c], st->postfilter_period_old, st->postfilter_period, mode->shortMdctSize,
 80066ca:	f8db 0024 	ldr.w	r0, [fp, #36]	; 0x24
 80066ce:	f107 01e8 	add.w	r1, r7, #232	; 0xe8
 80066d2:	eb01 0985 	add.w	r9, r1, r5, lsl #2
      st->postfilter_period_old=IMAX(st->postfilter_period_old, COMBFILTER_MINPERIOD);
 80066d6:	e9cb 320f 	strd	r3, r2, [fp, #60]	; 0x3c
      comb_filter(out_syn[c], out_syn[c], st->postfilter_period_old, st->postfilter_period, mode->shortMdctSize,
 80066da:	f859 1c38 	ldr.w	r1, [r9, #-56]
 80066de:	e9cd 4006 	strd	r4, r0, [sp, #24]
 80066e2:	f8d8 0034 	ldr.w	r0, [r8, #52]	; 0x34
 80066e6:	9005      	str	r0, [sp, #20]
 80066e8:	f8db 0048 	ldr.w	r0, [fp, #72]	; 0x48
 80066ec:	9004      	str	r0, [sp, #16]
 80066ee:	f8db 004c 	ldr.w	r0, [fp, #76]	; 0x4c
 80066f2:	9003      	str	r0, [sp, #12]
 80066f4:	f9bb 6044 	ldrsh.w	r6, [fp, #68]	; 0x44
 80066f8:	4608      	mov	r0, r1
 80066fa:	9602      	str	r6, [sp, #8]
 80066fc:	f9bb 6046 	ldrsh.w	r6, [fp, #70]	; 0x46
 8006700:	9601      	str	r6, [sp, #4]
 8006702:	f8d8 6024 	ldr.w	r6, [r8, #36]	; 0x24
 8006706:	9600      	str	r6, [sp, #0]
 8006708:	f7fe fab2 	bl	8004c70 <comb_filter>
      if (LM!=0)
 800670c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8006710:	2b00      	cmp	r3, #0
 8006712:	f040 821e 	bne.w	8006b52 <celt_decode_with_ec+0xc2a>
   } while (++c<CC);
 8006716:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8006718:	1c6b      	adds	r3, r5, #1
 800671a:	429a      	cmp	r2, r3
 800671c:	f04f 0501 	mov.w	r5, #1
 8006720:	dccb      	bgt.n	80066ba <celt_decode_with_ec+0x792>
   st->postfilter_period_old = st->postfilter_period;
 8006722:	f8db 303c 	ldr.w	r3, [fp, #60]	; 0x3c
   st->postfilter_gain_old = st->postfilter_gain;
 8006726:	f8bb 2044 	ldrh.w	r2, [fp, #68]	; 0x44
   st->postfilter_period_old = st->postfilter_period;
 800672a:	f8cb 3040 	str.w	r3, [fp, #64]	; 0x40
   st->postfilter_tapset_old = st->postfilter_tapset;
 800672e:	f8db 3048 	ldr.w	r3, [fp, #72]	; 0x48
   st->postfilter_period = postfilter_pitch;
 8006732:	6a79      	ldr	r1, [r7, #36]	; 0x24
   st->postfilter_gain_old = st->postfilter_gain;
 8006734:	f8ab 2046 	strh.w	r2, [fp, #70]	; 0x46
   st->postfilter_tapset_old = st->postfilter_tapset;
 8006738:	f8cb 304c 	str.w	r3, [fp, #76]	; 0x4c
   st->postfilter_gain = postfilter_gain;
 800673c:	69fa      	ldr	r2, [r7, #28]
   st->postfilter_tapset = postfilter_tapset;
 800673e:	6a3b      	ldr	r3, [r7, #32]
   if (LM!=0)
 8006740:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 8006744:	4654      	mov	r4, sl
   st->postfilter_period = postfilter_pitch;
 8006746:	f8cb 103c 	str.w	r1, [fp, #60]	; 0x3c
   st->postfilter_gain = postfilter_gain;
 800674a:	f8ab 2044 	strh.w	r2, [fp, #68]	; 0x44
   st->postfilter_tapset = postfilter_tapset;
 800674e:	f8cb 3048 	str.w	r3, [fp, #72]	; 0x48
   if (LM!=0)
 8006752:	b128      	cbz	r0, 8006760 <celt_decode_with_ec+0x838>
      st->postfilter_period_old = st->postfilter_period;
 8006754:	f8cb 1040 	str.w	r1, [fp, #64]	; 0x40
      st->postfilter_gain_old = st->postfilter_gain;
 8006758:	f8ab 2046 	strh.w	r2, [fp, #70]	; 0x46
      st->postfilter_tapset_old = st->postfilter_tapset;
 800675c:	f8cb 304c 	str.w	r3, [fp, #76]	; 0x4c
   if (C==1)
 8006760:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8006764:	2b01      	cmp	r3, #1
      OPUS_COPY(&oldBandE[nbEBands], oldBandE, nbEBands);
 8006766:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800676a:	ea4f 0543 	mov.w	r5, r3, lsl #1
   if (C==1)
 800676e:	f000 8377 	beq.w	8006e60 <celt_decode_with_ec+0xf38>
   if (!isTransient)
 8006772:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8006774:	2b00      	cmp	r3, #0
 8006776:	f000 832b 	beq.w	8006dd0 <celt_decode_with_ec+0xea8>
      for (i=0;i<2*nbEBands;i++)
 800677a:	2d00      	cmp	r5, #0
 800677c:	dd11      	ble.n	80067a2 <celt_decode_with_ec+0x87a>
 800677e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006780:	1e9d      	subs	r5, r3, #2
 8006782:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006784:	441d      	add	r5, r3
 8006786:	1e98      	subs	r0, r3, #2
 8006788:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800678c:	1e99      	subs	r1, r3, #2
         oldLogE[i] = MIN16(oldLogE[i], oldBandE[i]);
 800678e:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
 8006792:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
 8006796:	4293      	cmp	r3, r2
 8006798:	bfa8      	it	ge
 800679a:	4613      	movge	r3, r2
      for (i=0;i<2*nbEBands;i++)
 800679c:	42a8      	cmp	r0, r5
         oldLogE[i] = MIN16(oldLogE[i], oldBandE[i]);
 800679e:	800b      	strh	r3, [r1, #0]
      for (i=0;i<2*nbEBands;i++)
 80067a0:	d1f5      	bne.n	800678e <celt_decode_with_ec+0x866>
      for (i=0;i<start;i++)
 80067a2:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80067a6:	2b00      	cmp	r3, #0
 80067a8:	f340 8369 	ble.w	8006e7e <celt_decode_with_ec+0xf56>
 80067ac:	f04f 0a00 	mov.w	sl, #0
 80067b0:	f8c7 a090 	str.w	sl, [r7, #144]	; 0x90
 80067b4:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80067b6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80067b8:	4413      	add	r3, r2
 80067ba:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 80067be:	009b      	lsls	r3, r3, #2
 80067c0:	18d0      	adds	r0, r2, r3
 80067c2:	1815      	adds	r5, r2, r0
 80067c4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80067c6:	4413      	add	r3, r2
 80067c8:	4415      	add	r5, r2
 80067ca:	005b      	lsls	r3, r3, #1
 80067cc:	006d      	lsls	r5, r5, #1
 80067ce:	f105 012c 	add.w	r1, r5, #44	; 0x2c
 80067d2:	f103 062e 	add.w	r6, r3, #46	; 0x2e
 80067d6:	4451      	add	r1, sl
 80067d8:	4456      	add	r6, sl
 80067da:	0076      	lsls	r6, r6, #1
 80067dc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80067e0:	45b4      	cmp	ip, r6
 80067e2:	bfb4      	ite	lt
 80067e4:	f04f 0800 	movlt.w	r8, #0
 80067e8:	f04f 0801 	movge.w	r8, #1
 80067ec:	4410      	add	r0, r2
 80067ee:	0040      	lsls	r0, r0, #1
 80067f0:	f100 0e2c 	add.w	lr, r0, #44	; 0x2c
 80067f4:	352e      	adds	r5, #46	; 0x2e
 80067f6:	332c      	adds	r3, #44	; 0x2c
 80067f8:	302e      	adds	r0, #46	; 0x2e
 80067fa:	4455      	add	r5, sl
 80067fc:	4453      	add	r3, sl
 80067fe:	44d6      	add	lr, sl
 8006800:	4450      	add	r0, sl
 8006802:	005a      	lsls	r2, r3, #1
 8006804:	006d      	lsls	r5, r5, #1
 8006806:	0040      	lsls	r0, r0, #1
 8006808:	ea4f 094e 	mov.w	r9, lr, lsl #1
 800680c:	4295      	cmp	r5, r2
 800680e:	bfd8      	it	le
 8006810:	f048 0801 	orrle.w	r8, r8, #1
 8006814:	45b1      	cmp	r9, r6
 8006816:	bfb8      	it	lt
 8006818:	4282      	cmplt	r2, r0
 800681a:	bfac      	ite	ge
 800681c:	2601      	movge	r6, #1
 800681e:	2600      	movlt	r6, #0
 8006820:	ea06 0808 	and.w	r8, r6, r8
 8006824:	f8d7 608c 	ldr.w	r6, [r7, #140]	; 0x8c
 8006828:	2e0c      	cmp	r6, #12
 800682a:	bfd4      	ite	le
 800682c:	2600      	movle	r6, #0
 800682e:	f008 0601 	andgt.w	r6, r8, #1
 8006832:	2e00      	cmp	r6, #0
 8006834:	f000 8275 	beq.w	8006d22 <celt_decode_with_ec+0xdfa>
 8006838:	4584      	cmp	ip, r0
 800683a:	bfb4      	ite	lt
 800683c:	2000      	movlt	r0, #0
 800683e:	2001      	movge	r0, #1
 8006840:	454d      	cmp	r5, r9
 8006842:	bfd8      	it	le
 8006844:	f040 0001 	orrle.w	r0, r0, #1
 8006848:	2800      	cmp	r0, #0
 800684a:	f000 826a 	beq.w	8006d22 <celt_decode_with_ec+0xdfa>
 800684e:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 8006852:	445a      	add	r2, fp
 8006854:	2800      	cmp	r0, #0
 8006856:	f3c2 0840 	ubfx	r8, r2, #1, #1
 800685a:	bfc8      	it	gt
 800685c:	4684      	movgt	ip, r0
 800685e:	f100 32ff 	add.w	r2, r0, #4294967295
 8006862:	bfdc      	itt	le
 8006864:	f04f 0c01 	movle.w	ip, #1
 8006868:	2200      	movle	r2, #0
 800686a:	f1b8 0f00 	cmp.w	r8, #0
 800686e:	bf0c      	ite	eq
 8006870:	2001      	moveq	r0, #1
 8006872:	2002      	movne	r0, #2
 8006874:	4282      	cmp	r2, r0
 8006876:	f0c0 830e 	bcc.w	8006e96 <celt_decode_with_ec+0xf6e>
 800687a:	f1b8 0f00 	cmp.w	r8, #0
 800687e:	f000 81fd 	beq.w	8006c7c <celt_decode_with_ec+0xd54>
         oldBandE[c*nbEBands+i]=0;
 8006882:	2000      	movs	r0, #0
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006884:	f44f 4210 	mov.w	r2, #36864	; 0x9000
 8006888:	2601      	movs	r6, #1
         oldBandE[c*nbEBands+i]=0;
 800688a:	6f3d      	ldr	r5, [r7, #112]	; 0x70
 800688c:	f825 001a 	strh.w	r0, [r5, sl, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006890:	6f78      	ldr	r0, [r7, #116]	; 0x74
 8006892:	f820 201a 	strh.w	r2, [r0, sl, lsl #1]
 8006896:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
 800689a:	f820 201a 	strh.w	r2, [r0, sl, lsl #1]
 800689e:	2000      	movs	r0, #0
 80068a0:	f04f 2590 	mov.w	r5, #2415955968	; 0x90009000
         oldBandE[c*nbEBands+i]=0;
 80068a4:	4602      	mov	r2, r0
 80068a6:	4443      	add	r3, r8
 80068a8:	4441      	add	r1, r8
 80068aa:	44c6      	add	lr, r8
 80068ac:	ebac 0c08 	sub.w	ip, ip, r8
 80068b0:	eb0b 0343 	add.w	r3, fp, r3, lsl #1
 80068b4:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
 80068b8:	eb0b 0e4e 	add.w	lr, fp, lr, lsl #1
 80068bc:	ea4f 085c 	mov.w	r8, ip, lsr #1
 80068c0:	3001      	adds	r0, #1
 80068c2:	4580      	cmp	r8, r0
 80068c4:	f843 2b04 	str.w	r2, [r3], #4
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 80068c8:	f841 5b04 	str.w	r5, [r1], #4
 80068cc:	f84e 5b04 	str.w	r5, [lr], #4
 80068d0:	d8f6      	bhi.n	80068c0 <celt_decode_with_ec+0x998>
 80068d2:	f02c 0101 	bic.w	r1, ip, #1
 80068d6:	458c      	cmp	ip, r1
 80068d8:	440e      	add	r6, r1
 80068da:	d021      	beq.n	8006920 <celt_decode_with_ec+0x9f8>
 80068dc:	f44f 4010 	mov.w	r0, #36864	; 0x9000
         oldBandE[c*nbEBands+i]=0;
 80068e0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80068e2:	eb06 010a 	add.w	r1, r6, sl
 80068e6:	f823 2011 	strh.w	r2, [r3, r1, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 80068ea:	6f7b      	ldr	r3, [r7, #116]	; 0x74
      for (i=0;i<start;i++)
 80068ec:	3601      	adds	r6, #1
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 80068ee:	f823 0011 	strh.w	r0, [r3, r1, lsl #1]
 80068f2:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80068f6:	f823 0011 	strh.w	r0, [r3, r1, lsl #1]
      for (i=0;i<start;i++)
 80068fa:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80068fe:	429e      	cmp	r6, r3
 8006900:	da0e      	bge.n	8006920 <celt_decode_with_ec+0x9f8>
         oldBandE[c*nbEBands+i]=0;
 8006902:	2100      	movs	r1, #0
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006904:	f44f 4210 	mov.w	r2, #36864	; 0x9000
         oldBandE[c*nbEBands+i]=0;
 8006908:	6f38      	ldr	r0, [r7, #112]	; 0x70
 800690a:	eb0a 0306 	add.w	r3, sl, r6
 800690e:	f820 1013 	strh.w	r1, [r0, r3, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006912:	6f79      	ldr	r1, [r7, #116]	; 0x74
 8006914:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
 8006918:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800691c:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
      for (i=end;i<nbEBands;i++)
 8006920:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8006924:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8006928:	4293      	cmp	r3, r2
 800692a:	f340 80d4 	ble.w	8006ad6 <celt_decode_with_ec+0xbae>
 800692e:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8006930:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006932:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 8006934:	4413      	add	r3, r2
 8006936:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800693a:	009b      	lsls	r3, r3, #2
 800693c:	18d0      	adds	r0, r2, r3
 800693e:	1815      	adds	r5, r2, r0
 8006940:	440b      	add	r3, r1
 8006942:	440d      	add	r5, r1
 8006944:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 8006948:	005b      	lsls	r3, r3, #1
 800694a:	006d      	lsls	r5, r5, #1
 800694c:	eb01 060a 	add.w	r6, r1, sl
 8006950:	f105 022c 	add.w	r2, r5, #44	; 0x2c
 8006954:	f103 0c2e 	add.w	ip, r3, #46	; 0x2e
 8006958:	4432      	add	r2, r6
 800695a:	44b4      	add	ip, r6
 800695c:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 8006960:	ea4f 0842 	mov.w	r8, r2, lsl #1
 8006964:	45e0      	cmp	r8, ip
 8006966:	bfb4      	ite	lt
 8006968:	f04f 0900 	movlt.w	r9, #0
 800696c:	f04f 0901 	movge.w	r9, #1
 8006970:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 8006972:	352e      	adds	r5, #46	; 0x2e
 8006974:	4408      	add	r0, r1
 8006976:	0040      	lsls	r0, r0, #1
 8006978:	f100 012c 	add.w	r1, r0, #44	; 0x2c
 800697c:	332c      	adds	r3, #44	; 0x2c
 800697e:	302e      	adds	r0, #46	; 0x2e
 8006980:	4433      	add	r3, r6
 8006982:	4431      	add	r1, r6
 8006984:	4430      	add	r0, r6
 8006986:	4435      	add	r5, r6
 8006988:	65fa      	str	r2, [r7, #92]	; 0x5c
 800698a:	65bb      	str	r3, [r7, #88]	; 0x58
 800698c:	005a      	lsls	r2, r3, #1
 800698e:	6539      	str	r1, [r7, #80]	; 0x50
 8006990:	0043      	lsls	r3, r0, #1
 8006992:	0049      	lsls	r1, r1, #1
 8006994:	006d      	lsls	r5, r5, #1
 8006996:	4295      	cmp	r5, r2
 8006998:	bfd8      	it	le
 800699a:	f049 0901 	orrle.w	r9, r9, #1
 800699e:	6679      	str	r1, [r7, #100]	; 0x64
 80069a0:	4561      	cmp	r1, ip
 80069a2:	bfb8      	it	lt
 80069a4:	429a      	cmplt	r2, r3
 80069a6:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 80069aa:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 80069ae:	4608      	mov	r0, r1
 80069b0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80069b4:	bfa8      	it	ge
 80069b6:	f04f 0c01 	movge.w	ip, #1
 80069ba:	eba3 0e01 	sub.w	lr, r3, r1
 80069be:	bfb8      	it	lt
 80069c0:	f04f 0c00 	movlt.w	ip, #0
 80069c4:	f1be 0f0c 	cmp.w	lr, #12
 80069c8:	bf94      	ite	ls
 80069ca:	2100      	movls	r1, #0
 80069cc:	2101      	movhi	r1, #1
 80069ce:	4283      	cmp	r3, r0
 80069d0:	bfd8      	it	le
 80069d2:	2100      	movle	r1, #0
 80069d4:	ea09 0c0c 	and.w	ip, r9, ip
 80069d8:	ea1c 0f01 	tst.w	ip, r1
 80069dc:	f000 8187 	beq.w	8006cee <celt_decode_with_ec+0xdc6>
 80069e0:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 80069e4:	4588      	cmp	r8, r1
 80069e6:	4608      	mov	r0, r1
 80069e8:	bfb4      	ite	lt
 80069ea:	2000      	movlt	r0, #0
 80069ec:	2001      	movge	r0, #1
 80069ee:	6e79      	ldr	r1, [r7, #100]	; 0x64
 80069f0:	428d      	cmp	r5, r1
 80069f2:	bfd8      	it	le
 80069f4:	f040 0001 	orrle.w	r0, r0, #1
 80069f8:	2800      	cmp	r0, #0
 80069fa:	f000 8178 	beq.w	8006cee <celt_decode_with_ec+0xdc6>
 80069fe:	4619      	mov	r1, r3
 8006a00:	f8d7 5094 	ldr.w	r5, [r7, #148]	; 0x94
 8006a04:	445a      	add	r2, fp
 8006a06:	f3c2 0240 	ubfx	r2, r2, #1, #1
 8006a0a:	42ab      	cmp	r3, r5
 8006a0c:	bfcc      	ite	gt
 8006a0e:	46f4      	movgt	ip, lr
 8006a10:	f04f 0c01 	movle.w	ip, #1
 8006a14:	2a00      	cmp	r2, #0
 8006a16:	f10e 3eff 	add.w	lr, lr, #4294967295
 8006a1a:	4628      	mov	r0, r5
 8006a1c:	bf0c      	ite	eq
 8006a1e:	2001      	moveq	r0, #1
 8006a20:	2002      	movne	r0, #2
 8006a22:	42a9      	cmp	r1, r5
 8006a24:	bfd8      	it	le
 8006a26:	f04f 0e00 	movle.w	lr, #0
 8006a2a:	4570      	cmp	r0, lr
 8006a2c:	462b      	mov	r3, r5
 8006a2e:	f200 8241 	bhi.w	8006eb4 <celt_decode_with_ec+0xf8c>
 8006a32:	2a00      	cmp	r2, #0
 8006a34:	f000 8120 	beq.w	8006c78 <celt_decode_with_ec+0xd50>
         oldBandE[c*nbEBands+i]=0;
 8006a38:	2500      	movs	r5, #0
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006a3a:	f44f 4010 	mov.w	r0, #36864	; 0x9000
         oldBandE[c*nbEBands+i]=0;
 8006a3e:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8006a40:	f821 5016 	strh.w	r5, [r1, r6, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006a44:	6f79      	ldr	r1, [r7, #116]	; 0x74
 8006a46:	f821 0016 	strh.w	r0, [r1, r6, lsl #1]
 8006a4a:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 8006a4e:	f821 0016 	strh.w	r0, [r1, r6, lsl #1]
      for (i=end;i<nbEBands;i++)
 8006a52:	1c5e      	adds	r6, r3, #1
   end = st->end;
 8006a54:	2000      	movs	r0, #0
 8006a56:	6dbb      	ldr	r3, [r7, #88]	; 0x58
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006a58:	f04f 2590 	mov.w	r5, #2415955968	; 0x90009000
 8006a5c:	4413      	add	r3, r2
 8006a5e:	4698      	mov	r8, r3
 8006a60:	6d3b      	ldr	r3, [r7, #80]	; 0x50
         oldBandE[c*nbEBands+i]=0;
 8006a62:	4686      	mov	lr, r0
 8006a64:	4413      	add	r3, r2
 8006a66:	4619      	mov	r1, r3
 8006a68:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8006a6a:	ebac 0c02 	sub.w	ip, ip, r2
 8006a6e:	441a      	add	r2, r3
 8006a70:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
 8006a74:	eb0b 0348 	add.w	r3, fp, r8, lsl #1
 8006a78:	eb0b 0242 	add.w	r2, fp, r2, lsl #1
 8006a7c:	ea4f 085c 	mov.w	r8, ip, lsr #1
 8006a80:	3001      	adds	r0, #1
 8006a82:	4580      	cmp	r8, r0
 8006a84:	f843 eb04 	str.w	lr, [r3], #4
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006a88:	f842 5b04 	str.w	r5, [r2], #4
 8006a8c:	f841 5b04 	str.w	r5, [r1], #4
 8006a90:	d8f6      	bhi.n	8006a80 <celt_decode_with_ec+0xb58>
 8006a92:	f02c 0301 	bic.w	r3, ip, #1
 8006a96:	4563      	cmp	r3, ip
 8006a98:	441e      	add	r6, r3
 8006a9a:	d01c      	beq.n	8006ad6 <celt_decode_with_ec+0xbae>
         oldBandE[c*nbEBands+i]=0;
 8006a9c:	f04f 0c00 	mov.w	ip, #0
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006aa0:	f44f 4310 	mov.w	r3, #36864	; 0x9000
         oldBandE[c*nbEBands+i]=0;
 8006aa4:	6f3d      	ldr	r5, [r7, #112]	; 0x70
 8006aa6:	eb06 010a 	add.w	r1, r6, sl
 8006aaa:	f825 c011 	strh.w	ip, [r5, r1, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006aae:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8006ab2:	6f7d      	ldr	r5, [r7, #116]	; 0x74
      for (i=end;i<nbEBands;i++)
 8006ab4:	3601      	adds	r6, #1
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006ab6:	f825 3011 	strh.w	r3, [r5, r1, lsl #1]
 8006aba:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
      for (i=end;i<nbEBands;i++)
 8006abe:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 8006ac2:	428e      	cmp	r6, r1
 8006ac4:	da07      	bge.n	8006ad6 <celt_decode_with_ec+0xbae>
         oldBandE[c*nbEBands+i]=0;
 8006ac6:	6f38      	ldr	r0, [r7, #112]	; 0x70
 8006ac8:	4456      	add	r6, sl
 8006aca:	f820 c016 	strh.w	ip, [r0, r6, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006ace:	f825 3016 	strh.w	r3, [r5, r6, lsl #1]
 8006ad2:	f822 3016 	strh.w	r3, [r2, r6, lsl #1]
   } while (++c<2);
 8006ad6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8006ada:	b353      	cbz	r3, 8006b32 <celt_decode_with_ec+0xc0a>
   deemphasis(out_syn, pcm, N, CC, st->downsample, mode->preemph, st->preemph_memD, accum);
 8006adc:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
   st->rng = dec->rng;
 8006ade:	69e1      	ldr	r1, [r4, #28]
   deemphasis(out_syn, pcm, N, CC, st->downsample, mode->preemph, st->preemph_memD, accum);
 8006ae0:	3210      	adds	r2, #16
   st->rng = dec->rng;
 8006ae2:	f8cb 1028 	str.w	r1, [fp, #40]	; 0x28
   deemphasis(out_syn, pcm, N, CC, st->downsample, mode->preemph, st->preemph_memD, accum);
 8006ae6:	9201      	str	r2, [sp, #4]
 8006ae8:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8006aec:	f10b 0350 	add.w	r3, fp, #80	; 0x50
 8006af0:	e9cd 3202 	strd	r3, r2, [sp, #8]
 8006af4:	f8db 5010 	ldr.w	r5, [fp, #16]
 8006af8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8006afa:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8006afc:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8006afe:	f107 00b0 	add.w	r0, r7, #176	; 0xb0
 8006b02:	9500      	str	r5, [sp, #0]
 8006b04:	f7fe fae8 	bl	80050d8 <deemphasis>
 8006b08:	69e3      	ldr	r3, [r4, #28]
   st->loss_count = 0;
 8006b0a:	2100      	movs	r1, #0
 8006b0c:	fab3 f383 	clz	r3, r3
 8006b10:	6962      	ldr	r2, [r4, #20]
 8006b12:	f1c3 0320 	rsb	r3, r3, #32
 8006b16:	1ad3      	subs	r3, r2, r3
   if (ec_tell(dec) > 8*len)
 8006b18:	6e3a      	ldr	r2, [r7, #96]	; 0x60
   st->loss_count = 0;
 8006b1a:	f8cb 1034 	str.w	r1, [fp, #52]	; 0x34
   if (ec_tell(dec) > 8*len)
 8006b1e:	429a      	cmp	r2, r3
 8006b20:	da5b      	bge.n	8006bda <celt_decode_with_ec+0xcb2>
      return OPUS_INTERNAL_ERROR;
 8006b22:	f06f 0002 	mvn.w	r0, #2
 8006b26:	f8d7 d014 	ldr.w	sp, [r7, #20]
}
 8006b2a:	37ec      	adds	r7, #236	; 0xec
 8006b2c:	46bd      	mov	sp, r7
 8006b2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   } while (++c<2);
 8006b32:	2301      	movs	r3, #1
 8006b34:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
      for (i=0;i<start;i++)
 8006b38:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   nbEBands = mode->nbEBands;
 8006b3c:	f8d7 a080 	ldr.w	sl, [r7, #128]	; 0x80
      for (i=0;i<start;i++)
 8006b40:	2b00      	cmp	r3, #0
 8006b42:	f73f ae37 	bgt.w	80067b4 <celt_decode_with_ec+0x88c>
      for (i=end;i<nbEBands;i++)
 8006b46:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8006b4a:	4592      	cmp	sl, r2
 8006b4c:	f73f aeef 	bgt.w	800692e <celt_decode_with_ec+0xa06>
 8006b50:	e7c4      	b.n	8006adc <celt_decode_with_ec+0xbb4>
         comb_filter(out_syn[c]+mode->shortMdctSize, out_syn[c]+mode->shortMdctSize, st->postfilter_period, postfilter_pitch, N-mode->shortMdctSize,
 8006b52:	f8db 0024 	ldr.w	r0, [fp, #36]	; 0x24
 8006b56:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8006b5a:	f859 1c38 	ldr.w	r1, [r9, #-56]
 8006b5e:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
 8006b62:	e9cd 4006 	strd	r4, r0, [sp, #24]
 8006b66:	f8d8 0034 	ldr.w	r0, [r8, #52]	; 0x34
 8006b6a:	6a3e      	ldr	r6, [r7, #32]
 8006b6c:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8006b70:	e9cd 6004 	strd	r6, r0, [sp, #16]
 8006b74:	f8db 0048 	ldr.w	r0, [fp, #72]	; 0x48
 8006b78:	69fe      	ldr	r6, [r7, #28]
 8006b7a:	e9cd 6002 	strd	r6, r0, [sp, #8]
 8006b7e:	6ebe      	ldr	r6, [r7, #104]	; 0x68
 8006b80:	f9bb 0044 	ldrsh.w	r0, [fp, #68]	; 0x44
 8006b84:	1af3      	subs	r3, r6, r3
 8006b86:	e9cd 3000 	strd	r3, r0, [sp]
 8006b8a:	4608      	mov	r0, r1
 8006b8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006b8e:	f7fe f86f 	bl	8004c70 <comb_filter>
 8006b92:	e5c0      	b.n	8006716 <celt_decode_with_ec+0x7ee>
      offsets[i] = boost;
 8006b94:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8006b98:	461a      	mov	r2, r3
 8006b9a:	2300      	movs	r3, #0
 8006b9c:	6013      	str	r3, [r2, #0]
 8006b9e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8006ba2:	e402      	b.n	80063aa <celt_decode_with_ec+0x482>
   logp = isTransient ? 2 : 4;
 8006ba4:	2604      	movs	r6, #4
   tf_select_rsv = LM>0 && tell+logp+1<=budget;
 8006ba6:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
   logp = isTransient ? 2 : 4;
 8006baa:	4631      	mov	r1, r6
   tf_select_rsv = LM>0 && tell+logp+1<=budget;
 8006bac:	2800      	cmp	r0, #0
 8006bae:	f47f aaec 	bne.w	800618a <celt_decode_with_ec+0x262>
   for (i=start;i<end;i++)
 8006bb2:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 8006bb6:	f8d7 6094 	ldr.w	r6, [r7, #148]	; 0x94
 8006bba:	42b0      	cmp	r0, r6
 8006bbc:	f280 80d9 	bge.w	8006d72 <celt_decode_with_ec+0xe4a>
   budget -= tf_select_rsv;
 8006bc0:	4691      	mov	r9, r2
   tf_select_rsv = LM>0 && tell+logp+1<=budget;
 8006bc2:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8006bc6:	677a      	str	r2, [r7, #116]	; 0x74
 8006bc8:	f7ff baf0 	b.w	80061ac <celt_decode_with_ec+0x284>
   else if (tell==1)
 8006bcc:	2e01      	cmp	r6, #1
 8006bce:	f000 817a 	beq.w	8006ec6 <celt_decode_with_ec+0xf9e>
      silence = 0;
 8006bd2:	2300      	movs	r3, #0
 8006bd4:	633b      	str	r3, [r7, #48]	; 0x30
 8006bd6:	f7ff ba55 	b.w	8006084 <celt_decode_with_ec+0x15c>
   if(ec_get_error(dec))
 8006bda:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006bdc:	b113      	cbz	r3, 8006be4 <celt_decode_with_ec+0xcbc>
      st->error = 1;
 8006bde:	2301      	movs	r3, #1
 8006be0:	f8cb 302c 	str.w	r3, [fp, #44]	; 0x2c
   return frame_size/st->downsample;
 8006be4:	f8db 0010 	ldr.w	r0, [fp, #16]
 8006be8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006bea:	fb93 f0f0 	sdiv	r0, r3, r0
 8006bee:	e79a      	b.n	8006b26 <celt_decode_with_ec+0xbfe>
      anti_collapse_on = ec_dec_bits(dec, 1);
 8006bf0:	2101      	movs	r1, #1
 8006bf2:	4620      	mov	r0, r4
 8006bf4:	f001 fe42 	bl	800887c <ec_dec_bits>
 8006bf8:	69e2      	ldr	r2, [r4, #28]
 8006bfa:	4606      	mov	r6, r0
 8006bfc:	fab2 f282 	clz	r2, r2
   unquant_energy_finalise(mode, start, end, oldBandE,
 8006c00:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 8006c04:	9403      	str	r4, [sp, #12]
 8006c06:	9004      	str	r0, [sp, #16]
 8006c08:	6963      	ldr	r3, [r4, #20]
 8006c0a:	f1c2 0220 	rsb	r2, r2, #32
 8006c0e:	1a9b      	subs	r3, r3, r2
 8006c10:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8006c12:	4650      	mov	r0, sl
 8006c14:	1ad3      	subs	r3, r2, r3
 8006c16:	9302      	str	r3, [sp, #8]
 8006c18:	68fa      	ldr	r2, [r7, #12]
 8006c1a:	9201      	str	r2, [sp, #4]
 8006c1c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8006c1e:	9200      	str	r2, [sp, #0]
 8006c20:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006c22:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8006c26:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 8006c2a:	f003 fdf5 	bl	800a818 <unquant_energy_finalise>
   if (anti_collapse_on)
 8006c2e:	2e00      	cmp	r6, #0
 8006c30:	f43f accf 	beq.w	80065d2 <celt_decode_with_ec+0x6aa>
      anti_collapse(mode, X, collapse_masks, LM, C, N,
 8006c34:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
 8006c38:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006c3a:	9309      	str	r3, [sp, #36]	; 0x24
 8006c3c:	f8db 1028 	ldr.w	r1, [fp, #40]	; 0x28
 8006c40:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8006c44:	9108      	str	r1, [sp, #32]
 8006c46:	6c3d      	ldr	r5, [r7, #64]	; 0x40
 8006c48:	4650      	mov	r0, sl
 8006c4a:	9507      	str	r5, [sp, #28]
 8006c4c:	6f7d      	ldr	r5, [r7, #116]	; 0x74
 8006c4e:	9506      	str	r5, [sp, #24]
 8006c50:	f8d7 6088 	ldr.w	r6, [r7, #136]	; 0x88
 8006c54:	9605      	str	r6, [sp, #20]
 8006c56:	6f3d      	ldr	r5, [r7, #112]	; 0x70
 8006c58:	9504      	str	r5, [sp, #16]
 8006c5a:	f8d7 5094 	ldr.w	r5, [r7, #148]	; 0x94
 8006c5e:	9503      	str	r5, [sp, #12]
 8006c60:	f8d7 508c 	ldr.w	r5, [r7, #140]	; 0x8c
 8006c64:	9502      	str	r5, [sp, #8]
 8006c66:	6ebd      	ldr	r5, [r7, #104]	; 0x68
 8006c68:	9501      	str	r5, [sp, #4]
 8006c6a:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 8006c6e:	9100      	str	r1, [sp, #0]
 8006c70:	4649      	mov	r1, r9
 8006c72:	f7fc fc31 	bl	80034d8 <anti_collapse>
 8006c76:	e4ac      	b.n	80065d2 <celt_decode_with_ec+0x6aa>
 8006c78:	462e      	mov	r6, r5
 8006c7a:	e6eb      	b.n	8006a54 <celt_decode_with_ec+0xb2c>
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006c7c:	4646      	mov	r6, r8
 8006c7e:	e60e      	b.n	800689e <celt_decode_with_ec+0x976>
      tf_select = ec_dec_bit_logp(dec, 1);
 8006c80:	2101      	movs	r1, #1
 8006c82:	4620      	mov	r0, r4
 8006c84:	f001 fc30 	bl	80084e8 <ec_dec_bit_logp>
 8006c88:	f7ff bae7 	b.w	800625a <celt_decode_with_ec+0x332>
      if(ec_dec_bit_logp(dec, 1))
 8006c8c:	2101      	movs	r1, #1
 8006c8e:	4620      	mov	r0, r4
 8006c90:	f001 fc2a 	bl	80084e8 <ec_dec_bit_logp>
 8006c94:	6278      	str	r0, [r7, #36]	; 0x24
 8006c96:	2800      	cmp	r0, #0
 8006c98:	f040 812b 	bne.w	8006ef2 <celt_decode_with_ec+0xfca>
 8006c9c:	69e3      	ldr	r3, [r4, #28]
 8006c9e:	6966      	ldr	r6, [r4, #20]
 8006ca0:	fab3 f383 	clz	r3, r3
 8006ca4:	f1c3 0320 	rsb	r3, r3, #32
 8006ca8:	1af6      	subs	r6, r6, r3
   postfilter_tapset = 0;
 8006caa:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   postfilter_gain = 0;
 8006cae:	e9c7 3307 	strd	r3, r3, [r7, #28]
 8006cb2:	f7ff ba2e 	b.w	8006112 <celt_decode_with_ec+0x1ea>
      for (i=0;i<C*nbEBands;i++)
 8006cb6:	4629      	mov	r1, r5
 8006cb8:	e4a6      	b.n	8006608 <celt_decode_with_ec+0x6e0>
      for (i=0;i<nbEBands;i++)
 8006cba:	2b00      	cmp	r3, #0
 8006cbc:	f77f a9cc 	ble.w	8006058 <celt_decode_with_ec+0x130>
 8006cc0:	f103 4000 	add.w	r0, r3, #2147483648	; 0x80000000
 8006cc4:	009b      	lsls	r3, r3, #2
 8006cc6:	1e9d      	subs	r5, r3, #2
 8006cc8:	653b      	str	r3, [r7, #80]	; 0x50
 8006cca:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006ccc:	3801      	subs	r0, #1
 8006cce:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 8006cd2:	441d      	add	r5, r3
 8006cd4:	1e99      	subs	r1, r3, #2
         oldBandE[i]=MAX16(oldBandE[i],oldBandE[nbEBands+i]);
 8006cd6:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
 8006cda:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
 8006cde:	4293      	cmp	r3, r2
 8006ce0:	bfb8      	it	lt
 8006ce2:	4613      	movlt	r3, r2
      for (i=0;i<nbEBands;i++)
 8006ce4:	42a8      	cmp	r0, r5
         oldBandE[i]=MAX16(oldBandE[i],oldBandE[nbEBands+i]);
 8006ce6:	800b      	strh	r3, [r1, #0]
      for (i=0;i<nbEBands;i++)
 8006ce8:	d1f5      	bne.n	8006cd6 <celt_decode_with_ec+0xdae>
 8006cea:	f7ff b9b7 	b.w	800605c <celt_decode_with_ec+0x134>
         oldBandE[c*nbEBands+i]=0;
 8006cee:	2500      	movs	r5, #0
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006cf0:	f44f 4010 	mov.w	r0, #36864	; 0x9000
 8006cf4:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8006cf6:	0073      	lsls	r3, r6, #1
 8006cf8:	eb01 0c03 	add.w	ip, r1, r3
 8006cfc:	f8d7 6088 	ldr.w	r6, [r7, #136]	; 0x88
 8006d00:	6f79      	ldr	r1, [r7, #116]	; 0x74
   end = st->end;
 8006d02:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8006d06:	4419      	add	r1, r3
 8006d08:	4433      	add	r3, r6
 8006d0a:	f8d7 6080 	ldr.w	r6, [r7, #128]	; 0x80
      for (i=end;i<nbEBands;i++)
 8006d0e:	3201      	adds	r2, #1
 8006d10:	4296      	cmp	r6, r2
         oldBandE[c*nbEBands+i]=0;
 8006d12:	f82c 5b02 	strh.w	r5, [ip], #2
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006d16:	f821 0b02 	strh.w	r0, [r1], #2
 8006d1a:	f823 0b02 	strh.w	r0, [r3], #2
      for (i=end;i<nbEBands;i++)
 8006d1e:	dcf6      	bgt.n	8006d0e <celt_decode_with_ec+0xde6>
 8006d20:	e6d9      	b.n	8006ad6 <celt_decode_with_ec+0xbae>
      for (i=0;i<start;i++)
 8006d22:	2300      	movs	r3, #0
 8006d24:	f10a 4200 	add.w	r2, sl, #2147483648	; 0x80000000
 8006d28:	6f39      	ldr	r1, [r7, #112]	; 0x70
 8006d2a:	3a01      	subs	r2, #1
 8006d2c:	0052      	lsls	r2, r2, #1
 8006d2e:	1888      	adds	r0, r1, r2
 8006d30:	6f79      	ldr	r1, [r7, #116]	; 0x74
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006d32:	f44f 4510 	mov.w	r5, #36864	; 0x9000
 8006d36:	eb01 0e02 	add.w	lr, r1, r2
 8006d3a:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
         oldBandE[c*nbEBands+i]=0;
 8006d3e:	461e      	mov	r6, r3
 8006d40:	440a      	add	r2, r1
 8006d42:	4671      	mov	r1, lr
 8006d44:	f8d7 c08c 	ldr.w	ip, [r7, #140]	; 0x8c
      for (i=0;i<start;i++)
 8006d48:	3301      	adds	r3, #1
 8006d4a:	459c      	cmp	ip, r3
         oldBandE[c*nbEBands+i]=0;
 8006d4c:	f820 6f02 	strh.w	r6, [r0, #2]!
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006d50:	f821 5f02 	strh.w	r5, [r1, #2]!
 8006d54:	f822 5f02 	strh.w	r5, [r2, #2]!
      for (i=0;i<start;i++)
 8006d58:	dcf6      	bgt.n	8006d48 <celt_decode_with_ec+0xe20>
 8006d5a:	e5e1      	b.n	8006920 <celt_decode_with_ec+0x9f8>
         ec_dec_icdf(dec, trim_icdf, 7) : 5;
 8006d5c:	2207      	movs	r2, #7
 8006d5e:	4991      	ldr	r1, [pc, #580]	; (8006fa4 <celt_decode_with_ec+0x107c>)
 8006d60:	4620      	mov	r0, r4
 8006d62:	f001 fc13 	bl	800858c <ec_dec_icdf>
 8006d66:	4605      	mov	r5, r0
 8006d68:	f7ff bb35 	b.w	80063d6 <celt_decode_with_ec+0x4ae>
   if (tf_select_rsv &&
 8006d6c:	4282      	cmp	r2, r0
 8006d6e:	f080 80bb 	bcs.w	8006ee8 <celt_decode_with_ec+0xfc0>
   if (tell+4 <= total_bits)
 8006d72:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8006d74:	3503      	adds	r5, #3
 8006d76:	42ab      	cmp	r3, r5
 8006d78:	f340 80f5 	ble.w	8006f66 <celt_decode_with_ec+0x103e>
   ALLOC(cap, nbEBands, int);
 8006d7c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
      spread_decision = ec_dec_icdf(dec, spread_icdf, 5);
 8006d7e:	2205      	movs	r2, #5
 8006d80:	4989      	ldr	r1, [pc, #548]	; (8006fa8 <celt_decode_with_ec+0x1080>)
 8006d82:	4620      	mov	r0, r4
   ALLOC(cap, nbEBands, int);
 8006d84:	f023 0507 	bic.w	r5, r3, #7
      spread_decision = ec_dec_icdf(dec, spread_icdf, 5);
 8006d88:	f001 fc00 	bl	800858c <ec_dec_icdf>
   ALLOC(cap, nbEBands, int);
 8006d8c:	ebad 0d05 	sub.w	sp, sp, r5
 8006d90:	ab14      	add	r3, sp, #80	; 0x50
   init_caps(mode,cap,LM,C);
 8006d92:	4619      	mov	r1, r3
 8006d94:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
      spread_decision = ec_dec_icdf(dec, spread_icdf, 5);
 8006d98:	6138      	str	r0, [r7, #16]
   ALLOC(cap, nbEBands, int);
 8006d9a:	62bb      	str	r3, [r7, #40]	; 0x28
   init_caps(mode,cap,LM,C);
 8006d9c:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8006d9e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8006da2:	f7fe f971 	bl	8005088 <init_caps>
   ALLOC(offsets, nbEBands, int);
 8006da6:	ebad 0d05 	sub.w	sp, sp, r5
   tell = ec_tell_frac(dec);
 8006daa:	4620      	mov	r0, r4
 8006dac:	f001 fa88 	bl	80082c0 <ec_tell_frac>
   ALLOC(offsets, nbEBands, int);
 8006db0:	ab14      	add	r3, sp, #80	; 0x50
 8006db2:	62fb      	str	r3, [r7, #44]	; 0x2c
   total_bits<<=BITRES;
 8006db4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   for (i=start;i<end;i++)
 8006db6:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
   total_bits<<=BITRES;
 8006dba:	00db      	lsls	r3, r3, #3
 8006dbc:	637b      	str	r3, [r7, #52]	; 0x34
   for (i=start;i<end;i++)
 8006dbe:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8006dc2:	4293      	cmp	r3, r2
 8006dc4:	f6ff aa91 	blt.w	80062ea <celt_decode_with_ec+0x3c2>
   total_bits<<=BITRES;
 8006dc8:	f8d7 9034 	ldr.w	r9, [r7, #52]	; 0x34
 8006dcc:	f7ff baf7 	b.w	80063be <celt_decode_with_ec+0x496>
      OPUS_COPY(oldLogE2, oldLogE, 2*nbEBands);
 8006dd0:	f8d7 6088 	ldr.w	r6, [r7, #136]	; 0x88
 8006dd4:	f8d7 8050 	ldr.w	r8, [r7, #80]	; 0x50
 8006dd8:	f8d7 a074 	ldr.w	sl, [r7, #116]	; 0x74
 8006ddc:	4631      	mov	r1, r6
 8006dde:	4642      	mov	r2, r8
 8006de0:	4650      	mov	r0, sl
 8006de2:	f00d f97d 	bl	80140e0 <memcpy>
      OPUS_COPY(oldLogE, oldBandE, 2*nbEBands);
 8006de6:	f8d7 9070 	ldr.w	r9, [r7, #112]	; 0x70
 8006dea:	4642      	mov	r2, r8
 8006dec:	4630      	mov	r0, r6
 8006dee:	4649      	mov	r1, r9
 8006df0:	f00d f976 	bl	80140e0 <memcpy>
      if (st->loss_count < 10)
 8006df4:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8006df8:	687a      	ldr	r2, [r7, #4]
 8006dfa:	2b0a      	cmp	r3, #10
 8006dfc:	bfa8      	it	ge
 8006dfe:	f44f 6280 	movge.w	r2, #1024	; 0x400
      for (i=0;i<2*nbEBands;i++)
 8006e02:	2d00      	cmp	r5, #0
 8006e04:	b216      	sxth	r6, r2
 8006e06:	f77f accc 	ble.w	80067a2 <celt_decode_with_ec+0x87a>
 8006e0a:	4652      	mov	r2, sl
 8006e0c:	f1a8 0502 	sub.w	r5, r8, #2
 8006e10:	1950      	adds	r0, r2, r5
 8006e12:	f1a9 0102 	sub.w	r1, r9, #2
 8006e16:	444d      	add	r5, r9
         backgroundLogE[i] = MIN16(backgroundLogE[i] + max_background_increase, oldBandE[i]);
 8006e18:	f930 2f02 	ldrsh.w	r2, [r0, #2]!
 8006e1c:	f931 cf02 	ldrsh.w	ip, [r1, #2]!
 8006e20:	1993      	adds	r3, r2, r6
 8006e22:	4563      	cmp	r3, ip
 8006e24:	bfa8      	it	ge
 8006e26:	4663      	movge	r3, ip
      for (i=0;i<2*nbEBands;i++)
 8006e28:	42a9      	cmp	r1, r5
         backgroundLogE[i] = MIN16(backgroundLogE[i] + max_background_increase, oldBandE[i]);
 8006e2a:	8003      	strh	r3, [r0, #0]
      for (i=0;i<2*nbEBands;i++)
 8006e2c:	d1f4      	bne.n	8006e18 <celt_decode_with_ec+0xef0>
 8006e2e:	e4b8      	b.n	80067a2 <celt_decode_with_ec+0x87a>
   intra_ener = tell+3<=total_bits ? ec_dec_bit_logp(dec, 3) : 0;
 8006e30:	2000      	movs	r0, #0
 8006e32:	f7ff b97a 	b.w	800612a <celt_decode_with_ec+0x202>
      isTransient = ec_dec_bit_logp(dec, 3);
 8006e36:	2103      	movs	r1, #3
 8006e38:	4620      	mov	r0, r4
 8006e3a:	f001 fb55 	bl	80084e8 <ec_dec_bit_logp>
 8006e3e:	69e2      	ldr	r2, [r4, #28]
 8006e40:	6963      	ldr	r3, [r4, #20]
 8006e42:	fab2 f682 	clz	r6, r2
 8006e46:	f1c6 0620 	rsb	r6, r6, #32
 8006e4a:	1b9e      	subs	r6, r3, r6
   if (isTransient)
 8006e4c:	6678      	str	r0, [r7, #100]	; 0x64
 8006e4e:	4603      	mov	r3, r0
 8006e50:	3602      	adds	r6, #2
 8006e52:	2800      	cmp	r0, #0
 8006e54:	f43f a92b 	beq.w	80060ae <celt_decode_with_ec+0x186>
      shortBlocks = M;
 8006e58:	687b      	ldr	r3, [r7, #4]
 8006e5a:	60bb      	str	r3, [r7, #8]
 8006e5c:	f7ff b928 	b.w	80060b0 <celt_decode_with_ec+0x188>
      OPUS_COPY(&oldBandE[nbEBands], oldBandE, nbEBands);
 8006e60:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8006e62:	462a      	mov	r2, r5
 8006e64:	1958      	adds	r0, r3, r5
 8006e66:	4619      	mov	r1, r3
 8006e68:	f00d f93a 	bl	80140e0 <memcpy>
 8006e6c:	e481      	b.n	8006772 <celt_decode_with_ec+0x84a>
      ec_dec_init(&_dec,(unsigned char*)data,len);
 8006e6e:	f107 00b8 	add.w	r0, r7, #184	; 0xb8
 8006e72:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
      dec = &_dec;
 8006e74:	4604      	mov	r4, r0
      ec_dec_init(&_dec,(unsigned char*)data,len);
 8006e76:	f001 fa3f 	bl	80082f8 <ec_dec_init>
 8006e7a:	f7ff b8d8 	b.w	800602e <celt_decode_with_ec+0x106>
      for (i=end;i<nbEBands;i++)
 8006e7e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8006e82:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8006e86:	4293      	cmp	r3, r2
 8006e88:	f77f ae28 	ble.w	8006adc <celt_decode_with_ec+0xbb4>
 8006e8c:	f04f 0a00 	mov.w	sl, #0
 8006e90:	f8c7 a090 	str.w	sl, [r7, #144]	; 0x90
 8006e94:	e54b      	b.n	800692e <celt_decode_with_ec+0xa06>
         oldBandE[c*nbEBands+i]=0;
 8006e96:	2200      	movs	r2, #0
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006e98:	f44f 4310 	mov.w	r3, #36864	; 0x9000
         oldBandE[c*nbEBands+i]=0;
 8006e9c:	6f39      	ldr	r1, [r7, #112]	; 0x70
      for (i=0;i<start;i++)
 8006e9e:	2601      	movs	r6, #1
         oldBandE[c*nbEBands+i]=0;
 8006ea0:	f821 201a 	strh.w	r2, [r1, sl, lsl #1]
         oldLogE[c*nbEBands+i]=oldLogE2[c*nbEBands+i]=-QCONST16(28.f,DB_SHIFT);
 8006ea4:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8006ea6:	f822 301a 	strh.w	r3, [r2, sl, lsl #1]
 8006eaa:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8006eae:	f822 301a 	strh.w	r3, [r2, sl, lsl #1]
 8006eb2:	e526      	b.n	8006902 <celt_decode_with_ec+0x9da>
 8006eb4:	462e      	mov	r6, r5
 8006eb6:	e5f1      	b.n	8006a9c <celt_decode_with_ec+0xb74>
         if (mode->shortMdctSize<<LM==frame_size)
 8006eb8:	66b9      	str	r1, [r7, #104]	; 0x68
 8006eba:	2101      	movs	r1, #1
      for (LM=0;LM<=mode->maxLM;LM++)
 8006ebc:	f8c7 a090 	str.w	sl, [r7, #144]	; 0x90
         if (mode->shortMdctSize<<LM==frame_size)
 8006ec0:	6079      	str	r1, [r7, #4]
 8006ec2:	f7ff b884 	b.w	8005fce <celt_decode_with_ec+0xa6>
      silence = ec_dec_bit_logp(dec, 15);
 8006ec6:	210f      	movs	r1, #15
 8006ec8:	4620      	mov	r0, r4
 8006eca:	f001 fb0d 	bl	80084e8 <ec_dec_bit_logp>
   if (silence)
 8006ece:	6338      	str	r0, [r7, #48]	; 0x30
 8006ed0:	2800      	cmp	r0, #0
 8006ed2:	f43f a8d7 	beq.w	8006084 <celt_decode_with_ec+0x15c>
 8006ed6:	69e3      	ldr	r3, [r4, #28]
 8006ed8:	6962      	ldr	r2, [r4, #20]
 8006eda:	fab3 f683 	clz	r6, r3
 8006ede:	f1c6 0620 	rsb	r6, r6, #32
 8006ee2:	1b96      	subs	r6, r2, r6
 8006ee4:	f7ff b8c9 	b.w	800607a <celt_decode_with_ec+0x152>
   tf_changed = curr = 0;
 8006ee8:	2300      	movs	r3, #0
 8006eea:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8006eee:	f7ff b9a2 	b.w	8006236 <celt_decode_with_ec+0x30e>
         octave = ec_dec_uint(dec, 6);
 8006ef2:	2106      	movs	r1, #6
 8006ef4:	4620      	mov	r0, r4
 8006ef6:	f001 fba1 	bl	800863c <ec_dec_uint>
 8006efa:	4605      	mov	r5, r0
         postfilter_pitch = (16<<octave)+ec_dec_bits(dec, 4+octave)-1;
 8006efc:	4620      	mov	r0, r4
 8006efe:	1d29      	adds	r1, r5, #4
 8006f00:	f001 fcbc 	bl	800887c <ec_dec_bits>
 8006f04:	2310      	movs	r3, #16
 8006f06:	1e42      	subs	r2, r0, #1
 8006f08:	40ab      	lsls	r3, r5
 8006f0a:	4413      	add	r3, r2
         qg = ec_dec_bits(dec, 3);
 8006f0c:	2103      	movs	r1, #3
 8006f0e:	4620      	mov	r0, r4
         postfilter_pitch = (16<<octave)+ec_dec_bits(dec, 4+octave)-1;
 8006f10:	627b      	str	r3, [r7, #36]	; 0x24
         qg = ec_dec_bits(dec, 3);
 8006f12:	f001 fcb3 	bl	800887c <ec_dec_bits>
 8006f16:	69e3      	ldr	r3, [r4, #28]
 8006f18:	6962      	ldr	r2, [r4, #20]
 8006f1a:	fab3 f383 	clz	r3, r3
 8006f1e:	f1c3 0320 	rsb	r3, r3, #32
 8006f22:	1ad6      	subs	r6, r2, r3
         if (ec_tell(dec)+2<=total_bits)
 8006f24:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8006f26:	1c73      	adds	r3, r6, #1
 8006f28:	4293      	cmp	r3, r2
         qg = ec_dec_bits(dec, 3);
 8006f2a:	4605      	mov	r5, r0
         if (ec_tell(dec)+2<=total_bits)
 8006f2c:	db0d      	blt.n	8006f4a <celt_decode_with_ec+0x1022>
   postfilter_tapset = 0;
 8006f2e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8006f32:	623b      	str	r3, [r7, #32]
         postfilter_gain = QCONST16(.09375f,15)*(qg+1);
 8006f34:	3501      	adds	r5, #1
 8006f36:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8006f3a:	02ad      	lsls	r5, r5, #10
 8006f3c:	b22b      	sxth	r3, r5
 8006f3e:	61fb      	str	r3, [r7, #28]
 8006f40:	f7ff b8e7 	b.w	8006112 <celt_decode_with_ec+0x1ea>
      for (i=0;i<C*nbEBands;i++)
 8006f44:	2300      	movs	r3, #0
 8006f46:	f7ff bb77 	b.w	8006638 <celt_decode_with_ec+0x710>
            postfilter_tapset = ec_dec_icdf(dec, tapset_icdf, 2);
 8006f4a:	2202      	movs	r2, #2
 8006f4c:	4917      	ldr	r1, [pc, #92]	; (8006fac <celt_decode_with_ec+0x1084>)
 8006f4e:	4620      	mov	r0, r4
 8006f50:	f001 fb1c 	bl	800858c <ec_dec_icdf>
 8006f54:	69e3      	ldr	r3, [r4, #28]
 8006f56:	6962      	ldr	r2, [r4, #20]
 8006f58:	fab3 f383 	clz	r3, r3
 8006f5c:	f1c3 0320 	rsb	r3, r3, #32
 8006f60:	6238      	str	r0, [r7, #32]
 8006f62:	1ad6      	subs	r6, r2, r3
 8006f64:	e7e6      	b.n	8006f34 <celt_decode_with_ec+0x100c>
   ALLOC(cap, nbEBands, int);
 8006f66:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   init_caps(mode,cap,LM,C);
 8006f68:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
   ALLOC(cap, nbEBands, int);
 8006f6c:	f023 0507 	bic.w	r5, r3, #7
 8006f70:	ebad 0d05 	sub.w	sp, sp, r5
 8006f74:	ab14      	add	r3, sp, #80	; 0x50
   init_caps(mode,cap,LM,C);
 8006f76:	4619      	mov	r1, r3
   ALLOC(cap, nbEBands, int);
 8006f78:	62bb      	str	r3, [r7, #40]	; 0x28
   init_caps(mode,cap,LM,C);
 8006f7a:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8006f7c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8006f80:	f7fe f882 	bl	8005088 <init_caps>
   total_bits<<=BITRES;
 8006f84:	6e3b      	ldr	r3, [r7, #96]	; 0x60
   ALLOC(offsets, nbEBands, int);
 8006f86:	ebad 0d05 	sub.w	sp, sp, r5
   tell = ec_tell_frac(dec);
 8006f8a:	4620      	mov	r0, r4
   total_bits<<=BITRES;
 8006f8c:	ea4f 09c3 	mov.w	r9, r3, lsl #3
   tell = ec_tell_frac(dec);
 8006f90:	f001 f996 	bl	80082c0 <ec_tell_frac>
   ALLOC(offsets, nbEBands, int);
 8006f94:	ab14      	add	r3, sp, #80	; 0x50
 8006f96:	62fb      	str	r3, [r7, #44]	; 0x2c
   spread_decision = SPREAD_NORMAL;
 8006f98:	2302      	movs	r3, #2
   total_bits<<=BITRES;
 8006f9a:	f8c7 9034 	str.w	r9, [r7, #52]	; 0x34
   spread_decision = SPREAD_NORMAL;
 8006f9e:	613b      	str	r3, [r7, #16]
 8006fa0:	f7ff ba0d 	b.w	80063be <celt_decode_with_ec+0x496>
 8006fa4:	08015074 	.word	0x08015074
 8006fa8:	0801506c 	.word	0x0801506c
 8006fac:	08015070 	.word	0x08015070

08006fb0 <opus_custom_decoder_ctl>:

#endif
#endif /* CUSTOM_MODES */

int opus_custom_decoder_ctl(CELTDecoder * OPUS_RESTRICT st, int request, ...)
{
 8006fb0:	b40e      	push	{r1, r2, r3}
   va_list ap;

   va_start(ap, request);
   switch (request)
 8006fb2:	f640 71cf 	movw	r1, #4047	; 0xfcf
{
 8006fb6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006fba:	b082      	sub	sp, #8
 8006fbc:	ab0b      	add	r3, sp, #44	; 0x2c
 8006fbe:	f853 2b04 	ldr.w	r2, [r3], #4
 8006fc2:	4604      	mov	r4, r0
   switch (request)
 8006fc4:	428a      	cmp	r2, r1
   va_start(ap, request);
 8006fc6:	9301      	str	r3, [sp, #4]
   switch (request)
 8006fc8:	f000 80f0 	beq.w	80071ac <opus_custom_decoder_ctl+0x1fc>
 8006fcc:	f5b2 6f7d 	cmp.w	r2, #4048	; 0xfd0
 8006fd0:	db18      	blt.n	8007004 <opus_custom_decoder_ctl+0x54>
 8006fd2:	f242 711a 	movw	r1, #10010	; 0x271a
 8006fd6:	428a      	cmp	r2, r1
 8006fd8:	f000 80c4 	beq.w	8007164 <opus_custom_decoder_ctl+0x1b4>
 8006fdc:	f340 80d5 	ble.w	800718a <opus_custom_decoder_ctl+0x1da>
 8006fe0:	f242 711f 	movw	r1, #10015	; 0x271f
 8006fe4:	428a      	cmp	r2, r1
 8006fe6:	f000 80c8 	beq.w	800717a <opus_custom_decoder_ctl+0x1ca>
 8006fea:	f242 7120 	movw	r1, #10016	; 0x2720
 8006fee:	428a      	cmp	r2, r1
 8006ff0:	f000 8107 	beq.w	8007202 <opus_custom_decoder_ctl+0x252>
 8006ff4:	f242 711c 	movw	r1, #10012	; 0x271c
 8006ff8:	428a      	cmp	r2, r1
 8006ffa:	f000 80f7 	beq.w	80071ec <opus_custom_decoder_ctl+0x23c>
bad_arg:
   va_end(ap);
   return OPUS_BAD_ARG;
bad_request:
      va_end(ap);
  return OPUS_UNIMPLEMENTED;
 8006ffe:	f06f 0004 	mvn.w	r0, #4
 8007002:	e018      	b.n	8007036 <opus_custom_decoder_ctl+0x86>
   switch (request)
 8007004:	f640 71bf 	movw	r1, #4031	; 0xfbf
 8007008:	428a      	cmp	r2, r1
 800700a:	f000 80e1 	beq.w	80071d0 <opus_custom_decoder_ctl+0x220>
 800700e:	f5b2 6f7c 	cmp.w	r2, #4032	; 0xfc0
 8007012:	db15      	blt.n	8007040 <opus_custom_decoder_ctl+0x90>
 8007014:	f640 71c1 	movw	r1, #4033	; 0xfc1
 8007018:	428a      	cmp	r2, r1
 800701a:	f000 80e0 	beq.w	80071de <opus_custom_decoder_ctl+0x22e>
 800701e:	f640 71ce 	movw	r1, #4046	; 0xfce
 8007022:	428a      	cmp	r2, r1
 8007024:	d1eb      	bne.n	8006ffe <opus_custom_decoder_ctl+0x4e>
          opus_int32 value = va_arg(ap, opus_int32);
 8007026:	681a      	ldr	r2, [r3, #0]
 8007028:	3304      	adds	r3, #4
          if(value<0 || value>1)
 800702a:	2a01      	cmp	r2, #1
          opus_int32 value = va_arg(ap, opus_int32);
 800702c:	9301      	str	r3, [sp, #4]
          if(value<0 || value>1)
 800702e:	f200 80f8 	bhi.w	8007222 <opus_custom_decoder_ctl+0x272>
          st->disable_inv = value;
 8007032:	6202      	str	r2, [r0, #32]
   return OPUS_OK;
 8007034:	2000      	movs	r0, #0
}
 8007036:	b002      	add	sp, #8
 8007038:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800703c:	b003      	add	sp, #12
 800703e:	4770      	bx	lr
   switch (request)
 8007040:	f640 71bb 	movw	r1, #4027	; 0xfbb
 8007044:	428a      	cmp	r2, r1
 8007046:	f000 80df 	beq.w	8007208 <opus_custom_decoder_ctl+0x258>
 800704a:	f640 73bc 	movw	r3, #4028	; 0xfbc
 800704e:	429a      	cmp	r2, r3
 8007050:	d1d5      	bne.n	8006ffe <opus_custom_decoder_ctl+0x4e>
         oldLogE = oldBandE + 2*st->mode->nbEBands;
 8007052:	4682      	mov	sl, r0
         lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+st->overlap)*st->channels);
 8007054:	6882      	ldr	r2, [r0, #8]
         oldLogE = oldBandE + 2*st->mode->nbEBands;
 8007056:	f85a 7b58 	ldr.w	r7, [sl], #88
         oldBandE = lpc+st->channels*LPC_ORDER;
 800705a:	eb02 0842 	add.w	r8, r2, r2, lsl #1
         oldLogE = oldBandE + 2*st->mode->nbEBands;
 800705e:	68bd      	ldr	r5, [r7, #8]
            + (channels*(DECODE_BUFFER_SIZE+mode->overlap)-1)*sizeof(celt_sig)
 8007060:	687b      	ldr	r3, [r7, #4]
            + channels*LPC_ORDER*sizeof(opus_val16)
 8007062:	ea4f 0988 	mov.w	r9, r8, lsl #2
         oldLogE = oldBandE + 2*st->mode->nbEBands;
 8007066:	00ae      	lsls	r6, r5, #2
            + 4*2*mode->nbEBands*sizeof(opus_val16);
 8007068:	f109 0016 	add.w	r0, r9, #22
 800706c:	4430      	add	r0, r6
            + (channels*(DECODE_BUFFER_SIZE+mode->overlap)-1)*sizeof(celt_sig)
 800706e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
            + 4*2*mode->nbEBands*sizeof(opus_val16);
 8007072:	fb02 0303 	mla	r3, r2, r3, r0
         lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+st->overlap)*st->channels);
 8007076:	6861      	ldr	r1, [r4, #4]
         OPUS_CLEAR((char*)&st->DECODER_RESET_START,
 8007078:	f104 0028 	add.w	r0, r4, #40	; 0x28
         lpc = (opus_val16*)(st->_decode_mem+(DECODE_BUFFER_SIZE+st->overlap)*st->channels);
 800707c:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8007080:	fb02 fb01 	mul.w	fp, r2, r1
            + 4*2*mode->nbEBands*sizeof(opus_val16);
 8007084:	009a      	lsls	r2, r3, #2
         OPUS_CLEAR((char*)&st->DECODER_RESET_START,
 8007086:	3a28      	subs	r2, #40	; 0x28
 8007088:	2100      	movs	r1, #0
 800708a:	f00d f84d 	bl	8014128 <memset>
         for (i=0;i<2*st->mode->nbEBands;i++)
 800708e:	68bf      	ldr	r7, [r7, #8]
         oldLogE = oldBandE + 2*st->mode->nbEBands;
 8007090:	eb06 1808 	add.w	r8, r6, r8, lsl #4
         for (i=0;i<2*st->mode->nbEBands;i++)
 8007094:	007f      	lsls	r7, r7, #1
         oldLogE = oldBandE + 2*st->mode->nbEBands;
 8007096:	eb08 088b 	add.w	r8, r8, fp, lsl #2
         for (i=0;i<2*st->mode->nbEBands;i++)
 800709a:	2f00      	cmp	r7, #0
         oldLogE = oldBandE + 2*st->mode->nbEBands;
 800709c:	eb0a 0c08 	add.w	ip, sl, r8
         for (i=0;i<2*st->mode->nbEBands;i++)
 80070a0:	dd5d      	ble.n	800715e <opus_custom_decoder_ctl+0x1ae>
 80070a2:	eb05 0209 	add.w	r2, r5, r9
 80070a6:	445a      	add	r2, fp
 80070a8:	f102 0116 	add.w	r1, r2, #22
 80070ac:	f105 0317 	add.w	r3, r5, #23
 80070b0:	0089      	lsls	r1, r1, #2
 80070b2:	4413      	add	r3, r2
 80070b4:	ebb1 0f83 	cmp.w	r1, r3, lsl #2
 80070b8:	bfac      	ite	ge
 80070ba:	2101      	movge	r1, #1
 80070bc:	2100      	movlt	r1, #0
 80070be:	f105 0316 	add.w	r3, r5, #22
 80070c2:	4413      	add	r3, r2
 80070c4:	009b      	lsls	r3, r3, #2
 80070c6:	f102 0017 	add.w	r0, r2, #23
 80070ca:	ebb3 0f80 	cmp.w	r3, r0, lsl #2
 80070ce:	bfa8      	it	ge
 80070d0:	f041 0101 	orrge.w	r1, r1, #1
 80070d4:	2900      	cmp	r1, #0
 80070d6:	f000 80a7 	beq.w	8007228 <opus_custom_decoder_ctl+0x278>
 80070da:	2f0f      	cmp	r7, #15
 80070dc:	f240 80a4 	bls.w	8007228 <opus_custom_decoder_ctl+0x278>
 80070e0:	f3c4 0940 	ubfx	r9, r4, #1, #1
 80070e4:	f1b9 0f00 	cmp.w	r9, #0
 80070e8:	f000 8098 	beq.w	800721c <opus_custom_decoder_ctl+0x26c>
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
 80070ec:	f44f 4310 	mov.w	r3, #36864	; 0x9000
         for (i=0;i<2*st->mode->nbEBands;i++)
 80070f0:	f04f 0e01 	mov.w	lr, #1
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
 80070f4:	f82c 3025 	strh.w	r3, [ip, r5, lsl #2]
 80070f8:	f82a 3008 	strh.w	r3, [sl, r8]
         for (i=0;i<2*st->mode->nbEBands;i++)
 80070fc:	2100      	movs	r1, #0
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
 80070fe:	f04f 2090 	mov.w	r0, #2415955968	; 0x90009000
 8007102:	18ab      	adds	r3, r5, r2
 8007104:	eb09 0343 	add.w	r3, r9, r3, lsl #1
 8007108:	eb09 0242 	add.w	r2, r9, r2, lsl #1
 800710c:	332c      	adds	r3, #44	; 0x2c
 800710e:	322c      	adds	r2, #44	; 0x2c
 8007110:	eba7 0909 	sub.w	r9, r7, r9
 8007114:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 8007118:	eb04 0242 	add.w	r2, r4, r2, lsl #1
 800711c:	ea4f 0559 	mov.w	r5, r9, lsr #1
 8007120:	3101      	adds	r1, #1
 8007122:	428d      	cmp	r5, r1
 8007124:	f843 0b04 	str.w	r0, [r3], #4
 8007128:	f842 0b04 	str.w	r0, [r2], #4
 800712c:	d8f8      	bhi.n	8007120 <opus_custom_decoder_ctl+0x170>
 800712e:	f029 0301 	bic.w	r3, r9, #1
 8007132:	4599      	cmp	r9, r3
 8007134:	449e      	add	lr, r3
 8007136:	d012      	beq.n	800715e <opus_custom_decoder_ctl+0x1ae>
 8007138:	f44f 4310 	mov.w	r3, #36864	; 0x9000
         for (i=0;i<2*st->mode->nbEBands;i++)
 800713c:	f10e 0201 	add.w	r2, lr, #1
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
 8007140:	4466      	add	r6, ip
         for (i=0;i<2*st->mode->nbEBands;i++)
 8007142:	4297      	cmp	r7, r2
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
 8007144:	f826 301e 	strh.w	r3, [r6, lr, lsl #1]
 8007148:	f82c 301e 	strh.w	r3, [ip, lr, lsl #1]
 800714c:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
         for (i=0;i<2*st->mode->nbEBands;i++)
 8007150:	dd05      	ble.n	800715e <opus_custom_decoder_ctl+0x1ae>
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
 8007152:	f10e 0e02 	add.w	lr, lr, #2
 8007156:	f826 300e 	strh.w	r3, [r6, lr]
 800715a:	f82c 300e 	strh.w	r3, [ip, lr]
         st->skip_plc = 1;
 800715e:	2301      	movs	r3, #1
 8007160:	63a3      	str	r3, [r4, #56]	; 0x38
      break;
 8007162:	e767      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
         opus_int32 value = va_arg(ap, opus_int32);
 8007164:	681a      	ldr	r2, [r3, #0]
 8007166:	3304      	adds	r3, #4
         if (value<0 || value>=st->mode->nbEBands)
 8007168:	2a00      	cmp	r2, #0
         opus_int32 value = va_arg(ap, opus_int32);
 800716a:	9301      	str	r3, [sp, #4]
         if (value<0 || value>=st->mode->nbEBands)
 800716c:	db59      	blt.n	8007222 <opus_custom_decoder_ctl+0x272>
 800716e:	6803      	ldr	r3, [r0, #0]
 8007170:	689b      	ldr	r3, [r3, #8]
 8007172:	4293      	cmp	r3, r2
 8007174:	dd55      	ble.n	8007222 <opus_custom_decoder_ctl+0x272>
         st->start = value;
 8007176:	6142      	str	r2, [r0, #20]
      break;
 8007178:	e75c      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
         const CELTMode ** value = va_arg(ap, const CELTMode**);
 800717a:	681a      	ldr	r2, [r3, #0]
 800717c:	3304      	adds	r3, #4
 800717e:	9301      	str	r3, [sp, #4]
         if (value==0)
 8007180:	2a00      	cmp	r2, #0
 8007182:	d04e      	beq.n	8007222 <opus_custom_decoder_ctl+0x272>
         *value=st->mode;
 8007184:	6803      	ldr	r3, [r0, #0]
 8007186:	6013      	str	r3, [r2, #0]
      break;
 8007188:	e754      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
   switch (request)
 800718a:	f242 7117 	movw	r1, #10007	; 0x2717
 800718e:	428a      	cmp	r2, r1
 8007190:	d014      	beq.n	80071bc <opus_custom_decoder_ctl+0x20c>
 8007192:	f242 7118 	movw	r1, #10008	; 0x2718
 8007196:	428a      	cmp	r2, r1
 8007198:	f47f af31 	bne.w	8006ffe <opus_custom_decoder_ctl+0x4e>
         opus_int32 value = va_arg(ap, opus_int32);
 800719c:	681a      	ldr	r2, [r3, #0]
 800719e:	3304      	adds	r3, #4
         if (value<1 || value>2)
 80071a0:	1e51      	subs	r1, r2, #1
 80071a2:	2901      	cmp	r1, #1
         opus_int32 value = va_arg(ap, opus_int32);
 80071a4:	9301      	str	r3, [sp, #4]
         if (value<1 || value>2)
 80071a6:	d83c      	bhi.n	8007222 <opus_custom_decoder_ctl+0x272>
         st->stream_channels = value;
 80071a8:	60c2      	str	r2, [r0, #12]
      break;
 80071aa:	e743      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
          opus_int32 *value = va_arg(ap, opus_int32*);
 80071ac:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80071ae:	3304      	adds	r3, #4
 80071b0:	9301      	str	r3, [sp, #4]
          if (!value)
 80071b2:	2a00      	cmp	r2, #0
 80071b4:	d035      	beq.n	8007222 <opus_custom_decoder_ctl+0x272>
          *value = st->disable_inv;
 80071b6:	6a03      	ldr	r3, [r0, #32]
 80071b8:	6013      	str	r3, [r2, #0]
      break;
 80071ba:	e73b      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
         opus_int32 *value = va_arg(ap, opus_int32*);
 80071bc:	681a      	ldr	r2, [r3, #0]
 80071be:	3304      	adds	r3, #4
 80071c0:	9301      	str	r3, [sp, #4]
         if (value==NULL)
 80071c2:	2a00      	cmp	r2, #0
 80071c4:	d02d      	beq.n	8007222 <opus_custom_decoder_ctl+0x272>
         st->error = 0;
 80071c6:	2100      	movs	r1, #0
         *value=st->error;
 80071c8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
         st->error = 0;
 80071ca:	62c1      	str	r1, [r0, #44]	; 0x2c
         *value=st->error;
 80071cc:	6013      	str	r3, [r2, #0]
      break;
 80071ce:	e731      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
         opus_uint32 * value = va_arg(ap, opus_uint32 *);
 80071d0:	681a      	ldr	r2, [r3, #0]
 80071d2:	3304      	adds	r3, #4
 80071d4:	9301      	str	r3, [sp, #4]
         if (value==0)
 80071d6:	b322      	cbz	r2, 8007222 <opus_custom_decoder_ctl+0x272>
         *value=st->rng;
 80071d8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80071da:	6013      	str	r3, [r2, #0]
      break;
 80071dc:	e72a      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
         opus_int32 *value = va_arg(ap, opus_int32*);
 80071de:	681a      	ldr	r2, [r3, #0]
 80071e0:	3304      	adds	r3, #4
 80071e2:	9301      	str	r3, [sp, #4]
         if (value==NULL)
 80071e4:	b1ea      	cbz	r2, 8007222 <opus_custom_decoder_ctl+0x272>
         *value = st->postfilter_period;
 80071e6:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 80071e8:	6013      	str	r3, [r2, #0]
      break;
 80071ea:	e723      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
         opus_int32 value = va_arg(ap, opus_int32);
 80071ec:	681a      	ldr	r2, [r3, #0]
 80071ee:	3304      	adds	r3, #4
         if (value<1 || value>st->mode->nbEBands)
 80071f0:	2a00      	cmp	r2, #0
         opus_int32 value = va_arg(ap, opus_int32);
 80071f2:	9301      	str	r3, [sp, #4]
         if (value<1 || value>st->mode->nbEBands)
 80071f4:	dd15      	ble.n	8007222 <opus_custom_decoder_ctl+0x272>
 80071f6:	6803      	ldr	r3, [r0, #0]
 80071f8:	689b      	ldr	r3, [r3, #8]
 80071fa:	4293      	cmp	r3, r2
 80071fc:	db11      	blt.n	8007222 <opus_custom_decoder_ctl+0x272>
         st->end = value;
 80071fe:	6182      	str	r2, [r0, #24]
      break;
 8007200:	e718      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
         opus_int32 value = va_arg(ap, opus_int32);
 8007202:	681b      	ldr	r3, [r3, #0]
         st->signalling = value;
 8007204:	61c3      	str	r3, [r0, #28]
      break;
 8007206:	e715      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
         opus_int32 *value = va_arg(ap, opus_int32*);
 8007208:	681a      	ldr	r2, [r3, #0]
 800720a:	3304      	adds	r3, #4
 800720c:	9301      	str	r3, [sp, #4]
         if (value==NULL)
 800720e:	b142      	cbz	r2, 8007222 <opus_custom_decoder_ctl+0x272>
         *value = st->overlap/st->downsample;
 8007210:	6843      	ldr	r3, [r0, #4]
 8007212:	6901      	ldr	r1, [r0, #16]
 8007214:	fb93 f3f1 	sdiv	r3, r3, r1
 8007218:	6013      	str	r3, [r2, #0]
      break;
 800721a:	e70b      	b.n	8007034 <opus_custom_decoder_ctl+0x84>
         for (i=0;i<2*st->mode->nbEBands;i++)
 800721c:	f04f 0e00 	mov.w	lr, #0
 8007220:	e76c      	b.n	80070fc <opus_custom_decoder_ctl+0x14c>
   return OPUS_BAD_ARG;
 8007222:	f04f 30ff 	mov.w	r0, #4294967295
 8007226:	e706      	b.n	8007036 <opus_custom_decoder_ctl+0x86>
            oldLogE[i]=oldLogE2[i]=-QCONST16(28.f,DB_SHIFT);
 8007228:	f44f 4110 	mov.w	r1, #36864	; 0x9000
 800722c:	eb0c 0247 	add.w	r2, ip, r7, lsl #1
 8007230:	1eb3      	subs	r3, r6, #2
 8007232:	4463      	add	r3, ip
 8007234:	3a02      	subs	r2, #2
 8007236:	f1ac 0c02 	sub.w	ip, ip, #2
 800723a:	f823 1f02 	strh.w	r1, [r3, #2]!
 800723e:	f82c 1f02 	strh.w	r1, [ip, #2]!
         for (i=0;i<2*st->mode->nbEBands;i++)
 8007242:	4594      	cmp	ip, r2
 8007244:	d1f9      	bne.n	800723a <opus_custom_decoder_ctl+0x28a>
 8007246:	e78a      	b.n	800715e <opus_custom_decoder_ctl+0x1ae>

08007248 <_celt_lpc>:
void _celt_lpc(
      opus_val16       *_lpc, /* out: [0...p-1] LPC coefficients      */
const opus_val32 *ac,  /* in:  [0...p] autocorrelation values  */
int          p
)
{
 8007248:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   int i, j;
   opus_val32 r;
   opus_val32 error = ac[0];
 800724c:	f8d1 a000 	ldr.w	sl, [r1]
{
 8007250:	b09f      	sub	sp, #124	; 0x7c
 8007252:	460d      	mov	r5, r1
 8007254:	9104      	str	r1, [sp, #16]
 8007256:	4614      	mov	r4, r2
 8007258:	9203      	str	r2, [sp, #12]
 800725a:	9005      	str	r0, [sp, #20]
   opus_val32 lpc[LPC_ORDER];
#else
   float *lpc = _lpc;
#endif

   OPUS_CLEAR(lpc, p);
 800725c:	0092      	lsls	r2, r2, #2
 800725e:	a806      	add	r0, sp, #24
 8007260:	2100      	movs	r1, #0
 8007262:	f00c ff61 	bl	8014128 <memset>
   if (ac[0] != 0)
 8007266:	f1ba 0f00 	cmp.w	sl, #0
 800726a:	f000 8179 	beq.w	8007560 <_celt_lpc+0x318>
   {
      for (i = 0; i < p; i++) {
 800726e:	2c00      	cmp	r4, #0
 8007270:	f340 8179 	ble.w	8007566 <_celt_lpc+0x31e>
 8007274:	f04f 0b00 	mov.w	fp, #0
 8007278:	3504      	adds	r5, #4
         /* Sum up this iteration's reflection coefficient */
         opus_val32 rr = 0;
 800727a:	4658      	mov	r0, fp
 800727c:	462a      	mov	r2, r5
      for (i = 0; i < p; i++) {
 800727e:	ac06      	add	r4, sp, #24
         for (j = 0; j < i; j++)
            rr += MULT32_32_Q31(lpc[j],ac[i - j]);
         rr += SHR32(ac[i + 1],3);
 8007280:	f852 3b04 	ldr.w	r3, [r2], #4
         r = -frac_div32(SHL32(rr,3), error);
 8007284:	4651      	mov	r1, sl
         rr += SHR32(ac[i + 1],3);
 8007286:	eb00 00e3 	add.w	r0, r0, r3, asr #3
         r = -frac_div32(SHL32(rr,3), error);
 800728a:	00c0      	lsls	r0, r0, #3
         rr += SHR32(ac[i + 1],3);
 800728c:	9200      	str	r2, [sp, #0]
         r = -frac_div32(SHL32(rr,3), error);
 800728e:	f002 fa73 	bl	8009778 <frac_div32>
 8007292:	4240      	negs	r0, r0
         /*  Update LPC coefficients and total error */
         lpc[i] = SHR32(r,3);
 8007294:	10c3      	asrs	r3, r0, #3
         for (j = 0; j < (i+1)>>1; j++)
 8007296:	f10b 0b01 	add.w	fp, fp, #1
         lpc[i] = SHR32(r,3);
 800729a:	f844 3b04 	str.w	r3, [r4], #4
         for (j = 0; j < (i+1)>>1; j++)
 800729e:	ea5f 036b 	movs.w	r3, fp, asr #1
 80072a2:	9a00      	ldr	r2, [sp, #0]
 80072a4:	f000 8136 	beq.w	8007514 <_celt_lpc+0x2cc>
         {
            opus_val32 tmp1, tmp2;
            tmp1 = lpc[j];
            tmp2 = lpc[i-1-j];
 80072a8:	f854 1c08 	ldr.w	r1, [r4, #-8]
            tmp1 = lpc[j];
 80072ac:	f8dd c018 	ldr.w	ip, [sp, #24]
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80072b0:	fb81 6700 	smull	r6, r7, r1, r0
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80072b4:	fb8c 8900 	smull	r8, r9, ip, r0
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80072b8:	e9cd 6700 	strd	r6, r7, [sp]
 80072bc:	9f01      	ldr	r7, [sp, #4]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80072be:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80072c2:	0ff6      	lsrs	r6, r6, #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80072c4:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80072c8:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80072cc:	4471      	add	r1, lr
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80072ce:	4466      	add	r6, ip
         for (j = 0; j < (i+1)>>1; j++)
 80072d0:	2b01      	cmp	r3, #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80072d2:	9606      	str	r6, [sp, #24]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80072d4:	f844 1c08 	str.w	r1, [r4, #-8]
         for (j = 0; j < (i+1)>>1; j++)
 80072d8:	f000 811c 	beq.w	8007514 <_celt_lpc+0x2cc>
            tmp2 = lpc[i-1-j];
 80072dc:	f854 1c0c 	ldr.w	r1, [r4, #-12]
            tmp1 = lpc[j];
 80072e0:	f8dd c01c 	ldr.w	ip, [sp, #28]
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80072e4:	fb81 6700 	smull	r6, r7, r1, r0
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80072e8:	fb8c 8900 	smull	r8, r9, ip, r0
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80072ec:	e9cd 6700 	strd	r6, r7, [sp]
 80072f0:	9f01      	ldr	r7, [sp, #4]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80072f2:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80072f6:	0ff6      	lsrs	r6, r6, #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80072f8:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80072fc:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007300:	4471      	add	r1, lr
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007302:	4466      	add	r6, ip
         for (j = 0; j < (i+1)>>1; j++)
 8007304:	2b02      	cmp	r3, #2
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007306:	9607      	str	r6, [sp, #28]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007308:	f844 1c0c 	str.w	r1, [r4, #-12]
         for (j = 0; j < (i+1)>>1; j++)
 800730c:	f000 8102 	beq.w	8007514 <_celt_lpc+0x2cc>
            tmp2 = lpc[i-1-j];
 8007310:	f854 1c10 	ldr.w	r1, [r4, #-16]
            tmp1 = lpc[j];
 8007314:	f8dd c020 	ldr.w	ip, [sp, #32]
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007318:	fb81 6700 	smull	r6, r7, r1, r0
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 800731c:	fb8c 8900 	smull	r8, r9, ip, r0
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007320:	e9cd 6700 	strd	r6, r7, [sp]
 8007324:	9f01      	ldr	r7, [sp, #4]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007326:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 800732a:	0ff6      	lsrs	r6, r6, #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 800732c:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007330:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007334:	4471      	add	r1, lr
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007336:	4466      	add	r6, ip
         for (j = 0; j < (i+1)>>1; j++)
 8007338:	2b03      	cmp	r3, #3
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 800733a:	9608      	str	r6, [sp, #32]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 800733c:	f844 1c10 	str.w	r1, [r4, #-16]
         for (j = 0; j < (i+1)>>1; j++)
 8007340:	f000 80e8 	beq.w	8007514 <_celt_lpc+0x2cc>
            tmp2 = lpc[i-1-j];
 8007344:	f854 1c14 	ldr.w	r1, [r4, #-20]
            tmp1 = lpc[j];
 8007348:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 800734c:	fb81 6700 	smull	r6, r7, r1, r0
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007350:	fb8c 8900 	smull	r8, r9, ip, r0
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007354:	e9cd 6700 	strd	r6, r7, [sp]
 8007358:	9f01      	ldr	r7, [sp, #4]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 800735a:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 800735e:	0ff6      	lsrs	r6, r6, #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007360:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007364:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007368:	4471      	add	r1, lr
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 800736a:	4466      	add	r6, ip
         for (j = 0; j < (i+1)>>1; j++)
 800736c:	2b04      	cmp	r3, #4
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 800736e:	9609      	str	r6, [sp, #36]	; 0x24
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007370:	f844 1c14 	str.w	r1, [r4, #-20]
         for (j = 0; j < (i+1)>>1; j++)
 8007374:	f000 80ce 	beq.w	8007514 <_celt_lpc+0x2cc>
            tmp1 = lpc[j];
 8007378:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
            tmp2 = lpc[i-1-j];
 800737c:	f854 1c18 	ldr.w	r1, [r4, #-24]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007380:	fb8c 6700 	smull	r6, r7, ip, r0
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007384:	fb81 8900 	smull	r8, r9, r1, r0
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007388:	e9cd 6700 	strd	r6, r7, [sp]
 800738c:	9f01      	ldr	r7, [sp, #4]
 800738e:	0ff6      	lsrs	r6, r6, #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007390:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007394:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007398:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 800739c:	4431      	add	r1, r6
         for (j = 0; j < (i+1)>>1; j++)
 800739e:	2b05      	cmp	r3, #5
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80073a0:	eb0c 060e 	add.w	r6, ip, lr
 80073a4:	960a      	str	r6, [sp, #40]	; 0x28
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80073a6:	f844 1c18 	str.w	r1, [r4, #-24]
         for (j = 0; j < (i+1)>>1; j++)
 80073aa:	f000 80b3 	beq.w	8007514 <_celt_lpc+0x2cc>
            tmp1 = lpc[j];
 80073ae:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
            tmp2 = lpc[i-1-j];
 80073b2:	f854 1c1c 	ldr.w	r1, [r4, #-28]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80073b6:	fb8c 6700 	smull	r6, r7, ip, r0
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80073ba:	fb81 8900 	smull	r8, r9, r1, r0
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80073be:	e9cd 6700 	strd	r6, r7, [sp]
 80073c2:	9f01      	ldr	r7, [sp, #4]
 80073c4:	0ff6      	lsrs	r6, r6, #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80073c6:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80073ca:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80073ce:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80073d2:	4431      	add	r1, r6
         for (j = 0; j < (i+1)>>1; j++)
 80073d4:	2b06      	cmp	r3, #6
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80073d6:	eb0c 060e 	add.w	r6, ip, lr
 80073da:	960b      	str	r6, [sp, #44]	; 0x2c
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80073dc:	f844 1c1c 	str.w	r1, [r4, #-28]
         for (j = 0; j < (i+1)>>1; j++)
 80073e0:	f000 8098 	beq.w	8007514 <_celt_lpc+0x2cc>
            tmp1 = lpc[j];
 80073e4:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
            tmp2 = lpc[i-1-j];
 80073e8:	f854 1c20 	ldr.w	r1, [r4, #-32]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80073ec:	fb8c 6700 	smull	r6, r7, ip, r0
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80073f0:	fb81 8900 	smull	r8, r9, r1, r0
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80073f4:	e9cd 6700 	strd	r6, r7, [sp]
 80073f8:	9f01      	ldr	r7, [sp, #4]
 80073fa:	0ff6      	lsrs	r6, r6, #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80073fc:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007400:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007404:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007408:	4431      	add	r1, r6
         for (j = 0; j < (i+1)>>1; j++)
 800740a:	2b07      	cmp	r3, #7
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 800740c:	eb0c 060e 	add.w	r6, ip, lr
 8007410:	960c      	str	r6, [sp, #48]	; 0x30
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007412:	f844 1c20 	str.w	r1, [r4, #-32]
         for (j = 0; j < (i+1)>>1; j++)
 8007416:	d07d      	beq.n	8007514 <_celt_lpc+0x2cc>
            tmp1 = lpc[j];
 8007418:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
            tmp2 = lpc[i-1-j];
 800741c:	f854 1c24 	ldr.w	r1, [r4, #-36]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007420:	fb8c 6700 	smull	r6, r7, ip, r0
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007424:	fb81 8900 	smull	r8, r9, r1, r0
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007428:	e9cd 6700 	strd	r6, r7, [sp]
 800742c:	9f01      	ldr	r7, [sp, #4]
 800742e:	0ff6      	lsrs	r6, r6, #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007430:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007434:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007438:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 800743c:	4431      	add	r1, r6
         for (j = 0; j < (i+1)>>1; j++)
 800743e:	2b08      	cmp	r3, #8
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007440:	eb0c 060e 	add.w	r6, ip, lr
 8007444:	960d      	str	r6, [sp, #52]	; 0x34
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007446:	f844 1c24 	str.w	r1, [r4, #-36]
         for (j = 0; j < (i+1)>>1; j++)
 800744a:	d063      	beq.n	8007514 <_celt_lpc+0x2cc>
            tmp1 = lpc[j];
 800744c:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
            tmp2 = lpc[i-1-j];
 8007450:	f854 1c28 	ldr.w	r1, [r4, #-40]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007454:	fb80 670c 	smull	r6, r7, r0, ip
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007458:	fb80 8901 	smull	r8, r9, r0, r1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 800745c:	e9cd 6700 	strd	r6, r7, [sp]
 8007460:	9f01      	ldr	r7, [sp, #4]
 8007462:	0ff6      	lsrs	r6, r6, #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007464:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007468:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 800746c:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007470:	4431      	add	r1, r6
         for (j = 0; j < (i+1)>>1; j++)
 8007472:	2b09      	cmp	r3, #9
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007474:	eb0c 060e 	add.w	r6, ip, lr
 8007478:	960e      	str	r6, [sp, #56]	; 0x38
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 800747a:	f844 1c28 	str.w	r1, [r4, #-40]
         for (j = 0; j < (i+1)>>1; j++)
 800747e:	d049      	beq.n	8007514 <_celt_lpc+0x2cc>
            tmp1 = lpc[j];
 8007480:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
            tmp2 = lpc[i-1-j];
 8007484:	f854 1c2c 	ldr.w	r1, [r4, #-44]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007488:	fb80 670c 	smull	r6, r7, r0, ip
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 800748c:	fb80 8901 	smull	r8, r9, r0, r1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007490:	e9cd 6700 	strd	r6, r7, [sp]
 8007494:	9f01      	ldr	r7, [sp, #4]
 8007496:	0ff6      	lsrs	r6, r6, #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007498:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 800749c:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80074a0:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80074a4:	4431      	add	r1, r6
         for (j = 0; j < (i+1)>>1; j++)
 80074a6:	2b0a      	cmp	r3, #10
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80074a8:	eb0c 060e 	add.w	r6, ip, lr
 80074ac:	960f      	str	r6, [sp, #60]	; 0x3c
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80074ae:	f844 1c2c 	str.w	r1, [r4, #-44]
         for (j = 0; j < (i+1)>>1; j++)
 80074b2:	d02f      	beq.n	8007514 <_celt_lpc+0x2cc>
            tmp1 = lpc[j];
 80074b4:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
            tmp2 = lpc[i-1-j];
 80074b8:	f854 1c30 	ldr.w	r1, [r4, #-48]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80074bc:	fb80 670c 	smull	r6, r7, r0, ip
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80074c0:	fb80 8901 	smull	r8, r9, r0, r1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80074c4:	e9cd 6700 	strd	r6, r7, [sp]
 80074c8:	9f01      	ldr	r7, [sp, #4]
 80074ca:	0ff6      	lsrs	r6, r6, #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80074cc:	ea4f 7ed8 	mov.w	lr, r8, lsr #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80074d0:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80074d4:	ea4e 0e49 	orr.w	lr, lr, r9, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80074d8:	4431      	add	r1, r6
         for (j = 0; j < (i+1)>>1; j++)
 80074da:	2b0c      	cmp	r3, #12
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80074dc:	eb0c 060e 	add.w	r6, ip, lr
 80074e0:	9610      	str	r6, [sp, #64]	; 0x40
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80074e2:	f844 1c30 	str.w	r1, [r4, #-48]
         for (j = 0; j < (i+1)>>1; j++)
 80074e6:	d115      	bne.n	8007514 <_celt_lpc+0x2cc>
            tmp1 = lpc[j];
 80074e8:	9911      	ldr	r1, [sp, #68]	; 0x44
            tmp2 = lpc[i-1-j];
 80074ea:	f854 3c34 	ldr.w	r3, [r4, #-52]
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80074ee:	fb81 6700 	smull	r6, r7, r1, r0
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80074f2:	fb83 8900 	smull	r8, r9, r3, r0
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 80074f6:	e9cd 6700 	strd	r6, r7, [sp]
 80074fa:	9f01      	ldr	r7, [sp, #4]
 80074fc:	0ff6      	lsrs	r6, r6, #31
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 80074fe:	ea4f 7cd8 	mov.w	ip, r8, lsr #31
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007502:	ea46 0647 	orr.w	r6, r6, r7, lsl #1
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 8007506:	ea4c 0c49 	orr.w	ip, ip, r9, lsl #1
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 800750a:	4433      	add	r3, r6
            lpc[j]     = tmp1 + MULT32_32_Q31(r,tmp2);
 800750c:	4461      	add	r1, ip
 800750e:	9111      	str	r1, [sp, #68]	; 0x44
            lpc[i-1-j] = tmp2 + MULT32_32_Q31(r,tmp1);
 8007510:	f844 3c34 	str.w	r3, [r4, #-52]
         }

         error = error - MULT32_32_Q31(MULT32_32_Q31(r,r),error);
 8007514:	fb80 6700 	smull	r6, r7, r0, r0
 8007518:	0ff0      	lsrs	r0, r6, #31
 800751a:	ea40 0047 	orr.w	r0, r0, r7, lsl #1
 800751e:	fb8a 0100 	smull	r0, r1, sl, r0
 8007522:	0fc3      	lsrs	r3, r0, #31
 8007524:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
         /* Bail out once we get 30 dB gain */
#ifdef FIXED_POINT
         if (error<SHR32(ac[0],10))
 8007528:	9904      	ldr	r1, [sp, #16]
         error = error - MULT32_32_Q31(MULT32_32_Q31(r,r),error);
 800752a:	ebaa 0a03 	sub.w	sl, sl, r3
         if (error<SHR32(ac[0],10))
 800752e:	6809      	ldr	r1, [r1, #0]
 8007530:	ebba 2fa1 	cmp.w	sl, r1, asr #10
 8007534:	db1a      	blt.n	800756c <_celt_lpc+0x324>
      for (i = 0; i < p; i++) {
 8007536:	9b03      	ldr	r3, [sp, #12]
 8007538:	455b      	cmp	r3, fp
 800753a:	d017      	beq.n	800756c <_celt_lpc+0x324>
 800753c:	4611      	mov	r1, r2
         opus_val32 rr = 0;
 800753e:	2000      	movs	r0, #0
      for (i = 0; i < p; i++) {
 8007540:	f10d 0c18 	add.w	ip, sp, #24
            rr += MULT32_32_Q31(lpc[j],ac[i - j]);
 8007544:	f851 3d04 	ldr.w	r3, [r1, #-4]!
 8007548:	f85c 6b04 	ldr.w	r6, [ip], #4
         for (j = 0; j < i; j++)
 800754c:	42a9      	cmp	r1, r5
            rr += MULT32_32_Q31(lpc[j],ac[i - j]);
 800754e:	fb86 6703 	smull	r6, r7, r6, r3
 8007552:	ea4f 73d6 	mov.w	r3, r6, lsr #31
 8007556:	ea43 0347 	orr.w	r3, r3, r7, lsl #1
 800755a:	4418      	add	r0, r3
         for (j = 0; j < i; j++)
 800755c:	d1f2      	bne.n	8007544 <_celt_lpc+0x2fc>
 800755e:	e68f      	b.n	8007280 <_celt_lpc+0x38>
            break;
#endif
      }
   }
#ifdef FIXED_POINT
   for (i=0;i<p;i++)
 8007560:	9b03      	ldr	r3, [sp, #12]
 8007562:	2b00      	cmp	r3, #0
 8007564:	dc02      	bgt.n	800756c <_celt_lpc+0x324>
      _lpc[i] = ROUND16(lpc[i],16);
#endif
}
 8007566:	b01f      	add	sp, #124	; 0x7c
 8007568:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
         opus_val32 rr = 0;
 800756c:	2100      	movs	r1, #0
 800756e:	9b05      	ldr	r3, [sp, #20]
 8007570:	9c03      	ldr	r4, [sp, #12]
 8007572:	aa06      	add	r2, sp, #24
 8007574:	1e98      	subs	r0, r3, #2
      _lpc[i] = ROUND16(lpc[i],16);
 8007576:	f852 3b04 	ldr.w	r3, [r2], #4
   for (i=0;i<p;i++)
 800757a:	3101      	adds	r1, #1
      _lpc[i] = ROUND16(lpc[i],16);
 800757c:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 8007580:	141b      	asrs	r3, r3, #16
   for (i=0;i<p;i++)
 8007582:	428c      	cmp	r4, r1
      _lpc[i] = ROUND16(lpc[i],16);
 8007584:	f820 3f02 	strh.w	r3, [r0, #2]!
   for (i=0;i<p;i++)
 8007588:	dcf5      	bgt.n	8007576 <_celt_lpc+0x32e>
}
 800758a:	b01f      	add	sp, #124	; 0x7c
 800758c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08007590 <celt_fir_c>:
         const opus_val16 *num,
         opus_val16 *y,
         int N,
         int ord,
         int arch)
{
 8007590:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007594:	b093      	sub	sp, #76	; 0x4c
 8007596:	af00      	add	r7, sp, #0
 8007598:	6138      	str	r0, [r7, #16]
   int i,j;
   VARDECL(opus_val16, rnum);
   SAVE_STACK;
   celt_assert(x != y);
   ALLOC(rnum, ord, opus_val16);
 800759a:	6f38      	ldr	r0, [r7, #112]	; 0x70
{
 800759c:	e9c7 2302 	strd	r2, r3, [r7, #8]
   ALLOC(rnum, ord, opus_val16);
 80075a0:	0044      	lsls	r4, r0, #1
 80075a2:	4620      	mov	r0, r4
 80075a4:	3008      	adds	r0, #8
 80075a6:	f020 0007 	bic.w	r0, r0, #7
 80075aa:	ebad 0d00 	sub.w	sp, sp, r0
 80075ae:	466a      	mov	r2, sp
   for(i=0;i<ord;i++)
 80075b0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
   ALLOC(rnum, ord, opus_val16);
 80075b2:	603c      	str	r4, [r7, #0]
   for(i=0;i<ord;i++)
 80075b4:	2b00      	cmp	r3, #0
   ALLOC(rnum, ord, opus_val16);
 80075b6:	637a      	str	r2, [r7, #52]	; 0x34
   for(i=0;i<ord;i++)
 80075b8:	dd07      	ble.n	80075ca <celt_fir_c+0x3a>
 80075ba:	190b      	adds	r3, r1, r4
 80075bc:	3a02      	subs	r2, #2
      rnum[i] = num[ord-i-1];
 80075be:	f833 0d02 	ldrh.w	r0, [r3, #-2]!
   for(i=0;i<ord;i++)
 80075c2:	4299      	cmp	r1, r3
      rnum[i] = num[ord-i-1];
 80075c4:	f822 0f02 	strh.w	r0, [r2, #2]!
   for(i=0;i<ord;i++)
 80075c8:	d1f9      	bne.n	80075be <celt_fir_c+0x2e>
   for (i=0;i<N-3;i+=4)
 80075ca:	68fb      	ldr	r3, [r7, #12]
 80075cc:	2b03      	cmp	r3, #3
 80075ce:	f340 8130 	ble.w	8007832 <celt_fir_c+0x2a2>
 80075d2:	68ba      	ldr	r2, [r7, #8]
 80075d4:	6b7d      	ldr	r5, [r7, #52]	; 0x34
 80075d6:	643a      	str	r2, [r7, #64]	; 0x40
 80075d8:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80075da:	f8d7 c010 	ldr.w	ip, [r7, #16]
 80075de:	1f10      	subs	r0, r2, #4
 80075e0:	0880      	lsrs	r0, r0, #2
 80075e2:	1c41      	adds	r1, r0, #1
 80075e4:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
 80075e8:	3010      	adds	r0, #16
 80075ea:	62b8      	str	r0, [r7, #40]	; 0x28
 80075ec:	4660      	mov	r0, ip
 80075ee:	3b04      	subs	r3, #4
 80075f0:	089b      	lsrs	r3, r3, #2
 80075f2:	ebc2 72c2 	rsb	r2, r2, r2, lsl #31
 80075f6:	0052      	lsls	r2, r2, #1
 80075f8:	607b      	str	r3, [r7, #4]
 80075fa:	4663      	mov	r3, ip
 80075fc:	008c      	lsls	r4, r1, #2
 80075fe:	00ce      	lsls	r6, r1, #3
 8007600:	1d91      	adds	r1, r2, #6
 8007602:	1841      	adds	r1, r0, r1
 8007604:	46e3      	mov	fp, ip
 8007606:	468a      	mov	sl, r1
 8007608:	f102 000e 	add.w	r0, r2, #14
 800760c:	687a      	ldr	r2, [r7, #4]
 800760e:	4435      	add	r5, r6
 8007610:	3308      	adds	r3, #8
 8007612:	61bc      	str	r4, [r7, #24]
 8007614:	62fd      	str	r5, [r7, #44]	; 0x2c
 8007616:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800761a:	1c65      	adds	r5, r4, #1
 800761c:	3402      	adds	r4, #2
 800761e:	61fe      	str	r6, [r7, #28]
 8007620:	627d      	str	r5, [r7, #36]	; 0x24
 8007622:	623c      	str	r4, [r7, #32]
 8007624:	6178      	str	r0, [r7, #20]
 8007626:	633b      	str	r3, [r7, #48]	; 0x30
   for (j=0;j<len-3;j+=4)
 8007628:	6f38      	ldr	r0, [r7, #112]	; 0x70
   {
      opus_val32 sum[4];
      sum[0] = SHL32(EXTEND32(x[i  ]), SIG_SHIFT);
 800762a:	f9bb 8000 	ldrsh.w	r8, [fp]
      sum[1] = SHL32(EXTEND32(x[i+1]), SIG_SHIFT);
 800762e:	f9bb 9002 	ldrsh.w	r9, [fp, #2]
      sum[2] = SHL32(EXTEND32(x[i+2]), SIG_SHIFT);
 8007632:	f9bb 1004 	ldrsh.w	r1, [fp, #4]
      sum[3] = SHL32(EXTEND32(x[i+3]), SIG_SHIFT);
 8007636:	f9bb 3006 	ldrsh.w	r3, [fp, #6]
 800763a:	2803      	cmp	r0, #3
      sum[0] = SHL32(EXTEND32(x[i  ]), SIG_SHIFT);
 800763c:	ea4f 3808 	mov.w	r8, r8, lsl #12
      sum[1] = SHL32(EXTEND32(x[i+1]), SIG_SHIFT);
 8007640:	ea4f 3909 	mov.w	r9, r9, lsl #12
      sum[2] = SHL32(EXTEND32(x[i+2]), SIG_SHIFT);
 8007644:	ea4f 3101 	mov.w	r1, r1, lsl #12
      sum[3] = SHL32(EXTEND32(x[i+3]), SIG_SHIFT);
 8007648:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800764c:	4652      	mov	r2, sl
   y_0=*y++;
 800764e:	f93a 5c06 	ldrsh.w	r5, [sl, #-6]
   y_1=*y++;
 8007652:	f93a ec04 	ldrsh.w	lr, [sl, #-4]
   y_2=*y++;
 8007656:	f93a 6c02 	ldrsh.w	r6, [sl, #-2]
   for (j=0;j<len-3;j+=4)
 800765a:	f340 80e0 	ble.w	800781e <celt_fir_c+0x28e>
 800765e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007660:	f8c7 a044 	str.w	sl, [r7, #68]	; 0x44
 8007664:	f102 0008 	add.w	r0, r2, #8
 8007668:	697a      	ldr	r2, [r7, #20]
 800766a:	f8d7 a028 	ldr.w	sl, [r7, #40]	; 0x28
 800766e:	eb02 040b 	add.w	r4, r2, fp
      tmp = *x++;
 8007672:	f930 2c08 	ldrsh.w	r2, [r0, #-8]
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 8007676:	f934 cc08 	ldrsh.w	ip, [r4, #-8]
      sum[0] = MAC16_16(sum[0],tmp,y_0);
 800767a:	fb02 8805 	mla	r8, r2, r5, r8
      sum[1] = MAC16_16(sum[1],tmp,y_1);
 800767e:	fb02 990e 	mla	r9, r2, lr, r9
      sum[2] = MAC16_16(sum[2],tmp,y_2);
 8007682:	fb02 1106 	mla	r1, r2, r6, r1
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 8007686:	fb02 330c 	mla	r3, r2, ip, r3
      y_0=*y++;
 800768a:	f934 5c06 	ldrsh.w	r5, [r4, #-6]
      tmp=*x++;
 800768e:	f930 2c06 	ldrsh.w	r2, [r0, #-6]
 8007692:	3008      	adds	r0, #8
      sum[0] = MAC16_16(sum[0],tmp,y_1);
 8007694:	fb0e 8802 	mla	r8, lr, r2, r8
      sum[1] = MAC16_16(sum[1],tmp,y_2);
 8007698:	fb06 9902 	mla	r9, r6, r2, r9
      sum[2] = MAC16_16(sum[2],tmp,y_3);
 800769c:	fb0c 1102 	mla	r1, ip, r2, r1
      sum[3] = MAC16_16(sum[3],tmp,y_0);
 80076a0:	fb02 3305 	mla	r3, r2, r5, r3
      y_1=*y++;
 80076a4:	f934 ec04 	ldrsh.w	lr, [r4, #-4]
      tmp=*x++;
 80076a8:	f930 2c0c 	ldrsh.w	r2, [r0, #-12]
 80076ac:	3408      	adds	r4, #8
      sum[0] = MAC16_16(sum[0],tmp,y_2);
 80076ae:	fb06 8802 	mla	r8, r6, r2, r8
      sum[1] = MAC16_16(sum[1],tmp,y_3);
 80076b2:	fb0c 9902 	mla	r9, ip, r2, r9
      sum[2] = MAC16_16(sum[2],tmp,y_0);
 80076b6:	fb05 1102 	mla	r1, r5, r2, r1
      sum[3] = MAC16_16(sum[3],tmp,y_1);
 80076ba:	fb02 330e 	mla	r3, r2, lr, r3
      y_2=*y++;
 80076be:	f934 6c0a 	ldrsh.w	r6, [r4, #-10]
      tmp=*x++;
 80076c2:	f930 2c0a 	ldrsh.w	r2, [r0, #-10]
   for (j=0;j<len-3;j+=4)
 80076c6:	4582      	cmp	sl, r0
      sum[0] = MAC16_16(sum[0],tmp,y_3);
 80076c8:	fb0c 8802 	mla	r8, ip, r2, r8
      sum[1] = MAC16_16(sum[1],tmp,y_0);
 80076cc:	fb05 9902 	mla	r9, r5, r2, r9
      sum[2] = MAC16_16(sum[2],tmp,y_1);
 80076d0:	fb0e 1102 	mla	r1, lr, r2, r1
      sum[3] = MAC16_16(sum[3],tmp,y_2);
 80076d4:	fb02 3306 	mla	r3, r2, r6, r3
   for (j=0;j<len-3;j+=4)
 80076d8:	d1cb      	bne.n	8007672 <celt_fir_c+0xe2>
 80076da:	6a38      	ldr	r0, [r7, #32]
 80076dc:	f8d7 a044 	ldr.w	sl, [r7, #68]	; 0x44
 80076e0:	63b8      	str	r0, [r7, #56]	; 0x38
 80076e2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80076e4:	69fa      	ldr	r2, [r7, #28]
 80076e6:	f8c7 c044 	str.w	ip, [r7, #68]	; 0x44
 80076ea:	63f8      	str	r0, [r7, #60]	; 0x3c
 80076ec:	f8d7 c018 	ldr.w	ip, [r7, #24]
      tmp=*x++;
 80076f0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80076f2:	4452      	add	r2, sl
   if (j++<len)
 80076f4:	6f3c      	ldr	r4, [r7, #112]	; 0x70
 80076f6:	4564      	cmp	r4, ip
 80076f8:	dd0f      	ble.n	800771a <celt_fir_c+0x18a>
      opus_val16 tmp = *x++;
 80076fa:	f9b0 c000 	ldrsh.w	ip, [r0]
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 80076fe:	f9b2 4000 	ldrsh.w	r4, [r2]
      sum[0] = MAC16_16(sum[0],tmp,y_0);
 8007702:	fb0c 8805 	mla	r8, ip, r5, r8
      sum[1] = MAC16_16(sum[1],tmp,y_1);
 8007706:	fb0c 990e 	mla	r9, ip, lr, r9
      sum[2] = MAC16_16(sum[2],tmp,y_2);
 800770a:	fb0c 1106 	mla	r1, ip, r6, r1
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 800770e:	647c      	str	r4, [r7, #68]	; 0x44
 8007710:	fb0c 3304 	mla	r3, ip, r4, r3
 8007714:	6f3c      	ldr	r4, [r7, #112]	; 0x70
      opus_val16 tmp = *x++;
 8007716:	3002      	adds	r0, #2
      y_3=*y++;
 8007718:	3202      	adds	r2, #2
   if (j++<len)
 800771a:	46a4      	mov	ip, r4
 800771c:	6bfc      	ldr	r4, [r7, #60]	; 0x3c
 800771e:	45a4      	cmp	ip, r4
 8007720:	dd0e      	ble.n	8007740 <celt_fir_c+0x1b0>
      opus_val16 tmp=*x++;
 8007722:	f9b0 c000 	ldrsh.w	ip, [r0]
      y_0=*y++;
 8007726:	f9b2 5000 	ldrsh.w	r5, [r2]
      sum[2] = MAC16_16(sum[2],tmp,y_3);
 800772a:	6c7c      	ldr	r4, [r7, #68]	; 0x44
      sum[0] = MAC16_16(sum[0],tmp,y_1);
 800772c:	fb0c 880e 	mla	r8, ip, lr, r8
      sum[1] = MAC16_16(sum[1],tmp,y_2);
 8007730:	fb0c 9906 	mla	r9, ip, r6, r9
      sum[2] = MAC16_16(sum[2],tmp,y_3);
 8007734:	fb04 110c 	mla	r1, r4, ip, r1
      sum[3] = MAC16_16(sum[3],tmp,y_0);
 8007738:	fb0c 3305 	mla	r3, ip, r5, r3
      opus_val16 tmp=*x++;
 800773c:	3002      	adds	r0, #2
      y_0=*y++;
 800773e:	3202      	adds	r2, #2
   if (j<len)
 8007740:	6f3c      	ldr	r4, [r7, #112]	; 0x70
 8007742:	46a4      	mov	ip, r4
 8007744:	6bbc      	ldr	r4, [r7, #56]	; 0x38
 8007746:	45a4      	cmp	ip, r4
 8007748:	dd0b      	ble.n	8007762 <celt_fir_c+0x1d2>
      opus_val16 tmp=*x++;
 800774a:	f9b0 0000 	ldrsh.w	r0, [r0]
      sum[3] = MAC16_16(sum[3],tmp,y_1);
 800774e:	8812      	ldrh	r2, [r2, #0]
      sum[1] = MAC16_16(sum[1],tmp,y_3);
 8007750:	6c7c      	ldr	r4, [r7, #68]	; 0x44
      sum[0] = MAC16_16(sum[0],tmp,y_2);
 8007752:	fb00 8806 	mla	r8, r0, r6, r8
      sum[1] = MAC16_16(sum[1],tmp,y_3);
 8007756:	fb04 9900 	mla	r9, r4, r0, r9
      sum[2] = MAC16_16(sum[2],tmp,y_0);
 800775a:	fb00 1105 	mla	r1, r0, r5, r1
      sum[3] = MAC16_16(sum[3],tmp,y_1);
 800775e:	fb10 3302 	smlabb	r3, r0, r2, r3
      xcorr_kernel(rnum, x+i-ord, sum, ord, arch);
      y[i  ] = ROUND16(sum[0], SIG_SHIFT);
 8007762:	2400      	movs	r4, #0
      y[i+1] = ROUND16(sum[1], SIG_SHIFT);
      y[i+2] = ROUND16(sum[2], SIG_SHIFT);
 8007764:	4620      	mov	r0, r4
 8007766:	f501 6100 	add.w	r1, r1, #2048	; 0x800
      y[i  ] = ROUND16(sum[0], SIG_SHIFT);
 800776a:	f508 6800 	add.w	r8, r8, #2048	; 0x800
      y[i+2] = ROUND16(sum[2], SIG_SHIFT);
 800776e:	1309      	asrs	r1, r1, #12
      y[i+3] = ROUND16(sum[3], SIG_SHIFT);
 8007770:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8007774:	131b      	asrs	r3, r3, #12
      y[i  ] = ROUND16(sum[0], SIG_SHIFT);
 8007776:	ea4f 3828 	mov.w	r8, r8, asr #12
      y[i+1] = ROUND16(sum[1], SIG_SHIFT);
 800777a:	f509 6900 	add.w	r9, r9, #2048	; 0x800
      y[i+2] = ROUND16(sum[2], SIG_SHIFT);
 800777e:	f361 000f 	bfi	r0, r1, #0, #16
 8007782:	f363 401f 	bfi	r0, r3, #16, #16
      y[i+1] = ROUND16(sum[1], SIG_SHIFT);
 8007786:	ea4f 3929 	mov.w	r9, r9, asr #12
      y[i  ] = ROUND16(sum[0], SIG_SHIFT);
 800778a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800778c:	f368 040f 	bfi	r4, r8, #0, #16
 8007790:	f369 441f 	bfi	r4, r9, #16, #16
 8007794:	601c      	str	r4, [r3, #0]
 8007796:	6058      	str	r0, [r3, #4]
 8007798:	3308      	adds	r3, #8
 800779a:	643b      	str	r3, [r7, #64]	; 0x40
   for (i=0;i<N-3;i+=4)
 800779c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800779e:	f10b 0b08 	add.w	fp, fp, #8
 80077a2:	455b      	cmp	r3, fp
 80077a4:	f10a 0a08 	add.w	sl, sl, #8
 80077a8:	f47f af3e 	bne.w	8007628 <celt_fir_c+0x98>
 80077ac:	687b      	ldr	r3, [r7, #4]
 80077ae:	3301      	adds	r3, #1
 80077b0:	009b      	lsls	r3, r3, #2
   }
   for (;i<N;i++)
 80077b2:	68fa      	ldr	r2, [r7, #12]
 80077b4:	429a      	cmp	r2, r3
 80077b6:	dd2e      	ble.n	8007816 <celt_fir_c+0x286>
 80077b8:	6f39      	ldr	r1, [r7, #112]	; 0x70
 80077ba:	005c      	lsls	r4, r3, #1
 80077bc:	ebc1 76c1 	rsb	r6, r1, r1, lsl #31
 80077c0:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80077c2:	683b      	ldr	r3, [r7, #0]
 80077c4:	4608      	mov	r0, r1
 80077c6:	4688      	mov	r8, r1
 80077c8:	f1a3 0c02 	sub.w	ip, r3, #2
 80077cc:	68bb      	ldr	r3, [r7, #8]
 80077ce:	0076      	lsls	r6, r6, #1
 80077d0:	4423      	add	r3, r4
 80077d2:	461d      	mov	r5, r3
 80077d4:	693b      	ldr	r3, [r7, #16]
 80077d6:	f8d7 e070 	ldr.w	lr, [r7, #112]	; 0x70
 80077da:	4460      	add	r0, ip
 80077dc:	441c      	add	r4, r3
 80077de:	eb03 0c42 	add.w	ip, r3, r2, lsl #1
 80077e2:	3e02      	subs	r6, #2
   {
      opus_val32 sum = SHL32(EXTEND32(x[i]), SIG_SHIFT);
 80077e4:	f934 3b02 	ldrsh.w	r3, [r4], #2
      for (j=0;j<ord;j++)
 80077e8:	f1be 0f00 	cmp.w	lr, #0
      opus_val32 sum = SHL32(EXTEND32(x[i]), SIG_SHIFT);
 80077ec:	ea4f 3303 	mov.w	r3, r3, lsl #12
      for (j=0;j<ord;j++)
 80077f0:	dd0a      	ble.n	8007808 <celt_fir_c+0x278>
 80077f2:	f1a8 0202 	sub.w	r2, r8, #2
 80077f6:	1931      	adds	r1, r6, r4
         sum = MAC16_16(sum,rnum[j],x[i+j-ord]);
 80077f8:	f832 af02 	ldrh.w	sl, [r2, #2]!
 80077fc:	f931 9b02 	ldrsh.w	r9, [r1], #2
      for (j=0;j<ord;j++)
 8007800:	4282      	cmp	r2, r0
         sum = MAC16_16(sum,rnum[j],x[i+j-ord]);
 8007802:	fb1a 3309 	smlabb	r3, sl, r9, r3
      for (j=0;j<ord;j++)
 8007806:	d1f7      	bne.n	80077f8 <celt_fir_c+0x268>
      y[i] = ROUND16(sum, SIG_SHIFT);
 8007808:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 800780c:	131b      	asrs	r3, r3, #12
   for (;i<N;i++)
 800780e:	45a4      	cmp	ip, r4
      y[i] = ROUND16(sum, SIG_SHIFT);
 8007810:	f825 3b02 	strh.w	r3, [r5], #2
   for (;i<N;i++)
 8007814:	d1e6      	bne.n	80077e4 <celt_fir_c+0x254>
   }
   RESTORE_STACK;
}
 8007816:	374c      	adds	r7, #76	; 0x4c
 8007818:	46bd      	mov	sp, r7
 800781a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   for (j=0;j<len-3;j+=4)
 800781e:	2000      	movs	r0, #0
 8007820:	4604      	mov	r4, r0
 8007822:	46a4      	mov	ip, r4
 8007824:	2402      	movs	r4, #2
 8007826:	63bc      	str	r4, [r7, #56]	; 0x38
 8007828:	2401      	movs	r4, #1
 800782a:	6478      	str	r0, [r7, #68]	; 0x44
 800782c:	63fc      	str	r4, [r7, #60]	; 0x3c
 800782e:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8007830:	e760      	b.n	80076f4 <celt_fir_c+0x164>
   for (i=0;i<N-3;i+=4)
 8007832:	2300      	movs	r3, #0
 8007834:	e7bd      	b.n	80077b2 <celt_fir_c+0x222>
 8007836:	bf00      	nop

08007838 <celt_iir>:
         opus_val32 *_y,
         int N,
         int ord,
         opus_val16 *mem,
         int arch)
{
 8007838:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800783c:	b099      	sub	sp, #100	; 0x64
 800783e:	af00      	add	r7, sp, #0
 8007840:	60b8      	str	r0, [r7, #8]
   VARDECL(opus_val16, rden);
   VARDECL(opus_val16, y);
   SAVE_STACK;

   celt_assert((ord&3)==0);
   ALLOC(rden, ord, opus_val16);
 8007842:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
{
 8007846:	617b      	str	r3, [r7, #20]
   ALLOC(rden, ord, opus_val16);
 8007848:	0046      	lsls	r6, r0, #1
   ALLOC(y, N+ord, opus_val16);
 800784a:	18c5      	adds	r5, r0, r3
   ALLOC(rden, ord, opus_val16);
 800784c:	f106 0008 	add.w	r0, r6, #8
 8007850:	f020 0007 	bic.w	r0, r0, #7
 8007854:	ebad 0d00 	sub.w	sp, sp, r0
 8007858:	4668      	mov	r0, sp
   ALLOC(y, N+ord, opus_val16);
 800785a:	006b      	lsls	r3, r5, #1
 800785c:	3308      	adds	r3, #8
 800785e:	f023 0307 	bic.w	r3, r3, #7
 8007862:	ebad 0d03 	sub.w	sp, sp, r3
   for(i=0;i<ord;i++)
 8007866:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   ALLOC(rden, ord, opus_val16);
 800786a:	613e      	str	r6, [r7, #16]
   for(i=0;i<ord;i++)
 800786c:	2b00      	cmp	r3, #0
   ALLOC(rden, ord, opus_val16);
 800786e:	6438      	str	r0, [r7, #64]	; 0x40
{
 8007870:	460c      	mov	r4, r1
 8007872:	60fa      	str	r2, [r7, #12]
   ALLOC(y, N+ord, opus_val16);
 8007874:	f8c7 d018 	str.w	sp, [r7, #24]
   for(i=0;i<ord;i++)
 8007878:	f340 81e3 	ble.w	8007c42 <celt_iir+0x40a>
 800787c:	198b      	adds	r3, r1, r6
 800787e:	1e82      	subs	r2, r0, #2
      rden[i] = den[ord-i-1];
 8007880:	f833 1d02 	ldrh.w	r1, [r3, #-2]!
   for(i=0;i<ord;i++)
 8007884:	429c      	cmp	r4, r3
      rden[i] = den[ord-i-1];
 8007886:	f822 1f02 	strh.w	r1, [r2, #2]!
   for(i=0;i<ord;i++)
 800788a:	d1f9      	bne.n	8007880 <celt_iir+0x48>
 800788c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8007890:	693a      	ldr	r2, [r7, #16]
 8007892:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 8007896:	189a      	adds	r2, r3, r2
 8007898:	69bb      	ldr	r3, [r7, #24]
 800789a:	1e99      	subs	r1, r3, #2
   for(i=0;i<ord;i++)
      y[i] = -mem[ord-i-1];
 800789c:	f832 3d02 	ldrh.w	r3, [r2, #-2]!
 80078a0:	425b      	negs	r3, r3
   for(i=0;i<ord;i++)
 80078a2:	4290      	cmp	r0, r2
      y[i] = -mem[ord-i-1];
 80078a4:	f821 3f02 	strh.w	r3, [r1, #2]!
   for(i=0;i<ord;i++)
 80078a8:	d1f8      	bne.n	800789c <celt_iir+0x64>
 80078aa:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
   for(;i<N+ord;i++)
 80078ae:	4285      	cmp	r5, r0
 80078b0:	dd07      	ble.n	80078c2 <celt_iir+0x8a>
 80078b2:	69bb      	ldr	r3, [r7, #24]
      y[i]=0;
 80078b4:	1a2a      	subs	r2, r5, r0
 80078b6:	0052      	lsls	r2, r2, #1
 80078b8:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 80078bc:	2100      	movs	r1, #0
 80078be:	f00c fc33 	bl	8014128 <memset>
   for (i=0;i<N-3;i+=4)
 80078c2:	697b      	ldr	r3, [r7, #20]
 80078c4:	2b03      	cmp	r3, #3
 80078c6:	f340 81be 	ble.w	8007c46 <celt_iir+0x40e>
 80078ca:	68ba      	ldr	r2, [r7, #8]
 80078cc:	3b04      	subs	r3, #4
 80078ce:	65ba      	str	r2, [r7, #88]	; 0x58
 80078d0:	68fa      	ldr	r2, [r7, #12]
 80078d2:	f023 0103 	bic.w	r1, r3, #3
 80078d6:	65fa      	str	r2, [r7, #92]	; 0x5c
 80078d8:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 80078dc:	607b      	str	r3, [r7, #4]
 80078de:	3a04      	subs	r2, #4
 80078e0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80078e4:	0892      	lsrs	r2, r2, #2
 80078e6:	4419      	add	r1, r3
 80078e8:	1c53      	adds	r3, r2, #1
 80078ea:	00dd      	lsls	r5, r3, #3
 80078ec:	637d      	str	r5, [r7, #52]	; 0x34
 80078ee:	009d      	lsls	r5, r3, #2
 80078f0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80078f4:	69b8      	ldr	r0, [r7, #24]
 80078f6:	ebc3 7cc3 	rsb	ip, r3, r3, lsl #31
 80078fa:	f9b4 3000 	ldrsh.w	r3, [r4]
 80078fe:	6c3e      	ldr	r6, [r7, #64]	; 0x40
 8007900:	657b      	str	r3, [r7, #84]	; 0x54
 8007902:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 8007906:	eb00 0141 	add.w	r1, r0, r1, lsl #1
 800790a:	64fb      	str	r3, [r7, #76]	; 0x4c
 800790c:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
 8007910:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
 8007914:	63bb      	str	r3, [r7, #56]	; 0x38
 8007916:	f101 0308 	add.w	r3, r1, #8
 800791a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800791c:	f102 0310 	add.w	r3, r2, #16
 8007920:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007922:	62fb      	str	r3, [r7, #44]	; 0x2c
 8007924:	18b3      	adds	r3, r6, r2
 8007926:	633b      	str	r3, [r7, #48]	; 0x30
 8007928:	1c6b      	adds	r3, r5, #1
 800792a:	62bb      	str	r3, [r7, #40]	; 0x28
 800792c:	1cab      	adds	r3, r5, #2
 800792e:	627b      	str	r3, [r7, #36]	; 0x24
 8007930:	ea4f 034c 	mov.w	r3, ip, lsl #1
 8007934:	61fb      	str	r3, [r7, #28]
 8007936:	1d83      	adds	r3, r0, #6
 8007938:	469a      	mov	sl, r3
 800793a:	693a      	ldr	r2, [r7, #16]
 800793c:	623d      	str	r5, [r7, #32]
 800793e:	eb00 0b02 	add.w	fp, r0, r2
 8007942:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
   {
      /* Unroll by 4 as if it were an FIR filter */
      opus_val32 sum[4];
      sum[0]=_x[i];
 8007946:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007948:	2903      	cmp	r1, #3
 800794a:	681a      	ldr	r2, [r3, #0]
      sum[1]=_x[i+1];
      sum[2]=_x[i+2];
 800794c:	e9d3 9801 	ldrd	r9, r8, [r3, #4]
      sum[3]=_x[i+3];
 8007950:	f8d3 e00c 	ldr.w	lr, [r3, #12]
   y_0=*y++;
 8007954:	f93a 4c06 	ldrsh.w	r4, [sl, #-6]
 8007958:	4653      	mov	r3, sl
   y_1=*y++;
 800795a:	f93a cc04 	ldrsh.w	ip, [sl, #-4]
   y_2=*y++;
 800795e:	f93a 5c02 	ldrsh.w	r5, [sl, #-2]
   for (j=0;j<len-3;j+=4)
 8007962:	f340 8163 	ble.w	8007c2c <celt_iir+0x3f4>
 8007966:	69fb      	ldr	r3, [r7, #28]
 8007968:	f8c7 a050 	str.w	sl, [r7, #80]	; 0x50
 800796c:	f103 000e 	add.w	r0, r3, #14
 8007970:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007972:	f8d7 a02c 	ldr.w	sl, [r7, #44]	; 0x2c
 8007976:	4458      	add	r0, fp
 8007978:	f103 0108 	add.w	r1, r3, #8
      tmp = *x++;
 800797c:	f931 3c08 	ldrsh.w	r3, [r1, #-8]
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 8007980:	f930 6c08 	ldrsh.w	r6, [r0, #-8]
      sum[0] = MAC16_16(sum[0],tmp,y_0);
 8007984:	fb03 2204 	mla	r2, r3, r4, r2
      sum[1] = MAC16_16(sum[1],tmp,y_1);
 8007988:	fb03 990c 	mla	r9, r3, ip, r9
      sum[2] = MAC16_16(sum[2],tmp,y_2);
 800798c:	fb03 8805 	mla	r8, r3, r5, r8
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 8007990:	fb03 ee06 	mla	lr, r3, r6, lr
      y_0=*y++;
 8007994:	f930 4c06 	ldrsh.w	r4, [r0, #-6]
      tmp=*x++;
 8007998:	f931 3c06 	ldrsh.w	r3, [r1, #-6]
 800799c:	3108      	adds	r1, #8
      sum[0] = MAC16_16(sum[0],tmp,y_1);
 800799e:	fb0c 2203 	mla	r2, ip, r3, r2
      sum[1] = MAC16_16(sum[1],tmp,y_2);
 80079a2:	fb05 9903 	mla	r9, r5, r3, r9
      sum[2] = MAC16_16(sum[2],tmp,y_3);
 80079a6:	fb06 8803 	mla	r8, r6, r3, r8
      sum[3] = MAC16_16(sum[3],tmp,y_0);
 80079aa:	fb03 ee04 	mla	lr, r3, r4, lr
      y_1=*y++;
 80079ae:	f930 cc04 	ldrsh.w	ip, [r0, #-4]
      tmp=*x++;
 80079b2:	f931 3c0c 	ldrsh.w	r3, [r1, #-12]
 80079b6:	3008      	adds	r0, #8
      sum[0] = MAC16_16(sum[0],tmp,y_2);
 80079b8:	fb05 2203 	mla	r2, r5, r3, r2
      sum[1] = MAC16_16(sum[1],tmp,y_3);
 80079bc:	fb06 9903 	mla	r9, r6, r3, r9
      sum[2] = MAC16_16(sum[2],tmp,y_0);
 80079c0:	fb04 8803 	mla	r8, r4, r3, r8
      sum[3] = MAC16_16(sum[3],tmp,y_1);
 80079c4:	fb03 ee0c 	mla	lr, r3, ip, lr
      y_2=*y++;
 80079c8:	f930 5c0a 	ldrsh.w	r5, [r0, #-10]
      tmp=*x++;
 80079cc:	f931 3c0a 	ldrsh.w	r3, [r1, #-10]
   for (j=0;j<len-3;j+=4)
 80079d0:	458a      	cmp	sl, r1
      sum[0] = MAC16_16(sum[0],tmp,y_3);
 80079d2:	fb06 2203 	mla	r2, r6, r3, r2
      sum[1] = MAC16_16(sum[1],tmp,y_0);
 80079d6:	fb04 9903 	mla	r9, r4, r3, r9
      sum[2] = MAC16_16(sum[2],tmp,y_1);
 80079da:	fb0c 8803 	mla	r8, ip, r3, r8
      sum[3] = MAC16_16(sum[3],tmp,y_2);
 80079de:	fb03 ee05 	mla	lr, r3, r5, lr
   for (j=0;j<len-3;j+=4)
 80079e2:	d1cb      	bne.n	800797c <celt_iir+0x144>
 80079e4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80079e6:	f8d7 a050 	ldr.w	sl, [r7, #80]	; 0x50
 80079ea:	6479      	str	r1, [r7, #68]	; 0x44
 80079ec:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80079ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80079f0:	653e      	str	r6, [r7, #80]	; 0x50
 80079f2:	64b9      	str	r1, [r7, #72]	; 0x48
 80079f4:	6a3e      	ldr	r6, [r7, #32]
      tmp=*x++;
 80079f6:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80079f8:	4453      	add	r3, sl
   if (j++<len)
 80079fa:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
 80079fe:	42b0      	cmp	r0, r6
 8007a00:	dd10      	ble.n	8007a24 <celt_iir+0x1ec>
      opus_val16 tmp = *x++;
 8007a02:	f9b1 0000 	ldrsh.w	r0, [r1]
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 8007a06:	f9b3 6000 	ldrsh.w	r6, [r3]
      sum[0] = MAC16_16(sum[0],tmp,y_0);
 8007a0a:	fb00 2204 	mla	r2, r0, r4, r2
      sum[1] = MAC16_16(sum[1],tmp,y_1);
 8007a0e:	fb00 990c 	mla	r9, r0, ip, r9
      sum[2] = MAC16_16(sum[2],tmp,y_2);
 8007a12:	fb00 8805 	mla	r8, r0, r5, r8
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 8007a16:	fb00 ee06 	mla	lr, r0, r6, lr
 8007a1a:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
 8007a1e:	653e      	str	r6, [r7, #80]	; 0x50
      opus_val16 tmp = *x++;
 8007a20:	3102      	adds	r1, #2
      y_3=*y++;
 8007a22:	3302      	adds	r3, #2
   if (j++<len)
 8007a24:	4606      	mov	r6, r0
 8007a26:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8007a28:	4286      	cmp	r6, r0
 8007a2a:	dd0e      	ble.n	8007a4a <celt_iir+0x212>
      opus_val16 tmp=*x++;
 8007a2c:	f9b1 0000 	ldrsh.w	r0, [r1]
      y_0=*y++;
 8007a30:	f9b3 4000 	ldrsh.w	r4, [r3]
      sum[2] = MAC16_16(sum[2],tmp,y_3);
 8007a34:	6d3e      	ldr	r6, [r7, #80]	; 0x50
      sum[0] = MAC16_16(sum[0],tmp,y_1);
 8007a36:	fb00 220c 	mla	r2, r0, ip, r2
      sum[1] = MAC16_16(sum[1],tmp,y_2);
 8007a3a:	fb00 9905 	mla	r9, r0, r5, r9
      sum[2] = MAC16_16(sum[2],tmp,y_3);
 8007a3e:	fb06 8800 	mla	r8, r6, r0, r8
      sum[3] = MAC16_16(sum[3],tmp,y_0);
 8007a42:	fb00 ee04 	mla	lr, r0, r4, lr
      opus_val16 tmp=*x++;
 8007a46:	3102      	adds	r1, #2
      y_0=*y++;
 8007a48:	3302      	adds	r3, #2
   if (j<len)
 8007a4a:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
 8007a4e:	4606      	mov	r6, r0
 8007a50:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8007a52:	4286      	cmp	r6, r0
 8007a54:	dd0b      	ble.n	8007a6e <celt_iir+0x236>
      opus_val16 tmp=*x++;
 8007a56:	f9b1 1000 	ldrsh.w	r1, [r1]
      sum[3] = MAC16_16(sum[3],tmp,y_1);
 8007a5a:	881b      	ldrh	r3, [r3, #0]
      sum[1] = MAC16_16(sum[1],tmp,y_3);
 8007a5c:	6d38      	ldr	r0, [r7, #80]	; 0x50
      sum[0] = MAC16_16(sum[0],tmp,y_2);
 8007a5e:	fb01 2205 	mla	r2, r1, r5, r2
      sum[1] = MAC16_16(sum[1],tmp,y_3);
 8007a62:	fb00 9901 	mla	r9, r0, r1, r9
      sum[2] = MAC16_16(sum[2],tmp,y_0);
 8007a66:	fb01 8804 	mla	r8, r1, r4, r8
      sum[3] = MAC16_16(sum[3],tmp,y_1);
 8007a6a:	fb11 ee03 	smlabb	lr, r1, r3, lr
      xcorr_kernel(rden, y+i, sum, ord, arch);

      /* Patch up the result to compensate for the fact that this is an IIR */
      y[i+ord  ] = -SROUND16(sum[0],SIG_SHIFT);
 8007a6e:	f502 6100 	add.w	r1, r2, #2048	; 0x800
 8007a72:	1309      	asrs	r1, r1, #12
 8007a74:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8007a78:	4b74      	ldr	r3, [pc, #464]	; (8007c4c <celt_iir+0x414>)
 8007a7a:	f280 80c6 	bge.w	8007c0a <celt_iir+0x3d2>
 8007a7e:	4299      	cmp	r1, r3
 8007a80:	f2c0 80c1 	blt.w	8007c06 <celt_iir+0x3ce>
 8007a84:	4249      	negs	r1, r1
 8007a86:	b209      	sxth	r1, r1
 8007a88:	460b      	mov	r3, r1
      _y[i  ] = sum[0];
      sum[1] = MAC16_16(sum[1], y[i+ord  ], den[0]);
 8007a8a:	6d78      	ldr	r0, [r7, #84]	; 0x54
      _y[i  ] = sum[0];
 8007a8c:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
      sum[1] = MAC16_16(sum[1], y[i+ord  ], den[0]);
 8007a8e:	fb03 9300 	mla	r3, r3, r0, r9
      y[i+ord+1] = -SROUND16(sum[1],SIG_SHIFT);
 8007a92:	f503 6000 	add.w	r0, r3, #2048	; 0x800
 8007a96:	1300      	asrs	r0, r0, #12
 8007a98:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
      y[i+ord  ] = -SROUND16(sum[0],SIG_SHIFT);
 8007a9c:	f8ab 1000 	strh.w	r1, [fp]
      _y[i  ] = sum[0];
 8007aa0:	6022      	str	r2, [r4, #0]
      y[i+ord+1] = -SROUND16(sum[1],SIG_SHIFT);
 8007aa2:	f280 80b4 	bge.w	8007c0e <celt_iir+0x3d6>
 8007aa6:	4a69      	ldr	r2, [pc, #420]	; (8007c4c <celt_iir+0x414>)
 8007aa8:	4290      	cmp	r0, r2
 8007aaa:	f2c0 80b8 	blt.w	8007c1e <celt_iir+0x3e6>
 8007aae:	4242      	negs	r2, r0
 8007ab0:	b212      	sxth	r2, r2
 8007ab2:	4614      	mov	r4, r2
      _y[i+1] = sum[1];
      sum[2] = MAC16_16(sum[2], y[i+ord+1], den[0]);
 8007ab4:	6d78      	ldr	r0, [r7, #84]	; 0x54
      _y[i+1] = sum[1];
 8007ab6:	6dfd      	ldr	r5, [r7, #92]	; 0x5c
      sum[2] = MAC16_16(sum[2], y[i+ord+1], den[0]);
 8007ab8:	fb04 8400 	mla	r4, r4, r0, r8
      sum[2] = MAC16_16(sum[2], y[i+ord  ], den[1]);
 8007abc:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
      _y[i+1] = sum[1];
 8007abe:	606b      	str	r3, [r5, #4]
      sum[2] = MAC16_16(sum[2], y[i+ord  ], den[1]);
 8007ac0:	fb01 4400 	mla	r4, r1, r0, r4
      y[i+ord+2] = -SROUND16(sum[2],SIG_SHIFT);
 8007ac4:	f504 6000 	add.w	r0, r4, #2048	; 0x800
 8007ac8:	1300      	asrs	r0, r0, #12
 8007aca:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
      y[i+ord+1] = -SROUND16(sum[1],SIG_SHIFT);
 8007ace:	f8ab 2002 	strh.w	r2, [fp, #2]
      y[i+ord+2] = -SROUND16(sum[2],SIG_SHIFT);
 8007ad2:	4b5e      	ldr	r3, [pc, #376]	; (8007c4c <celt_iir+0x414>)
 8007ad4:	f280 8095 	bge.w	8007c02 <celt_iir+0x3ca>
 8007ad8:	4298      	cmp	r0, r3
 8007ada:	f2c0 8090 	blt.w	8007bfe <celt_iir+0x3c6>
 8007ade:	4240      	negs	r0, r0
 8007ae0:	b200      	sxth	r0, r0
 8007ae2:	4603      	mov	r3, r0
      _y[i+2] = sum[2];

      sum[3] = MAC16_16(sum[3], y[i+ord+2], den[0]);
 8007ae4:	6d7d      	ldr	r5, [r7, #84]	; 0x54
      y[i+ord+2] = -SROUND16(sum[2],SIG_SHIFT);
 8007ae6:	f8ab 0004 	strh.w	r0, [fp, #4]
      sum[3] = MAC16_16(sum[3], y[i+ord+2], den[0]);
 8007aea:	fb03 e305 	mla	r3, r3, r5, lr
      sum[3] = MAC16_16(sum[3], y[i+ord+1], den[1]);
 8007aee:	6cfd      	ldr	r5, [r7, #76]	; 0x4c
 8007af0:	fb02 3305 	mla	r3, r2, r5, r3
      sum[3] = MAC16_16(sum[3], y[i+ord  ], den[2]);
 8007af4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007af6:	fb01 3102 	mla	r1, r1, r2, r3
      y[i+ord+3] = -SROUND16(sum[3],SIG_SHIFT);
 8007afa:	f501 6300 	add.w	r3, r1, #2048	; 0x800
 8007afe:	131b      	asrs	r3, r3, #12
      _y[i+2] = sum[2];
 8007b00:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
      y[i+ord+3] = -SROUND16(sum[3],SIG_SHIFT);
 8007b02:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
      _y[i+2] = sum[2];
 8007b06:	6094      	str	r4, [r2, #8]
      y[i+ord+3] = -SROUND16(sum[3],SIG_SHIFT);
 8007b08:	f280 8084 	bge.w	8007c14 <celt_iir+0x3dc>
 8007b0c:	4a4f      	ldr	r2, [pc, #316]	; (8007c4c <celt_iir+0x414>)
 8007b0e:	4293      	cmp	r3, r2
 8007b10:	f2c0 8089 	blt.w	8007c26 <celt_iir+0x3ee>
 8007b14:	425b      	negs	r3, r3
 8007b16:	b21b      	sxth	r3, r3
 8007b18:	f8ab 3006 	strh.w	r3, [fp, #6]
      _y[i+3] = sum[3];
 8007b1c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007b1e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8007b20:	60d9      	str	r1, [r3, #12]
 8007b22:	3310      	adds	r3, #16
 8007b24:	65fb      	str	r3, [r7, #92]	; 0x5c
   for (i=0;i<N-3;i+=4)
 8007b26:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007b28:	f10b 0b08 	add.w	fp, fp, #8
 8007b2c:	3210      	adds	r2, #16
 8007b2e:	455b      	cmp	r3, fp
 8007b30:	65ba      	str	r2, [r7, #88]	; 0x58
 8007b32:	f10a 0a08 	add.w	sl, sl, #8
 8007b36:	f47f af04 	bne.w	8007942 <celt_iir+0x10a>
 8007b3a:	687b      	ldr	r3, [r7, #4]
 8007b3c:	f023 0c03 	bic.w	ip, r3, #3
 8007b40:	697b      	ldr	r3, [r7, #20]
 8007b42:	f10c 0c04 	add.w	ip, ip, #4
   }
   for (;i<N;i++)
 8007b46:	4563      	cmp	r3, ip
 8007b48:	dd40      	ble.n	8007bcc <celt_iir+0x394>
 8007b4a:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8007b4e:	68b9      	ldr	r1, [r7, #8]
 8007b50:	eb02 060c 	add.w	r6, r2, ip
 8007b54:	693a      	ldr	r2, [r7, #16]
 8007b56:	68f8      	ldr	r0, [r7, #12]
 8007b58:	1e95      	subs	r5, r2, #2
 8007b5a:	69ba      	ldr	r2, [r7, #24]
 8007b5c:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8007b60:	eb02 0646 	add.w	r6, r2, r6, lsl #1
 8007b64:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
   {
      opus_val32 sum = _x[i];
      for (j=0;j<ord;j++)
         sum -= MULT16_16(rden[j],y[i+j]);
      y[i+ord] = SROUND16(sum,SIG_SHIFT);
 8007b68:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 8007c4c <celt_iir+0x414>
 8007b6c:	ebc2 79c2 	rsb	r9, r2, r2, lsl #31
 8007b70:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8007b72:	eb01 0e0c 	add.w	lr, r1, ip
 8007b76:	4693      	mov	fp, r2
 8007b78:	4415      	add	r5, r2
 8007b7a:	3e02      	subs	r6, #2
 8007b7c:	4484      	add	ip, r0
 8007b7e:	eb01 0883 	add.w	r8, r1, r3, lsl #2
 8007b82:	ea4f 0949 	mov.w	r9, r9, lsl #1
      for (j=0;j<ord;j++)
 8007b86:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
      opus_val32 sum = _x[i];
 8007b8a:	f85e 0b04 	ldr.w	r0, [lr], #4
      for (j=0;j<ord;j++)
 8007b8e:	2b00      	cmp	r3, #0
 8007b90:	dd0d      	ble.n	8007bae <celt_iir+0x376>
 8007b92:	f1ab 0102 	sub.w	r1, fp, #2
 8007b96:	eb09 0406 	add.w	r4, r9, r6
         sum -= MULT16_16(rden[j],y[i+j]);
 8007b9a:	f831 3f02 	ldrh.w	r3, [r1, #2]!
 8007b9e:	f834 2f02 	ldrh.w	r2, [r4, #2]!
      for (j=0;j<ord;j++)
 8007ba2:	428d      	cmp	r5, r1
         sum -= MULT16_16(rden[j],y[i+j]);
 8007ba4:	fb13 f302 	smulbb	r3, r3, r2
 8007ba8:	eba0 0003 	sub.w	r0, r0, r3
      for (j=0;j<ord;j++)
 8007bac:	d1f5      	bne.n	8007b9a <celt_iir+0x362>
      y[i+ord] = SROUND16(sum,SIG_SHIFT);
 8007bae:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8007bb2:	131b      	asrs	r3, r3, #12
 8007bb4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8007bb8:	da2e      	bge.n	8007c18 <celt_iir+0x3e0>
 8007bba:	4553      	cmp	r3, sl
 8007bbc:	db3f      	blt.n	8007c3e <celt_iir+0x406>
 8007bbe:	b21b      	sxth	r3, r3
   for (;i<N;i++)
 8007bc0:	45f0      	cmp	r8, lr
      y[i+ord] = SROUND16(sum,SIG_SHIFT);
 8007bc2:	f826 3f02 	strh.w	r3, [r6, #2]!
      _y[i] = sum;
 8007bc6:	f84c 0b04 	str.w	r0, [ip], #4
   for (;i<N;i++)
 8007bca:	d1dc      	bne.n	8007b86 <celt_iir+0x34e>
   }
   for(i=0;i<ord;i++)
 8007bcc:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8007bd0:	2b00      	cmp	r3, #0
 8007bd2:	dd10      	ble.n	8007bf6 <celt_iir+0x3be>
 8007bd4:	68fb      	ldr	r3, [r7, #12]
 8007bd6:	697a      	ldr	r2, [r7, #20]
 8007bd8:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 8007bdc:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8007be0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8007be4:	3902      	subs	r1, #2
 8007be6:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
      mem[i] = _y[N-i-1];
 8007bea:	f852 0d04 	ldr.w	r0, [r2, #-4]!
   for(i=0;i<ord;i++)
 8007bee:	4293      	cmp	r3, r2
      mem[i] = _y[N-i-1];
 8007bf0:	f821 0f02 	strh.w	r0, [r1, #2]!
   for(i=0;i<ord;i++)
 8007bf4:	d1f9      	bne.n	8007bea <celt_iir+0x3b2>
   RESTORE_STACK;
#endif
}
 8007bf6:	3764      	adds	r7, #100	; 0x64
 8007bf8:	46bd      	mov	sp, r7
 8007bfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007bfe:	f647 73ff 	movw	r3, #32767	; 0x7fff
      y[i+ord+2] = -SROUND16(sum[2],SIG_SHIFT);
 8007c02:	4618      	mov	r0, r3
 8007c04:	e76e      	b.n	8007ae4 <celt_iir+0x2ac>
 8007c06:	f647 73ff 	movw	r3, #32767	; 0x7fff
      y[i+ord  ] = -SROUND16(sum[0],SIG_SHIFT);
 8007c0a:	4619      	mov	r1, r3
 8007c0c:	e73d      	b.n	8007a8a <celt_iir+0x252>
 8007c0e:	4c0f      	ldr	r4, [pc, #60]	; (8007c4c <celt_iir+0x414>)
      y[i+ord+1] = -SROUND16(sum[1],SIG_SHIFT);
 8007c10:	4622      	mov	r2, r4
 8007c12:	e74f      	b.n	8007ab4 <celt_iir+0x27c>
      y[i+ord+3] = -SROUND16(sum[3],SIG_SHIFT);
 8007c14:	4b0d      	ldr	r3, [pc, #52]	; (8007c4c <celt_iir+0x414>)
 8007c16:	e77f      	b.n	8007b18 <celt_iir+0x2e0>
      y[i+ord] = SROUND16(sum,SIG_SHIFT);
 8007c18:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8007c1c:	e7d0      	b.n	8007bc0 <celt_iir+0x388>
 8007c1e:	f647 74ff 	movw	r4, #32767	; 0x7fff
      y[i+ord+1] = -SROUND16(sum[1],SIG_SHIFT);
 8007c22:	4622      	mov	r2, r4
 8007c24:	e746      	b.n	8007ab4 <celt_iir+0x27c>
      y[i+ord+3] = -SROUND16(sum[3],SIG_SHIFT);
 8007c26:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8007c2a:	e775      	b.n	8007b18 <celt_iir+0x2e0>
   for (j=0;j<len-3;j+=4)
 8007c2c:	2002      	movs	r0, #2
 8007c2e:	2100      	movs	r1, #0
 8007c30:	6478      	str	r0, [r7, #68]	; 0x44
 8007c32:	2001      	movs	r0, #1
 8007c34:	460e      	mov	r6, r1
 8007c36:	6539      	str	r1, [r7, #80]	; 0x50
 8007c38:	64b8      	str	r0, [r7, #72]	; 0x48
 8007c3a:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8007c3c:	e6dd      	b.n	80079fa <celt_iir+0x1c2>
      y[i+ord] = SROUND16(sum,SIG_SHIFT);
 8007c3e:	4653      	mov	r3, sl
 8007c40:	e7be      	b.n	8007bc0 <celt_iir+0x388>
   for(i=0;i<ord;i++)
 8007c42:	2000      	movs	r0, #0
 8007c44:	e633      	b.n	80078ae <celt_iir+0x76>
   for (i=0;i<N-3;i+=4)
 8007c46:	f04f 0c00 	mov.w	ip, #0
 8007c4a:	e77c      	b.n	8007b46 <celt_iir+0x30e>
 8007c4c:	ffff8001 	.word	0xffff8001

08007c50 <_celt_autocorr>:
                   int          overlap,
                   int          lag,
                   int          n,
                   int          arch
                  )
{
 8007c50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007c54:	b085      	sub	sp, #20
 8007c56:	af02      	add	r7, sp, #8
 8007c58:	6b7d      	ldr	r5, [r7, #52]	; 0x34
 8007c5a:	4691      	mov	r9, r2
   int fastN=n-lag;
   int shift;
   const opus_val16 *xptr;
   VARDECL(opus_val16, xx);
   SAVE_STACK;
   ALLOC(xx, n, opus_val16);
 8007c5c:	006c      	lsls	r4, r5, #1
 8007c5e:	f104 0608 	add.w	r6, r4, #8
 8007c62:	f026 0607 	bic.w	r6, r6, #7
   int fastN=n-lag;
 8007c66:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   ALLOC(xx, n, opus_val16);
 8007c68:	ebad 0d06 	sub.w	sp, sp, r6
{
 8007c6c:	4680      	mov	r8, r0
 8007c6e:	6079      	str	r1, [r7, #4]
   ALLOC(xx, n, opus_val16);
 8007c70:	ae02      	add	r6, sp, #8
   int fastN=n-lag;
 8007c72:	eba5 0b02 	sub.w	fp, r5, r2
   celt_assert(n>0);
   celt_assert(overlap>=0);
   if (overlap == 0)
 8007c76:	b34b      	cbz	r3, 8007ccc <_celt_autocorr+0x7c>
   {
      xptr = x;
   } else {
      for (i=0;i<n;i++)
 8007c78:	2d00      	cmp	r5, #0
 8007c7a:	469a      	mov	sl, r3
 8007c7c:	dd04      	ble.n	8007c88 <_celt_autocorr+0x38>
 8007c7e:	4601      	mov	r1, r0
 8007c80:	4622      	mov	r2, r4
 8007c82:	4630      	mov	r0, r6
 8007c84:	f00c fa2c 	bl	80140e0 <memcpy>
         xx[i] = x[i];
      for (i=0;i<overlap;i++)
 8007c88:	f1ba 0f00 	cmp.w	sl, #0
 8007c8c:	dd1d      	ble.n	8007cca <_celt_autocorr+0x7a>
 8007c8e:	f1a8 0002 	sub.w	r0, r8, #2
 8007c92:	f1a4 0c02 	sub.w	ip, r4, #2
 8007c96:	f1a9 0902 	sub.w	r9, r9, #2
 8007c9a:	eb00 0a4a 	add.w	sl, r0, sl, lsl #1
 8007c9e:	44a0      	add	r8, r4
 8007ca0:	44b4      	add	ip, r6
 8007ca2:	f1a6 0e02 	sub.w	lr, r6, #2
      {
         xx[i] = MULT16_16_Q15(x[i],window[i]);
 8007ca6:	f939 1f02 	ldrsh.w	r1, [r9, #2]!
 8007caa:	f830 2f02 	ldrh.w	r2, [r0, #2]!
         xx[n-i-1] = MULT16_16_Q15(x[n-i-1],window[i]);
 8007cae:	f838 3d02 	ldrh.w	r3, [r8, #-2]!
         xx[i] = MULT16_16_Q15(x[i],window[i]);
 8007cb2:	fb12 f201 	smulbb	r2, r2, r1
         xx[n-i-1] = MULT16_16_Q15(x[n-i-1],window[i]);
 8007cb6:	fb13 f301 	smulbb	r3, r3, r1
         xx[i] = MULT16_16_Q15(x[i],window[i]);
 8007cba:	13d2      	asrs	r2, r2, #15
         xx[n-i-1] = MULT16_16_Q15(x[n-i-1],window[i]);
 8007cbc:	13db      	asrs	r3, r3, #15
      for (i=0;i<overlap;i++)
 8007cbe:	4582      	cmp	sl, r0
         xx[i] = MULT16_16_Q15(x[i],window[i]);
 8007cc0:	f82e 2f02 	strh.w	r2, [lr, #2]!
         xx[n-i-1] = MULT16_16_Q15(x[n-i-1],window[i]);
 8007cc4:	f82c 3902 	strh.w	r3, [ip], #-2
      for (i=0;i<overlap;i++)
 8007cc8:	d1ed      	bne.n	8007ca6 <_celt_autocorr+0x56>
   ALLOC(xx, n, opus_val16);
 8007cca:	46b0      	mov	r8, r6
   }
   shift=0;
#ifdef FIXED_POINT
   {
      opus_val32 ac0;
      ac0 = 1+(n<<7);
 8007ccc:	01ea      	lsls	r2, r5, #7
      if (n&1) ac0 += SHR32(MULT16_16(xptr[0],xptr[0]),9);
 8007cce:	f015 0101 	ands.w	r1, r5, #1
      ac0 = 1+(n<<7);
 8007cd2:	f102 0201 	add.w	r2, r2, #1
      if (n&1) ac0 += SHR32(MULT16_16(xptr[0],xptr[0]),9);
 8007cd6:	d005      	beq.n	8007ce4 <_celt_autocorr+0x94>
 8007cd8:	f9b8 3000 	ldrsh.w	r3, [r8]
 8007cdc:	fb03 f303 	mul.w	r3, r3, r3
 8007ce0:	eb02 2263 	add.w	r2, r2, r3, asr #9
      for(i=(n&1);i<n;i+=2)
 8007ce4:	42a9      	cmp	r1, r5
 8007ce6:	da19      	bge.n	8007d1c <_celt_autocorr+0xcc>
 8007ce8:	1e68      	subs	r0, r5, #1
 8007cea:	1a40      	subs	r0, r0, r1
 8007cec:	f020 0001 	bic.w	r0, r0, #1
 8007cf0:	1843      	adds	r3, r0, r1
 8007cf2:	f108 0004 	add.w	r0, r8, #4
 8007cf6:	eb08 0141 	add.w	r1, r8, r1, lsl #1
 8007cfa:	eb00 0043 	add.w	r0, r0, r3, lsl #1
      {
         ac0 += SHR32(MULT16_16(xptr[i],xptr[i]),9);
 8007cfe:	f9b1 c000 	ldrsh.w	ip, [r1]
         ac0 += SHR32(MULT16_16(xptr[i+1],xptr[i+1]),9);
 8007d02:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
         ac0 += SHR32(MULT16_16(xptr[i],xptr[i]),9);
 8007d06:	fb0c fc0c 	mul.w	ip, ip, ip
         ac0 += SHR32(MULT16_16(xptr[i+1],xptr[i+1]),9);
 8007d0a:	fb03 f303 	mul.w	r3, r3, r3
 8007d0e:	3104      	adds	r1, #4
         ac0 += SHR32(MULT16_16(xptr[i],xptr[i]),9);
 8007d10:	eb02 2c6c 	add.w	ip, r2, ip, asr #9
      for(i=(n&1);i<n;i+=2)
 8007d14:	4288      	cmp	r0, r1
         ac0 += SHR32(MULT16_16(xptr[i+1],xptr[i+1]),9);
 8007d16:	eb0c 2263 	add.w	r2, ip, r3, asr #9
      for(i=(n&1);i<n;i+=2)
 8007d1a:	d1f0      	bne.n	8007cfe <_celt_autocorr+0xae>
   return EC_ILOG(x)-1;
 8007d1c:	fab2 f282 	clz	r2, r2
      }

      shift = celt_ilog2(ac0)-30+10;
 8007d20:	f1c2 000b 	rsb	r0, r2, #11
      shift = (shift)/2;
 8007d24:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
 8007d28:	ea4f 0960 	mov.w	r9, r0, asr #1
 8007d2c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
      if (shift>0)
 8007d2e:	f1b9 0f00 	cmp.w	r9, #0
 8007d32:	f103 0c01 	add.w	ip, r3, #1
 8007d36:	f340 8092 	ble.w	8007e5e <_celt_autocorr+0x20e>
      {
         for(i=0;i<n;i++)
 8007d3a:	2d00      	cmp	r5, #0
 8007d3c:	dd11      	ble.n	8007d62 <_celt_autocorr+0x112>
            xx[i] = PSHR32(xptr[i], shift);
 8007d3e:	2001      	movs	r0, #1
 8007d40:	1ea1      	subs	r1, r4, #2
 8007d42:	fa00 f009 	lsl.w	r0, r0, r9
 8007d46:	4441      	add	r1, r8
 8007d48:	1040      	asrs	r0, r0, #1
 8007d4a:	f1a8 0802 	sub.w	r8, r8, #2
 8007d4e:	1eb2      	subs	r2, r6, #2
 8007d50:	f938 3f02 	ldrsh.w	r3, [r8, #2]!
 8007d54:	4403      	add	r3, r0
 8007d56:	fa43 f309 	asr.w	r3, r3, r9
         for(i=0;i<n;i++)
 8007d5a:	4541      	cmp	r1, r8
            xx[i] = PSHR32(xptr[i], shift);
 8007d5c:	f822 3f02 	strh.w	r3, [r2, #2]!
         for(i=0;i<n;i++)
 8007d60:	d1f6      	bne.n	8007d50 <_celt_autocorr+0x100>
         xptr = xx;
      } else
         shift = 0;
   }
#endif
   celt_pitch_xcorr(xptr, xptr, ac, fastN, lag+1, arch);
 8007d62:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007d64:	687a      	ldr	r2, [r7, #4]
 8007d66:	e9cd c300 	strd	ip, r3, [sp]
 8007d6a:	4631      	mov	r1, r6
 8007d6c:	465b      	mov	r3, fp
 8007d6e:	4630      	mov	r0, r6
 8007d70:	f002 f976 	bl	800a060 <celt_pitch_xcorr_c>
   for (k=0;k<=lag;k++)
 8007d74:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007d76:	ea4f 0049 	mov.w	r0, r9, lsl #1
 8007d7a:	2b00      	cmp	r3, #0
 8007d7c:	db7e      	blt.n	8007e7c <_celt_autocorr+0x22c>
 8007d7e:	f04f 0900 	mov.w	r9, #0
 8007d82:	f10b 4a00 	add.w	sl, fp, #2147483648	; 0x80000000
 8007d86:	687b      	ldr	r3, [r7, #4]
 8007d88:	f1a4 0e02 	sub.w	lr, r4, #2
 8007d8c:	f10a 3aff 	add.w	sl, sl, #4294967295
 8007d90:	6038      	str	r0, [r7, #0]
 8007d92:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8007d94:	46d8      	mov	r8, fp
 8007d96:	44b6      	add	lr, r6
 8007d98:	eb06 0a4a 	add.w	sl, r6, sl, lsl #1
 8007d9c:	f1a3 0b04 	sub.w	fp, r3, #4
   {
      for (i = k+fastN, d = 0; i < n; i++)
 8007da0:	4545      	cmp	r5, r8
 8007da2:	dd38      	ble.n	8007e16 <_celt_autocorr+0x1c6>
 8007da4:	4653      	mov	r3, sl
 8007da6:	2100      	movs	r1, #0
 8007da8:	eba8 0209 	sub.w	r2, r8, r9
 8007dac:	eb06 0242 	add.w	r2, r6, r2, lsl #1
         d = MAC16_16(d, xptr[i], xptr[i-k]);
 8007db0:	f833 cf02 	ldrh.w	ip, [r3, #2]!
 8007db4:	f932 4b02 	ldrsh.w	r4, [r2], #2
      for (i = k+fastN, d = 0; i < n; i++)
 8007db8:	459e      	cmp	lr, r3
         d = MAC16_16(d, xptr[i], xptr[i-k]);
 8007dba:	fb1c 1104 	smlabb	r1, ip, r4, r1
      for (i = k+fastN, d = 0; i < n; i++)
 8007dbe:	d1f7      	bne.n	8007db0 <_celt_autocorr+0x160>
      ac[k] += d;
 8007dc0:	f85b 3f04 	ldr.w	r3, [fp, #4]!
   for (k=0;k<=lag;k++)
 8007dc4:	f109 0901 	add.w	r9, r9, #1
      ac[k] += d;
 8007dc8:	4419      	add	r1, r3
   for (k=0;k<=lag;k++)
 8007dca:	4548      	cmp	r0, r9
 8007dcc:	f108 0801 	add.w	r8, r8, #1
 8007dd0:	f10a 0a02 	add.w	sl, sl, #2
      ac[k] += d;
 8007dd4:	f8cb 1000 	str.w	r1, [fp]
   for (k=0;k<=lag;k++)
 8007dd8:	dae2      	bge.n	8007da0 <_celt_autocorr+0x150>
 8007dda:	e9d7 0300 	ldrd	r0, r3, [r7]
 8007dde:	681b      	ldr	r3, [r3, #0]
   }
#ifdef FIXED_POINT
   shift = 2*shift;
   if (shift<=0)
 8007de0:	2800      	cmp	r0, #0
 8007de2:	d037      	beq.n	8007e54 <_celt_autocorr+0x204>
      ac[0] += SHL32((opus_int32)1, -shift);
   if (ac[0] < 268435456)
 8007de4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8007de8:	da17      	bge.n	8007e1a <_celt_autocorr+0x1ca>
   {
      int shift2 = 29 - EC_ILOG(ac[0]);
 8007dea:	fab3 f383 	clz	r3, r3
 8007dee:	1ed9      	subs	r1, r3, #3
      for (i=0;i<=lag;i++)
 8007df0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007df2:	2b00      	cmp	r3, #0
 8007df4:	db0a      	blt.n	8007e0c <_celt_autocorr+0x1bc>
 8007df6:	461c      	mov	r4, r3
 8007df8:	687b      	ldr	r3, [r7, #4]
 8007dfa:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8007dfe:	3b04      	subs	r3, #4
         ac[i] = SHL32(ac[i], shift2);
 8007e00:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8007e04:	408a      	lsls	r2, r1
      for (i=0;i<=lag;i++)
 8007e06:	42a3      	cmp	r3, r4
         ac[i] = SHL32(ac[i], shift2);
 8007e08:	601a      	str	r2, [r3, #0]
      for (i=0;i<=lag;i++)
 8007e0a:	d1f9      	bne.n	8007e00 <_celt_autocorr+0x1b0>
      shift -= shift2;
 8007e0c:	1a40      	subs	r0, r0, r1
   }
#endif

   RESTORE_STACK;
   return shift;
}
 8007e0e:	370c      	adds	r7, #12
 8007e10:	46bd      	mov	sp, r7
 8007e12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for (i = k+fastN, d = 0; i < n; i++)
 8007e16:	2100      	movs	r1, #0
 8007e18:	e7d2      	b.n	8007dc0 <_celt_autocorr+0x170>
   } else if (ac[0] >= 536870912)
 8007e1a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8007e1e:	dbf6      	blt.n	8007e0e <_celt_autocorr+0x1be>
      int shift2=1;
 8007e20:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
      for (i=0;i<=lag;i++)
 8007e24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
      int shift2=1;
 8007e26:	bfac      	ite	ge
 8007e28:	2102      	movge	r1, #2
 8007e2a:	2101      	movlt	r1, #1
      for (i=0;i<=lag;i++)
 8007e2c:	2b00      	cmp	r3, #0
 8007e2e:	db0a      	blt.n	8007e46 <_celt_autocorr+0x1f6>
 8007e30:	461c      	mov	r4, r3
 8007e32:	687b      	ldr	r3, [r7, #4]
 8007e34:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8007e38:	3b04      	subs	r3, #4
         ac[i] = SHR32(ac[i], shift2);
 8007e3a:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8007e3e:	410a      	asrs	r2, r1
      for (i=0;i<=lag;i++)
 8007e40:	429c      	cmp	r4, r3
         ac[i] = SHR32(ac[i], shift2);
 8007e42:	601a      	str	r2, [r3, #0]
      for (i=0;i<=lag;i++)
 8007e44:	d1f9      	bne.n	8007e3a <_celt_autocorr+0x1ea>
      shift += shift2;
 8007e46:	4408      	add	r0, r1
}
 8007e48:	370c      	adds	r7, #12
 8007e4a:	46bd      	mov	sp, r7
 8007e4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007e50:	687b      	ldr	r3, [r7, #4]
 8007e52:	681b      	ldr	r3, [r3, #0]
      ac[0] += SHL32((opus_int32)1, -shift);
 8007e54:	687a      	ldr	r2, [r7, #4]
 8007e56:	3301      	adds	r3, #1
 8007e58:	2000      	movs	r0, #0
 8007e5a:	6013      	str	r3, [r2, #0]
 8007e5c:	e7c2      	b.n	8007de4 <_celt_autocorr+0x194>
   celt_pitch_xcorr(xptr, xptr, ac, fastN, lag+1, arch);
 8007e5e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007e60:	687a      	ldr	r2, [r7, #4]
 8007e62:	e9cd c300 	strd	ip, r3, [sp]
 8007e66:	4641      	mov	r1, r8
 8007e68:	465b      	mov	r3, fp
 8007e6a:	4640      	mov	r0, r8
 8007e6c:	f002 f8f8 	bl	800a060 <celt_pitch_xcorr_c>
   for (k=0;k<=lag;k++)
 8007e70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007e72:	2b00      	cmp	r3, #0
 8007e74:	dbec      	blt.n	8007e50 <_celt_autocorr+0x200>
 8007e76:	4646      	mov	r6, r8
 8007e78:	2000      	movs	r0, #0
 8007e7a:	e780      	b.n	8007d7e <_celt_autocorr+0x12e>
 8007e7c:	687b      	ldr	r3, [r7, #4]
 8007e7e:	681b      	ldr	r3, [r3, #0]
 8007e80:	e7b0      	b.n	8007de4 <_celt_autocorr+0x194>
 8007e82:	bf00      	nop

08007e84 <encode_pulses>:
  }
  while(j>0);
  return i;
}

void encode_pulses(const int *_y,int _n,int _k,ec_enc *_enc){
 8007e84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007e88:	4689      	mov	r9, r1
  k=abs(_y[j]);
 8007e8a:	2402      	movs	r4, #2
void encode_pulses(const int *_y,int _n,int _k,ec_enc *_enc){
 8007e8c:	469a      	mov	sl, r3
  j=_n-1;
 8007e8e:	1e4e      	subs	r6, r1, #1
  i=_y[j]<0;
 8007e90:	f850 1026 	ldr.w	r1, [r0, r6, lsl #2]
 8007e94:	f109 4b80 	add.w	fp, r9, #1073741824	; 0x40000000
 8007e98:	f10b 3bff 	add.w	fp, fp, #4294967295
  k=abs(_y[j]);
 8007e9c:	ea81 75e1 	eor.w	r5, r1, r1, asr #31
 8007ea0:	fa0b fb04 	lsl.w	fp, fp, r4
 8007ea4:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8007f4c <encode_pulses+0xc8>
 8007ea8:	eba5 75e1 	sub.w	r5, r5, r1, asr #31
 8007eac:	eb00 0c0b 	add.w	ip, r0, fp
  i=_y[j]<0;
 8007eb0:	0fc9      	lsrs	r1, r1, #31
    i+=CELT_PVQ_U(_n-j,k);
 8007eb2:	42ac      	cmp	r4, r5
 8007eb4:	4623      	mov	r3, r4
 8007eb6:	bfa8      	it	ge
 8007eb8:	462b      	movge	r3, r5
    k+=abs(_y[j]);
 8007eba:	f85c 7d04 	ldr.w	r7, [ip, #-4]!
    i+=CELT_PVQ_U(_n-j,k);
 8007ebe:	42ac      	cmp	r4, r5
 8007ec0:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 8007ec4:	bfd4      	ite	le
 8007ec6:	ea4f 0e85 	movle.w	lr, r5, lsl #2
 8007eca:	ea4f 0e84 	movgt.w	lr, r4, lsl #2
 8007ece:	f853 300e 	ldr.w	r3, [r3, lr]
    k+=abs(_y[j]);
 8007ed2:	ea87 7ee7 	eor.w	lr, r7, r7, asr #31
 8007ed6:	ebae 7ee7 	sub.w	lr, lr, r7, asr #31
    if(_y[j]<0)i+=CELT_PVQ_U(_n-j,k+1);
 8007eda:	2f00      	cmp	r7, #0
    j--;
 8007edc:	f106 36ff 	add.w	r6, r6, #4294967295
    i+=CELT_PVQ_U(_n-j,k);
 8007ee0:	4419      	add	r1, r3
    k+=abs(_y[j]);
 8007ee2:	4475      	add	r5, lr
    if(_y[j]<0)i+=CELT_PVQ_U(_n-j,k+1);
 8007ee4:	da0c      	bge.n	8007f00 <encode_pulses+0x7c>
 8007ee6:	1c6b      	adds	r3, r5, #1
 8007ee8:	42ac      	cmp	r4, r5
 8007eea:	bfd4      	ite	le
 8007eec:	4620      	movle	r0, r4
 8007eee:	4618      	movgt	r0, r3
 8007ef0:	429c      	cmp	r4, r3
 8007ef2:	f858 0020 	ldr.w	r0, [r8, r0, lsl #2]
 8007ef6:	bfcc      	ite	gt
 8007ef8:	00a3      	lslgt	r3, r4, #2
 8007efa:	009b      	lslle	r3, r3, #2
 8007efc:	58c3      	ldr	r3, [r0, r3]
 8007efe:	4419      	add	r1, r3
  while(j>0);
 8007f00:	2e00      	cmp	r6, #0
 8007f02:	f104 0401 	add.w	r4, r4, #1
 8007f06:	dcd4      	bgt.n	8007eb2 <encode_pulses+0x2e>
  celt_assert(_k>0);
  ec_enc_uint(_enc,icwrs(_n,_y),CELT_PVQ_V(_n,_k));
 8007f08:	4591      	cmp	r9, r2
 8007f0a:	464b      	mov	r3, r9
 8007f0c:	bfa8      	it	ge
 8007f0e:	4613      	movge	r3, r2
 8007f10:	4591      	cmp	r9, r2
 8007f12:	f102 0001 	add.w	r0, r2, #1
 8007f16:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 8007f1a:	dd12      	ble.n	8007f42 <encode_pulses+0xbe>
 8007f1c:	4604      	mov	r4, r0
 8007f1e:	445b      	add	r3, fp
 8007f20:	685a      	ldr	r2, [r3, #4]
 8007f22:	4581      	cmp	r9, r0
 8007f24:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 8007f28:	bfd4      	ite	le
 8007f2a:	ea4f 0b80 	movle.w	fp, r0, lsl #2
 8007f2e:	f10b 0b04 	addgt.w	fp, fp, #4
 8007f32:	f853 300b 	ldr.w	r3, [r3, fp]
 8007f36:	4650      	mov	r0, sl
}
 8007f38:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ec_enc_uint(_enc,icwrs(_n,_y),CELT_PVQ_V(_n,_k));
 8007f3c:	441a      	add	r2, r3
 8007f3e:	f000 bdbb 	b.w	8008ab8 <ec_enc_uint>
 8007f42:	464c      	mov	r4, r9
 8007f44:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8007f48:	e7eb      	b.n	8007f22 <encode_pulses+0x9e>
 8007f4a:	bf00      	nop
 8007f4c:	08016460 	.word	0x08016460

08007f50 <decode_pulses>:
  yy=MAC16_16(yy,val,val);
  return yy;
}

opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){
  return cwrsi(_n,_k,ec_dec_uint(_dec,CELT_PVQ_V(_n,_k)),_y);
 8007f50:	428a      	cmp	r2, r1
opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){
 8007f52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007f56:	4614      	mov	r4, r2
 8007f58:	4688      	mov	r8, r1
  return cwrsi(_n,_k,ec_dec_uint(_dec,CELT_PVQ_V(_n,_k)),_y);
 8007f5a:	bfa8      	it	ge
 8007f5c:	460a      	movge	r2, r1
 8007f5e:	f8df 935c 	ldr.w	r9, [pc, #860]	; 80082bc <decode_pulses+0x36c>
 8007f62:	4544      	cmp	r4, r8
 8007f64:	f104 0601 	add.w	r6, r4, #1
 8007f68:	f859 1022 	ldr.w	r1, [r9, r2, lsl #2]
 8007f6c:	bfb4      	ite	lt
 8007f6e:	4632      	movlt	r2, r6
 8007f70:	4642      	movge	r2, r8
opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){
 8007f72:	b083      	sub	sp, #12
  return cwrsi(_n,_k,ec_dec_uint(_dec,CELT_PVQ_V(_n,_k)),_y);
 8007f74:	bfb4      	ite	lt
 8007f76:	f851 1028 	ldrlt.w	r1, [r1, r8, lsl #2]
 8007f7a:	f851 1024 	ldrge.w	r1, [r1, r4, lsl #2]
opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){
 8007f7e:	9000      	str	r0, [sp, #0]
  return cwrsi(_n,_k,ec_dec_uint(_dec,CELT_PVQ_V(_n,_k)),_y);
 8007f80:	45b0      	cmp	r8, r6
 8007f82:	f859 0022 	ldr.w	r0, [r9, r2, lsl #2]
 8007f86:	bfd4      	ite	le
 8007f88:	00b2      	lslle	r2, r6, #2
 8007f8a:	ea4f 0288 	movgt.w	r2, r8, lsl #2
 8007f8e:	5882      	ldr	r2, [r0, r2]
 8007f90:	4618      	mov	r0, r3
 8007f92:	4411      	add	r1, r2
 8007f94:	f000 fb52 	bl	800863c <ec_dec_uint>
  while(_n>2){
 8007f98:	f1b8 0f02 	cmp.w	r8, #2
 8007f9c:	f340 817e 	ble.w	800829c <decode_pulses+0x34c>
  opus_val32  yy=0;
 8007fa0:	2200      	movs	r2, #0
  while(_n>2){
 8007fa2:	f8dd a000 	ldr.w	sl, [sp]
 8007fa6:	ea4f 0388 	mov.w	r3, r8, lsl #2
    if(_k>=_n){
 8007faa:	45a0      	cmp	r8, r4
 8007fac:	9301      	str	r3, [sp, #4]
  while(_n>2){
 8007fae:	4619      	mov	r1, r3
 8007fb0:	4693      	mov	fp, r2
 8007fb2:	f10a 0a04 	add.w	sl, sl, #4
 8007fb6:	f108 33ff 	add.w	r3, r8, #4294967295
 8007fba:	fa1f fe84 	uxth.w	lr, r4
    if(_k>=_n){
 8007fbe:	f300 80af 	bgt.w	8008120 <decode_pulses+0x1d0>
      row=CELT_PVQ_U_ROW[_n];
 8007fc2:	f859 7001 	ldr.w	r7, [r9, r1]
      p=row[_k+1];
 8007fc6:	00b5      	lsls	r5, r6, #2
 8007fc8:	f857 2026 	ldr.w	r2, [r7, r6, lsl #2]
      s=-(_i>=p);
 8007fcc:	f04f 36ff 	mov.w	r6, #4294967295
 8007fd0:	4282      	cmp	r2, r0
 8007fd2:	bf88      	it	hi
 8007fd4:	2600      	movhi	r6, #0
      _i-=p&s;
 8007fd6:	ea06 0c02 	and.w	ip, r6, r2
      if(q>_i){
 8007fda:	587a      	ldr	r2, [r7, r1]
      _i-=p&s;
 8007fdc:	eba0 000c 	sub.w	r0, r0, ip
      if(q>_i){
 8007fe0:	4290      	cmp	r0, r2
 8007fe2:	eb0e 0c06 	add.w	ip, lr, r6
 8007fe6:	fa1f fc8c 	uxth.w	ip, ip
 8007fea:	b236      	sxth	r6, r6
 8007fec:	d271      	bcs.n	80080d2 <decode_pulses+0x182>
 8007fee:	eb09 0201 	add.w	r2, r9, r1
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8007ff2:	f852 4c04 	ldr.w	r4, [r2, #-4]
 8007ff6:	5865      	ldr	r5, [r4, r1]
        while(p>_i);
 8007ff8:	4285      	cmp	r5, r0
 8007ffa:	f240 8144 	bls.w	8008286 <decode_pulses+0x336>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8007ffe:	f852 5c08 	ldr.w	r5, [r2, #-8]
 8008002:	1e5c      	subs	r4, r3, #1
 8008004:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 8008006:	42a8      	cmp	r0, r5
 8008008:	d26e      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 800800a:	f852 5c0c 	ldr.w	r5, [r2, #-12]
 800800e:	f1a8 0403 	sub.w	r4, r8, #3
 8008012:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 8008014:	42a8      	cmp	r0, r5
 8008016:	d267      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008018:	f852 5c10 	ldr.w	r5, [r2, #-16]
 800801c:	f1a8 0404 	sub.w	r4, r8, #4
 8008020:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 8008022:	42a8      	cmp	r0, r5
 8008024:	d260      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008026:	f852 5c14 	ldr.w	r5, [r2, #-20]
 800802a:	f1a8 0405 	sub.w	r4, r8, #5
 800802e:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 8008030:	42a8      	cmp	r0, r5
 8008032:	d259      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008034:	f852 5c18 	ldr.w	r5, [r2, #-24]
 8008038:	f1a8 0406 	sub.w	r4, r8, #6
 800803c:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 800803e:	42a8      	cmp	r0, r5
 8008040:	d252      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008042:	f852 5c1c 	ldr.w	r5, [r2, #-28]
 8008046:	f1a8 0407 	sub.w	r4, r8, #7
 800804a:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 800804c:	42a8      	cmp	r0, r5
 800804e:	d24b      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008050:	f852 5c20 	ldr.w	r5, [r2, #-32]
 8008054:	f1a8 0408 	sub.w	r4, r8, #8
 8008058:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 800805a:	42a8      	cmp	r0, r5
 800805c:	f080 8122 	bcs.w	80082a4 <decode_pulses+0x354>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008060:	f852 5c24 	ldr.w	r5, [r2, #-36]
 8008064:	f1a3 0408 	sub.w	r4, r3, #8
 8008068:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 800806a:	42a8      	cmp	r0, r5
 800806c:	d23c      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 800806e:	f852 5c28 	ldr.w	r5, [r2, #-40]
 8008072:	f1a3 0409 	sub.w	r4, r3, #9
 8008076:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 8008078:	42a8      	cmp	r0, r5
 800807a:	d235      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 800807c:	f852 5c2c 	ldr.w	r5, [r2, #-44]
 8008080:	f1a3 040a 	sub.w	r4, r3, #10
 8008084:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 8008086:	42a8      	cmp	r0, r5
 8008088:	d22e      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 800808a:	f852 5c30 	ldr.w	r5, [r2, #-48]
 800808e:	f1a3 040b 	sub.w	r4, r3, #11
 8008092:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 8008094:	42a8      	cmp	r0, r5
 8008096:	d227      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008098:	f852 5c34 	ldr.w	r5, [r2, #-52]
 800809c:	f1a3 040c 	sub.w	r4, r3, #12
 80080a0:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 80080a2:	42a8      	cmp	r0, r5
 80080a4:	d220      	bcs.n	80080e8 <decode_pulses+0x198>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80080a6:	f852 5c38 	ldr.w	r5, [r2, #-56]
 80080aa:	f1a3 040d 	sub.w	r4, r3, #13
 80080ae:	586d      	ldr	r5, [r5, r1]
        while(p>_i);
 80080b0:	42a8      	cmp	r0, r5
 80080b2:	d219      	bcs.n	80080e8 <decode_pulses+0x198>
 80080b4:	f1a3 040e 	sub.w	r4, r3, #14
 80080b8:	fa1f fe84 	uxth.w	lr, r4
 80080bc:	ebac 0c0e 	sub.w	ip, ip, lr
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80080c0:	f852 2c3c 	ldr.w	r2, [r2, #-60]
 80080c4:	ea86 060c 	eor.w	r6, r6, ip
 80080c8:	b236      	sxth	r6, r6
 80080ca:	5855      	ldr	r5, [r2, r1]
 80080cc:	fb06 bb06 	mla	fp, r6, r6, fp
 80080d0:	e013      	b.n	80080fa <decode_pulses+0x1aa>
      else for(p=row[_k];p>_i;p=row[_k])_k--;
 80080d2:	1f2a      	subs	r2, r5, #4
 80080d4:	58bd      	ldr	r5, [r7, r2]
 80080d6:	4417      	add	r7, r2
 80080d8:	42a8      	cmp	r0, r5
 80080da:	f080 80d2 	bcs.w	8008282 <decode_pulses+0x332>
 80080de:	f857 5d04 	ldr.w	r5, [r7, #-4]!
 80080e2:	3c01      	subs	r4, #1
 80080e4:	42a8      	cmp	r0, r5
 80080e6:	d3fa      	bcc.n	80080de <decode_pulses+0x18e>
 80080e8:	fa1f fe84 	uxth.w	lr, r4
 80080ec:	ebac 0c0e 	sub.w	ip, ip, lr
 80080f0:	ea86 060c 	eor.w	r6, r6, ip
 80080f4:	b236      	sxth	r6, r6
 80080f6:	fb06 bb06 	mla	fp, r6, r6, fp
      _i-=p;
 80080fa:	1b40      	subs	r0, r0, r5
      *_y++=val;
 80080fc:	f84a 6c04 	str.w	r6, [sl, #-4]
  while(_n>2){
 8008100:	2b02      	cmp	r3, #2
 8008102:	f1a1 0104 	sub.w	r1, r1, #4
 8008106:	4698      	mov	r8, r3
 8008108:	d01d      	beq.n	8008146 <decode_pulses+0x1f6>
    if(_k>=_n){
 800810a:	45a0      	cmp	r8, r4
 800810c:	f104 0601 	add.w	r6, r4, #1
 8008110:	f10a 0a04 	add.w	sl, sl, #4
 8008114:	f108 33ff 	add.w	r3, r8, #4294967295
 8008118:	fa1f fe84 	uxth.w	lr, r4
 800811c:	f77f af51 	ble.w	8007fc2 <decode_pulses+0x72>
      p=CELT_PVQ_U_ROW[_k][_n];
 8008120:	f859 2024 	ldr.w	r2, [r9, r4, lsl #2]
      q=CELT_PVQ_U_ROW[_k+1][_n];
 8008124:	f859 5026 	ldr.w	r5, [r9, r6, lsl #2]
      p=CELT_PVQ_U_ROW[_k][_n];
 8008128:	5852      	ldr	r2, [r2, r1]
      q=CELT_PVQ_U_ROW[_k+1][_n];
 800812a:	586d      	ldr	r5, [r5, r1]
      if(p<=_i&&_i<q){
 800812c:	4282      	cmp	r2, r0
 800812e:	d832      	bhi.n	8008196 <decode_pulses+0x246>
 8008130:	4285      	cmp	r5, r0
 8008132:	d930      	bls.n	8008196 <decode_pulses+0x246>
        _i-=p;
 8008134:	1a80      	subs	r0, r0, r2
        *_y++=0;
 8008136:	2200      	movs	r2, #0
  while(_n>2){
 8008138:	2b02      	cmp	r3, #2
        *_y++=0;
 800813a:	f84a 2c04 	str.w	r2, [sl, #-4]
 800813e:	f1a1 0104 	sub.w	r1, r1, #4
 8008142:	4698      	mov	r8, r3
  while(_n>2){
 8008144:	d1e1      	bne.n	800810a <decode_pulses+0x1ba>
 8008146:	465d      	mov	r5, fp
 8008148:	4677      	mov	r7, lr
 800814a:	9b01      	ldr	r3, [sp, #4]
 800814c:	9a00      	ldr	r2, [sp, #0]
 800814e:	3b08      	subs	r3, #8
 8008150:	441a      	add	r2, r3
 8008152:	9200      	str	r2, [sp, #0]
  p=2*_k+1;
 8008154:	0064      	lsls	r4, r4, #1
 8008156:	3401      	adds	r4, #1
  s=-(_i>=p);
 8008158:	4284      	cmp	r4, r0
 800815a:	f04f 32ff 	mov.w	r2, #4294967295
 800815e:	bf88      	it	hi
 8008160:	2200      	movhi	r2, #0
  _i-=p&s;
 8008162:	4014      	ands	r4, r2
 8008164:	1b04      	subs	r4, r0, r4
  _k=(_i+1)>>1;
 8008166:	1c61      	adds	r1, r4, #1
  if(_k)_i-=2*_k-1;
 8008168:	084b      	lsrs	r3, r1, #1
 800816a:	bf18      	it	ne
 800816c:	eba1 0443 	subne.w	r4, r1, r3, lsl #1
  val=(k0-_k+s)^s;
 8008170:	4417      	add	r7, r2
 8008172:	b29b      	uxth	r3, r3
 8008174:	1aff      	subs	r7, r7, r3
 8008176:	4057      	eors	r7, r2
 8008178:	b23f      	sxth	r7, r7
  yy=MAC16_16(yy,val,val);
 800817a:	fb07 5007 	mla	r0, r7, r7, r5
  s=-(int)_i;
 800817e:	4264      	negs	r4, r4
  val=(_k+s)^s;
 8008180:	4423      	add	r3, r4
 8008182:	405c      	eors	r4, r3
 8008184:	b224      	sxth	r4, r4
}
 8008186:	fb04 0004 	mla	r0, r4, r4, r0
  *_y++=val;
 800818a:	9b00      	ldr	r3, [sp, #0]
 800818c:	601f      	str	r7, [r3, #0]
  *_y=val;
 800818e:	605c      	str	r4, [r3, #4]
}
 8008190:	b003      	add	sp, #12
 8008192:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        s=-(_i>=q);
 8008196:	4285      	cmp	r5, r0
 8008198:	f04f 32ff 	mov.w	r2, #4294967295
 800819c:	bf88      	it	hi
 800819e:	2200      	movhi	r2, #0
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80081a0:	1e67      	subs	r7, r4, #1
 80081a2:	f859 6027 	ldr.w	r6, [r9, r7, lsl #2]
        _i-=q&s;
 80081a6:	4015      	ands	r5, r2
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80081a8:	5876      	ldr	r6, [r6, r1]
        _i-=q&s;
 80081aa:	1b40      	subs	r0, r0, r5
        while(p>_i);
 80081ac:	42b0      	cmp	r0, r6
 80081ae:	d259      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80081b0:	1ea7      	subs	r7, r4, #2
 80081b2:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 80081b6:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 80081b8:	42b0      	cmp	r0, r6
 80081ba:	d253      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80081bc:	1ee7      	subs	r7, r4, #3
 80081be:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 80081c2:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 80081c4:	42b0      	cmp	r0, r6
 80081c6:	d24d      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80081c8:	1f27      	subs	r7, r4, #4
 80081ca:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 80081ce:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 80081d0:	42b0      	cmp	r0, r6
 80081d2:	d247      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80081d4:	1f67      	subs	r7, r4, #5
 80081d6:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 80081da:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 80081dc:	42b0      	cmp	r0, r6
 80081de:	d241      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80081e0:	1fa7      	subs	r7, r4, #6
 80081e2:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 80081e6:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 80081e8:	42b0      	cmp	r0, r6
 80081ea:	d23b      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80081ec:	1fe7      	subs	r7, r4, #7
 80081ee:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 80081f2:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 80081f4:	42b0      	cmp	r0, r6
 80081f6:	d235      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 80081f8:	f1a4 0708 	sub.w	r7, r4, #8
 80081fc:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 8008200:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 8008202:	42b0      	cmp	r0, r6
 8008204:	d22e      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008206:	f1a4 0709 	sub.w	r7, r4, #9
 800820a:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 800820e:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 8008210:	42b0      	cmp	r0, r6
 8008212:	d227      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008214:	f1a4 070a 	sub.w	r7, r4, #10
 8008218:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 800821c:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 800821e:	42b0      	cmp	r0, r6
 8008220:	d220      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008222:	f1a4 070b 	sub.w	r7, r4, #11
 8008226:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 800822a:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 800822c:	42b0      	cmp	r0, r6
 800822e:	d219      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 8008230:	f1a4 070c 	sub.w	r7, r4, #12
 8008234:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 8008238:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 800823a:	42b0      	cmp	r0, r6
 800823c:	d212      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 800823e:	f1a4 070d 	sub.w	r7, r4, #13
 8008242:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 8008246:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 8008248:	42b0      	cmp	r0, r6
 800824a:	d20b      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 800824c:	f1a4 070e 	sub.w	r7, r4, #14
 8008250:	f859 5027 	ldr.w	r5, [r9, r7, lsl #2]
 8008254:	586e      	ldr	r6, [r5, r1]
        while(p>_i);
 8008256:	42b0      	cmp	r0, r6
 8008258:	d204      	bcs.n	8008264 <decode_pulses+0x314>
        do p=CELT_PVQ_U_ROW[--_k][_n];
 800825a:	3c0f      	subs	r4, #15
 800825c:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
 8008260:	586e      	ldr	r6, [r5, r1]
 8008262:	e000      	b.n	8008266 <decode_pulses+0x316>
 8008264:	463c      	mov	r4, r7
        val=(k0-_k+s)^s;
 8008266:	eb0e 0502 	add.w	r5, lr, r2
 800826a:	fa1f fe84 	uxth.w	lr, r4
 800826e:	eba5 050e 	sub.w	r5, r5, lr
 8008272:	406a      	eors	r2, r5
 8008274:	b212      	sxth	r2, r2
        yy=MAC16_16(yy,val,val);
 8008276:	fb02 bb02 	mla	fp, r2, r2, fp
        _i-=p;
 800827a:	1b80      	subs	r0, r0, r6
        *_y++=val;
 800827c:	f84a 2c04 	str.w	r2, [sl, #-4]
 8008280:	e73e      	b.n	8008100 <decode_pulses+0x1b0>
      else for(p=row[_k];p>_i;p=row[_k])_k--;
 8008282:	2600      	movs	r6, #0
 8008284:	e739      	b.n	80080fa <decode_pulses+0x1aa>
 8008286:	fa1f fe83 	uxth.w	lr, r3
 800828a:	ebac 0c0e 	sub.w	ip, ip, lr
 800828e:	ea86 060c 	eor.w	r6, r6, ip
 8008292:	b236      	sxth	r6, r6
 8008294:	fb06 bb06 	mla	fp, r6, r6, fp
        while(p>_i);
 8008298:	461c      	mov	r4, r3
 800829a:	e72e      	b.n	80080fa <decode_pulses+0x1aa>
  opus_val32  yy=0;
 800829c:	2300      	movs	r3, #0
 800829e:	b2a7      	uxth	r7, r4
 80082a0:	461d      	mov	r5, r3
 80082a2:	e757      	b.n	8008154 <decode_pulses+0x204>
 80082a4:	f1a3 0e07 	sub.w	lr, r3, #7
 80082a8:	fa1f fe8e 	uxth.w	lr, lr
 80082ac:	ebac 0c0e 	sub.w	ip, ip, lr
 80082b0:	ea86 060c 	eor.w	r6, r6, ip
 80082b4:	b236      	sxth	r6, r6
 80082b6:	fb06 bb06 	mla	fp, r6, r6, fp
 80082ba:	e71e      	b.n	80080fa <decode_pulses+0x1aa>
 80082bc:	08016460 	.word	0x08016460

080082c0 <ec_tell_frac>:
  opus_uint32 nbits;
  opus_uint32 r;
  int         l;
  unsigned    b;
  nbits=_this->nbits_total<<BITRES;
  l=EC_ILOG(_this->rng);
 80082c0:	69c2      	ldr	r2, [r0, #28]
opus_uint32 ec_tell_frac(ec_ctx *_this){
 80082c2:	b410      	push	{r4}
  l=EC_ILOG(_this->rng);
 80082c4:	fab2 f382 	clz	r3, r2
  r=_this->rng>>(l-16);
 80082c8:	f1c3 0110 	rsb	r1, r3, #16
 80082cc:	40ca      	lsrs	r2, r1
  nbits=_this->nbits_total<<BITRES;
 80082ce:	6940      	ldr	r0, [r0, #20]
  b = (r>>12)-8;
  b += r>correction[b];
 80082d0:	4c08      	ldr	r4, [pc, #32]	; (80082f4 <ec_tell_frac+0x34>)
  l=EC_ILOG(_this->rng);
 80082d2:	f1c3 0320 	rsb	r3, r3, #32
  b = (r>>12)-8;
 80082d6:	0b11      	lsrs	r1, r2, #12
 80082d8:	3908      	subs	r1, #8
  l = (l<<3)+b;
 80082da:	00db      	lsls	r3, r3, #3
  return nbits-l;
 80082dc:	ebc3 03c0 	rsb	r3, r3, r0, lsl #3
  b += r>correction[b];
 80082e0:	f854 0021 	ldr.w	r0, [r4, r1, lsl #2]
  return nbits-l;
 80082e4:	1a5b      	subs	r3, r3, r1
}
 80082e6:	4290      	cmp	r0, r2
 80082e8:	bf2c      	ite	cs
 80082ea:	4618      	movcs	r0, r3
 80082ec:	1e58      	subcc	r0, r3, #1
 80082ee:	f85d 4b04 	ldr.w	r4, [sp], #4
 80082f2:	4770      	bx	lr
 80082f4:	080166a0 	.word	0x080166a0

080082f8 <ec_dec_init>:
    /*And subtract them from val, capped to be less than EC_CODE_TOP.*/
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
  }
}

void ec_dec_init(ec_dec *_this,unsigned char *_buf,opus_uint32 _storage){
 80082f8:	b4f0      	push	{r4, r5, r6, r7}
    The final value after the ec_dec_normalize() call will be the same as in
     the encoder, but we have to compensate for the bits that are added there.*/
  _this->nbits_total=EC_CODE_BITS+1
   -((EC_CODE_BITS-EC_CODE_EXTRA)/EC_SYM_BITS)*EC_SYM_BITS;
  _this->offs=0;
  _this->rng=1U<<EC_CODE_EXTRA;
 80082fa:	2380      	movs	r3, #128	; 0x80
  _this->end_offs=0;
 80082fc:	2500      	movs	r5, #0
  _this->nbits_total=EC_CODE_BITS+1
 80082fe:	2409      	movs	r4, #9
  _this->storage=_storage;
 8008300:	e9c0 1200 	strd	r1, r2, [r0]
  _this->nbits_total=EC_CODE_BITS+1
 8008304:	6144      	str	r4, [r0, #20]
  _this->rng=1U<<EC_CODE_EXTRA;
 8008306:	61c3      	str	r3, [r0, #28]
  _this->end_window=0;
 8008308:	e9c0 5502 	strd	r5, r5, [r0, #8]
  _this->nend_bits=0;
 800830c:	6105      	str	r5, [r0, #16]
  _this->offs=0;
 800830e:	6185      	str	r5, [r0, #24]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008310:	2a00      	cmp	r2, #0
 8008312:	d051      	beq.n	80083b8 <ec_dec_init+0xc0>
 8008314:	2601      	movs	r6, #1
    _this->nbits_total+=EC_SYM_BITS;
 8008316:	f04f 0c11 	mov.w	ip, #17
    _this->rng<<=EC_SYM_BITS;
 800831a:	f44f 4700 	mov.w	r7, #32768	; 0x8000
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800831e:	6186      	str	r6, [r0, #24]
 8008320:	780b      	ldrb	r3, [r1, #0]
 8008322:	42b2      	cmp	r2, r6
 8008324:	fa43 f406 	asr.w	r4, r3, r6
 8008328:	f1c4 047f 	rsb	r4, r4, #127	; 0x7f
  _this->rem=ec_read_byte(_this);
  _this->val=_this->rng-1-(_this->rem>>(EC_SYM_BITS-EC_CODE_EXTRA));
  _this->error=0;
 800832c:	62c5      	str	r5, [r0, #44]	; 0x2c
  _this->rem=ec_read_byte(_this);
 800832e:	6283      	str	r3, [r0, #40]	; 0x28
  _this->val=_this->rng-1-(_this->rem>>(EC_SYM_BITS-EC_CODE_EXTRA));
 8008330:	6204      	str	r4, [r0, #32]
    _this->nbits_total+=EC_SYM_BITS;
 8008332:	f8c0 c014 	str.w	ip, [r0, #20]
    _this->rng<<=EC_SYM_BITS;
 8008336:	61c7      	str	r7, [r0, #28]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008338:	d902      	bls.n	8008340 <ec_dec_init+0x48>
 800833a:	2602      	movs	r6, #2
 800833c:	6186      	str	r6, [r0, #24]
 800833e:	784d      	ldrb	r5, [r1, #1]
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 8008340:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008344:	ea6f 0353 	mvn.w	r3, r3, lsr #1
    _this->nbits_total+=EC_SYM_BITS;
 8008348:	f04f 0c19 	mov.w	ip, #25
    _this->rng<<=EC_SYM_BITS;
 800834c:	f44f 0700 	mov.w	r7, #8388608	; 0x800000
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008350:	0224      	lsls	r4, r4, #8
 8008352:	fa54 f383 	uxtab	r3, r4, r3
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008356:	42b2      	cmp	r2, r6
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008358:	6203      	str	r3, [r0, #32]
    _this->rem=ec_read_byte(_this);
 800835a:	6285      	str	r5, [r0, #40]	; 0x28
    _this->nbits_total+=EC_SYM_BITS;
 800835c:	f8c0 c014 	str.w	ip, [r0, #20]
    _this->rng<<=EC_SYM_BITS;
 8008360:	61c7      	str	r7, [r0, #28]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008362:	d927      	bls.n	80083b4 <ec_dec_init+0xbc>
 8008364:	1c77      	adds	r7, r6, #1
 8008366:	6187      	str	r7, [r0, #24]
 8008368:	5d8c      	ldrb	r4, [r1, r6]
 800836a:	463e      	mov	r6, r7
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 800836c:	ea44 2505 	orr.w	r5, r4, r5, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008370:	ea6f 0555 	mvn.w	r5, r5, lsr #1
    _this->rng<<=EC_SYM_BITS;
 8008374:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
    _this->nbits_total+=EC_SYM_BITS;
 8008378:	f04f 0c21 	mov.w	ip, #33	; 0x21
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800837c:	42b2      	cmp	r2, r6
 800837e:	bf98      	it	ls
 8008380:	2200      	movls	r2, #0
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008382:	ea4f 2303 	mov.w	r3, r3, lsl #8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008386:	bf88      	it	hi
 8008388:	1c72      	addhi	r2, r6, #1
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 800838a:	fa53 f385 	uxtab	r3, r3, r5
 800838e:	6203      	str	r3, [r0, #32]
    _this->rem=ec_read_byte(_this);
 8008390:	6284      	str	r4, [r0, #40]	; 0x28
    _this->rng<<=EC_SYM_BITS;
 8008392:	61c7      	str	r7, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
 8008394:	f8c0 c014 	str.w	ip, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008398:	bf84      	itt	hi
 800839a:	6182      	strhi	r2, [r0, #24]
 800839c:	5d8a      	ldrbhi	r2, [r1, r6]
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 800839e:	021b      	lsls	r3, r3, #8
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 80083a0:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 80083a4:	ea6f 0454 	mvn.w	r4, r4, lsr #1
 80083a8:	fa53 f384 	uxtab	r3, r3, r4
 80083ac:	6203      	str	r3, [r0, #32]
    _this->rem=ec_read_byte(_this);
 80083ae:	6282      	str	r2, [r0, #40]	; 0x28
  /*Normalize the interval.*/
  ec_dec_normalize(_this);
}
 80083b0:	bcf0      	pop	{r4, r5, r6, r7}
 80083b2:	4770      	bx	lr
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80083b4:	2400      	movs	r4, #0
 80083b6:	e7d9      	b.n	800836c <ec_dec_init+0x74>
  _this->error=0;
 80083b8:	62c2      	str	r2, [r0, #44]	; 0x2c
 80083ba:	247f      	movs	r4, #127	; 0x7f
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80083bc:	4613      	mov	r3, r2
  _this->error=0;
 80083be:	4616      	mov	r6, r2
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80083c0:	4615      	mov	r5, r2
 80083c2:	e7bd      	b.n	8008340 <ec_dec_init+0x48>

080083c4 <ec_decode>:
   if (d>256)
 80083c4:	f5b1 7f80 	cmp.w	r1, #256	; 0x100

unsigned ec_decode(ec_dec *_this,unsigned _ft){
 80083c8:	b470      	push	{r4, r5, r6}
  unsigned s;
  _this->ext=celt_udiv(_this->rng,_ft);
 80083ca:	69c4      	ldr	r4, [r0, #28]
 80083cc:	d822      	bhi.n	8008414 <ec_decode+0x50>
      t = EC_ILOG(d&-d);
 80083ce:	424a      	negs	r2, r1
 80083d0:	400a      	ands	r2, r1
 80083d2:	fab2 f282 	clz	r2, r2
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 80083d6:	4b11      	ldr	r3, [pc, #68]	; (800841c <ec_decode+0x58>)
      t = EC_ILOG(d&-d);
 80083d8:	f1c2 0220 	rsb	r2, r2, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 80083dc:	fa21 f502 	lsr.w	r5, r1, r2
 80083e0:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80083e4:	3a01      	subs	r2, #1
 80083e6:	fa24 f202 	lsr.w	r2, r4, r2
 80083ea:	fba2 5603 	umull	r5, r6, r2, r3
      return q+(n-q*d >= d);
 80083ee:	fb01 4216 	mls	r2, r1, r6, r4
 80083f2:	4291      	cmp	r1, r2
 80083f4:	bf8c      	ite	hi
 80083f6:	4632      	movhi	r2, r6
 80083f8:	1c72      	addls	r2, r6, #1
  s=(unsigned)(_this->val/_this->ext);
 80083fa:	6a03      	ldr	r3, [r0, #32]
  return _ft-EC_MINI(s+1,_ft);
 80083fc:	1e4c      	subs	r4, r1, #1
  s=(unsigned)(_this->val/_this->ext);
 80083fe:	fbb3 f3f2 	udiv	r3, r3, r2
  return _ft-EC_MINI(s+1,_ft);
 8008402:	1ae4      	subs	r4, r4, r3
 8008404:	3301      	adds	r3, #1
  _this->ext=celt_udiv(_this->rng,_ft);
 8008406:	6242      	str	r2, [r0, #36]	; 0x24
}
 8008408:	428b      	cmp	r3, r1
 800840a:	bf94      	ite	ls
 800840c:	4620      	movls	r0, r4
 800840e:	2000      	movhi	r0, #0
 8008410:	bc70      	pop	{r4, r5, r6}
 8008412:	4770      	bx	lr
      return n/d;
 8008414:	fbb4 f2f1 	udiv	r2, r4, r1
 8008418:	e7ef      	b.n	80083fa <ec_decode+0x36>
 800841a:	bf00      	nop
 800841c:	0801649c 	.word	0x0801649c

08008420 <ec_decode_bin>:

unsigned ec_decode_bin(ec_dec *_this,unsigned _bits){
   unsigned s;
   _this->ext=_this->rng>>_bits;
   s=(unsigned)(_this->val/_this->ext);
   return (1U<<_bits)-EC_MINI(s+1U,1U<<_bits);
 8008420:	2201      	movs	r2, #1
unsigned ec_decode_bin(ec_dec *_this,unsigned _bits){
 8008422:	b410      	push	{r4}
   s=(unsigned)(_this->val/_this->ext);
 8008424:	e9d0 4307 	ldrd	r4, r3, [r0, #28]
   _this->ext=_this->rng>>_bits;
 8008428:	40cc      	lsrs	r4, r1
   s=(unsigned)(_this->val/_this->ext);
 800842a:	fbb3 f3f4 	udiv	r3, r3, r4
   return (1U<<_bits)-EC_MINI(s+1U,1U<<_bits);
 800842e:	fa02 f101 	lsl.w	r1, r2, r1
 8008432:	1e4a      	subs	r2, r1, #1
 8008434:	1ad2      	subs	r2, r2, r3
 8008436:	3301      	adds	r3, #1
   _this->ext=_this->rng>>_bits;
 8008438:	6244      	str	r4, [r0, #36]	; 0x24
}
 800843a:	4299      	cmp	r1, r3
 800843c:	bf2c      	ite	cs
 800843e:	4610      	movcs	r0, r2
 8008440:	2000      	movcc	r0, #0
 8008442:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008446:	4770      	bx	lr

08008448 <ec_dec_update>:

void ec_dec_update(ec_dec *_this,unsigned _fl,unsigned _fh,unsigned _ft){
 8008448:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  opus_uint32 s;
  s=IMUL32(_this->ext,_ft-_fh);
 800844c:	6a45      	ldr	r5, [r0, #36]	; 0x24
 800844e:	1a9b      	subs	r3, r3, r2
 8008450:	fb05 f303 	mul.w	r3, r5, r3
  _this->val-=s;
 8008454:	6a04      	ldr	r4, [r0, #32]
 8008456:	1ae4      	subs	r4, r4, r3
 8008458:	6204      	str	r4, [r0, #32]
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
 800845a:	2900      	cmp	r1, #0
 800845c:	d140      	bne.n	80084e0 <ec_dec_update+0x98>
 800845e:	69c2      	ldr	r2, [r0, #28]
 8008460:	1ad2      	subs	r2, r2, r3
  while(_this->rng<=EC_CODE_BOT){
 8008462:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
 8008466:	61c2      	str	r2, [r0, #28]
  while(_this->rng<=EC_CODE_BOT){
 8008468:	d838      	bhi.n	80084dc <ec_dec_update+0x94>
    _this->rem=ec_read_byte(_this);
 800846a:	f04f 0c00 	mov.w	ip, #0
 800846e:	6945      	ldr	r5, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008470:	6847      	ldr	r7, [r0, #4]
 8008472:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8008474:	6986      	ldr	r6, [r0, #24]
 8008476:	3508      	adds	r5, #8
    _this->rng<<=EC_SYM_BITS;
 8008478:	0212      	lsls	r2, r2, #8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800847a:	42b7      	cmp	r7, r6
 800847c:	f106 0e01 	add.w	lr, r6, #1
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 8008480:	ea4f 2103 	mov.w	r1, r3, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008484:	ea4f 2804 	mov.w	r8, r4, lsl #8
    _this->rng<<=EC_SYM_BITS;
 8008488:	61c2      	str	r2, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
 800848a:	6145      	str	r5, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800848c:	d915      	bls.n	80084ba <ec_dec_update+0x72>
 800848e:	6801      	ldr	r1, [r0, #0]
 8008490:	f8c0 e018 	str.w	lr, [r0, #24]
 8008494:	5d89      	ldrb	r1, [r1, r6]
  while(_this->rng<=EC_CODE_BOT){
 8008496:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 800849a:	ea41 2403 	orr.w	r4, r1, r3, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 800849e:	ea6f 0464 	mvn.w	r4, r4, asr #1
 80084a2:	fa58 f484 	uxtab	r4, r8, r4
 80084a6:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 80084aa:	f105 0508 	add.w	r5, r5, #8
 80084ae:	6204      	str	r4, [r0, #32]
    _this->rem=ec_read_byte(_this);
 80084b0:	6281      	str	r1, [r0, #40]	; 0x28
  while(_this->rng<=EC_CODE_BOT){
 80084b2:	d813      	bhi.n	80084dc <ec_dec_update+0x94>
 80084b4:	4676      	mov	r6, lr
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80084b6:	460b      	mov	r3, r1
 80084b8:	e7de      	b.n	8008478 <ec_dec_update+0x30>
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 80084ba:	ea6f 0161 	mvn.w	r1, r1, asr #1
 80084be:	fa58 f481 	uxtab	r4, r8, r1
 80084c2:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
 80084c6:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 80084ca:	6204      	str	r4, [r0, #32]
    _this->rem=ec_read_byte(_this);
 80084cc:	f8c0 c028 	str.w	ip, [r0, #40]	; 0x28
 80084d0:	f105 0508 	add.w	r5, r5, #8
  while(_this->rng<=EC_CODE_BOT){
 80084d4:	d802      	bhi.n	80084dc <ec_dec_update+0x94>
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80084d6:	2100      	movs	r1, #0
 80084d8:	460b      	mov	r3, r1
 80084da:	e7cd      	b.n	8008478 <ec_dec_update+0x30>
  ec_dec_normalize(_this);
}
 80084dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
 80084e0:	1a52      	subs	r2, r2, r1
 80084e2:	fb05 f202 	mul.w	r2, r5, r2
 80084e6:	e7bc      	b.n	8008462 <ec_dec_update+0x1a>

080084e8 <ec_dec_bit_logp>:
  opus_uint32 r;
  opus_uint32 d;
  opus_uint32 s;
  int         ret;
  r=_this->rng;
  d=_this->val;
 80084e8:	e9d0 2307 	ldrd	r2, r3, [r0, #28]
  s=r>>_logp;
 80084ec:	fa22 f101 	lsr.w	r1, r2, r1
  ret=d<s;
 80084f0:	428b      	cmp	r3, r1
 80084f2:	bf34      	ite	cc
 80084f4:	f04f 0c01 	movcc.w	ip, #1
 80084f8:	f04f 0c00 	movcs.w	ip, #0
  if(!ret)_this->val=d-s;
 80084fc:	d302      	bcc.n	8008504 <ec_dec_bit_logp+0x1c>
 80084fe:	1a5b      	subs	r3, r3, r1
 8008500:	6203      	str	r3, [r0, #32]
  _this->rng=ret?s:r-s;
 8008502:	1a51      	subs	r1, r2, r1
  while(_this->rng<=EC_CODE_BOT){
 8008504:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
  _this->rng=ret?s:r-s;
 8008508:	61c1      	str	r1, [r0, #28]
  while(_this->rng<=EC_CODE_BOT){
 800850a:	d83c      	bhi.n	8008586 <ec_dec_bit_logp+0x9e>
int ec_dec_bit_logp(ec_dec *_this,unsigned _logp){
 800850c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _this->rem=ec_read_byte(_this);
 8008510:	2700      	movs	r7, #0
 8008512:	6944      	ldr	r4, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008514:	6846      	ldr	r6, [r0, #4]
 8008516:	f8d0 9028 	ldr.w	r9, [r0, #40]	; 0x28
 800851a:	6985      	ldr	r5, [r0, #24]
 800851c:	3408      	adds	r4, #8
    _this->rng<<=EC_SYM_BITS;
 800851e:	0209      	lsls	r1, r1, #8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008520:	42ae      	cmp	r6, r5
 8008522:	f105 0e01 	add.w	lr, r5, #1
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 8008526:	ea4f 2209 	mov.w	r2, r9, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 800852a:	ea4f 2803 	mov.w	r8, r3, lsl #8
    _this->rng<<=EC_SYM_BITS;
 800852e:	61c1      	str	r1, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
 8008530:	6144      	str	r4, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008532:	d915      	bls.n	8008560 <ec_dec_bit_logp+0x78>
 8008534:	6802      	ldr	r2, [r0, #0]
 8008536:	f8c0 e018 	str.w	lr, [r0, #24]
 800853a:	5d52      	ldrb	r2, [r2, r5]
  while(_this->rng<=EC_CODE_BOT){
 800853c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 8008540:	ea42 2309 	orr.w	r3, r2, r9, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008544:	ea6f 0363 	mvn.w	r3, r3, asr #1
 8008548:	fa58 f383 	uxtab	r3, r8, r3
 800854c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8008550:	f104 0408 	add.w	r4, r4, #8
 8008554:	6203      	str	r3, [r0, #32]
    _this->rem=ec_read_byte(_this);
 8008556:	6282      	str	r2, [r0, #40]	; 0x28
  while(_this->rng<=EC_CODE_BOT){
 8008558:	d812      	bhi.n	8008580 <ec_dec_bit_logp+0x98>
 800855a:	4675      	mov	r5, lr
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800855c:	4691      	mov	r9, r2
 800855e:	e7de      	b.n	800851e <ec_dec_bit_logp+0x36>
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008560:	ea6f 0262 	mvn.w	r2, r2, asr #1
 8008564:	fa58 f382 	uxtab	r3, r8, r2
 8008568:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
 800856c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008570:	6203      	str	r3, [r0, #32]
    _this->rem=ec_read_byte(_this);
 8008572:	6287      	str	r7, [r0, #40]	; 0x28
 8008574:	f104 0408 	add.w	r4, r4, #8
  while(_this->rng<=EC_CODE_BOT){
 8008578:	d802      	bhi.n	8008580 <ec_dec_bit_logp+0x98>
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800857a:	2200      	movs	r2, #0
 800857c:	4691      	mov	r9, r2
 800857e:	e7ce      	b.n	800851e <ec_dec_bit_logp+0x36>
  ec_dec_normalize(_this);
  return ret;
}
 8008580:	4660      	mov	r0, ip
 8008582:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008586:	4660      	mov	r0, ip
 8008588:	4770      	bx	lr
 800858a:	bf00      	nop

0800858c <ec_dec_icdf>:

int ec_dec_icdf(ec_dec *_this,const unsigned char *_icdf,unsigned _ftb){
 800858c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  opus_uint32 r;
  opus_uint32 d;
  opus_uint32 s;
  opus_uint32 t;
  int         ret;
  s=_this->rng;
 8008590:	69c4      	ldr	r4, [r0, #28]
 8008592:	3901      	subs	r1, #1
  d=_this->val;
  r=s>>_ftb;
 8008594:	fa24 f502 	lsr.w	r5, r4, r2
  d=_this->val;
 8008598:	6a03      	ldr	r3, [r0, #32]
  ret=-1;
 800859a:	f04f 36ff 	mov.w	r6, #4294967295
 800859e:	e000      	b.n	80085a2 <ec_dec_icdf+0x16>
 80085a0:	4614      	mov	r4, r2
  do{
    t=s;
    s=IMUL32(r,_icdf[++ret]);
 80085a2:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 80085a6:	3601      	adds	r6, #1
 80085a8:	fb05 f202 	mul.w	r2, r5, r2
  }
  while(d<s);
 80085ac:	4293      	cmp	r3, r2
 80085ae:	d3f7      	bcc.n	80085a0 <ec_dec_icdf+0x14>
  _this->val=d-s;
 80085b0:	1a9b      	subs	r3, r3, r2
  _this->rng=t-s;
 80085b2:	1aa2      	subs	r2, r4, r2
  while(_this->rng<=EC_CODE_BOT){
 80085b4:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
  _this->rng=t-s;
 80085b8:	e9c0 2307 	strd	r2, r3, [r0, #28]
  while(_this->rng<=EC_CODE_BOT){
 80085bc:	d83a      	bhi.n	8008634 <ec_dec_icdf+0xa8>
    _this->rem=ec_read_byte(_this);
 80085be:	f04f 0c00 	mov.w	ip, #0
 80085c2:	6945      	ldr	r5, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80085c4:	6847      	ldr	r7, [r0, #4]
 80085c6:	6a81      	ldr	r1, [r0, #40]	; 0x28
 80085c8:	f8d0 e018 	ldr.w	lr, [r0, #24]
 80085cc:	3508      	adds	r5, #8
    _this->rng<<=EC_SYM_BITS;
 80085ce:	0212      	lsls	r2, r2, #8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80085d0:	4577      	cmp	r7, lr
 80085d2:	f10e 0801 	add.w	r8, lr, #1
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 80085d6:	ea4f 2401 	mov.w	r4, r1, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 80085da:	ea4f 2903 	mov.w	r9, r3, lsl #8
    _this->rng<<=EC_SYM_BITS;
 80085de:	61c2      	str	r2, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
 80085e0:	6145      	str	r5, [r0, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80085e2:	d916      	bls.n	8008612 <ec_dec_icdf+0x86>
 80085e4:	6804      	ldr	r4, [r0, #0]
 80085e6:	f8c0 8018 	str.w	r8, [r0, #24]
 80085ea:	f814 400e 	ldrb.w	r4, [r4, lr]
  while(_this->rng<=EC_CODE_BOT){
 80085ee:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 80085f2:	ea44 2301 	orr.w	r3, r4, r1, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 80085f6:	ea6f 0363 	mvn.w	r3, r3, asr #1
 80085fa:	fa59 f383 	uxtab	r3, r9, r3
 80085fe:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8008602:	f105 0508 	add.w	r5, r5, #8
 8008606:	6203      	str	r3, [r0, #32]
    _this->rem=ec_read_byte(_this);
 8008608:	6284      	str	r4, [r0, #40]	; 0x28
  while(_this->rng<=EC_CODE_BOT){
 800860a:	d813      	bhi.n	8008634 <ec_dec_icdf+0xa8>
 800860c:	46c6      	mov	lr, r8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800860e:	4621      	mov	r1, r4
 8008610:	e7dd      	b.n	80085ce <ec_dec_icdf+0x42>
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008612:	ea6f 0464 	mvn.w	r4, r4, asr #1
 8008616:	fa59 f384 	uxtab	r3, r9, r4
 800861a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
 800861e:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008622:	6203      	str	r3, [r0, #32]
    _this->rem=ec_read_byte(_this);
 8008624:	f8c0 c028 	str.w	ip, [r0, #40]	; 0x28
 8008628:	f105 0508 	add.w	r5, r5, #8
  while(_this->rng<=EC_CODE_BOT){
 800862c:	d802      	bhi.n	8008634 <ec_dec_icdf+0xa8>
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800862e:	2400      	movs	r4, #0
 8008630:	4621      	mov	r1, r4
 8008632:	e7cc      	b.n	80085ce <ec_dec_icdf+0x42>
  ec_dec_normalize(_this);
  return ret;
}
 8008634:	4630      	mov	r0, r6
 8008636:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800863a:	bf00      	nop

0800863c <ec_dec_uint>:

opus_uint32 ec_dec_uint(ec_dec *_this,opus_uint32 _ft){
 800863c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned ft;
  unsigned s;
  int      ftb;
  /*In order to optimize EC_ILOG(), it is undefined for the value 0.*/
  celt_assert(_ft>1);
  _ft--;
 8008640:	f101 38ff 	add.w	r8, r1, #4294967295
  ftb=EC_ILOG(_ft);
 8008644:	fab8 f788 	clz	r7, r8
 8008648:	f1c7 0220 	rsb	r2, r7, #32
  if(ftb>EC_UINT_BITS){
 800864c:	2a08      	cmp	r2, #8
opus_uint32 ec_dec_uint(ec_dec *_this,opus_uint32 _ft){
 800864e:	b083      	sub	sp, #12
 8008650:	4603      	mov	r3, r0
 8008652:	69c6      	ldr	r6, [r0, #28]
  if(ftb>EC_UINT_BITS){
 8008654:	dd64      	ble.n	8008720 <ec_dec_uint+0xe4>
    opus_uint32 t;
    ftb-=EC_UINT_BITS;
 8008656:	f1c7 0718 	rsb	r7, r7, #24
    ft=(unsigned)(_ft>>ftb)+1;
 800865a:	fa28 fc07 	lsr.w	ip, r8, r7
 800865e:	f10c 0e01 	add.w	lr, ip, #1
   if (d>256)
 8008662:	f5be 7f80 	cmp.w	lr, #256	; 0x100
 8008666:	f200 80b1 	bhi.w	80087cc <ec_dec_uint+0x190>
      t = EC_ILOG(d&-d);
 800866a:	ea2e 040c 	bic.w	r4, lr, ip
 800866e:	fab4 f484 	clz	r4, r4
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8008672:	4a81      	ldr	r2, [pc, #516]	; (8008878 <ec_dec_uint+0x23c>)
      t = EC_ILOG(d&-d);
 8008674:	f1c4 0420 	rsb	r4, r4, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8008678:	fa2e f104 	lsr.w	r1, lr, r4
 800867c:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8008680:	3c01      	subs	r4, #1
 8008682:	fa26 f404 	lsr.w	r4, r6, r4
 8008686:	fba4 4502 	umull	r4, r5, r4, r2
      return q+(n-q*d >= d);
 800868a:	fb0e 6015 	mls	r0, lr, r5, r6
 800868e:	4586      	cmp	lr, r0
 8008690:	bf8c      	ite	hi
 8008692:	4628      	movhi	r0, r5
 8008694:	1c68      	addls	r0, r5, #1
  s=(unsigned)(_this->val/_this->ext);
 8008696:	6a1a      	ldr	r2, [r3, #32]
  _this->ext=celt_udiv(_this->rng,_ft);
 8008698:	6258      	str	r0, [r3, #36]	; 0x24
  s=(unsigned)(_this->val/_this->ext);
 800869a:	fbb2 f1f0 	udiv	r1, r2, r0
  return _ft-EC_MINI(s+1,_ft);
 800869e:	1c4c      	adds	r4, r1, #1
 80086a0:	45a6      	cmp	lr, r4
 80086a2:	bf38      	it	cc
 80086a4:	4661      	movcc	r1, ip
  s=IMUL32(_this->ext,_ft-_fh);
 80086a6:	fb01 f400 	mul.w	r4, r1, r0
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
 80086aa:	ebbc 0101 	subs.w	r1, ip, r1
 80086ae:	bf08      	it	eq
 80086b0:	1b30      	subeq	r0, r6, r4
  _this->val-=s;
 80086b2:	1b12      	subs	r2, r2, r4
  while(_this->rng<=EC_CODE_BOT){
 80086b4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
  _this->val-=s;
 80086b8:	621a      	str	r2, [r3, #32]
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
 80086ba:	9101      	str	r1, [sp, #4]
 80086bc:	61d8      	str	r0, [r3, #28]
 80086be:	f8d3 e014 	ldr.w	lr, [r3, #20]
  while(_this->rng<=EC_CODE_BOT){
 80086c2:	f200 80ac 	bhi.w	800881e <ec_dec_uint+0x1e2>
    _this->rem=ec_read_byte(_this);
 80086c6:	f04f 0a00 	mov.w	sl, #0
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80086ca:	f8d3 9004 	ldr.w	r9, [r3, #4]
 80086ce:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 80086d0:	699d      	ldr	r5, [r3, #24]
 80086d2:	f10e 0408 	add.w	r4, lr, #8
    _this->rng<<=EC_SYM_BITS;
 80086d6:	0200      	lsls	r0, r0, #8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80086d8:	45a9      	cmp	r9, r5
 80086da:	f105 0101 	add.w	r1, r5, #1
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 80086de:	ea4f 2b06 	mov.w	fp, r6, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 80086e2:	ea4f 2c02 	mov.w	ip, r2, lsl #8
    _this->rng<<=EC_SYM_BITS;
 80086e6:	61d8      	str	r0, [r3, #28]
    _this->nbits_total+=EC_SYM_BITS;
 80086e8:	615c      	str	r4, [r3, #20]
 80086ea:	46a6      	mov	lr, r4
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80086ec:	f240 8085 	bls.w	80087fa <ec_dec_uint+0x1be>
 80086f0:	681a      	ldr	r2, [r3, #0]
 80086f2:	6199      	str	r1, [r3, #24]
 80086f4:	f812 b005 	ldrb.w	fp, [r2, r5]
  while(_this->rng<=EC_CODE_BOT){
 80086f8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 80086fc:	ea4b 2206 	orr.w	r2, fp, r6, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008700:	ea6f 0262 	mvn.w	r2, r2, asr #1
 8008704:	fa5c f282 	uxtab	r2, ip, r2
 8008708:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 800870c:	f104 0408 	add.w	r4, r4, #8
 8008710:	621a      	str	r2, [r3, #32]
    _this->rem=ec_read_byte(_this);
 8008712:	f8c3 b028 	str.w	fp, [r3, #40]	; 0x28
  while(_this->rng<=EC_CODE_BOT){
 8008716:	f200 8082 	bhi.w	800881e <ec_dec_uint+0x1e2>
 800871a:	460d      	mov	r5, r1
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800871c:	465e      	mov	r6, fp
 800871e:	e7da      	b.n	80086d6 <ec_dec_uint+0x9a>
   if (d>256)
 8008720:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8008724:	d855      	bhi.n	80087d2 <ec_dec_uint+0x196>
      t = EC_ILOG(d&-d);
 8008726:	424c      	negs	r4, r1
 8008728:	400c      	ands	r4, r1
 800872a:	fab4 f484 	clz	r4, r4
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800872e:	4a52      	ldr	r2, [pc, #328]	; (8008878 <ec_dec_uint+0x23c>)
      t = EC_ILOG(d&-d);
 8008730:	f1c4 0420 	rsb	r4, r4, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 8008734:	fa21 f004 	lsr.w	r0, r1, r4
 8008738:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 800873c:	3c01      	subs	r4, #1
 800873e:	fa26 f404 	lsr.w	r4, r6, r4
 8008742:	fba4 4502 	umull	r4, r5, r4, r2
      return q+(n-q*d >= d);
 8008746:	fb01 6215 	mls	r2, r1, r5, r6
 800874a:	4291      	cmp	r1, r2
 800874c:	bf98      	it	ls
 800874e:	3501      	addls	r5, #1
  s=(unsigned)(_this->val/_this->ext);
 8008750:	6a1a      	ldr	r2, [r3, #32]
  _this->ext=celt_udiv(_this->rng,_ft);
 8008752:	625d      	str	r5, [r3, #36]	; 0x24
  s=(unsigned)(_this->val/_this->ext);
 8008754:	fbb2 f0f5 	udiv	r0, r2, r5
  return _ft-EC_MINI(s+1,_ft);
 8008758:	1c44      	adds	r4, r0, #1
 800875a:	42a1      	cmp	r1, r4
 800875c:	bf38      	it	cc
 800875e:	4640      	movcc	r0, r8
  s=IMUL32(_this->ext,_ft-_fh);
 8008760:	fb00 f105 	mul.w	r1, r0, r5
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
 8008764:	ebb8 0000 	subs.w	r0, r8, r0
 8008768:	bf08      	it	eq
 800876a:	1a75      	subeq	r5, r6, r1
  _this->val-=s;
 800876c:	1a52      	subs	r2, r2, r1
  while(_this->rng<=EC_CODE_BOT){
 800876e:	f5b5 0f00 	cmp.w	r5, #8388608	; 0x800000
  _this->val-=s;
 8008772:	621a      	str	r2, [r3, #32]
  _this->rng=_fl>0?IMUL32(_this->ext,_fh-_fl):_this->rng-s;
 8008774:	61dd      	str	r5, [r3, #28]
  while(_this->rng<=EC_CODE_BOT){
 8008776:	d87c      	bhi.n	8008872 <ec_dec_uint+0x236>
    _this->rem=ec_read_byte(_this);
 8008778:	f04f 0c00 	mov.w	ip, #0
 800877c:	695e      	ldr	r6, [r3, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800877e:	685f      	ldr	r7, [r3, #4]
 8008780:	f8d3 9028 	ldr.w	r9, [r3, #40]	; 0x28
 8008784:	f8d3 e018 	ldr.w	lr, [r3, #24]
 8008788:	3608      	adds	r6, #8
    _this->rng<<=EC_SYM_BITS;
 800878a:	022d      	lsls	r5, r5, #8
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800878c:	4577      	cmp	r7, lr
 800878e:	f10e 0101 	add.w	r1, lr, #1
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 8008792:	ea4f 2409 	mov.w	r4, r9, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 8008796:	ea4f 2802 	mov.w	r8, r2, lsl #8
    _this->rng<<=EC_SYM_BITS;
 800879a:	61dd      	str	r5, [r3, #28]
    _this->nbits_total+=EC_SYM_BITS;
 800879c:	615e      	str	r6, [r3, #20]
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 800879e:	d91b      	bls.n	80087d8 <ec_dec_uint+0x19c>
 80087a0:	681c      	ldr	r4, [r3, #0]
 80087a2:	6199      	str	r1, [r3, #24]
 80087a4:	f814 400e 	ldrb.w	r4, [r4, lr]
  while(_this->rng<=EC_CODE_BOT){
 80087a8:	f5b5 0f00 	cmp.w	r5, #8388608	; 0x800000
    sym=(sym<<EC_SYM_BITS|_this->rem)>>(EC_SYM_BITS-EC_CODE_EXTRA);
 80087ac:	ea44 2209 	orr.w	r2, r4, r9, lsl #8
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 80087b0:	ea6f 0262 	mvn.w	r2, r2, asr #1
 80087b4:	fa58 f282 	uxtab	r2, r8, r2
 80087b8:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80087bc:	f106 0608 	add.w	r6, r6, #8
 80087c0:	621a      	str	r2, [r3, #32]
    _this->rem=ec_read_byte(_this);
 80087c2:	629c      	str	r4, [r3, #40]	; 0x28
  while(_this->rng<=EC_CODE_BOT){
 80087c4:	d855      	bhi.n	8008872 <ec_dec_uint+0x236>
 80087c6:	468e      	mov	lr, r1
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80087c8:	46a1      	mov	r9, r4
 80087ca:	e7de      	b.n	800878a <ec_dec_uint+0x14e>
      return n/d;
 80087cc:	fbb6 f0fe 	udiv	r0, r6, lr
 80087d0:	e761      	b.n	8008696 <ec_dec_uint+0x5a>
 80087d2:	fbb6 f5f1 	udiv	r5, r6, r1
 80087d6:	e7bb      	b.n	8008750 <ec_dec_uint+0x114>
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 80087d8:	ea6f 0464 	mvn.w	r4, r4, asr #1
 80087dc:	fa58 f284 	uxtab	r2, r8, r4
 80087e0:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
 80087e4:	f5b5 0f00 	cmp.w	r5, #8388608	; 0x800000
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 80087e8:	621a      	str	r2, [r3, #32]
    _this->rem=ec_read_byte(_this);
 80087ea:	f8c3 c028 	str.w	ip, [r3, #40]	; 0x28
 80087ee:	f106 0608 	add.w	r6, r6, #8
  while(_this->rng<=EC_CODE_BOT){
 80087f2:	d83e      	bhi.n	8008872 <ec_dec_uint+0x236>
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 80087f4:	2400      	movs	r4, #0
 80087f6:	46a1      	mov	r9, r4
 80087f8:	e7c7      	b.n	800878a <ec_dec_uint+0x14e>
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 80087fa:	ea6f 0b6b 	mvn.w	fp, fp, asr #1
 80087fe:	fa5c f28b 	uxtab	r2, ip, fp
 8008802:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  while(_this->rng<=EC_CODE_BOT){
 8008806:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    _this->val=((_this->val<<EC_SYM_BITS)+(EC_SYM_MAX&~sym))&(EC_CODE_TOP-1);
 800880a:	621a      	str	r2, [r3, #32]
    _this->rem=ec_read_byte(_this);
 800880c:	f8c3 a028 	str.w	sl, [r3, #40]	; 0x28
 8008810:	f104 0408 	add.w	r4, r4, #8
  while(_this->rng<=EC_CODE_BOT){
 8008814:	d803      	bhi.n	800881e <ec_dec_uint+0x1e2>
  return _this->offs<_this->storage?_this->buf[_this->offs++]:0;
 8008816:	f04f 0b00 	mov.w	fp, #0
 800881a:	465e      	mov	r6, fp
 800881c:	e75b      	b.n	80086d6 <ec_dec_uint+0x9a>
opus_uint32 ec_dec_bits(ec_dec *_this,unsigned _bits){
  ec_window   window;
  int         available;
  opus_uint32 ret;
  window=_this->end_window;
  available=_this->nend_bits;
 800881e:	691a      	ldr	r2, [r3, #16]
    t=(opus_uint32)s<<ftb|ec_dec_bits(_this,ftb);
 8008820:	9e01      	ldr	r6, [sp, #4]
  if((unsigned)available<_bits){
 8008822:	4297      	cmp	r7, r2
    t=(opus_uint32)s<<ftb|ec_dec_bits(_this,ftb);
 8008824:	fa06 f607 	lsl.w	r6, r6, r7
  window=_this->end_window;
 8008828:	68dd      	ldr	r5, [r3, #12]
  if((unsigned)available<_bits){
 800882a:	d90f      	bls.n	800884c <ec_dec_uint+0x210>
 800882c:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
 8008830:	46b4      	mov	ip, r6
   _this->buf[_this->storage-++(_this->end_offs)]:0;
 8008832:	4288      	cmp	r0, r1
 8008834:	d906      	bls.n	8008844 <ec_dec_uint+0x208>
 8008836:	3101      	adds	r1, #1
 8008838:	681e      	ldr	r6, [r3, #0]
 800883a:	6099      	str	r1, [r3, #8]
 800883c:	1a44      	subs	r4, r0, r1
 800883e:	5d34      	ldrb	r4, [r6, r4]
 8008840:	4094      	lsls	r4, r2
 8008842:	4325      	orrs	r5, r4
    do{
      window|=(ec_window)ec_read_byte_from_end(_this)<<available;
      available+=EC_SYM_BITS;
 8008844:	3208      	adds	r2, #8
    }
    while(available<=EC_WINDOW_SIZE-EC_SYM_BITS);
 8008846:	2a18      	cmp	r2, #24
 8008848:	ddf3      	ble.n	8008832 <ec_dec_uint+0x1f6>
 800884a:	4666      	mov	r6, ip
  }
  ret=(opus_uint32)window&(((opus_uint32)1<<_bits)-1U);
 800884c:	f04f 30ff 	mov.w	r0, #4294967295
 8008850:	40b8      	lsls	r0, r7
 8008852:	ea25 0000 	bic.w	r0, r5, r0
    t=(opus_uint32)s<<ftb|ec_dec_bits(_this,ftb);
 8008856:	4330      	orrs	r0, r6
  window>>=_bits;
  available-=_bits;
 8008858:	1bd2      	subs	r2, r2, r7
  _this->end_window=window;
  _this->nend_bits=available;
  _this->nbits_total+=_bits;
 800885a:	eb0e 0407 	add.w	r4, lr, r7
    if(t<=_ft)return t;
 800885e:	4580      	cmp	r8, r0
  window>>=_bits;
 8008860:	fa25 f707 	lsr.w	r7, r5, r7
  _this->nbits_total+=_bits;
 8008864:	e9c3 2404 	strd	r2, r4, [r3, #16]
  _this->end_window=window;
 8008868:	60df      	str	r7, [r3, #12]
    if(t<=_ft)return t;
 800886a:	d202      	bcs.n	8008872 <ec_dec_uint+0x236>
    _this->error=1;
 800886c:	2201      	movs	r2, #1
    return _ft;
 800886e:	4640      	mov	r0, r8
    _this->error=1;
 8008870:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8008872:	b003      	add	sp, #12
 8008874:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008878:	0801649c 	.word	0x0801649c

0800887c <ec_dec_bits>:
opus_uint32 ec_dec_bits(ec_dec *_this,unsigned _bits){
 800887c:	b4f0      	push	{r4, r5, r6, r7}
  window=_this->end_window;
 800887e:	e9d0 6303 	ldrd	r6, r3, [r0, #12]
  if((unsigned)available<_bits){
 8008882:	428b      	cmp	r3, r1
opus_uint32 ec_dec_bits(ec_dec *_this,unsigned _bits){
 8008884:	4602      	mov	r2, r0
  if((unsigned)available<_bits){
 8008886:	d20d      	bcs.n	80088a4 <ec_dec_bits+0x28>
 8008888:	e9d0 0401 	ldrd	r0, r4, [r0, #4]
   _this->buf[_this->storage-++(_this->end_offs)]:0;
 800888c:	42a0      	cmp	r0, r4
 800888e:	d906      	bls.n	800889e <ec_dec_bits+0x22>
 8008890:	3401      	adds	r4, #1
 8008892:	6817      	ldr	r7, [r2, #0]
 8008894:	6094      	str	r4, [r2, #8]
 8008896:	1b05      	subs	r5, r0, r4
 8008898:	5d7d      	ldrb	r5, [r7, r5]
 800889a:	409d      	lsls	r5, r3
 800889c:	432e      	orrs	r6, r5
      available+=EC_SYM_BITS;
 800889e:	3308      	adds	r3, #8
    while(available<=EC_WINDOW_SIZE-EC_SYM_BITS);
 80088a0:	2b18      	cmp	r3, #24
 80088a2:	ddf3      	ble.n	800888c <ec_dec_bits+0x10>
  ret=(opus_uint32)window&(((opus_uint32)1<<_bits)-1U);
 80088a4:	f04f 30ff 	mov.w	r0, #4294967295
  _this->nbits_total+=_bits;
 80088a8:	6954      	ldr	r4, [r2, #20]
  available-=_bits;
 80088aa:	1a5b      	subs	r3, r3, r1
  _this->nbits_total+=_bits;
 80088ac:	440c      	add	r4, r1
  ret=(opus_uint32)window&(((opus_uint32)1<<_bits)-1U);
 80088ae:	4088      	lsls	r0, r1
  window>>=_bits;
 80088b0:	fa26 f101 	lsr.w	r1, r6, r1
  return ret;
}
 80088b4:	ea26 0000 	bic.w	r0, r6, r0
  _this->nbits_total+=_bits;
 80088b8:	6154      	str	r4, [r2, #20]
  _this->nend_bits=available;
 80088ba:	6113      	str	r3, [r2, #16]
  _this->end_window=window;
 80088bc:	60d1      	str	r1, [r2, #12]
}
 80088be:	bcf0      	pop	{r4, r5, r6, r7}
 80088c0:	4770      	bx	lr
 80088c2:	bf00      	nop

080088c4 <ec_encode>:
   if (d>256)
 80088c4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  _this->ext=0;
  _this->storage=_size;
  _this->error=0;
}

void ec_encode(ec_enc *_this,unsigned _fl,unsigned _fh,unsigned _ft){
 80088c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  opus_uint32 r;
  r=celt_udiv(_this->rng,_ft);
 80088cc:	69c6      	ldr	r6, [r0, #28]
 80088ce:	d961      	bls.n	8008994 <ec_encode+0xd0>
      return n/d;
 80088d0:	fbb6 f4f3 	udiv	r4, r6, r3
  if(_fl>0){
 80088d4:	2900      	cmp	r1, #0
 80088d6:	d176      	bne.n	80089c6 <ec_encode+0x102>
    _this->val+=_this->rng-IMUL32(r,(_ft-_fl));
    _this->rng=IMUL32(r,(_fh-_fl));
  }
  else _this->rng-=IMUL32(r,(_ft-_fh));
 80088d8:	1a9b      	subs	r3, r3, r2
 80088da:	fb04 6313 	mls	r3, r4, r3, r6
  while(_this->rng<=EC_CODE_BOT){
 80088de:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80088e2:	61c3      	str	r3, [r0, #28]
 80088e4:	d84d      	bhi.n	8008982 <ec_encode+0xbe>
      do _this->error|=ec_write_byte(_this,sym);
 80088e6:	f04f 35ff 	mov.w	r5, #4294967295
 80088ea:	6a03      	ldr	r3, [r0, #32]
    ec_enc_carry_out(_this,(int)(_this->val>>EC_CODE_SHIFT));
 80088ec:	0ddc      	lsrs	r4, r3, #23
  if(_c!=EC_SYM_MAX){
 80088ee:	2cff      	cmp	r4, #255	; 0xff
 80088f0:	d049      	beq.n	8008986 <ec_encode+0xc2>
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
 80088f2:	6a83      	ldr	r3, [r0, #40]	; 0x28
    carry=_c>>EC_SYM_BITS;
 80088f4:	ea4f 2e24 	mov.w	lr, r4, asr #8
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
 80088f8:	2b00      	cmp	r3, #0
 80088fa:	db0e      	blt.n	800891a <ec_encode+0x56>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 80088fc:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
 8008900:	6982      	ldr	r2, [r0, #24]
 8008902:	4411      	add	r1, r2
 8008904:	42b9      	cmp	r1, r7
 8008906:	d242      	bcs.n	800898e <ec_encode+0xca>
  _this->buf[_this->offs++]=(unsigned char)_value;
 8008908:	6801      	ldr	r1, [r0, #0]
 800890a:	1c56      	adds	r6, r2, #1
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
 800890c:	4473      	add	r3, lr
  _this->buf[_this->offs++]=(unsigned char)_value;
 800890e:	6186      	str	r6, [r0, #24]
 8008910:	548b      	strb	r3, [r1, r2]
  return 0;
 8008912:	2200      	movs	r2, #0
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
 8008914:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8008916:	4313      	orrs	r3, r2
 8008918:	62c3      	str	r3, [r0, #44]	; 0x2c
    if(_this->ext>0){
 800891a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800891c:	b30b      	cbz	r3, 8008962 <ec_encode+0x9e>
 800891e:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
 8008922:	6982      	ldr	r2, [r0, #24]
      sym=(EC_SYM_MAX+carry)&EC_SYM_MAX;
 8008924:	f10e 0eff 	add.w	lr, lr, #255	; 0xff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008928:	1856      	adds	r6, r2, r1
 800892a:	42be      	cmp	r6, r7
  _this->buf[_this->offs++]=(unsigned char)_value;
 800892c:	f102 0c01 	add.w	ip, r2, #1
      while(--(_this->ext)>0);
 8008930:	f103 33ff 	add.w	r3, r3, #4294967295
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008934:	d211      	bcs.n	800895a <ec_encode+0x96>
  _this->buf[_this->offs++]=(unsigned char)_value;
 8008936:	6803      	ldr	r3, [r0, #0]
 8008938:	f8c0 c018 	str.w	ip, [r0, #24]
 800893c:	f803 e002 	strb.w	lr, [r3, r2]
      while(--(_this->ext)>0);
 8008940:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8008942:	3b01      	subs	r3, #1
 8008944:	6243      	str	r3, [r0, #36]	; 0x24
 8008946:	b163      	cbz	r3, 8008962 <ec_encode+0x9e>
 8008948:	e9d0 7101 	ldrd	r7, r1, [r0, #4]
 800894c:	6982      	ldr	r2, [r0, #24]
 800894e:	3b01      	subs	r3, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008950:	1856      	adds	r6, r2, r1
 8008952:	42be      	cmp	r6, r7
  _this->buf[_this->offs++]=(unsigned char)_value;
 8008954:	f102 0c01 	add.w	ip, r2, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008958:	d3ed      	bcc.n	8008936 <ec_encode+0x72>
      do _this->error|=ec_write_byte(_this,sym);
 800895a:	62c5      	str	r5, [r0, #44]	; 0x2c
      while(--(_this->ext)>0);
 800895c:	6243      	str	r3, [r0, #36]	; 0x24
 800895e:	2b00      	cmp	r3, #0
 8008960:	d1e2      	bne.n	8008928 <ec_encode+0x64>
    _this->rem=_c&EC_SYM_MAX;
 8008962:	b2e4      	uxtb	r4, r4
 8008964:	6a03      	ldr	r3, [r0, #32]
 8008966:	6284      	str	r4, [r0, #40]	; 0x28
    _this->rng<<=EC_SYM_BITS;
 8008968:	69c2      	ldr	r2, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
 800896a:	6941      	ldr	r1, [r0, #20]
    _this->rng<<=EC_SYM_BITS;
 800896c:	0212      	lsls	r2, r2, #8
    _this->val=(_this->val<<EC_SYM_BITS)&(EC_CODE_TOP-1);
 800896e:	021b      	lsls	r3, r3, #8
 8008970:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    _this->nbits_total+=EC_SYM_BITS;
 8008974:	3108      	adds	r1, #8
  while(_this->rng<=EC_CODE_BOT){
 8008976:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    _this->rng<<=EC_SYM_BITS;
 800897a:	e9c0 2307 	strd	r2, r3, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
 800897e:	6141      	str	r1, [r0, #20]
  while(_this->rng<=EC_CODE_BOT){
 8008980:	d9b4      	bls.n	80088ec <ec_encode+0x28>
  ec_enc_normalize(_this);
}
 8008982:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else _this->ext++;
 8008986:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8008988:	3201      	adds	r2, #1
 800898a:	6242      	str	r2, [r0, #36]	; 0x24
 800898c:	e7ec      	b.n	8008968 <ec_encode+0xa4>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 800898e:	f04f 32ff 	mov.w	r2, #4294967295
 8008992:	e7bf      	b.n	8008914 <ec_encode+0x50>
      t = EC_ILOG(d&-d);
 8008994:	425c      	negs	r4, r3
 8008996:	401c      	ands	r4, r3
 8008998:	fab4 f484 	clz	r4, r4
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800899c:	4d0f      	ldr	r5, [pc, #60]	; (80089dc <ec_encode+0x118>)
      t = EC_ILOG(d&-d);
 800899e:	f1c4 0420 	rsb	r4, r4, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 80089a2:	fa23 f704 	lsr.w	r7, r3, r4
 80089a6:	f855 5027 	ldr.w	r5, [r5, r7, lsl #2]
 80089aa:	3c01      	subs	r4, #1
 80089ac:	fa26 f404 	lsr.w	r4, r6, r4
 80089b0:	fba4 7805 	umull	r7, r8, r4, r5
      return q+(n-q*d >= d);
 80089b4:	fb03 6418 	mls	r4, r3, r8, r6
 80089b8:	42a3      	cmp	r3, r4
 80089ba:	bf8c      	ite	hi
 80089bc:	4644      	movhi	r4, r8
 80089be:	f108 0401 	addls.w	r4, r8, #1
  if(_fl>0){
 80089c2:	2900      	cmp	r1, #0
 80089c4:	d088      	beq.n	80088d8 <ec_encode+0x14>
    _this->val+=_this->rng-IMUL32(r,(_ft-_fl));
 80089c6:	6a07      	ldr	r7, [r0, #32]
 80089c8:	1a5d      	subs	r5, r3, r1
 80089ca:	443e      	add	r6, r7
 80089cc:	fb04 6615 	mls	r6, r4, r5, r6
    _this->rng=IMUL32(r,(_fh-_fl));
 80089d0:	1a53      	subs	r3, r2, r1
 80089d2:	fb04 f303 	mul.w	r3, r4, r3
    _this->val+=_this->rng-IMUL32(r,(_ft-_fl));
 80089d6:	6206      	str	r6, [r0, #32]
 80089d8:	e781      	b.n	80088de <ec_encode+0x1a>
 80089da:	bf00      	nop
 80089dc:	0801649c 	.word	0x0801649c

080089e0 <ec_enc_bit_logp>:
  else _this->rng-=IMUL32(r,((1U<<_bits)-_fh));
  ec_enc_normalize(_this);
}

/*The probability of having a "one" is 1/(1<<_logp).*/
void ec_enc_bit_logp(ec_enc *_this,int _val,unsigned _logp){
 80089e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  opus_uint32 r;
  opus_uint32 s;
  opus_uint32 l;
  r=_this->rng;
  l=_this->val;
 80089e2:	e9d0 4307 	ldrd	r4, r3, [r0, #28]
  s=r>>_logp;
 80089e6:	fa24 f202 	lsr.w	r2, r4, r2
  r-=s;
 80089ea:	1aa4      	subs	r4, r4, r2
  if(_val)_this->val=l+r;
 80089ec:	b111      	cbz	r1, 80089f4 <ec_enc_bit_logp+0x14>
 80089ee:	4423      	add	r3, r4
  _this->rng=_val?s:r;
 80089f0:	4614      	mov	r4, r2
  if(_val)_this->val=l+r;
 80089f2:	6203      	str	r3, [r0, #32]
  while(_this->rng<=EC_CODE_BOT){
 80089f4:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
  _this->rng=_val?s:r;
 80089f8:	61c4      	str	r4, [r0, #28]
  while(_this->rng<=EC_CODE_BOT){
 80089fa:	d854      	bhi.n	8008aa6 <ec_enc_bit_logp+0xc6>
      do _this->error|=ec_write_byte(_this,sym);
 80089fc:	f04f 35ff 	mov.w	r5, #4294967295
    ec_enc_carry_out(_this,(int)(_this->val>>EC_CODE_SHIFT));
 8008a00:	ea4f 5ed3 	mov.w	lr, r3, lsr #23
  if(_c!=EC_SYM_MAX){
 8008a04:	f1be 0fff 	cmp.w	lr, #255	; 0xff
 8008a08:	d04e      	beq.n	8008aa8 <ec_enc_bit_logp+0xc8>
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
 8008a0a:	6a83      	ldr	r3, [r0, #40]	; 0x28
    carry=_c>>EC_SYM_BITS;
 8008a0c:	ea4f 272e 	mov.w	r7, lr, asr #8
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
 8008a10:	2b00      	cmp	r3, #0
 8008a12:	db11      	blt.n	8008a38 <ec_enc_bit_logp+0x58>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008a14:	e9d0 4201 	ldrd	r4, r2, [r0, #4]
 8008a18:	f8d0 c018 	ldr.w	ip, [r0, #24]
 8008a1c:	4462      	add	r2, ip
 8008a1e:	42a2      	cmp	r2, r4
 8008a20:	d246      	bcs.n	8008ab0 <ec_enc_bit_logp+0xd0>
  _this->buf[_this->offs++]=(unsigned char)_value;
 8008a22:	6802      	ldr	r2, [r0, #0]
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
 8008a24:	443b      	add	r3, r7
  _this->buf[_this->offs++]=(unsigned char)_value;
 8008a26:	f10c 0101 	add.w	r1, ip, #1
 8008a2a:	6181      	str	r1, [r0, #24]
 8008a2c:	f802 300c 	strb.w	r3, [r2, ip]
  return 0;
 8008a30:	2200      	movs	r2, #0
    if(_this->rem>=0)_this->error|=ec_write_byte(_this,_this->rem+carry);
 8008a32:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8008a34:	4313      	orrs	r3, r2
 8008a36:	62c3      	str	r3, [r0, #44]	; 0x2c
    if(_this->ext>0){
 8008a38:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8008a3a:	b31b      	cbz	r3, 8008a84 <ec_enc_bit_logp+0xa4>
 8008a3c:	e9d0 4201 	ldrd	r4, r2, [r0, #4]
 8008a40:	f8d0 c018 	ldr.w	ip, [r0, #24]
      sym=(EC_SYM_MAX+carry)&EC_SYM_MAX;
 8008a44:	37ff      	adds	r7, #255	; 0xff
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008a46:	eb0c 0102 	add.w	r1, ip, r2
 8008a4a:	42a1      	cmp	r1, r4
  _this->buf[_this->offs++]=(unsigned char)_value;
 8008a4c:	f10c 0601 	add.w	r6, ip, #1
      while(--(_this->ext)>0);
 8008a50:	f103 33ff 	add.w	r3, r3, #4294967295
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008a54:	d212      	bcs.n	8008a7c <ec_enc_bit_logp+0x9c>
  _this->buf[_this->offs++]=(unsigned char)_value;
 8008a56:	6803      	ldr	r3, [r0, #0]
 8008a58:	6186      	str	r6, [r0, #24]
 8008a5a:	f803 700c 	strb.w	r7, [r3, ip]
      while(--(_this->ext)>0);
 8008a5e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8008a60:	3b01      	subs	r3, #1
 8008a62:	6243      	str	r3, [r0, #36]	; 0x24
 8008a64:	b173      	cbz	r3, 8008a84 <ec_enc_bit_logp+0xa4>
 8008a66:	e9d0 4201 	ldrd	r4, r2, [r0, #4]
 8008a6a:	f8d0 c018 	ldr.w	ip, [r0, #24]
 8008a6e:	3b01      	subs	r3, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008a70:	eb0c 0102 	add.w	r1, ip, r2
 8008a74:	42a1      	cmp	r1, r4
  _this->buf[_this->offs++]=(unsigned char)_value;
 8008a76:	f10c 0601 	add.w	r6, ip, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008a7a:	d3ec      	bcc.n	8008a56 <ec_enc_bit_logp+0x76>
      do _this->error|=ec_write_byte(_this,sym);
 8008a7c:	62c5      	str	r5, [r0, #44]	; 0x2c
      while(--(_this->ext)>0);
 8008a7e:	6243      	str	r3, [r0, #36]	; 0x24
 8008a80:	2b00      	cmp	r3, #0
 8008a82:	d1e0      	bne.n	8008a46 <ec_enc_bit_logp+0x66>
    _this->rem=_c&EC_SYM_MAX;
 8008a84:	fa5f f38e 	uxtb.w	r3, lr
 8008a88:	6283      	str	r3, [r0, #40]	; 0x28
 8008a8a:	6a03      	ldr	r3, [r0, #32]
    _this->rng<<=EC_SYM_BITS;
 8008a8c:	69c2      	ldr	r2, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
 8008a8e:	6941      	ldr	r1, [r0, #20]
    _this->rng<<=EC_SYM_BITS;
 8008a90:	0212      	lsls	r2, r2, #8
    _this->val=(_this->val<<EC_SYM_BITS)&(EC_CODE_TOP-1);
 8008a92:	021b      	lsls	r3, r3, #8
 8008a94:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    _this->nbits_total+=EC_SYM_BITS;
 8008a98:	3108      	adds	r1, #8
  while(_this->rng<=EC_CODE_BOT){
 8008a9a:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    _this->rng<<=EC_SYM_BITS;
 8008a9e:	e9c0 2307 	strd	r2, r3, [r0, #28]
    _this->nbits_total+=EC_SYM_BITS;
 8008aa2:	6141      	str	r1, [r0, #20]
  while(_this->rng<=EC_CODE_BOT){
 8008aa4:	d9ac      	bls.n	8008a00 <ec_enc_bit_logp+0x20>
  ec_enc_normalize(_this);
}
 8008aa6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else _this->ext++;
 8008aa8:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8008aaa:	3201      	adds	r2, #1
 8008aac:	6242      	str	r2, [r0, #36]	; 0x24
 8008aae:	e7ed      	b.n	8008a8c <ec_enc_bit_logp+0xac>
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008ab0:	f04f 32ff 	mov.w	r2, #4294967295
 8008ab4:	e7bd      	b.n	8008a32 <ec_enc_bit_logp+0x52>
 8008ab6:	bf00      	nop

08008ab8 <ec_enc_uint>:
  }
  else _this->rng-=IMUL32(r,_icdf[_s]);
  ec_enc_normalize(_this);
}

void ec_enc_uint(ec_enc *_this,opus_uint32 _fl,opus_uint32 _ft){
 8008ab8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  unsigned  ft;
  unsigned  fl;
  int       ftb;
  /*In order to optimize EC_ILOG(), it is undefined for the value 0.*/
  celt_assert(_ft>1);
  _ft--;
 8008abc:	1e56      	subs	r6, r2, #1
  ftb=EC_ILOG(_ft);
 8008abe:	fab6 f786 	clz	r7, r6
 8008ac2:	f1c7 0320 	rsb	r3, r7, #32
  if(ftb>EC_UINT_BITS){
 8008ac6:	2b08      	cmp	r3, #8
void ec_enc_uint(ec_enc *_this,opus_uint32 _fl,opus_uint32 _ft){
 8008ac8:	460d      	mov	r5, r1
  if(ftb>EC_UINT_BITS){
 8008aca:	dc05      	bgt.n	8008ad8 <ec_enc_uint+0x20>
    fl=(unsigned)(_fl>>ftb);
    ec_encode(_this,fl,fl+1,ft);
    ec_enc_bits(_this,_fl&(((opus_uint32)1<<ftb)-1U),ftb);
  }
  else ec_encode(_this,_fl,_fl+1,_ft+1);
}
 8008acc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  else ec_encode(_this,_fl,_fl+1,_ft+1);
 8008ad0:	4613      	mov	r3, r2
 8008ad2:	1c4a      	adds	r2, r1, #1
 8008ad4:	f7ff bef6 	b.w	80088c4 <ec_encode>
    ftb-=EC_UINT_BITS;
 8008ad8:	f1c7 0718 	rsb	r7, r7, #24
    fl=(unsigned)(_fl>>ftb);
 8008adc:	40f9      	lsrs	r1, r7
    ft=(_ft>>ftb)+1;
 8008ade:	fa26 f307 	lsr.w	r3, r6, r7
    ec_encode(_this,fl,fl+1,ft);
 8008ae2:	1c4a      	adds	r2, r1, #1
 8008ae4:	3301      	adds	r3, #1
 8008ae6:	4604      	mov	r4, r0
 8008ae8:	f7ff feec 	bl	80088c4 <ec_encode>
    ec_enc_bits(_this,_fl&(((opus_uint32)1<<ftb)-1U),ftb);
 8008aec:	f04f 33ff 	mov.w	r3, #4294967295

void ec_enc_bits(ec_enc *_this,opus_uint32 _fl,unsigned _bits){
  ec_window window;
  int       used;
  window=_this->end_window;
  used=_this->nend_bits;
 8008af0:	6900      	ldr	r0, [r0, #16]
    ec_enc_bits(_this,_fl&(((opus_uint32)1<<ftb)-1U),ftb);
 8008af2:	fa03 f207 	lsl.w	r2, r3, r7
  celt_assert(_bits>0);
  if(used+_bits>EC_WINDOW_SIZE){
 8008af6:	19c1      	adds	r1, r0, r7
 8008af8:	2920      	cmp	r1, #32
    ec_enc_bits(_this,_fl&(((opus_uint32)1<<ftb)-1U),ftb);
 8008afa:	ea25 0202 	bic.w	r2, r5, r2
  window=_this->end_window;
 8008afe:	f8d4 c00c 	ldr.w	ip, [r4, #12]
  if(used+_bits>EC_WINDOW_SIZE){
 8008b02:	d915      	bls.n	8008b30 <ec_enc_uint+0x78>
    do{
      _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
 8008b04:	4699      	mov	r9, r3
 8008b06:	e9d4 1501 	ldrd	r1, r5, [r4, #4]
 8008b0a:	f8d4 e018 	ldr.w	lr, [r4, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008b0e:	eb05 030e 	add.w	r3, r5, lr
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
 8008b12:	1c6e      	adds	r6, r5, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008b14:	428b      	cmp	r3, r1
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
 8008b16:	eba1 0806 	sub.w	r8, r1, r6
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008b1a:	d214      	bcs.n	8008b46 <ec_enc_uint+0x8e>
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
 8008b1c:	6821      	ldr	r1, [r4, #0]
      window>>=EC_SYM_BITS;
      used-=EC_SYM_BITS;
 8008b1e:	3808      	subs	r0, #8
    }
    while(used>=EC_SYM_BITS);
 8008b20:	2807      	cmp	r0, #7
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
 8008b22:	60a6      	str	r6, [r4, #8]
 8008b24:	f801 c008 	strb.w	ip, [r1, r8]
      window>>=EC_SYM_BITS;
 8008b28:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
    while(used>=EC_SYM_BITS);
 8008b2c:	dceb      	bgt.n	8008b06 <ec_enc_uint+0x4e>
 8008b2e:	19c1      	adds	r1, r0, r7
  }
  window|=(ec_window)_fl<<used;
  used+=_bits;
  _this->end_window=window;
  _this->nend_bits=used;
  _this->nbits_total+=_bits;
 8008b30:	6963      	ldr	r3, [r4, #20]
  window|=(ec_window)_fl<<used;
 8008b32:	fa02 f000 	lsl.w	r0, r2, r0
 8008b36:	ea40 000c 	orr.w	r0, r0, ip
  _this->nbits_total+=_bits;
 8008b3a:	441f      	add	r7, r3
  _this->nend_bits=used;
 8008b3c:	e9c4 0103 	strd	r0, r1, [r4, #12]
  _this->nbits_total+=_bits;
 8008b40:	6167      	str	r7, [r4, #20]
}
 8008b42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      used-=EC_SYM_BITS;
 8008b46:	3808      	subs	r0, #8
    while(used>=EC_SYM_BITS);
 8008b48:	2807      	cmp	r0, #7
      _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
 8008b4a:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
      window>>=EC_SYM_BITS;
 8008b4e:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
    while(used>=EC_SYM_BITS);
 8008b52:	dcdc      	bgt.n	8008b0e <ec_enc_uint+0x56>
 8008b54:	e7eb      	b.n	8008b2e <ec_enc_uint+0x76>
 8008b56:	bf00      	nop

08008b58 <ec_enc_bits>:
void ec_enc_bits(ec_enc *_this,opus_uint32 _fl,unsigned _bits){
 8008b58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  used=_this->nend_bits;
 8008b5c:	6904      	ldr	r4, [r0, #16]
void ec_enc_bits(ec_enc *_this,opus_uint32 _fl,unsigned _bits){
 8008b5e:	4696      	mov	lr, r2
  if(used+_bits>EC_WINDOW_SIZE){
 8008b60:	18a3      	adds	r3, r4, r2
 8008b62:	2b20      	cmp	r3, #32
  window=_this->end_window;
 8008b64:	68c5      	ldr	r5, [r0, #12]
  if(used+_bits>EC_WINDOW_SIZE){
 8008b66:	d917      	bls.n	8008b98 <ec_enc_bits+0x40>
      _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
 8008b68:	f04f 39ff 	mov.w	r9, #4294967295
 8008b6c:	e9d0 6701 	ldrd	r6, r7, [r0, #4]
 8008b70:	6982      	ldr	r2, [r0, #24]
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008b72:	18bb      	adds	r3, r7, r2
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
 8008b74:	f107 0c01 	add.w	ip, r7, #1
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008b78:	42b3      	cmp	r3, r6
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
 8008b7a:	eba6 080c 	sub.w	r8, r6, ip
  if(_this->offs+_this->end_offs>=_this->storage)return -1;
 8008b7e:	d215      	bcs.n	8008bac <ec_enc_bits+0x54>
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
 8008b80:	6803      	ldr	r3, [r0, #0]
      used-=EC_SYM_BITS;
 8008b82:	3c08      	subs	r4, #8
    while(used>=EC_SYM_BITS);
 8008b84:	2c07      	cmp	r4, #7
  _this->buf[_this->storage-++(_this->end_offs)]=(unsigned char)_value;
 8008b86:	f8c0 c008 	str.w	ip, [r0, #8]
 8008b8a:	f803 5008 	strb.w	r5, [r3, r8]
      window>>=EC_SYM_BITS;
 8008b8e:	ea4f 2515 	mov.w	r5, r5, lsr #8
    while(used>=EC_SYM_BITS);
 8008b92:	dceb      	bgt.n	8008b6c <ec_enc_bits+0x14>
 8008b94:	eb04 030e 	add.w	r3, r4, lr
  _this->nbits_total+=_bits;
 8008b98:	6942      	ldr	r2, [r0, #20]
  window|=(ec_window)_fl<<used;
 8008b9a:	fa01 f404 	lsl.w	r4, r1, r4
 8008b9e:	4325      	orrs	r5, r4
  _this->nbits_total+=_bits;
 8008ba0:	4472      	add	r2, lr
  _this->nend_bits=used;
 8008ba2:	e9c0 5303 	strd	r5, r3, [r0, #12]
  _this->nbits_total+=_bits;
 8008ba6:	6142      	str	r2, [r0, #20]
}
 8008ba8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      used-=EC_SYM_BITS;
 8008bac:	3c08      	subs	r4, #8
    while(used>=EC_SYM_BITS);
 8008bae:	2c07      	cmp	r4, #7
      _this->error|=ec_write_byte_at_end(_this,(unsigned)window&EC_SYM_MAX);
 8008bb0:	f8c0 902c 	str.w	r9, [r0, #44]	; 0x2c
      window>>=EC_SYM_BITS;
 8008bb4:	ea4f 2515 	mov.w	r5, r5, lsr #8
    while(used>=EC_SYM_BITS);
 8008bb8:	dcdb      	bgt.n	8008b72 <ec_enc_bits+0x1a>
 8008bba:	e7eb      	b.n	8008b94 <ec_enc_bits+0x3c>

08008bbc <opus_fft_impl>:
}

#endif /* CUSTOM_MODES */

void opus_fft_impl(const kiss_fft_state *st,kiss_fft_cpx *fout)
{
 8008bbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008bc0:	4605      	mov	r5, r0
    int shift;

    /* st->shift can be -1 */
    shift = st->shift>0 ? st->shift : 0;

    fstride[0] = 1;
 8008bc2:	2301      	movs	r3, #1
{
 8008bc4:	b0ad      	sub	sp, #180	; 0xb4
    shift = st->shift>0 ? st->shift : 0;
 8008bc6:	68c4      	ldr	r4, [r0, #12]
    L=0;
    do {
       p = st->factors[2*L];
       m = st->factors[2*L+1];
 8008bc8:	f9b5 2012 	ldrsh.w	r2, [r5, #18]
{
 8008bcc:	9021      	str	r0, [sp, #132]	; 0x84
       p = st->factors[2*L];
 8008bce:	f9b0 0010 	ldrsh.w	r0, [r0, #16]
{
 8008bd2:	9122      	str	r1, [sp, #136]	; 0x88
       fstride[L+1] = fstride[L]*p;
       L++;
    } while(m!=1);
 8008bd4:	429a      	cmp	r2, r3
    shift = st->shift>0 ? st->shift : 0;
 8008bd6:	ea24 71e4 	bic.w	r1, r4, r4, asr #31
 8008bda:	9123      	str	r1, [sp, #140]	; 0x8c
    fstride[0] = 1;
 8008bdc:	e9cd 3024 	strd	r3, r0, [sp, #144]	; 0x90
    } while(m!=1);
 8008be0:	f000 8476 	beq.w	80094d0 <opus_fft_impl+0x914>
       fstride[L+1] = fstride[L]*p;
 8008be4:	8aab      	ldrh	r3, [r5, #20]
       m = st->factors[2*L+1];
 8008be6:	f9b5 2016 	ldrsh.w	r2, [r5, #22]
       fstride[L+1] = fstride[L]*p;
 8008bea:	fb13 f300 	smulbb	r3, r3, r0
    } while(m!=1);
 8008bee:	2a01      	cmp	r2, #1
       fstride[L+1] = fstride[L]*p;
 8008bf0:	9326      	str	r3, [sp, #152]	; 0x98
    } while(m!=1);
 8008bf2:	f000 8472 	beq.w	80094da <opus_fft_impl+0x91e>
       p = st->factors[2*L];
 8008bf6:	f9b5 1018 	ldrsh.w	r1, [r5, #24]
       m = st->factors[2*L+1];
 8008bfa:	f9b5 201a 	ldrsh.w	r2, [r5, #26]
       fstride[L+1] = fstride[L]*p;
 8008bfe:	fb03 f301 	mul.w	r3, r3, r1
    } while(m!=1);
 8008c02:	2a01      	cmp	r2, #1
       fstride[L+1] = fstride[L]*p;
 8008c04:	9327      	str	r3, [sp, #156]	; 0x9c
    } while(m!=1);
 8008c06:	f000 847f 	beq.w	8009508 <opus_fft_impl+0x94c>
       p = st->factors[2*L];
 8008c0a:	f9b5 101c 	ldrsh.w	r1, [r5, #28]
       m = st->factors[2*L+1];
 8008c0e:	f9b5 201e 	ldrsh.w	r2, [r5, #30]
       fstride[L+1] = fstride[L]*p;
 8008c12:	fb03 f301 	mul.w	r3, r3, r1
    } while(m!=1);
 8008c16:	2a01      	cmp	r2, #1
       fstride[L+1] = fstride[L]*p;
 8008c18:	9328      	str	r3, [sp, #160]	; 0xa0
    } while(m!=1);
 8008c1a:	f000 847b 	beq.w	8009514 <opus_fft_impl+0x958>
       p = st->factors[2*L];
 8008c1e:	f9b5 1020 	ldrsh.w	r1, [r5, #32]
       m = st->factors[2*L+1];
 8008c22:	f9b5 2022 	ldrsh.w	r2, [r5, #34]	; 0x22
       fstride[L+1] = fstride[L]*p;
 8008c26:	fb03 f301 	mul.w	r3, r3, r1
    } while(m!=1);
 8008c2a:	2a01      	cmp	r2, #1
       fstride[L+1] = fstride[L]*p;
 8008c2c:	9329      	str	r3, [sp, #164]	; 0xa4
    } while(m!=1);
 8008c2e:	f000 8449 	beq.w	80094c4 <opus_fft_impl+0x908>
       p = st->factors[2*L];
 8008c32:	f9b5 1024 	ldrsh.w	r1, [r5, #36]	; 0x24
       m = st->factors[2*L+1];
 8008c36:	f9b5 2026 	ldrsh.w	r2, [r5, #38]	; 0x26
       fstride[L+1] = fstride[L]*p;
 8008c3a:	fb03 f301 	mul.w	r3, r3, r1
    } while(m!=1);
 8008c3e:	2a01      	cmp	r2, #1
       fstride[L+1] = fstride[L]*p;
 8008c40:	932a      	str	r3, [sp, #168]	; 0xa8
    } while(m!=1);
 8008c42:	f000 846d 	beq.w	8009520 <opus_fft_impl+0x964>
       p = st->factors[2*L];
 8008c46:	f9b5 2028 	ldrsh.w	r2, [r5, #40]	; 0x28
       fstride[L+1] = fstride[L]*p;
 8008c4a:	2106      	movs	r1, #6
 8008c4c:	fb03 f302 	mul.w	r3, r3, r2
 8008c50:	2207      	movs	r2, #7
 8008c52:	932b      	str	r3, [sp, #172]	; 0xac
 8008c54:	462b      	mov	r3, r5
 8008c56:	9114      	str	r1, [sp, #80]	; 0x50
    m = st->factors[2*L-1];
 8008c58:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8008c5c:	f9b2 200e 	ldrsh.w	r2, [r2, #14]
 8008c60:	9209      	str	r2, [sp, #36]	; 0x24
 8008c62:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8008c64:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8008c68:	9315      	str	r3, [sp, #84]	; 0x54
 8008c6a:	4613      	mov	r3, r2
    for (i=L-1;i>=0;i--)
    {
       if (i!=0)
 8008c6c:	2b00      	cmp	r3, #0
 8008c6e:	f000 8439 	beq.w	80094e4 <opus_fft_impl+0x928>
          m2 = st->factors[2*i-1];
       else
          m2 = 1;
       switch (st->factors[2*i])
 8008c72:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8008c74:	f9b2 3010 	ldrsh.w	r3, [r2, #16]
          m2 = st->factors[2*i-1];
 8008c78:	f9b2 200e 	ldrsh.w	r2, [r2, #14]
       switch (st->factors[2*i])
 8008c7c:	3b02      	subs	r3, #2
          m2 = st->factors[2*i-1];
 8008c7e:	9217      	str	r2, [sp, #92]	; 0x5c
       switch (st->factors[2*i])
 8008c80:	2b03      	cmp	r3, #3
 8008c82:	f200 8215 	bhi.w	80090b0 <opus_fft_impl+0x4f4>
 8008c86:	e8df f013 	tbh	[pc, r3, lsl #1]
 8008c8a:	0004      	.short	0x0004
 8008c8c:	0221031b 	.word	0x0221031b
 8008c90:	008b      	.short	0x008b
          m2 = st->factors[2*i-1];
 8008c92:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8008c94:	9309      	str	r3, [sp, #36]	; 0x24
       {
       case 2:
          kf_bfly2(fout, m, fstride[i]);
 8008c96:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008c98:	aa24      	add	r2, sp, #144	; 0x90
 8008c9a:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
      for (i=0;i<N;i++)
 8008c9e:	2f00      	cmp	r7, #0
 8008ca0:	dd6e      	ble.n	8008d80 <opus_fft_impl+0x1c4>
 8008ca2:	2600      	movs	r6, #0
 8008ca4:	46b8      	mov	r8, r7
 8008ca6:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8008ca8:	3340      	adds	r3, #64	; 0x40
         t.r = S_MUL(SUB32_ovflw(Fout2[3].i, Fout2[3].r), tw);
 8008caa:	e953 1402 	ldrd	r1, r4, [r3, #-8]
         C_SUB( Fout2[3] ,  Fout[3] , t );
 8008cae:	f853 5c24 	ldr.w	r5, [r3, #-36]
         t.i = S_MUL(NEG32_ovflw(ADD32_ovflw(Fout2[3].i, Fout2[3].r)), tw);
 8008cb2:	1862      	adds	r2, r4, r1
  __asm__(
 8008cb4:	4f38      	ldr	r7, [pc, #224]	; (8008d98 <opus_fft_impl+0x1dc>)
         t.r = S_MUL(SUB32_ovflw(Fout2[3].i, Fout2[3].r), tw);
 8008cb6:	1a64      	subs	r4, r4, r1
         t.i = S_MUL(NEG32_ovflw(ADD32_ovflw(Fout2[3].i, Fout2[3].r)), tw);
 8008cb8:	4252      	negs	r2, r2
 8008cba:	fb82 c107 	smull	ip, r1, r2, r7
 8008cbe:	fb84 c207 	smull	ip, r2, r4, r7
  return SHL32(rd_hi,1);
 8008cc2:	0049      	lsls	r1, r1, #1
         C_SUB( Fout2[3] ,  Fout[3] , t );
 8008cc4:	f853 4c28 	ldr.w	r4, [r3, #-40]
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
 8008cc8:	f853 ec18 	ldr.w	lr, [r3, #-24]
 8008ccc:	f853 0c14 	ldr.w	r0, [r3, #-20]
         C_SUB( Fout2[3] ,  Fout[3] , t );
 8008cd0:	eba5 0c01 	sub.w	ip, r5, r1
 8008cd4:	0052      	lsls	r2, r2, #1
         C_ADDTO( Fout[3] ,  t );
 8008cd6:	4429      	add	r1, r5
 8008cd8:	f843 1c24 	str.w	r1, [r3, #-36]
         C_SUB( Fout2[1] ,  Fout[1] , t );
 8008cdc:	f853 5c38 	ldr.w	r5, [r3, #-56]
         C_SUB( Fout2[3] ,  Fout[3] , t );
 8008ce0:	1aa1      	subs	r1, r4, r2
         C_ADDTO( Fout[3] ,  t );
 8008ce2:	4422      	add	r2, r4
         C_SUB( Fout2[3] ,  Fout[3] , t );
 8008ce4:	f843 cc04 	str.w	ip, [r3, #-4]
 8008ce8:	f843 1c08 	str.w	r1, [r3, #-8]
         C_SUB( Fout2[1] ,  Fout[1] , t );
 8008cec:	f853 cc34 	ldr.w	ip, [r3, #-52]
         C_ADDTO( Fout[3] ,  t );
 8008cf0:	f843 2c28 	str.w	r2, [r3, #-40]
         t.r = S_MUL(ADD32_ovflw(Fout2[1].r, Fout2[1].i), tw);
 8008cf4:	eb0e 0200 	add.w	r2, lr, r0
         t.i = S_MUL(SUB32_ovflw(Fout2[1].i, Fout2[1].r), tw);
 8008cf8:	eba0 000e 	sub.w	r0, r0, lr
  __asm__(
 8008cfc:	fb82 e107 	smull	lr, r1, r2, r7
  return SHL32(rd_hi,1);
 8008d00:	0049      	lsls	r1, r1, #1
         t = Fout2[0];
 8008d02:	f853 4c1c 	ldr.w	r4, [r3, #-28]
  __asm__(
 8008d06:	fb80 e207 	smull	lr, r2, r0, r7
         C_SUB( Fout2[1] ,  Fout[1] , t );
 8008d0a:	1a68      	subs	r0, r5, r1
  return SHL32(rd_hi,1);
 8008d0c:	0052      	lsls	r2, r2, #1
         C_ADDTO( Fout[1] ,  t );
 8008d0e:	4429      	add	r1, r5
         C_SUB( Fout2[0] ,  Fout[0] , t );
 8008d10:	f853 5c3c 	ldr.w	r5, [r3, #-60]
         C_ADDTO( Fout[1] ,  t );
 8008d14:	f843 1c38 	str.w	r1, [r3, #-56]
         C_SUB( Fout2[1] ,  Fout[1] , t );
 8008d18:	ebac 0102 	sub.w	r1, ip, r2
         C_ADDTO( Fout[1] ,  t );
 8008d1c:	4462      	add	r2, ip
         C_SUB( Fout2[0] ,  Fout[0] , t );
 8008d1e:	f853 ec20 	ldr.w	lr, [r3, #-32]
         C_SUB( Fout2[1] ,  Fout[1] , t );
 8008d22:	f843 0c18 	str.w	r0, [r3, #-24]
         C_ADDTO( Fout[1] ,  t );
 8008d26:	f843 2c34 	str.w	r2, [r3, #-52]
         C_SUB( Fout2[0] ,  Fout[0] , t );
 8008d2a:	f853 0c40 	ldr.w	r0, [r3, #-64]
 8008d2e:	1b2a      	subs	r2, r5, r4
         t.i = -Fout2[2].r;
 8008d30:	f853 cc10 	ldr.w	ip, [r3, #-16]
         C_ADDTO( Fout[0] ,  t );
 8008d34:	442c      	add	r4, r5
         C_SUB( Fout2[1] ,  Fout[1] , t );
 8008d36:	f843 1c14 	str.w	r1, [r3, #-20]
         C_SUB( Fout2[2] ,  Fout[2] , t );
 8008d3a:	f853 5c0c 	ldr.w	r5, [r3, #-12]
 8008d3e:	f853 1c2c 	ldr.w	r1, [r3, #-44]
         C_SUB( Fout2[0] ,  Fout[0] , t );
 8008d42:	f843 2c1c 	str.w	r2, [r3, #-28]
         C_SUB( Fout2[2] ,  Fout[2] , t );
 8008d46:	f853 2c30 	ldr.w	r2, [r3, #-48]
         C_ADDTO( Fout[0] ,  t );
 8008d4a:	f843 4c3c 	str.w	r4, [r3, #-60]
      for (i=0;i<N;i++)
 8008d4e:	3601      	adds	r6, #1
         C_SUB( Fout2[0] ,  Fout[0] , t );
 8008d50:	eba0 040e 	sub.w	r4, r0, lr
         C_ADDTO( Fout[0] ,  t );
 8008d54:	4470      	add	r0, lr
         C_SUB( Fout2[0] ,  Fout[0] , t );
 8008d56:	f843 4c20 	str.w	r4, [r3, #-32]
         C_ADDTO( Fout[0] ,  t );
 8008d5a:	f843 0c40 	str.w	r0, [r3, #-64]
         C_SUB( Fout2[2] ,  Fout[2] , t );
 8008d5e:	eb0c 0401 	add.w	r4, ip, r1
 8008d62:	1b50      	subs	r0, r2, r5
         C_ADDTO( Fout[2] ,  t );
 8008d64:	eba1 010c 	sub.w	r1, r1, ip
 8008d68:	442a      	add	r2, r5
      for (i=0;i<N;i++)
 8008d6a:	45b0      	cmp	r8, r6
         C_ADDTO( Fout[2] ,  t );
 8008d6c:	f843 1c2c 	str.w	r1, [r3, #-44]
         C_SUB( Fout2[2] ,  Fout[2] , t );
 8008d70:	e943 0404 	strd	r0, r4, [r3, #-16]
         C_ADDTO( Fout[2] ,  t );
 8008d74:	f843 2c30 	str.w	r2, [r3, #-48]
 8008d78:	f103 0340 	add.w	r3, r3, #64	; 0x40
      for (i=0;i<N;i++)
 8008d7c:	d195      	bne.n	8008caa <opus_fft_impl+0xee>
 8008d7e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008d80:	9a15      	ldr	r2, [sp, #84]	; 0x54
    for (i=L-1;i>=0;i--)
 8008d82:	3b01      	subs	r3, #1
 8008d84:	3a04      	subs	r2, #4
 8008d86:	9215      	str	r2, [sp, #84]	; 0x54
 8008d88:	1c5a      	adds	r2, r3, #1
 8008d8a:	9314      	str	r3, [sp, #80]	; 0x50
 8008d8c:	f47f af6e 	bne.w	8008c6c <opus_fft_impl+0xb0>
          break;
 #endif
       }
       m = m2;
    }
}
 8008d90:	b02d      	add	sp, #180	; 0xb4
 8008d92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008d96:	bf00      	nop
 8008d98:	5a820000 	.word	0x5a820000
          m2 = 1;
 8008d9c:	2301      	movs	r3, #1
 8008d9e:	9317      	str	r3, [sp, #92]	; 0x5c
          kf_bfly5(fout,fstride[i]<<shift,st,m, fstride[i], m2);
 8008da0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8008da2:	aa24      	add	r2, sp, #144	; 0x90
 8008da4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8008da8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8008daa:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8008dac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   for (i=0;i<N;i++)
 8008dae:	2a00      	cmp	r2, #0
          kf_bfly5(fout,fstride[i]<<shift,st,m, fstride[i], m2);
 8008db0:	931a      	str	r3, [sp, #104]	; 0x68
 8008db2:	4613      	mov	r3, r2
 8008db4:	9219      	str	r2, [sp, #100]	; 0x64
 8008db6:	fa03 f301 	lsl.w	r3, r3, r1
   for (i=0;i<N;i++)
 8008dba:	f340 8179 	ble.w	80090b0 <opus_fft_impl+0x4f4>
      Fout3=Fout0+3*m;
 8008dbe:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008dc0:	4611      	mov	r1, r2
 8008dc2:	eb02 0042 	add.w	r0, r2, r2, lsl #1
      Fout1=Fout0+m;
 8008dc6:	00d5      	lsls	r5, r2, #3
 8008dc8:	2900      	cmp	r1, #0
      Fout2=Fout0+2*m;
 8008dca:	ea4f 1402 	mov.w	r4, r2, lsl #4
      Fout3=Fout0+3*m;
 8008dce:	ea4f 00c0 	mov.w	r0, r0, lsl #3
      Fout1=Fout0+m;
 8008dd2:	951b      	str	r5, [sp, #108]	; 0x6c
      Fout4=Fout0+4*m;
 8008dd4:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8008dd8:	f340 816a 	ble.w	80090b0 <opus_fft_impl+0x4f4>
   for (i=0;i<N;i++)
 8008ddc:	2100      	movs	r1, #0
 8008dde:	1b52      	subs	r2, r2, r5
 8008de0:	9118      	str	r1, [sp, #96]	; 0x60
 8008de2:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8008de6:	9220      	str	r2, [sp, #128]	; 0x80
 8008de8:	008a      	lsls	r2, r1, #2
 8008dea:	9213      	str	r2, [sp, #76]	; 0x4c
 8008dec:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8008dee:	1b64      	subs	r4, r4, r5
 8008df0:	00d2      	lsls	r2, r2, #3
 8008df2:	921c      	str	r2, [sp, #112]	; 0x70
 8008df4:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8008df6:	1b40      	subs	r0, r0, r5
 8008df8:	442a      	add	r2, r5
 8008dfa:	9216      	str	r2, [sp, #88]	; 0x58
 8008dfc:	009a      	lsls	r2, r3, #2
 8008dfe:	9212      	str	r2, [sp, #72]	; 0x48
 8008e00:	00da      	lsls	r2, r3, #3
 8008e02:	011b      	lsls	r3, r3, #4
 8008e04:	9310      	str	r3, [sp, #64]	; 0x40
 8008e06:	f1c5 0308 	rsb	r3, r5, #8
 8008e0a:	941f      	str	r4, [sp, #124]	; 0x7c
 8008e0c:	901e      	str	r0, [sp, #120]	; 0x78
 8008e0e:	9211      	str	r2, [sp, #68]	; 0x44
 8008e10:	931d      	str	r3, [sp, #116]	; 0x74
      Fout1=Fout0+m;
 8008e12:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8008e14:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8008e16:	469b      	mov	fp, r3
 8008e18:	920a      	str	r2, [sp, #40]	; 0x28
 8008e1a:	e9cd 2207 	strd	r2, r2, [sp, #28]
 8008e1e:	9209      	str	r2, [sp, #36]	; 0x24
 8008e20:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 8008e22:	46d9      	mov	r9, fp
 8008e24:	441a      	add	r2, r3
 8008e26:	9204      	str	r2, [sp, #16]
 8008e28:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8008e2a:	991d      	ldr	r1, [sp, #116]	; 0x74
 8008e2c:	441a      	add	r2, r3
 8008e2e:	9205      	str	r2, [sp, #20]
 8008e30:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8008e32:	441a      	add	r2, r3
 8008e34:	9206      	str	r2, [sp, #24]
 8008e36:	461a      	mov	r2, r3
 8008e38:	18cb      	adds	r3, r1, r3
 8008e3a:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8008e3c:	9301      	str	r3, [sp, #4]
 8008e3e:	188a      	adds	r2, r1, r2
 8008e40:	920f      	str	r2, [sp, #60]	; 0x3c
         scratch[0] = *Fout0;
 8008e42:	9b01      	ldr	r3, [sp, #4]
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
 8008e44:	9a0a      	ldr	r2, [sp, #40]	; 0x28
         scratch[0] = *Fout0;
 8008e46:	f853 3c04 	ldr.w	r3, [r3, #-4]
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
 8008e4a:	4615      	mov	r5, r2
         scratch[0] = *Fout0;
 8008e4c:	9302      	str	r3, [sp, #8]
         C_MUL(scratch[1] ,*Fout1, tw[u*fstride]);
 8008e4e:	f9b5 2000 	ldrsh.w	r2, [r5]
 8008e52:	e899 0003 	ldmia.w	r9, {r0, r1}
 8008e56:	f9b5 4002 	ldrsh.w	r4, [r5, #2]
 8008e5a:	fb81 6502 	smull	r6, r5, r1, r2
 8008e5e:	fbc0 6504 	smlal	r6, r5, r0, r4
 8008e62:	f1c4 0400 	rsb	r4, r4, #0
 8008e66:	fb80 2702 	smull	r2, r7, r0, r2
 8008e6a:	ea4f 36d6 	mov.w	r6, r6, lsr #15
 8008e6e:	fbc1 2704 	smlal	r2, r7, r1, r4
 8008e72:	ea46 4545 	orr.w	r5, r6, r5, lsl #17
 8008e76:	ea4f 32d2 	mov.w	r2, r2, lsr #15
 8008e7a:	ea42 4747 	orr.w	r7, r2, r7, lsl #17
         C_MUL(scratch[2] ,*Fout2, tw[2*u*fstride]);
 8008e7e:	9804      	ldr	r0, [sp, #16]
 8008e80:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8008e82:	4684      	mov	ip, r0
 8008e84:	f9b6 2000 	ldrsh.w	r2, [r6]
 8008e88:	e89c 0003 	ldmia.w	ip, {r0, r1}
 8008e8c:	f9b6 4002 	ldrsh.w	r4, [r6, #2]
 8008e90:	fb81 6c02 	smull	r6, ip, r1, r2
 8008e94:	fbc0 6c04 	smlal	r6, ip, r0, r4
 8008e98:	f1c4 0400 	rsb	r4, r4, #0
 8008e9c:	fb80 2802 	smull	r2, r8, r0, r2
 8008ea0:	ea4f 36d6 	mov.w	r6, r6, lsr #15
 8008ea4:	fbc1 2804 	smlal	r2, r8, r1, r4
 8008ea8:	ea46 4c4c 	orr.w	ip, r6, ip, lsl #17
 8008eac:	ea4f 32d2 	mov.w	r2, r2, lsr #15
 8008eb0:	ea42 4848 	orr.w	r8, r2, r8, lsl #17
         C_MUL(scratch[3] ,*Fout3, tw[3*u*fstride]);
 8008eb4:	9a05      	ldr	r2, [sp, #20]
 8008eb6:	9c08      	ldr	r4, [sp, #32]
 8008eb8:	4696      	mov	lr, r2
 8008eba:	f9b4 2000 	ldrsh.w	r2, [r4]
 8008ebe:	e89e 0003 	ldmia.w	lr, {r0, r1}
 8008ec2:	f9b4 6002 	ldrsh.w	r6, [r4, #2]
 8008ec6:	fb81 a402 	smull	sl, r4, r1, r2
 8008eca:	fbc0 a406 	smlal	sl, r4, r0, r6
 8008ece:	f1c6 0600 	rsb	r6, r6, #0
 8008ed2:	fb80 2e02 	smull	r2, lr, r0, r2
 8008ed6:	ea4f 3ada 	mov.w	sl, sl, lsr #15
 8008eda:	fbc1 2e06 	smlal	r2, lr, r1, r6
 8008ede:	ea4a 4444 	orr.w	r4, sl, r4, lsl #17
 8008ee2:	ea4f 32d2 	mov.w	r2, r2, lsr #15
 8008ee6:	ea42 4e4e 	orr.w	lr, r2, lr, lsl #17
         C_MUL(scratch[4] ,*Fout4, tw[4*u*fstride]);
 8008eea:	e9dd 6006 	ldrd	r6, r0, [sp, #24]
 8008eee:	4682      	mov	sl, r0
 8008ef0:	f9ba 3000 	ldrsh.w	r3, [sl]
 8008ef4:	e896 0003 	ldmia.w	r6, {r0, r1}
 8008ef8:	f9ba a002 	ldrsh.w	sl, [sl, #2]
 8008efc:	fb81 b203 	smull	fp, r2, r1, r3
 8008f00:	fbc0 b20a 	smlal	fp, r2, r0, sl
 8008f04:	f1ca 0a00 	rsb	sl, sl, #0
 8008f08:	fb80 3603 	smull	r3, r6, r0, r3
 8008f0c:	ea4f 3bdb 	mov.w	fp, fp, lsr #15
 8008f10:	fbc1 360a 	smlal	r3, r6, r1, sl
 8008f14:	ea4b 4242 	orr.w	r2, fp, r2, lsl #17
 8008f18:	ea4f 33d3 	mov.w	r3, r3, lsr #15
 8008f1c:	ea43 4646 	orr.w	r6, r3, r6, lsl #17
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
 8008f20:	9801      	ldr	r0, [sp, #4]
         C_ADD( scratch[8],scratch[2],scratch[3]);
 8008f22:	eb08 010e 	add.w	r1, r8, lr
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
 8008f26:	f850 0c08 	ldr.w	r0, [r0, #-8]
         C_ADD( scratch[8],scratch[2],scratch[3]);
 8008f2a:	eb0c 0a04 	add.w	sl, ip, r4
         C_SUB( scratch[9],scratch[2],scratch[3]);
 8008f2e:	eba8 0e0e 	sub.w	lr, r8, lr
         C_ADD( scratch[8],scratch[2],scratch[3]);
 8008f32:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
         C_SUB( scratch[9],scratch[2],scratch[3]);
 8008f36:	f8cd e034 	str.w	lr, [sp, #52]	; 0x34
         C_ADD( scratch[7],scratch[1],scratch[4]);
 8008f3a:	eb07 0e06 	add.w	lr, r7, r6
         C_SUB( scratch[10],scratch[1],scratch[4]);
 8008f3e:	1bbf      	subs	r7, r7, r6
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
 8008f40:	9003      	str	r0, [sp, #12]
         C_SUB( scratch[10],scratch[1],scratch[4]);
 8008f42:	970b      	str	r7, [sp, #44]	; 0x2c
  __asm__(
 8008f44:	4b5c      	ldr	r3, [pc, #368]	; (80090b8 <opus_fft_impl+0x4fc>)
 8008f46:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 8008f48:	fb81 0a03 	smull	r0, sl, r1, r3
 8008f4c:	fb87 6b03 	smull	r6, fp, r7, r3
 8008f50:	4b5a      	ldr	r3, [pc, #360]	; (80090bc <opus_fft_impl+0x500>)
 8008f52:	fb81 7603 	smull	r7, r6, r1, r3
  return SHL32(rd_hi,1);
 8008f56:	0076      	lsls	r6, r6, #1
 8008f58:	960e      	str	r6, [sp, #56]	; 0x38
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
 8008f5a:	9e03      	ldr	r6, [sp, #12]
         C_SUB( scratch[9],scratch[2],scratch[3]);
 8008f5c:	ebac 0404 	sub.w	r4, ip, r4
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
 8008f60:	eb0e 0c01 	add.w	ip, lr, r1
         C_ADD( scratch[7],scratch[1],scratch[4]);
 8008f64:	18a8      	adds	r0, r5, r2
         C_SUB( scratch[10],scratch[1],scratch[4]);
 8008f66:	1aaa      	subs	r2, r5, r2
  __asm__(
 8008f68:	4d55      	ldr	r5, [pc, #340]	; (80090c0 <opus_fft_impl+0x504>)
 8008f6a:	fb84 1705 	smull	r1, r7, r4, r5
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
 8008f6e:	eb0c 0106 	add.w	r1, ip, r6
 8008f72:	4e54      	ldr	r6, [pc, #336]	; (80090c4 <opus_fft_impl+0x508>)
 8008f74:	fb84 5806 	smull	r5, r8, r4, r6
         Fout0->i = ADD32_ovflw(Fout0->i, ADD32_ovflw(scratch[7].i, scratch[8].i));
 8008f78:	9c0c      	ldr	r4, [sp, #48]	; 0x30
         Fout0->r = ADD32_ovflw(Fout0->r, ADD32_ovflw(scratch[7].r, scratch[8].r));
 8008f7a:	9d01      	ldr	r5, [sp, #4]
 8008f7c:	46a4      	mov	ip, r4
 8008f7e:	f845 1c08 	str.w	r1, [r5, #-8]
         Fout0->i = ADD32_ovflw(Fout0->i, ADD32_ovflw(scratch[7].i, scratch[8].i));
 8008f82:	1901      	adds	r1, r0, r4
 8008f84:	fb8c 4503 	smull	r4, r5, ip, r3
  return SHL32(rd_hi,1);
 8008f88:	006c      	lsls	r4, r5, #1
 8008f8a:	940c      	str	r4, [sp, #48]	; 0x30
 8008f8c:	9c02      	ldr	r4, [sp, #8]
  __asm__(
 8008f8e:	4d4c      	ldr	r5, [pc, #304]	; (80090c0 <opus_fft_impl+0x504>)
 8008f90:	4421      	add	r1, r4
 8008f92:	9c01      	ldr	r4, [sp, #4]
  return SHL32(rd_hi,1);
 8008f94:	007f      	lsls	r7, r7, #1
 8008f96:	f844 1c04 	str.w	r1, [r4, #-4]
  __asm__(
 8008f9a:	fb82 1406 	smull	r1, r4, r2, r6
 8008f9e:	fb82 c105 	smull	ip, r1, r2, r5
  return SHL32(rd_hi,1);
 8008fa2:	0049      	lsls	r1, r1, #1
         scratch[6].r =  ADD32_ovflw(S_MUL(scratch[10].i,ya.i), S_MUL(scratch[9].i,yb.i));
 8008fa4:	eb07 0444 	add.w	r4, r7, r4, lsl #1
  __asm__(
 8008fa8:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8008faa:	fb8e 2703 	smull	r2, r7, lr, r3
         scratch[12].r = SUB32_ovflw(S_MUL(scratch[9].i,ya.i), S_MUL(scratch[10].i,yb.i));
 8008fae:	ebc1 0848 	rsb	r8, r1, r8, lsl #1
  return SHL32(rd_hi,1);
 8008fb2:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
  __asm__(
 8008fb6:	fb86 2105 	smull	r2, r1, r6, r5
         scratch[5].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,ya.r), S_MUL(scratch[8].r,yb.r)));
 8008fba:	9a03      	ldr	r2, [sp, #12]
 8008fbc:	eb0a 0a47 	add.w	sl, sl, r7, lsl #1
 8008fc0:	4492      	add	sl, r2
 8008fc2:	4b3d      	ldr	r3, [pc, #244]	; (80090b8 <opus_fft_impl+0x4fc>)
 8008fc4:	fb8e 7203 	smull	r7, r2, lr, r3
 8008fc8:	46b6      	mov	lr, r6
 8008fca:	4e3e      	ldr	r6, [pc, #248]	; (80090c4 <opus_fft_impl+0x508>)
 8008fcc:	fb8e c706 	smull	ip, r7, lr, r6
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
 8008fd0:	9e0e      	ldr	r6, [sp, #56]	; 0x38
  return SHL32(rd_hi,1);
 8008fd2:	ea4f 0b4b 	mov.w	fp, fp, lsl #1
  __asm__(
 8008fd6:	461d      	mov	r5, r3
 8008fd8:	eb06 0642 	add.w	r6, r6, r2, lsl #1
 8008fdc:	4b37      	ldr	r3, [pc, #220]	; (80090bc <opus_fft_impl+0x500>)
 8008fde:	fb80 c203 	smull	ip, r2, r0, r3
         scratch[5].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,ya.r), S_MUL(scratch[8].i,yb.r)));
 8008fe2:	eb0b 0b42 	add.w	fp, fp, r2, lsl #1
 8008fe6:	9a02      	ldr	r2, [sp, #8]
 8008fe8:	4b36      	ldr	r3, [pc, #216]	; (80090c4 <opus_fft_impl+0x508>)
 8008fea:	4493      	add	fp, r2
 8008fec:	fb80 2c05 	smull	r2, ip, r0, r5
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
 8008ff0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8008ff2:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8008ff4:	eb02 054c 	add.w	r5, r2, ip, lsl #1
 8008ff8:	4684      	mov	ip, r0
 8008ffa:	fb8c 0203 	smull	r0, r2, ip, r3
         scratch[11].r = ADD32_ovflw(scratch[0].r, ADD32_ovflw(S_MUL(scratch[7].r,yb.r), S_MUL(scratch[8].r,ya.r)));
 8008ffe:	9803      	ldr	r0, [sp, #12]
 8009000:	4b2f      	ldr	r3, [pc, #188]	; (80090c0 <opus_fft_impl+0x504>)
 8009002:	4406      	add	r6, r0
 8009004:	980b      	ldr	r0, [sp, #44]	; 0x2c
  return SHL32(rd_hi,1);
 8009006:	0049      	lsls	r1, r1, #1
  __asm__(
 8009008:	4686      	mov	lr, r0
 800900a:	fb8e c003 	smull	ip, r0, lr, r3
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
 800900e:	9b02      	ldr	r3, [sp, #8]
         scratch[6].i = NEG32_ovflw(ADD32_ovflw(S_MUL(scratch[10].r,ya.i), S_MUL(scratch[9].r,yb.i)));
 8009010:	eb01 0142 	add.w	r1, r1, r2, lsl #1
  return SHL32(rd_hi,1);
 8009014:	007f      	lsls	r7, r7, #1
         scratch[12].i = SUB32_ovflw(S_MUL(scratch[10].r,yb.i), S_MUL(scratch[9].r,ya.i));
 8009016:	ebc7 0740 	rsb	r7, r7, r0, lsl #1
         scratch[11].i = ADD32_ovflw(scratch[0].i, ADD32_ovflw(S_MUL(scratch[7].i,yb.r), S_MUL(scratch[8].i,ya.r)));
 800901a:	441d      	add	r5, r3
         C_SUB(*Fout1,scratch[5],scratch[6]);
 800901c:	eb0b 0001 	add.w	r0, fp, r1
 8009020:	f8c9 0004 	str.w	r0, [r9, #4]
 8009024:	9b0a      	ldr	r3, [sp, #40]	; 0x28
         C_ADD(*Fout2,scratch[11],scratch[12]);
 8009026:	19e8      	adds	r0, r5, r7
         C_SUB(*Fout3,scratch[11],scratch[12]);
 8009028:	1bed      	subs	r5, r5, r7
 800902a:	9f12      	ldr	r7, [sp, #72]	; 0x48
         C_SUB(*Fout1,scratch[5],scratch[6]);
 800902c:	ebaa 0204 	sub.w	r2, sl, r4
 8009030:	19df      	adds	r7, r3, r7
 8009032:	970a      	str	r7, [sp, #40]	; 0x28
 8009034:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009036:	9f11      	ldr	r7, [sp, #68]	; 0x44
 8009038:	f8c9 2000 	str.w	r2, [r9]
 800903c:	443b      	add	r3, r7
 800903e:	9309      	str	r3, [sp, #36]	; 0x24
         C_ADD(*Fout4,scratch[5],scratch[6]);
 8009040:	eb04 0c0a 	add.w	ip, r4, sl
 8009044:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8009046:	9c08      	ldr	r4, [sp, #32]
 8009048:	9f06      	ldr	r7, [sp, #24]
 800904a:	441c      	add	r4, r3
 800904c:	ebab 0101 	sub.w	r1, fp, r1
 8009050:	6079      	str	r1, [r7, #4]
 8009052:	9b07      	ldr	r3, [sp, #28]
         C_ADD(*Fout2,scratch[11],scratch[12]);
 8009054:	9904      	ldr	r1, [sp, #16]
 8009056:	9408      	str	r4, [sp, #32]
 8009058:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800905a:	eb06 0208 	add.w	r2, r6, r8
 800905e:	4423      	add	r3, r4
 8009060:	460c      	mov	r4, r1
 8009062:	9307      	str	r3, [sp, #28]
 8009064:	9b01      	ldr	r3, [sp, #4]
         C_ADD(*Fout4,scratch[5],scratch[6]);
 8009066:	f8c7 c000 	str.w	ip, [r7]
 800906a:	3308      	adds	r3, #8
         C_ADD(*Fout2,scratch[11],scratch[12]);
 800906c:	600a      	str	r2, [r1, #0]
 800906e:	6048      	str	r0, [r1, #4]
 8009070:	9301      	str	r3, [sp, #4]
         C_SUB(*Fout3,scratch[11],scratch[12]);
 8009072:	9905      	ldr	r1, [sp, #20]
         ++Fout0;++Fout1;++Fout2;++Fout3;++Fout4;
 8009074:	f107 0308 	add.w	r3, r7, #8
 8009078:	9306      	str	r3, [sp, #24]
 800907a:	f104 0308 	add.w	r3, r4, #8
 800907e:	9304      	str	r3, [sp, #16]
 8009080:	f101 0308 	add.w	r3, r1, #8
 8009084:	9305      	str	r3, [sp, #20]
      for ( u=0; u<m; ++u ) {
 8009086:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
         ++Fout0;++Fout1;++Fout2;++Fout3;++Fout4;
 8009088:	f109 0908 	add.w	r9, r9, #8
         C_SUB(*Fout3,scratch[11],scratch[12]);
 800908c:	eba6 0608 	sub.w	r6, r6, r8
      for ( u=0; u<m; ++u ) {
 8009090:	454b      	cmp	r3, r9
         C_SUB(*Fout3,scratch[11],scratch[12]);
 8009092:	e9c1 6500 	strd	r6, r5, [r1]
      for ( u=0; u<m; ++u ) {
 8009096:	f47f aed4 	bne.w	8008e42 <opus_fft_impl+0x286>
 800909a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800909c:	991c      	ldr	r1, [sp, #112]	; 0x70
   for (i=0;i<N;i++)
 800909e:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80090a0:	440a      	add	r2, r1
 80090a2:	9216      	str	r2, [sp, #88]	; 0x58
 80090a4:	9a19      	ldr	r2, [sp, #100]	; 0x64
 80090a6:	3301      	adds	r3, #1
 80090a8:	429a      	cmp	r2, r3
 80090aa:	9318      	str	r3, [sp, #96]	; 0x60
 80090ac:	f47f aeb1 	bne.w	8008e12 <opus_fft_impl+0x256>
      Fout4=Fout0+4*m;
 80090b0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80090b2:	9309      	str	r3, [sp, #36]	; 0x24
 80090b4:	e663      	b.n	8008d7e <opus_fft_impl+0x1c2>
 80090b6:	bf00      	nop
 80090b8:	98720000 	.word	0x98720000
 80090bc:	278e0000 	.word	0x278e0000
 80090c0:	b4c30000 	.word	0xb4c30000
 80090c4:	86440000 	.word	0x86440000
          m2 = 1;
 80090c8:	2301      	movs	r3, #1
 80090ca:	9317      	str	r3, [sp, #92]	; 0x5c
          kf_bfly4(fout,fstride[i]<<shift,st,m, fstride[i], m2);
 80090cc:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80090ce:	aa24      	add	r2, sp, #144	; 0x90
 80090d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80090d4:	9312      	str	r3, [sp, #72]	; 0x48
   if (m==1)
 80090d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80090d8:	2b01      	cmp	r3, #1
 80090da:	f000 81ad 	beq.w	8009438 <opus_fft_impl+0x87c>
 80090de:	4618      	mov	r0, r3
      const int m3=3*m;
 80090e0:	eb03 0243 	add.w	r2, r3, r3, lsl #1
      for (i=0;i<N;i++)
 80090e4:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80090e6:	2b00      	cmp	r3, #0
 80090e8:	dde2      	ble.n	80090b0 <opus_fft_impl+0x4f4>
          kf_bfly4(fout,fstride[i]<<shift,st,m, fstride[i], m2);
 80090ea:	9923      	ldr	r1, [sp, #140]	; 0x8c
            C_MUL(scratch[2],Fout[m3] , *tw3 );
 80090ec:	00d4      	lsls	r4, r2, #3
          kf_bfly4(fout,fstride[i]<<shift,st,m, fstride[i], m2);
 80090ee:	408b      	lsls	r3, r1
            tw3 += fstride*3;
 80090f0:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 80090f4:	008a      	lsls	r2, r1, #2
 80090f6:	920d      	str	r2, [sp, #52]	; 0x34
            tw1 += fstride;
 80090f8:	009a      	lsls	r2, r3, #2
            tw2 += fstride*2;
 80090fa:	00db      	lsls	r3, r3, #3
 80090fc:	930c      	str	r3, [sp, #48]	; 0x30
         tw3 = tw2 = tw1 = st->twiddles;
 80090fe:	9b21      	ldr	r3, [sp, #132]	; 0x84
            C_MUL(scratch[1],Fout[m2] , *tw2 );
 8009100:	0101      	lsls	r1, r0, #4
         tw3 = tw2 = tw1 = st->twiddles;
 8009102:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009104:	2800      	cmp	r0, #0
 8009106:	9313      	str	r3, [sp, #76]	; 0x4c
            C_MUL(scratch[0],Fout[m] , *tw1 );
 8009108:	ea4f 03c0 	mov.w	r3, r0, lsl #3
            C_MUL(scratch[2],Fout[m3] , *tw3 );
 800910c:	940a      	str	r4, [sp, #40]	; 0x28
            tw1 += fstride;
 800910e:	920b      	str	r2, [sp, #44]	; 0x2c
            C_MUL(scratch[0],Fout[m] , *tw1 );
 8009110:	9306      	str	r3, [sp, #24]
            C_MUL(scratch[1],Fout[m2] , *tw2 );
 8009112:	9107      	str	r1, [sp, #28]
 8009114:	ddcc      	ble.n	80090b0 <opus_fft_impl+0x4f4>
      for (i=0;i<N;i++)
 8009116:	2200      	movs	r2, #0
 8009118:	9211      	str	r2, [sp, #68]	; 0x44
 800911a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 800911c:	00d2      	lsls	r2, r2, #3
 800911e:	9216      	str	r2, [sp, #88]	; 0x58
 8009120:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8009122:	3208      	adds	r2, #8
 8009124:	9210      	str	r2, [sp, #64]	; 0x40
 8009126:	f1a3 0208 	sub.w	r2, r3, #8
 800912a:	9218      	str	r2, [sp, #96]	; 0x60
 800912c:	1f1a      	subs	r2, r3, #4
 800912e:	9219      	str	r2, [sp, #100]	; 0x64
 8009130:	1aca      	subs	r2, r1, r3
 8009132:	1ae3      	subs	r3, r4, r3
 8009134:	920e      	str	r2, [sp, #56]	; 0x38
 8009136:	930f      	str	r3, [sp, #60]	; 0x3c
 8009138:	9a18      	ldr	r2, [sp, #96]	; 0x60
 800913a:	9910      	ldr	r1, [sp, #64]	; 0x40
 800913c:	4610      	mov	r0, r2
 800913e:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8009140:	eb00 0a01 	add.w	sl, r0, r1
 8009144:	1856      	adds	r6, r2, r1
 8009146:	468c      	mov	ip, r1
 8009148:	46b0      	mov	r8, r6
 800914a:	46d1      	mov	r9, sl
         tw3 = tw2 = tw1 = st->twiddles;
 800914c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800914e:	9a06      	ldr	r2, [sp, #24]
 8009150:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8009154:	9301      	str	r3, [sp, #4]
 8009156:	1853      	adds	r3, r2, r1
 8009158:	9309      	str	r3, [sp, #36]	; 0x24
            C_MUL(scratch[0],Fout[m] , *tw1 );
 800915a:	9b01      	ldr	r3, [sp, #4]
 800915c:	461a      	mov	r2, r3
 800915e:	f9b2 3000 	ldrsh.w	r3, [r2]
 8009162:	e899 0003 	ldmia.w	r9, {r0, r1}
 8009166:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 800916a:	fb81 5703 	smull	r5, r7, r1, r3
 800916e:	fbc0 5702 	smlal	r5, r7, r0, r2
 8009172:	f1c2 0200 	rsb	r2, r2, #0
 8009176:	fb80 3403 	smull	r3, r4, r0, r3
 800917a:	ea4f 35d5 	mov.w	r5, r5, lsr #15
 800917e:	fbc1 3402 	smlal	r3, r4, r1, r2
 8009182:	ea45 4747 	orr.w	r7, r5, r7, lsl #17
 8009186:	ea4f 33d3 	mov.w	r3, r3, lsr #15
 800918a:	ea43 4444 	orr.w	r4, r3, r4, lsl #17
            C_MUL(scratch[1],Fout[m2] , *tw2 );
 800918e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
            C_MUL(scratch[0],Fout[m] , *tw1 );
 8009190:	9404      	str	r4, [sp, #16]
            C_MUL(scratch[1],Fout[m2] , *tw2 );
 8009192:	eb02 0e09 	add.w	lr, r2, r9
 8009196:	9a02      	ldr	r2, [sp, #8]
 8009198:	f9b2 5000 	ldrsh.w	r5, [r2]
 800919c:	e89e 0003 	ldmia.w	lr, {r0, r1}
 80091a0:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
 80091a4:	fb81 2e05 	smull	r2, lr, r1, r5
 80091a8:	fbc0 2e03 	smlal	r2, lr, r0, r3
 80091ac:	f1c3 0300 	rsb	r3, r3, #0
 80091b0:	fb80 5405 	smull	r5, r4, r0, r5
 80091b4:	ea4f 32d2 	mov.w	r2, r2, lsr #15
 80091b8:	fbc1 5403 	smlal	r5, r4, r1, r3
 80091bc:	ea42 4e4e 	orr.w	lr, r2, lr, lsl #17
 80091c0:	ea4f 35d5 	mov.w	r5, r5, lsr #15
 80091c4:	ea45 4444 	orr.w	r4, r5, r4, lsl #17
            C_MUL(scratch[2],Fout[m3] , *tw3 );
 80091c8:	980f      	ldr	r0, [sp, #60]	; 0x3c
            C_MUL(scratch[1],Fout[m2] , *tw2 );
 80091ca:	9405      	str	r4, [sp, #20]
            C_MUL(scratch[2],Fout[m3] , *tw3 );
 80091cc:	eb00 0509 	add.w	r5, r0, r9
 80091d0:	9803      	ldr	r0, [sp, #12]
 80091d2:	4604      	mov	r4, r0
 80091d4:	f9b4 2000 	ldrsh.w	r2, [r4]
 80091d8:	e895 0003 	ldmia.w	r5, {r0, r1}
 80091dc:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 80091e0:	fb81 6502 	smull	r6, r5, r1, r2
 80091e4:	fbc0 6503 	smlal	r6, r5, r0, r3
 80091e8:	f1c3 0300 	rsb	r3, r3, #0
 80091ec:	fb80 2402 	smull	r2, r4, r0, r2
 80091f0:	ea4f 36d6 	mov.w	r6, r6, lsr #15
 80091f4:	fbc1 2403 	smlal	r2, r4, r1, r3
 80091f8:	ea46 4545 	orr.w	r5, r6, r5, lsl #17
 80091fc:	ea4f 32d2 	mov.w	r2, r2, lsr #15
 8009200:	ea42 4444 	orr.w	r4, r2, r4, lsl #17
            C_SUB( scratch[5] , *Fout, scratch[1] );
 8009204:	e95c 2302 	ldrd	r2, r3, [ip, #-8]
            C_ADDTO(*Fout, scratch[1]);
 8009208:	9905      	ldr	r1, [sp, #20]
 800920a:	9e06      	ldr	r6, [sp, #24]
 800920c:	1850      	adds	r0, r2, r1
            C_ADD( scratch[3] , scratch[0] , scratch[2] );
 800920e:	9904      	ldr	r1, [sp, #16]
 8009210:	9408      	str	r4, [sp, #32]
 8009212:	eb01 0b04 	add.w	fp, r1, r4
            C_SUB( Fout[m2], *Fout, scratch[3] );
 8009216:	9c07      	ldr	r4, [sp, #28]
            C_ADDTO(*Fout, scratch[1]);
 8009218:	f84c 0c08 	str.w	r0, [ip, #-8]
 800921c:	eb03 010e 	add.w	r1, r3, lr
 8009220:	eba9 0606 	sub.w	r6, r9, r6
            C_SUB( Fout[m2], *Fout, scratch[3] );
 8009224:	eba0 000b 	sub.w	r0, r0, fp
            C_ADDTO(*Fout, scratch[1]);
 8009228:	f84c 1c04 	str.w	r1, [ip, #-4]
            C_SUB( Fout[m2], *Fout, scratch[3] );
 800922c:	5130      	str	r0, [r6, r4]
 800922e:	9806      	ldr	r0, [sp, #24]
            C_ADD( scratch[3] , scratch[0] , scratch[2] );
 8009230:	eb07 0a05 	add.w	sl, r7, r5
 8009234:	eba8 0000 	sub.w	r0, r8, r0
            C_SUB( Fout[m2], *Fout, scratch[3] );
 8009238:	eba1 010a 	sub.w	r1, r1, sl
 800923c:	5101      	str	r1, [r0, r4]
            C_SUB( scratch[5] , *Fout, scratch[1] );
 800923e:	9905      	ldr	r1, [sp, #20]
            C_SUB( scratch[4] , scratch[0] , scratch[2] );
 8009240:	9c04      	ldr	r4, [sp, #16]
            C_SUB( scratch[5] , *Fout, scratch[1] );
 8009242:	1a52      	subs	r2, r2, r1
            C_SUB( scratch[4] , scratch[0] , scratch[2] );
 8009244:	9908      	ldr	r1, [sp, #32]
 8009246:	1b7d      	subs	r5, r7, r5
 8009248:	1a64      	subs	r4, r4, r1
            C_ADDTO( *Fout , scratch[3] );
 800924a:	f85c 7c08 	ldr.w	r7, [ip, #-8]
 800924e:	f85c 1c04 	ldr.w	r1, [ip, #-4]
            C_SUB( scratch[5] , *Fout, scratch[1] );
 8009252:	eba3 030e 	sub.w	r3, r3, lr
            C_ADDTO( *Fout , scratch[3] );
 8009256:	445f      	add	r7, fp
 8009258:	4451      	add	r1, sl
 800925a:	e94c 7102 	strd	r7, r1, [ip, #-8]
            Fout[m].r = ADD32_ovflw(scratch[5].r, scratch[4].i);
 800925e:	1951      	adds	r1, r2, r5
            Fout[m].i = SUB32_ovflw(scratch[5].i, scratch[4].r);
 8009260:	1b1f      	subs	r7, r3, r4
            Fout[m3].r = SUB32_ovflw(scratch[5].r, scratch[4].i);
 8009262:	1b52      	subs	r2, r2, r5
            Fout[m3].i = ADD32_ovflw(scratch[5].i, scratch[4].r);
 8009264:	441c      	add	r4, r3
            tw1 += fstride;
 8009266:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8009268:	9b01      	ldr	r3, [sp, #4]
            Fout[m].r = ADD32_ovflw(scratch[5].r, scratch[4].i);
 800926a:	f848 1c04 	str.w	r1, [r8, #-4]
            tw1 += fstride;
 800926e:	195d      	adds	r5, r3, r5
 8009270:	9501      	str	r5, [sp, #4]
            tw2 += fstride*2;
 8009272:	9b02      	ldr	r3, [sp, #8]
 8009274:	9d0c      	ldr	r5, [sp, #48]	; 0x30
            Fout[m].i = SUB32_ovflw(scratch[5].i, scratch[4].r);
 8009276:	f8c9 7004 	str.w	r7, [r9, #4]
            tw2 += fstride*2;
 800927a:	195d      	adds	r5, r3, r5
 800927c:	9502      	str	r5, [sp, #8]
            tw3 += fstride*3;
 800927e:	9b03      	ldr	r3, [sp, #12]
 8009280:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 8009282:	f10c 0c08 	add.w	ip, ip, #8
 8009286:	442b      	add	r3, r5
 8009288:	9303      	str	r3, [sp, #12]
            Fout[m3].r = SUB32_ovflw(scratch[5].r, scratch[4].i);
 800928a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800928c:	f108 0808 	add.w	r8, r8, #8
 8009290:	50f2      	str	r2, [r6, r3]
            Fout[m3].i = ADD32_ovflw(scratch[5].i, scratch[4].r);
 8009292:	50c4      	str	r4, [r0, r3]
         for (j=0;j<m;j++)
 8009294:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009296:	f109 0908 	add.w	r9, r9, #8
 800929a:	4563      	cmp	r3, ip
 800929c:	f47f af5d 	bne.w	800915a <opus_fft_impl+0x59e>
 80092a0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80092a2:	9916      	ldr	r1, [sp, #88]	; 0x58
      for (i=0;i<N;i++)
 80092a4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80092a6:	440a      	add	r2, r1
 80092a8:	9210      	str	r2, [sp, #64]	; 0x40
 80092aa:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80092ac:	3301      	adds	r3, #1
 80092ae:	429a      	cmp	r2, r3
 80092b0:	9311      	str	r3, [sp, #68]	; 0x44
 80092b2:	f47f af41 	bne.w	8009138 <opus_fft_impl+0x57c>
      Fout4=Fout0+4*m;
 80092b6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80092b8:	9309      	str	r3, [sp, #36]	; 0x24
 80092ba:	e560      	b.n	8008d7e <opus_fft_impl+0x1c2>
          m2 = 1;
 80092bc:	2301      	movs	r3, #1
 80092be:	9317      	str	r3, [sp, #92]	; 0x5c
          kf_bfly3(fout,fstride[i]<<shift,st,m, fstride[i], m2);
 80092c0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80092c2:	aa24      	add	r2, sp, #144	; 0x90
 80092c4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80092c8:	9923      	ldr	r1, [sp, #140]	; 0x8c
 80092ca:	4613      	mov	r3, r2
   for (i=0;i<N;i++)
 80092cc:	2a00      	cmp	r2, #0
          kf_bfly3(fout,fstride[i]<<shift,st,m, fstride[i], m2);
 80092ce:	920b      	str	r2, [sp, #44]	; 0x2c
 80092d0:	fa03 f301 	lsl.w	r3, r3, r1
   for (i=0;i<N;i++)
 80092d4:	f77f aeec 	ble.w	80090b0 <opus_fft_impl+0x4f4>
 80092d8:	2200      	movs	r2, #0
         C_MUL(scratch[1],Fout[m] , *tw1);
 80092da:	9909      	ldr	r1, [sp, #36]	; 0x24
   for (i=0;i<N;i++)
 80092dc:	920a      	str	r2, [sp, #40]	; 0x28
         C_MUL(scratch[2],Fout[m2] , *tw2);
 80092de:	0108      	lsls	r0, r1, #4
         C_MUL(scratch[1],Fout[m] , *tw1);
 80092e0:	00ca      	lsls	r2, r1, #3
      tw1=tw2=st->twiddles;
 80092e2:	9921      	ldr	r1, [sp, #132]	; 0x84
         C_MUL(scratch[1],Fout[m] , *tw1);
 80092e4:	9204      	str	r2, [sp, #16]
      tw1=tw2=st->twiddles;
 80092e6:	6b49      	ldr	r1, [r1, #52]	; 0x34
         C_MUL(scratch[2],Fout[m2] , *tw2);
 80092e8:	9005      	str	r0, [sp, #20]
      tw1=tw2=st->twiddles;
 80092ea:	910c      	str	r1, [sp, #48]	; 0x30
 80092ec:	9922      	ldr	r1, [sp, #136]	; 0x88
 80092ee:	4411      	add	r1, r2
 80092f0:	9108      	str	r1, [sp, #32]
 80092f2:	f1c2 0108 	rsb	r1, r2, #8
 80092f6:	1a82      	subs	r2, r0, r2
 80092f8:	920e      	str	r2, [sp, #56]	; 0x38
         tw1 += fstride;
 80092fa:	009a      	lsls	r2, r3, #2
         tw2 += fstride*2;
 80092fc:	00db      	lsls	r3, r3, #3
 80092fe:	9307      	str	r3, [sp, #28]
 8009300:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8009302:	910f      	str	r1, [sp, #60]	; 0x3c
 8009304:	00db      	lsls	r3, r3, #3
         tw1 += fstride;
 8009306:	9206      	str	r2, [sp, #24]
 8009308:	930d      	str	r3, [sp, #52]	; 0x34
      k=m;
 800930a:	9909      	ldr	r1, [sp, #36]	; 0x24
   for (i=0;i<N;i++)
 800930c:	9a08      	ldr	r2, [sp, #32]
      k=m;
 800930e:	9103      	str	r1, [sp, #12]
 8009310:	990f      	ldr	r1, [sp, #60]	; 0x3c
   for (i=0;i<N;i++)
 8009312:	4613      	mov	r3, r2
 8009314:	4608      	mov	r0, r1
      tw1=tw2=st->twiddles;
 8009316:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 800931a:	990e      	ldr	r1, [sp, #56]	; 0x38
 800931c:	e9cd bb01 	strd	fp, fp, [sp, #4]
 8009320:	eb00 0c02 	add.w	ip, r0, r2
 8009324:	188f      	adds	r7, r1, r2
 8009326:	f102 0804 	add.w	r8, r2, #4
         C_MUL(scratch[1],Fout[m] , *tw1);
 800932a:	9a01      	ldr	r2, [sp, #4]
 800932c:	f9b2 5000 	ldrsh.w	r5, [r2]
 8009330:	e893 0003 	ldmia.w	r3, {r0, r1}
 8009334:	f9b2 e002 	ldrsh.w	lr, [r2, #2]
 8009338:	fb81 9405 	smull	r9, r4, r1, r5
 800933c:	fbc0 940e 	smlal	r9, r4, r0, lr
 8009340:	f1ce 0e00 	rsb	lr, lr, #0
 8009344:	fb80 5205 	smull	r5, r2, r0, r5
 8009348:	ea4f 39d9 	mov.w	r9, r9, lsr #15
 800934c:	fbc1 520e 	smlal	r5, r2, r1, lr
 8009350:	ea49 4444 	orr.w	r4, r9, r4, lsl #17
 8009354:	ea4f 35d5 	mov.w	r5, r5, lsr #15
 8009358:	ea45 4242 	orr.w	r2, r5, r2, lsl #17
         C_MUL(scratch[2],Fout[m2] , *tw2);
 800935c:	9902      	ldr	r1, [sp, #8]
 800935e:	460e      	mov	r6, r1
 8009360:	f9b6 5000 	ldrsh.w	r5, [r6]
 8009364:	e897 0003 	ldmia.w	r7, {r0, r1}
 8009368:	f9b6 a002 	ldrsh.w	sl, [r6, #2]
 800936c:	fb81 b905 	smull	fp, r9, r1, r5
 8009370:	fbc0 b90a 	smlal	fp, r9, r0, sl
 8009374:	f1ca 0a00 	rsb	sl, sl, #0
 8009378:	fb80 5e05 	smull	r5, lr, r0, r5
 800937c:	ea4f 3bdb 	mov.w	fp, fp, lsr #15
 8009380:	fbc1 5e0a 	smlal	r5, lr, r1, sl
 8009384:	ea4b 4949 	orr.w	r9, fp, r9, lsl #17
 8009388:	ea4f 35d5 	mov.w	r5, r5, lsr #15
 800938c:	ea45 4e4e 	orr.w	lr, r5, lr, lsl #17
         Fout[m].r = SUB32_ovflw(Fout->r, HALF_OF(scratch[3].r));
 8009390:	f85c 1c08 	ldr.w	r1, [ip, #-8]
         C_ADD(scratch[3],scratch[1],scratch[2]);
 8009394:	eb02 0b0e 	add.w	fp, r2, lr
         Fout[m].r = SUB32_ovflw(Fout->r, HALF_OF(scratch[3].r));
 8009398:	eba1 016b 	sub.w	r1, r1, fp, asr #1
 800939c:	f848 1c04 	str.w	r1, [r8, #-4]
         Fout[m].i = SUB32_ovflw(Fout->i, HALF_OF(scratch[3].i));
 80093a0:	f85c 5c04 	ldr.w	r5, [ip, #-4]
         C_ADD(scratch[3],scratch[1],scratch[2]);
 80093a4:	eb04 0a09 	add.w	sl, r4, r9
         Fout[m].i = SUB32_ovflw(Fout->i, HALF_OF(scratch[3].i));
 80093a8:	eba5 056a 	sub.w	r5, r5, sl, asr #1
 80093ac:	605d      	str	r5, [r3, #4]
         C_ADDTO(*Fout,scratch[3]);
 80093ae:	e95c 0102 	ldrd	r0, r1, [ip, #-8]
 80093b2:	4458      	add	r0, fp
 80093b4:	4451      	add	r1, sl
 80093b6:	e94c 0102 	strd	r0, r1, [ip, #-8]
         C_SUB(scratch[0],scratch[1],scratch[2]);
 80093ba:	eba4 0409 	sub.w	r4, r4, r9
         Fout[m2].r = ADD32_ovflw(Fout[m].r, scratch[0].i);
 80093be:	f858 1c04 	ldr.w	r1, [r8, #-4]
  __asm__(
 80093c2:	4e5c      	ldr	r6, [pc, #368]	; (8009534 <opus_fft_impl+0x978>)
 80093c4:	fb84 5006 	smull	r5, r0, r4, r6
 80093c8:	9c04      	ldr	r4, [sp, #16]
  return SHL32(rd_hi,1);
 80093ca:	0040      	lsls	r0, r0, #1
 80093cc:	9d05      	ldr	r5, [sp, #20]
 80093ce:	4401      	add	r1, r0
 80093d0:	1b1c      	subs	r4, r3, r4
 80093d2:	5161      	str	r1, [r4, r5]
         Fout[m2].i = SUB32_ovflw(Fout[m].i, scratch[0].r);
 80093d4:	6859      	ldr	r1, [r3, #4]
         C_SUB(scratch[0],scratch[1],scratch[2]);
 80093d6:	eba2 020e 	sub.w	r2, r2, lr
  __asm__(
 80093da:	fb82 5406 	smull	r5, r4, r2, r6
  return SHL32(rd_hi,1);
 80093de:	0064      	lsls	r4, r4, #1
         Fout[m2].i = SUB32_ovflw(Fout[m].i, scratch[0].r);
 80093e0:	1b09      	subs	r1, r1, r4
 80093e2:	6079      	str	r1, [r7, #4]
         Fout[m].r = SUB32_ovflw(Fout[m].r, scratch[0].i);
 80093e4:	f858 2c04 	ldr.w	r2, [r8, #-4]
         tw1 += fstride;
 80093e8:	9901      	ldr	r1, [sp, #4]
         Fout[m].r = SUB32_ovflw(Fout[m].r, scratch[0].i);
 80093ea:	1a10      	subs	r0, r2, r0
 80093ec:	f848 0c04 	str.w	r0, [r8, #-4]
         tw1 += fstride;
 80093f0:	9d06      	ldr	r5, [sp, #24]
         Fout[m].i = ADD32_ovflw(Fout[m].i, scratch[0].r);
 80093f2:	685a      	ldr	r2, [r3, #4]
         tw1 += fstride;
 80093f4:	4429      	add	r1, r5
         Fout[m].i = ADD32_ovflw(Fout[m].i, scratch[0].r);
 80093f6:	4414      	add	r4, r2
         tw1 += fstride;
 80093f8:	9101      	str	r1, [sp, #4]
      } while(--k);
 80093fa:	9a03      	ldr	r2, [sp, #12]
         tw2 += fstride*2;
 80093fc:	9902      	ldr	r1, [sp, #8]
 80093fe:	9807      	ldr	r0, [sp, #28]
      } while(--k);
 8009400:	3a01      	subs	r2, #1
         tw2 += fstride*2;
 8009402:	4401      	add	r1, r0
         Fout[m].i = ADD32_ovflw(Fout[m].i, scratch[0].r);
 8009404:	605c      	str	r4, [r3, #4]
         tw2 += fstride*2;
 8009406:	9102      	str	r1, [sp, #8]
 8009408:	f10c 0c08 	add.w	ip, ip, #8
 800940c:	f107 0708 	add.w	r7, r7, #8
 8009410:	f108 0808 	add.w	r8, r8, #8
 8009414:	f103 0308 	add.w	r3, r3, #8
      } while(--k);
 8009418:	9203      	str	r2, [sp, #12]
 800941a:	d186      	bne.n	800932a <opus_fft_impl+0x76e>
 800941c:	9a08      	ldr	r2, [sp, #32]
 800941e:	990d      	ldr	r1, [sp, #52]	; 0x34
   for (i=0;i<N;i++)
 8009420:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009422:	440a      	add	r2, r1
 8009424:	9208      	str	r2, [sp, #32]
 8009426:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8009428:	3301      	adds	r3, #1
 800942a:	429a      	cmp	r2, r3
 800942c:	930a      	str	r3, [sp, #40]	; 0x28
 800942e:	f47f af6c 	bne.w	800930a <opus_fft_impl+0x74e>
      Fout4=Fout0+4*m;
 8009432:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8009434:	9309      	str	r3, [sp, #36]	; 0x24
 8009436:	e4a2      	b.n	8008d7e <opus_fft_impl+0x1c2>
      for (i=0;i<N;i++)
 8009438:	9d12      	ldr	r5, [sp, #72]	; 0x48
 800943a:	2d00      	cmp	r5, #0
 800943c:	f77f ae38 	ble.w	80090b0 <opus_fft_impl+0x4f4>
 8009440:	f04f 0c00 	mov.w	ip, #0
 8009444:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009446:	3320      	adds	r3, #32
         C_SUB( scratch0 , *Fout, Fout[2] );
 8009448:	f853 6c10 	ldr.w	r6, [r3, #-16]
         C_ADD( scratch1 , Fout[1] , Fout[3] );
 800944c:	f853 2c08 	ldr.w	r2, [r3, #-8]
         C_SUB( scratch0 , *Fout, Fout[2] );
 8009450:	f853 1c20 	ldr.w	r1, [r3, #-32]
         C_ADD( scratch1 , Fout[1] , Fout[3] );
 8009454:	f853 0c18 	ldr.w	r0, [r3, #-24]
 8009458:	f853 4c14 	ldr.w	r4, [r3, #-20]
 800945c:	f853 8c04 	ldr.w	r8, [r3, #-4]
         C_SUB( scratch0 , *Fout, Fout[2] );
 8009460:	eba1 0e06 	sub.w	lr, r1, r6
         C_ADDTO(*Fout, Fout[2]);
 8009464:	4431      	add	r1, r6
         C_ADD( scratch1 , Fout[1] , Fout[3] );
 8009466:	1886      	adds	r6, r0, r2
         C_SUB( scratch0 , *Fout, Fout[2] );
 8009468:	f853 7c0c 	ldr.w	r7, [r3, #-12]
         C_SUB( scratch1 , Fout[1] , Fout[3] );
 800946c:	1a80      	subs	r0, r0, r2
         C_SUB( Fout[2], *Fout, scratch1 );
 800946e:	eba1 0906 	sub.w	r9, r1, r6
         C_SUB( scratch0 , *Fout, Fout[2] );
 8009472:	f853 2c1c 	ldr.w	r2, [r3, #-28]
         C_ADDTO( *Fout , scratch1 );
 8009476:	4431      	add	r1, r6
         C_SUB( scratch1 , Fout[1] , Fout[3] );
 8009478:	eba4 0608 	sub.w	r6, r4, r8
         C_ADDTO( *Fout , scratch1 );
 800947c:	f843 1c20 	str.w	r1, [r3, #-32]
         C_ADD( scratch1 , Fout[1] , Fout[3] );
 8009480:	eb04 0108 	add.w	r1, r4, r8
         Fout[1].r = ADD32_ovflw(scratch0.r, scratch1.i);
 8009484:	eb0e 0406 	add.w	r4, lr, r6
 8009488:	f843 4c18 	str.w	r4, [r3, #-24]
      for (i=0;i<N;i++)
 800948c:	f10c 0c01 	add.w	ip, ip, #1
         C_ADDTO(*Fout, Fout[2]);
 8009490:	19d4      	adds	r4, r2, r7
         C_SUB( scratch0 , *Fout, Fout[2] );
 8009492:	1bd2      	subs	r2, r2, r7
         Fout[3].r = SUB32_ovflw(scratch0.r, scratch1.i);
 8009494:	ebae 0606 	sub.w	r6, lr, r6
         C_SUB( Fout[2], *Fout, scratch1 );
 8009498:	1a67      	subs	r7, r4, r1
      for (i=0;i<N;i++)
 800949a:	4565      	cmp	r5, ip
         C_ADDTO( *Fout , scratch1 );
 800949c:	4421      	add	r1, r4
         Fout[1].i = SUB32_ovflw(scratch0.i, scratch1.r);
 800949e:	eba2 0400 	sub.w	r4, r2, r0
         Fout[3].i = ADD32_ovflw(scratch0.i, scratch1.r);
 80094a2:	4402      	add	r2, r0
         C_SUB( Fout[2], *Fout, scratch1 );
 80094a4:	f843 9c10 	str.w	r9, [r3, #-16]
 80094a8:	e943 7603 	strd	r7, r6, [r3, #-12]
         C_ADDTO( *Fout , scratch1 );
 80094ac:	f843 1c1c 	str.w	r1, [r3, #-28]
         Fout[1].i = SUB32_ovflw(scratch0.i, scratch1.r);
 80094b0:	f843 4c14 	str.w	r4, [r3, #-20]
         Fout[3].i = ADD32_ovflw(scratch0.i, scratch1.r);
 80094b4:	f843 2c04 	str.w	r2, [r3, #-4]
 80094b8:	f103 0320 	add.w	r3, r3, #32
      for (i=0;i<N;i++)
 80094bc:	d1c4      	bne.n	8009448 <opus_fft_impl+0x88c>
      Fout4=Fout0+4*m;
 80094be:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80094c0:	9309      	str	r3, [sp, #36]	; 0x24
 80094c2:	e45c      	b.n	8008d7e <opus_fft_impl+0x1c2>
       fstride[L+1] = fstride[L]*p;
 80094c4:	2304      	movs	r3, #4
 80094c6:	2205      	movs	r2, #5
 80094c8:	9314      	str	r3, [sp, #80]	; 0x50
 80094ca:	462b      	mov	r3, r5
 80094cc:	f7ff bbc4 	b.w	8008c58 <opus_fft_impl+0x9c>
    L=0;
 80094d0:	2300      	movs	r3, #0
 80094d2:	9314      	str	r3, [sp, #80]	; 0x50
 80094d4:	462b      	mov	r3, r5
 80094d6:	f7ff bbbf 	b.w	8008c58 <opus_fft_impl+0x9c>
       fstride[L+1] = fstride[L]*p;
 80094da:	9214      	str	r2, [sp, #80]	; 0x50
 80094dc:	462b      	mov	r3, r5
 80094de:	2202      	movs	r2, #2
 80094e0:	f7ff bbba 	b.w	8008c58 <opus_fft_impl+0x9c>
       switch (st->factors[2*i])
 80094e4:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80094e6:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80094ea:	3b02      	subs	r3, #2
 80094ec:	2b03      	cmp	r3, #3
 80094ee:	f63f ac4f 	bhi.w	8008d90 <opus_fft_impl+0x1d4>
 80094f2:	a201      	add	r2, pc, #4	; (adr r2, 80094f8 <opus_fft_impl+0x93c>)
 80094f4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80094f8:	0800952d 	.word	0x0800952d
 80094fc:	080092bd 	.word	0x080092bd
 8009500:	080090c9 	.word	0x080090c9
 8009504:	08008d9d 	.word	0x08008d9d
       fstride[L+1] = fstride[L]*p;
 8009508:	2302      	movs	r3, #2
 800950a:	2203      	movs	r2, #3
 800950c:	9314      	str	r3, [sp, #80]	; 0x50
 800950e:	462b      	mov	r3, r5
 8009510:	f7ff bba2 	b.w	8008c58 <opus_fft_impl+0x9c>
 8009514:	2303      	movs	r3, #3
 8009516:	2204      	movs	r2, #4
 8009518:	9314      	str	r3, [sp, #80]	; 0x50
 800951a:	462b      	mov	r3, r5
 800951c:	f7ff bb9c 	b.w	8008c58 <opus_fft_impl+0x9c>
 8009520:	2305      	movs	r3, #5
 8009522:	2206      	movs	r2, #6
 8009524:	9314      	str	r3, [sp, #80]	; 0x50
 8009526:	462b      	mov	r3, r5
 8009528:	f7ff bb96 	b.w	8008c58 <opus_fft_impl+0x9c>
          m2 = 1;
 800952c:	2301      	movs	r3, #1
 800952e:	9309      	str	r3, [sp, #36]	; 0x24
 8009530:	f7ff bbb1 	b.w	8008c96 <opus_fft_impl+0xda>
 8009534:	91260000 	.word	0x91260000

08009538 <ec_laplace_decode>:
   }
   ec_encode_bin(enc, fl, fl+fs, 15);
}

int ec_laplace_decode(ec_dec *dec, unsigned fs, int decay)
{
 8009538:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800953c:	460c      	mov	r4, r1
   int val=0;
   unsigned fl;
   unsigned fm;
   fm = ec_decode_bin(dec, 15);
 800953e:	210f      	movs	r1, #15
{
 8009540:	4691      	mov	r9, r2
 8009542:	4680      	mov	r8, r0
   fm = ec_decode_bin(dec, 15);
 8009544:	f7fe ff6c 	bl	8008420 <ec_decode_bin>
   fl = 0;
   if (fm >= fs)
 8009548:	42a0      	cmp	r0, r4
 800954a:	d336      	bcc.n	80095ba <ec_laplace_decode+0x82>
   ft = 32768 - LAPLACE_MINP*(2*LAPLACE_NMIN) - fs0;
 800954c:	f5c4 42ff 	rsb	r2, r4, #32640	; 0x7f80
 8009550:	3260      	adds	r2, #96	; 0x60
   return ft*(opus_int32)(16384-decay)>>15;
 8009552:	f5c9 4380 	rsb	r3, r9, #16384	; 0x4000
 8009556:	fb03 f302 	mul.w	r3, r3, r2
 800955a:	0bdb      	lsrs	r3, r3, #15
   {
      val++;
      fl = fs;
      fs = ec_laplace_get_freq1(fs, decay)+LAPLACE_MINP;
      /* Search the decaying part of the PDF.*/
      while(fs > LAPLACE_MINP && fm >= fl+2*fs)
 800955c:	1c5f      	adds	r7, r3, #1
 800955e:	b37b      	cbz	r3, 80095c0 <ec_laplace_decode+0x88>
 8009560:	007b      	lsls	r3, r7, #1
 8009562:	18e1      	adds	r1, r4, r3
 8009564:	4288      	cmp	r0, r1
 8009566:	d32e      	bcc.n	80095c6 <ec_laplace_decode+0x8e>
      val++;
 8009568:	2501      	movs	r5, #1
 800956a:	e002      	b.n	8009572 <ec_laplace_decode+0x3a>
      while(fs > LAPLACE_MINP && fm >= fl+2*fs)
 800956c:	4286      	cmp	r6, r0
 800956e:	d810      	bhi.n	8009592 <ec_laplace_decode+0x5a>
 8009570:	4631      	mov	r1, r6
      {
         fs *= 2;
         fl += fs;
         fs = ((fs-2*LAPLACE_MINP)*(opus_int32)decay)>>15;
 8009572:	3b02      	subs	r3, #2
 8009574:	fb09 f303 	mul.w	r3, r9, r3
 8009578:	0bdc      	lsrs	r4, r3, #15
      while(fs > LAPLACE_MINP && fm >= fl+2*fs)
 800957a:	1c67      	adds	r7, r4, #1
 800957c:	007b      	lsls	r3, r7, #1
         fs += LAPLACE_MINP;
         val++;
 800957e:	3501      	adds	r5, #1
      while(fs > LAPLACE_MINP && fm >= fl+2*fs)
 8009580:	185e      	adds	r6, r3, r1
 8009582:	2c00      	cmp	r4, #0
 8009584:	d1f2      	bne.n	800956c <ec_laplace_decode+0x34>
      if (fs <= LAPLACE_MINP)
      {
         int di;
         di = (fm-fl)>>(LAPLACE_LOG_MINP+1);
         val += di;
         fl += 2*di*LAPLACE_MINP;
 8009586:	2701      	movs	r7, #1
         di = (fm-fl)>>(LAPLACE_LOG_MINP+1);
 8009588:	1a43      	subs	r3, r0, r1
 800958a:	085b      	lsrs	r3, r3, #1
         val += di;
 800958c:	441d      	add	r5, r3
         fl += 2*di*LAPLACE_MINP;
 800958e:	eb01 0143 	add.w	r1, r1, r3, lsl #1
      }
      if (fm < fl+fs)
 8009592:	19cc      	adds	r4, r1, r7
 8009594:	4284      	cmp	r4, r0
 8009596:	bf96      	itet	ls
 8009598:	4621      	movls	r1, r4
         val = -val;
 800959a:	426d      	neghi	r5, r5
      if (fm < fl+fs)
 800959c:	19e4      	addls	r4, r4, r7
   }
   celt_assert(fl<32768);
   celt_assert(fs>0);
   celt_assert(fl<=fm);
   celt_assert(fm<IMIN(fl+fs,32768));
   ec_dec_update(dec, fl, IMIN(fl+fs,32768), 32768);
 800959e:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
 80095a2:	4622      	mov	r2, r4
 80095a4:	4640      	mov	r0, r8
 80095a6:	bf28      	it	cs
 80095a8:	f44f 4200 	movcs.w	r2, #32768	; 0x8000
 80095ac:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80095b0:	f7fe ff4a 	bl	8008448 <ec_dec_update>
   return val;
}
 80095b4:	4628      	mov	r0, r5
 80095b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   fl = 0;
 80095ba:	2100      	movs	r1, #0
   int val=0;
 80095bc:	460d      	mov	r5, r1
 80095be:	e7ee      	b.n	800959e <ec_laplace_decode+0x66>
      while(fs > LAPLACE_MINP && fm >= fl+2*fs)
 80095c0:	4621      	mov	r1, r4
      val++;
 80095c2:	463d      	mov	r5, r7
 80095c4:	e7df      	b.n	8009586 <ec_laplace_decode+0x4e>
      while(fs > LAPLACE_MINP && fm >= fl+2*fs)
 80095c6:	4621      	mov	r1, r4
      val++;
 80095c8:	2501      	movs	r5, #1
 80095ca:	e7e2      	b.n	8009592 <ec_laplace_decode+0x5a>

080095cc <isqrt32>:
  /*Uses the second method from
     http://www.azillionmonkeys.com/qed/sqroot.html
    The main idea is to search for the largest binary digit b such that
     (g+b)*(g+b) <= _val, and add it to the solution g.*/
  g=0;
  bshift=(EC_ILOG(_val)-1)>>1;
 80095cc:	fab0 f280 	clz	r2, r0
  b=1U<<bshift;
 80095d0:	2101      	movs	r1, #1
unsigned isqrt32(opus_uint32 _val){
 80095d2:	4603      	mov	r3, r0
  bshift=(EC_ILOG(_val)-1)>>1;
 80095d4:	f1c2 021f 	rsb	r2, r2, #31
 80095d8:	410a      	asrs	r2, r1
  b=1U<<bshift;
 80095da:	4091      	lsls	r1, r2
  do{
    opus_uint32 t;
    t=(((opus_uint32)g<<1)+b)<<bshift;
 80095dc:	fa01 f002 	lsl.w	r0, r1, r2
    if(t<=_val){
 80095e0:	4298      	cmp	r0, r3
unsigned isqrt32(opus_uint32 _val){
 80095e2:	b470      	push	{r4, r5, r6}
      g+=b;
      _val-=t;
 80095e4:	bf96      	itet	ls
 80095e6:	1a1b      	subls	r3, r3, r0
  g=0;
 80095e8:	2000      	movhi	r0, #0
      g+=b;
 80095ea:	4608      	movls	r0, r1
    }
    b>>=1;
    bshift--;
  }
  while(bshift>=0);
 80095ec:	1e56      	subs	r6, r2, #1
    b>>=1;
 80095ee:	ea4f 0551 	mov.w	r5, r1, lsr #1
  while(bshift>=0);
 80095f2:	f100 80be 	bmi.w	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 80095f6:	eb05 0440 	add.w	r4, r5, r0, lsl #1
 80095fa:	40b4      	lsls	r4, r6
    if(t<=_val){
 80095fc:	42a3      	cmp	r3, r4
      g+=b;
 80095fe:	bf28      	it	cs
 8009600:	1940      	addcs	r0, r0, r5
    bshift--;
 8009602:	f1a2 0502 	sub.w	r5, r2, #2
      _val-=t;
 8009606:	bf28      	it	cs
 8009608:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 800960a:	1c6c      	adds	r4, r5, #1
    b>>=1;
 800960c:	ea4f 0691 	mov.w	r6, r1, lsr #2
  while(bshift>=0);
 8009610:	f000 80af 	beq.w	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 8009614:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 8009618:	40ac      	lsls	r4, r5
    if(t<=_val){
 800961a:	42a3      	cmp	r3, r4
    bshift--;
 800961c:	f1a2 0503 	sub.w	r5, r2, #3
      g+=b;
 8009620:	bf24      	itt	cs
 8009622:	1980      	addcs	r0, r0, r6
      _val-=t;
 8009624:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 8009626:	1c6c      	adds	r4, r5, #1
    b>>=1;
 8009628:	ea4f 06d1 	mov.w	r6, r1, lsr #3
  while(bshift>=0);
 800962c:	f000 80a1 	beq.w	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 8009630:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 8009634:	40ac      	lsls	r4, r5
    if(t<=_val){
 8009636:	42a3      	cmp	r3, r4
    bshift--;
 8009638:	f1a2 0504 	sub.w	r5, r2, #4
      g+=b;
 800963c:	bf24      	itt	cs
 800963e:	1980      	addcs	r0, r0, r6
      _val-=t;
 8009640:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 8009642:	1c6c      	adds	r4, r5, #1
    b>>=1;
 8009644:	ea4f 1611 	mov.w	r6, r1, lsr #4
  while(bshift>=0);
 8009648:	f000 8093 	beq.w	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 800964c:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 8009650:	40ac      	lsls	r4, r5
    if(t<=_val){
 8009652:	42a3      	cmp	r3, r4
    bshift--;
 8009654:	f1a2 0505 	sub.w	r5, r2, #5
      g+=b;
 8009658:	bf24      	itt	cs
 800965a:	1980      	addcs	r0, r0, r6
      _val-=t;
 800965c:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 800965e:	1c6c      	adds	r4, r5, #1
    b>>=1;
 8009660:	ea4f 1651 	mov.w	r6, r1, lsr #5
  while(bshift>=0);
 8009664:	f000 8085 	beq.w	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 8009668:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 800966c:	40ac      	lsls	r4, r5
    if(t<=_val){
 800966e:	42a3      	cmp	r3, r4
    bshift--;
 8009670:	f1a2 0506 	sub.w	r5, r2, #6
      g+=b;
 8009674:	bf24      	itt	cs
 8009676:	1980      	addcs	r0, r0, r6
      _val-=t;
 8009678:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 800967a:	1c6c      	adds	r4, r5, #1
    b>>=1;
 800967c:	ea4f 1691 	mov.w	r6, r1, lsr #6
  while(bshift>=0);
 8009680:	d077      	beq.n	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 8009682:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 8009686:	40ac      	lsls	r4, r5
    if(t<=_val){
 8009688:	42a3      	cmp	r3, r4
    bshift--;
 800968a:	f1a2 0507 	sub.w	r5, r2, #7
      g+=b;
 800968e:	bf24      	itt	cs
 8009690:	1980      	addcs	r0, r0, r6
      _val-=t;
 8009692:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 8009694:	1c6c      	adds	r4, r5, #1
    b>>=1;
 8009696:	ea4f 16d1 	mov.w	r6, r1, lsr #7
  while(bshift>=0);
 800969a:	d06a      	beq.n	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 800969c:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 80096a0:	40ac      	lsls	r4, r5
    if(t<=_val){
 80096a2:	42a3      	cmp	r3, r4
    bshift--;
 80096a4:	f1a2 0508 	sub.w	r5, r2, #8
      g+=b;
 80096a8:	bf24      	itt	cs
 80096aa:	1980      	addcs	r0, r0, r6
      _val-=t;
 80096ac:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 80096ae:	1c6c      	adds	r4, r5, #1
    b>>=1;
 80096b0:	ea4f 2611 	mov.w	r6, r1, lsr #8
  while(bshift>=0);
 80096b4:	d05d      	beq.n	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 80096b6:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 80096ba:	40ac      	lsls	r4, r5
    if(t<=_val){
 80096bc:	42a3      	cmp	r3, r4
    bshift--;
 80096be:	f1a2 0509 	sub.w	r5, r2, #9
      g+=b;
 80096c2:	bf24      	itt	cs
 80096c4:	1980      	addcs	r0, r0, r6
      _val-=t;
 80096c6:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 80096c8:	1c6c      	adds	r4, r5, #1
    b>>=1;
 80096ca:	ea4f 2651 	mov.w	r6, r1, lsr #9
  while(bshift>=0);
 80096ce:	d050      	beq.n	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 80096d0:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 80096d4:	40ac      	lsls	r4, r5
    if(t<=_val){
 80096d6:	42a3      	cmp	r3, r4
    bshift--;
 80096d8:	f1a2 050a 	sub.w	r5, r2, #10
      g+=b;
 80096dc:	bf24      	itt	cs
 80096de:	1980      	addcs	r0, r0, r6
      _val-=t;
 80096e0:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 80096e2:	1c6c      	adds	r4, r5, #1
    b>>=1;
 80096e4:	ea4f 2691 	mov.w	r6, r1, lsr #10
  while(bshift>=0);
 80096e8:	d043      	beq.n	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 80096ea:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 80096ee:	40ac      	lsls	r4, r5
    if(t<=_val){
 80096f0:	42a3      	cmp	r3, r4
    bshift--;
 80096f2:	f1a2 050b 	sub.w	r5, r2, #11
      g+=b;
 80096f6:	bf24      	itt	cs
 80096f8:	1980      	addcs	r0, r0, r6
      _val-=t;
 80096fa:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 80096fc:	1c6c      	adds	r4, r5, #1
    b>>=1;
 80096fe:	ea4f 26d1 	mov.w	r6, r1, lsr #11
  while(bshift>=0);
 8009702:	d036      	beq.n	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 8009704:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 8009708:	40ac      	lsls	r4, r5
    if(t<=_val){
 800970a:	42a3      	cmp	r3, r4
    bshift--;
 800970c:	f1a2 050c 	sub.w	r5, r2, #12
      g+=b;
 8009710:	bf24      	itt	cs
 8009712:	1980      	addcs	r0, r0, r6
      _val-=t;
 8009714:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 8009716:	1c6c      	adds	r4, r5, #1
    b>>=1;
 8009718:	ea4f 3611 	mov.w	r6, r1, lsr #12
  while(bshift>=0);
 800971c:	d029      	beq.n	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 800971e:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 8009722:	40ac      	lsls	r4, r5
    if(t<=_val){
 8009724:	42a3      	cmp	r3, r4
    bshift--;
 8009726:	f1a2 050d 	sub.w	r5, r2, #13
      g+=b;
 800972a:	bf24      	itt	cs
 800972c:	1980      	addcs	r0, r0, r6
      _val-=t;
 800972e:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 8009730:	1c6c      	adds	r4, r5, #1
    b>>=1;
 8009732:	ea4f 3651 	mov.w	r6, r1, lsr #13
  while(bshift>=0);
 8009736:	d01c      	beq.n	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 8009738:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 800973c:	40ac      	lsls	r4, r5
    if(t<=_val){
 800973e:	42a3      	cmp	r3, r4
    bshift--;
 8009740:	f1a2 050e 	sub.w	r5, r2, #14
      g+=b;
 8009744:	bf24      	itt	cs
 8009746:	1980      	addcs	r0, r0, r6
      _val-=t;
 8009748:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 800974a:	1c6c      	adds	r4, r5, #1
    b>>=1;
 800974c:	ea4f 3691 	mov.w	r6, r1, lsr #14
  while(bshift>=0);
 8009750:	d00f      	beq.n	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 8009752:	eb06 0440 	add.w	r4, r6, r0, lsl #1
 8009756:	40ac      	lsls	r4, r5
    if(t<=_val){
 8009758:	42a3      	cmp	r3, r4
      g+=b;
 800975a:	bf24      	itt	cs
 800975c:	1980      	addcs	r0, r0, r6
      _val-=t;
 800975e:	1b1b      	subcs	r3, r3, r4
  while(bshift>=0);
 8009760:	2a0f      	cmp	r2, #15
    b>>=1;
 8009762:	ea4f 31d1 	mov.w	r1, r1, lsr #15
  while(bshift>=0);
 8009766:	d104      	bne.n	8009772 <isqrt32+0x1a6>
    t=(((opus_uint32)g<<1)+b)<<bshift;
 8009768:	eb01 0240 	add.w	r2, r1, r0, lsl #1
    if(t<=_val){
 800976c:	429a      	cmp	r2, r3
      g+=b;
 800976e:	bf98      	it	ls
 8009770:	1840      	addls	r0, r0, r1
  return g;
}
 8009772:	bc70      	pop	{r4, r5, r6}
 8009774:	4770      	bx	lr
 8009776:	bf00      	nop

08009778 <frac_div32>:
 8009778:	fab1 f381 	clz	r3, r1

opus_val32 frac_div32(opus_val32 a, opus_val32 b)
{
   opus_val16 rcp;
   opus_val32 result, rem;
   int shift = celt_ilog2(b)-29;
 800977c:	f1c3 031f 	rsb	r3, r3, #31
 8009780:	f1a3 021d 	sub.w	r2, r3, #29
   a = VSHR32(a,shift);
 8009784:	2a00      	cmp	r2, #0
{
 8009786:	b4f0      	push	{r4, r5, r6, r7}
   a = VSHR32(a,shift);
 8009788:	dd59      	ble.n	800983e <frac_div32+0xc6>
 800978a:	4110      	asrs	r0, r2
   b = VSHR32(b,shift);
 800978c:	4111      	asrs	r1, r2
   /* 16-bit reciprocal */
   rcp = ROUND16(celt_rcp(ROUND16(b,16)),3);
 800978e:	f501 4200 	add.w	r2, r1, #32768	; 0x8000
 8009792:	1412      	asrs	r2, r2, #16
 8009794:	fab2 f582 	clz	r5, r2
   /* n is Q15 with range [0,1). */
   n = VSHR32(x,i-15)-32768;
   /* Start with a linear approximation:
      r = 1.8823529411764706-0.9411764705882353*n.
      The coefficients and the result are Q14 in the range [15420,30840].*/
   r = ADD16(30840, MULT16_16_Q15(-15420, n));
 8009798:	f24c 34c4 	movw	r4, #50116	; 0xc3c4
 800979c:	f1c5 051f 	rsb	r5, r5, #31
   n = VSHR32(x,i-15)-32768;
 80097a0:	2d0f      	cmp	r5, #15
 80097a2:	bfcb      	itete	gt
 80097a4:	f1a5 030f 	subgt.w	r3, r5, #15
 80097a8:	f1c5 030f 	rsble	r3, r5, #15
 80097ac:	411a      	asrgt	r2, r3
 80097ae:	409a      	lslle	r2, r3
 80097b0:	f5a2 4200 	sub.w	r2, r2, #32768	; 0x8000
 80097b4:	b212      	sxth	r2, r2
   r = ADD16(30840, MULT16_16_Q15(-15420, n));
 80097b6:	fb12 f404 	smulbb	r4, r2, r4
 80097ba:	f3c4 34cf 	ubfx	r4, r4, #15, #16
 80097be:	f504 43f0 	add.w	r3, r4, #30720	; 0x7800
 80097c2:	3378      	adds	r3, #120	; 0x78
 80097c4:	b29b      	uxth	r3, r3
 80097c6:	b21e      	sxth	r6, r3
   /* Perform two Newton iterations:
      r -= r*((r*n)-1.Q15)
         = r*((r*n)+(r-1.Q15)). */
   r = SUB16(r, MULT16_16_Q15(r,
 80097c8:	fb02 f706 	mul.w	r7, r2, r6
 80097cc:	f5a4 64f1 	sub.w	r4, r4, #1928	; 0x788
 80097d0:	eb04 34e7 	add.w	r4, r4, r7, asr #15
 80097d4:	fb14 f406 	smulbb	r4, r4, r6
 80097d8:	eba3 33e4 	sub.w	r3, r3, r4, asr #15
 80097dc:	b29b      	uxth	r3, r3
 80097de:	b21e      	sxth	r6, r3
             ADD16(MULT16_16_Q15(r, n), ADD16(r, -32768))));
   /* We subtract an extra 1 in the second iteration to avoid overflow; it also
       neatly compensates for truncation error in the rest of the process. */
   r = SUB16(r, ADD16(1, MULT16_16_Q15(r,
 80097e0:	fb02 f406 	mul.w	r4, r2, r6
 80097e4:	f5a3 4200 	sub.w	r2, r3, #32768	; 0x8000
 80097e8:	eb02 32e4 	add.w	r2, r2, r4, asr #15
 80097ec:	fb12 f206 	smulbb	r2, r2, r6
 80097f0:	3b01      	subs	r3, #1
             ADD16(MULT16_16_Q15(r, n), ADD16(r, -32768)))));
   /* r is now the Q15 solution to 2/(n+1), with a maximum relative error
       of 7.05346E-5, a (relative) RMSE of 2.14418E-5, and a peak absolute
       error of 1.24665/32768. */
   return VSHR32(EXTEND32(r),i-16);
 80097f2:	2d10      	cmp	r5, #16
   r = SUB16(r, ADD16(1, MULT16_16_Q15(r,
 80097f4:	eba3 33e2 	sub.w	r3, r3, r2, asr #15
 80097f8:	b21b      	sxth	r3, r3
   return VSHR32(EXTEND32(r),i-16);
 80097fa:	bfcb      	itete	gt
 80097fc:	3d10      	subgt	r5, #16
 80097fe:	f1c5 0510 	rsble	r5, r5, #16
 8009802:	412b      	asrgt	r3, r5
 8009804:	40ab      	lslle	r3, r5
   rcp = ROUND16(celt_rcp(ROUND16(b,16)),3);
 8009806:	3304      	adds	r3, #4
      : "%r"(b), "r"(SHL32(a,16))
 8009808:	f343 03cf 	sbfx	r3, r3, #3, #16
 800980c:	041b      	lsls	r3, r3, #16
  __asm__(
 800980e:	fb80 4203 	smull	r4, r2, r0, r3
  return SHL32(rd_hi,1);
 8009812:	0052      	lsls	r2, r2, #1
   rem = PSHR32(a,2)-MULT32_32_Q31(result, b);
 8009814:	fb82 5601 	smull	r5, r6, r2, r1
 8009818:	0fec      	lsrs	r4, r5, #31
 800981a:	3002      	adds	r0, #2
 800981c:	ea44 0446 	orr.w	r4, r4, r6, lsl #1
 8009820:	ebc4 04a0 	rsb	r4, r4, r0, asr #2
  __asm__(
 8009824:	fb84 1003 	smull	r1, r0, r4, r3
   result = ADD32(result, SHL32(MULT16_32_Q15(rcp, rem),2));
 8009828:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
   if (result >= 536870912)       /*  2^29 */
 800982c:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
 8009830:	da0a      	bge.n	8009848 <frac_div32+0xd0>
   else if (result <= -536870912) /* -2^29 */
 8009832:	f1b0 4f60 	cmp.w	r0, #3758096384	; 0xe0000000
 8009836:	dd0b      	ble.n	8009850 <frac_div32+0xd8>
      return SHL32(result, 2);
 8009838:	0080      	lsls	r0, r0, #2
}
 800983a:	bcf0      	pop	{r4, r5, r6, r7}
 800983c:	4770      	bx	lr
   a = VSHR32(a,shift);
 800983e:	f1c3 031d 	rsb	r3, r3, #29
 8009842:	4098      	lsls	r0, r3
   b = VSHR32(b,shift);
 8009844:	4099      	lsls	r1, r3
 8009846:	e7a2      	b.n	800978e <frac_div32+0x16>
      return 2147483647;          /*  2^31 - 1 */
 8009848:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
}
 800984c:	bcf0      	pop	{r4, r5, r6, r7}
 800984e:	4770      	bx	lr
      return -2147483647;         /* -2^31 */
 8009850:	4800      	ldr	r0, [pc, #0]	; (8009854 <frac_div32+0xdc>)
 8009852:	e7f2      	b.n	800983a <frac_div32+0xc2>
 8009854:	80000001 	.word	0x80000001

08009858 <celt_rsqrt_norm>:
   r = ADD16(23557, MULT16_16_Q15(n, ADD16(-13490, MULT16_16_Q15(n, 6713))));
 8009858:	f645 4205 	movw	r2, #23557	; 0x5c05
   n = x-32768;
 800985c:	f5a0 4300 	sub.w	r3, r0, #32768	; 0x8000
 8009860:	b21b      	sxth	r3, r3
   r = ADD16(23557, MULT16_16_Q15(n, ADD16(-13490, MULT16_16_Q15(n, 6713))));
 8009862:	ebc3 1103 	rsb	r1, r3, r3, lsl #4
 8009866:	ebc3 1181 	rsb	r1, r3, r1, lsl #6
 800986a:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 800986e:	13c9      	asrs	r1, r1, #15
 8009870:	f5a1 5152 	sub.w	r1, r1, #13440	; 0x3480
 8009874:	3932      	subs	r1, #50	; 0x32
 8009876:	fb11 f103 	smulbb	r1, r1, r3
 800987a:	eb02 31e1 	add.w	r1, r2, r1, asr #15
 800987e:	b289      	uxth	r1, r1
{
 8009880:	b410      	push	{r4}
   r = ADD16(23557, MULT16_16_Q15(n, ADD16(-13490, MULT16_16_Q15(n, 6713))));
 8009882:	b20c      	sxth	r4, r1
   r2 = MULT16_16_Q15(r, r);
 8009884:	fb04 f204 	mul.w	r2, r4, r4
 8009888:	13d2      	asrs	r2, r2, #15
   y = SHL16(SUB16(ADD16(MULT16_16_Q15(r2, n), r2), 16384), 1);
 800988a:	fb12 f003 	smulbb	r0, r2, r3
 800988e:	f5a2 4380 	sub.w	r3, r2, #16384	; 0x4000
 8009892:	eb03 33e0 	add.w	r3, r3, r0, asr #15
 8009896:	f343 030e 	sbfx	r3, r3, #0, #15
 800989a:	005b      	lsls	r3, r3, #1
   return ADD16(r, MULT16_16_Q15(r, MULT16_16_Q15(y,
 800989c:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 80098a0:	10d2      	asrs	r2, r2, #3
 80098a2:	f5a2 4280 	sub.w	r2, r2, #16384	; 0x4000
 80098a6:	fb12 f303 	smulbb	r3, r2, r3
 80098aa:	13db      	asrs	r3, r3, #15
 80098ac:	fb04 f303 	mul.w	r3, r4, r3
 80098b0:	eb01 33e3 	add.w	r3, r1, r3, asr #15
}
 80098b4:	b218      	sxth	r0, r3
 80098b6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80098ba:	4770      	bx	lr

080098bc <celt_sqrt>:
   if (x==0)
 80098bc:	b3a8      	cbz	r0, 800992a <celt_sqrt+0x6e>
   else if (x>=1073741824)
 80098be:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80098c2:	da33      	bge.n	800992c <celt_sqrt+0x70>
 80098c4:	fab0 f180 	clz	r1, r0
   k = (celt_ilog2(x)>>1)-7;
 80098c8:	f1c1 011f 	rsb	r1, r1, #31
 80098cc:	1049      	asrs	r1, r1, #1
{
 80098ce:	b470      	push	{r4, r5, r6}
   k = (celt_ilog2(x)>>1)-7;
 80098d0:	1fcd      	subs	r5, r1, #7
   x = VSHR32(x, 2*k);
 80098d2:	2d00      	cmp	r5, #0
 80098d4:	dd2d      	ble.n	8009932 <celt_sqrt+0x76>
 80098d6:	006c      	lsls	r4, r5, #1
 80098d8:	fa40 f404 	asr.w	r4, r0, r4
   rt = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2],
 80098dc:	f64f 5268 	movw	r2, #64872	; 0xfd68
 80098e0:	f642 5629 	movw	r6, #11561	; 0x2d29
 80098e4:	f645 2387 	movw	r3, #23175	; 0x5a87
   n = x-32768;
 80098e8:	f5a4 4400 	sub.w	r4, r4, #32768	; 0x8000
 80098ec:	b224      	sxth	r4, r4
   rt = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2],
 80098ee:	fb14 f202 	smulbb	r2, r4, r2
 80098f2:	13d2      	asrs	r2, r2, #15
 80098f4:	f202 62a3 	addw	r2, r2, #1699	; 0x6a3
 80098f8:	b292      	uxth	r2, r2
 80098fa:	fb04 f202 	mul.w	r2, r4, r2
 80098fe:	13d2      	asrs	r2, r2, #15
 8009900:	f6a2 32c3 	subw	r2, r2, #3011	; 0xbc3
 8009904:	fb12 f204 	smulbb	r2, r2, r4
 8009908:	eb06 30e2 	add.w	r0, r6, r2, asr #15
 800990c:	b280      	uxth	r0, r0
 800990e:	fb04 f000 	mul.w	r0, r4, r0
   rt = VSHR32(rt,7-k);
 8009912:	f1c5 0507 	rsb	r5, r5, #7
 8009916:	2d00      	cmp	r5, #0
   rt = ADD16(C[0], MULT16_16_Q15(n, ADD16(C[1], MULT16_16_Q15(n, ADD16(C[2],
 8009918:	eb03 30e0 	add.w	r0, r3, r0, asr #15
 800991c:	b200      	sxth	r0, r0
   rt = VSHR32(rt,7-k);
 800991e:	bfd6      	itet	le
 8009920:	390e      	suble	r1, #14
 8009922:	4128      	asrgt	r0, r5
 8009924:	4088      	lslle	r0, r1
}
 8009926:	bc70      	pop	{r4, r5, r6}
 8009928:	4770      	bx	lr
 800992a:	4770      	bx	lr
      return 32767;
 800992c:	f647 70ff 	movw	r0, #32767	; 0x7fff
 8009930:	4770      	bx	lr
   x = VSHR32(x, 2*k);
 8009932:	ebc5 74c5 	rsb	r4, r5, r5, lsl #31
 8009936:	0064      	lsls	r4, r4, #1
 8009938:	fa00 f404 	lsl.w	r4, r0, r4
 800993c:	e7ce      	b.n	80098dc <celt_sqrt+0x20>
 800993e:	bf00      	nop

08009940 <celt_cos_norm>:
   x = x&0x0001ffff;
 8009940:	f3c0 0310 	ubfx	r3, r0, #0, #17
   if (x>SHL32(EXTEND32(1), 16))
 8009944:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8009948:	dd33      	ble.n	80099b2 <celt_cos_norm+0x72>
      x = SUB32(SHL32(EXTEND32(1), 17),x);
 800994a:	f5c3 3300 	rsb	r3, r3, #131072	; 0x20000
   if (x&0x00007fff)
 800994e:	f3c3 000e 	ubfx	r0, r3, #0, #15
 8009952:	2800      	cmp	r0, #0
 8009954:	d065      	beq.n	8009a22 <celt_cos_norm+0xe2>
      if (x<SHL32(EXTEND32(1), 15))
 8009956:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
{
 800995a:	b430      	push	{r4, r5}
      if (x<SHL32(EXTEND32(1), 15))
 800995c:	db36      	blt.n	80099cc <celt_cos_norm+0x8c>
   x2 = MULT16_16_P15(x,x);
 800995e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   return ADD16(1,MIN16(32766,ADD32(SUB16(L1,x2), MULT16_16_P15(x2, ADD32(L2, MULT16_16_P15(x2, ADD32(L3, MULT16_16_P15(L4, x2
 8009962:	f64f 558e 	movw	r5, #64910	; 0xfd8e
 8009966:	f242 0255 	movw	r2, #8277	; 0x2055
 800996a:	f647 71fe 	movw	r1, #32766	; 0x7ffe
         return NEG16(_celt_cos_pi_2(EXTRACT16(65536-x)));
 800996e:	425b      	negs	r3, r3
 8009970:	b21b      	sxth	r3, r3
   x2 = MULT16_16_P15(x,x);
 8009972:	fb03 0303 	mla	r3, r3, r3, r0
 8009976:	13db      	asrs	r3, r3, #15
 8009978:	b21c      	sxth	r4, r3
   return ADD16(1,MIN16(32766,ADD32(SUB16(L1,x2), MULT16_16_P15(x2, ADD32(L2, MULT16_16_P15(x2, ADD32(L3, MULT16_16_P15(L4, x2
 800997a:	fb14 0505 	smlabb	r5, r4, r5, r0
 800997e:	eb02 32e5 	add.w	r2, r2, r5, asr #15
 8009982:	b292      	uxth	r2, r2
 8009984:	fb04 f202 	mul.w	r2, r4, r2
 8009988:	4402      	add	r2, r0
 800998a:	13d2      	asrs	r2, r2, #15
 800998c:	f5a2 52ef 	sub.w	r2, r2, #7648	; 0x1de0
 8009990:	3a03      	subs	r2, #3
 8009992:	fb14 0202 	smlabb	r2, r4, r2, r0
 8009996:	f5c4 44ff 	rsb	r4, r4, #32640	; 0x7f80
 800999a:	13d2      	asrs	r2, r2, #15
 800999c:	347f      	adds	r4, #127	; 0x7f
 800999e:	4414      	add	r4, r2
 80099a0:	428c      	cmp	r4, r1
 80099a2:	bfdb      	ittet	le
 80099a4:	1a9b      	suble	r3, r3, r2
 80099a6:	f5a3 4300 	suble.w	r3, r3, #32768	; 0x8000
 80099aa:	481f      	ldrgt	r0, [pc, #124]	; (8009a28 <celt_cos_norm+0xe8>)
 80099ac:	b218      	sxthle	r0, r3
}
 80099ae:	bc30      	pop	{r4, r5}
 80099b0:	4770      	bx	lr
   if (x&0x00007fff)
 80099b2:	f3c0 020e 	ubfx	r2, r0, #0, #15
 80099b6:	2a00      	cmp	r2, #0
 80099b8:	d1cd      	bne.n	8009956 <celt_cos_norm+0x16>
      if (x&0x0000ffff)
 80099ba:	b280      	uxth	r0, r0
 80099bc:	bb90      	cbnz	r0, 8009a24 <celt_cos_norm+0xe4>
         return -32767;
 80099be:	f647 70ff 	movw	r0, #32767	; 0x7fff
 80099c2:	4a19      	ldr	r2, [pc, #100]	; (8009a28 <celt_cos_norm+0xe8>)
 80099c4:	2b00      	cmp	r3, #0
 80099c6:	bf18      	it	ne
 80099c8:	4610      	movne	r0, r2
 80099ca:	4770      	bx	lr
   return ADD16(1,MIN16(32766,ADD32(SUB16(L1,x2), MULT16_16_P15(x2, ADD32(L2, MULT16_16_P15(x2, ADD32(L3, MULT16_16_P15(L4, x2
 80099cc:	f242 0155 	movw	r1, #8277	; 0x2055
 80099d0:	f647 70ff 	movw	r0, #32767	; 0x7fff
 80099d4:	f647 74fe 	movw	r4, #32766	; 0x7ffe
   x2 = MULT16_16_P15(x,x);
 80099d8:	fb03 f203 	mul.w	r2, r3, r3
   return ADD16(1,MIN16(32766,ADD32(SUB16(L1,x2), MULT16_16_P15(x2, ADD32(L2, MULT16_16_P15(x2, ADD32(L3, MULT16_16_P15(L4, x2
 80099dc:	4b13      	ldr	r3, [pc, #76]	; (8009a2c <celt_cos_norm+0xec>)
   x2 = MULT16_16_P15(x,x);
 80099de:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
 80099e2:	13d2      	asrs	r2, r2, #15
   return ADD16(1,MIN16(32766,ADD32(SUB16(L1,x2), MULT16_16_P15(x2, ADD32(L2, MULT16_16_P15(x2, ADD32(L3, MULT16_16_P15(L4, x2
 80099e4:	fb03 f302 	mul.w	r3, r3, r2
 80099e8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 80099ec:	eb01 33e3 	add.w	r3, r1, r3, asr #15
 80099f0:	b29b      	uxth	r3, r3
 80099f2:	fb02 f303 	mul.w	r3, r2, r3
 80099f6:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 80099fa:	13db      	asrs	r3, r3, #15
 80099fc:	f5a3 53ef 	sub.w	r3, r3, #7648	; 0x1de0
 8009a00:	3b03      	subs	r3, #3
 8009a02:	b219      	sxth	r1, r3
 8009a04:	fb02 f101 	mul.w	r1, r2, r1
 8009a08:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
 8009a0c:	13c9      	asrs	r1, r1, #15
 8009a0e:	1a83      	subs	r3, r0, r2
 8009a10:	440b      	add	r3, r1
 8009a12:	42a3      	cmp	r3, r4
 8009a14:	dccb      	bgt.n	80099ae <celt_cos_norm+0x6e>
}
 8009a16:	bc30      	pop	{r4, r5}
   return ADD16(1,MIN16(32766,ADD32(SUB16(L1,x2), MULT16_16_P15(x2, ADD32(L2, MULT16_16_P15(x2, ADD32(L3, MULT16_16_P15(L4, x2
 8009a18:	f5c2 4000 	rsb	r0, r2, #32768	; 0x8000
 8009a1c:	4408      	add	r0, r1
 8009a1e:	b200      	sxth	r0, r0
}
 8009a20:	4770      	bx	lr
 8009a22:	4770      	bx	lr
         return 0;
 8009a24:	4610      	mov	r0, r2
}
 8009a26:	4770      	bx	lr
 8009a28:	ffff8001 	.word	0xffff8001
 8009a2c:	fffffd8e 	.word	0xfffffd8e

08009a30 <celt_rcp>:
{
 8009a30:	b430      	push	{r4, r5}
 8009a32:	fab0 f480 	clz	r4, r0
   r = ADD16(30840, MULT16_16_Q15(-15420, n));
 8009a36:	f24c 31c4 	movw	r1, #50116	; 0xc3c4
 8009a3a:	f1c4 041f 	rsb	r4, r4, #31
   n = VSHR32(x,i-15)-32768;
 8009a3e:	2c0f      	cmp	r4, #15
 8009a40:	bfcb      	itete	gt
 8009a42:	f1a4 020f 	subgt.w	r2, r4, #15
 8009a46:	f1c4 020f 	rsble	r2, r4, #15
 8009a4a:	fa40 f202 	asrgt.w	r2, r0, r2
 8009a4e:	fa00 f202 	lslle.w	r2, r0, r2
 8009a52:	f5a2 4200 	sub.w	r2, r2, #32768	; 0x8000
 8009a56:	b212      	sxth	r2, r2
   r = ADD16(30840, MULT16_16_Q15(-15420, n));
 8009a58:	fb12 f101 	smulbb	r1, r2, r1
 8009a5c:	f3c1 31cf 	ubfx	r1, r1, #15, #16
 8009a60:	f501 43f0 	add.w	r3, r1, #30720	; 0x7800
 8009a64:	3378      	adds	r3, #120	; 0x78
 8009a66:	b29b      	uxth	r3, r3
 8009a68:	b218      	sxth	r0, r3
   r = SUB16(r, MULT16_16_Q15(r,
 8009a6a:	fb02 f500 	mul.w	r5, r2, r0
 8009a6e:	f5a1 61f1 	sub.w	r1, r1, #1928	; 0x788
 8009a72:	eb01 31e5 	add.w	r1, r1, r5, asr #15
 8009a76:	fb11 f100 	smulbb	r1, r1, r0
 8009a7a:	eba3 33e1 	sub.w	r3, r3, r1, asr #15
 8009a7e:	b29b      	uxth	r3, r3
 8009a80:	b219      	sxth	r1, r3
   r = SUB16(r, ADD16(1, MULT16_16_Q15(r,
 8009a82:	fb02 f201 	mul.w	r2, r2, r1
 8009a86:	f5a3 4000 	sub.w	r0, r3, #32768	; 0x8000
 8009a8a:	eb00 30e2 	add.w	r0, r0, r2, asr #15
 8009a8e:	fb10 f201 	smulbb	r2, r0, r1
 8009a92:	1e58      	subs	r0, r3, #1
   return VSHR32(EXTEND32(r),i-16);
 8009a94:	2c10      	cmp	r4, #16
   r = SUB16(r, ADD16(1, MULT16_16_Q15(r,
 8009a96:	eba0 30e2 	sub.w	r0, r0, r2, asr #15
 8009a9a:	b200      	sxth	r0, r0
   return VSHR32(EXTEND32(r),i-16);
 8009a9c:	bfcb      	itete	gt
 8009a9e:	3c10      	subgt	r4, #16
 8009aa0:	f1c4 0410 	rsble	r4, r4, #16
 8009aa4:	4120      	asrgt	r0, r4
 8009aa6:	40a0      	lslle	r0, r4
}
 8009aa8:	bc30      	pop	{r4, r5}
 8009aaa:	4770      	bx	lr

08009aac <clt_mdct_backward_c>:
#endif /* OVERRIDE_clt_mdct_forward */

#ifndef OVERRIDE_clt_mdct_backward
void clt_mdct_backward_c(const mdct_lookup *l, kiss_fft_scalar *in, kiss_fft_scalar * OPUS_RESTRICT out,
      const opus_val16 * OPUS_RESTRICT window, int overlap, int shift, int stride, int arch)
{
 8009aac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009ab0:	b08b      	sub	sp, #44	; 0x2c
 8009ab2:	9d15      	ldr	r5, [sp, #84]	; 0x54
 8009ab4:	9203      	str	r2, [sp, #12]
   const kiss_twiddle_scalar *trig;
   (void) arch;

   N = l->n;
   trig = l->trig;
   for (i=0;i<shift;i++)
 8009ab6:	2d00      	cmp	r5, #0
{
 8009ab8:	469b      	mov	fp, r3
   trig = l->trig;
 8009aba:	6987      	ldr	r7, [r0, #24]
   N = l->n;
 8009abc:	6803      	ldr	r3, [r0, #0]
{
 8009abe:	9a16      	ldr	r2, [sp, #88]	; 0x58
   for (i=0;i<shift;i++)
 8009ac0:	dd06      	ble.n	8009ad0 <clt_mdct_backward_c+0x24>
 8009ac2:	2400      	movs	r4, #0
 8009ac4:	3401      	adds	r4, #1
   {
      N >>= 1;
 8009ac6:	105b      	asrs	r3, r3, #1
   for (i=0;i<shift;i++)
 8009ac8:	42a5      	cmp	r5, r4
      trig += N;
 8009aca:	eb07 0743 	add.w	r7, r7, r3, lsl #1
   for (i=0;i<shift;i++)
 8009ace:	d1f9      	bne.n	8009ac4 <clt_mdct_backward_c+0x18>
   }
   N2 = N>>1;
 8009ad0:	105c      	asrs	r4, r3, #1

   /* Pre-rotate */
   {
      /* Temp pointers to make it really clear to the compiler what we're doing */
      const kiss_fft_scalar * OPUS_RESTRICT xp1 = in;
      const kiss_fft_scalar * OPUS_RESTRICT xp2 = in+stride*(N2-1);
 8009ad2:	f104 3cff 	add.w	ip, r4, #4294967295
      kiss_fft_scalar * OPUS_RESTRICT yp = out+(overlap>>1);
      const kiss_twiddle_scalar * OPUS_RESTRICT t = &trig[0];
      const opus_int16 * OPUS_RESTRICT bitrev = l->kfft[shift]->bitrev;
 8009ad6:	3502      	adds	r5, #2
 8009ad8:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
      const kiss_fft_scalar * OPUS_RESTRICT xp2 = in+stride*(N2-1);
 8009adc:	fb02 fc0c 	mul.w	ip, r2, ip
   N2 = N>>1;
 8009ae0:	9406      	str	r4, [sp, #24]
      kiss_fft_scalar * OPUS_RESTRICT yp = out+(overlap>>1);
 8009ae2:	9c14      	ldr	r4, [sp, #80]	; 0x50
   N4 = N>>2;
 8009ae4:	109b      	asrs	r3, r3, #2
      const opus_int16 * OPUS_RESTRICT bitrev = l->kfft[shift]->bitrev;
 8009ae6:	9005      	str	r0, [sp, #20]
 8009ae8:	f8d0 e030 	ldr.w	lr, [r0, #48]	; 0x30
      kiss_fft_scalar * OPUS_RESTRICT yp = out+(overlap>>1);
 8009aec:	9803      	ldr	r0, [sp, #12]
 8009aee:	1064      	asrs	r4, r4, #1
      for(i=0;i<N4;i++)
 8009af0:	2b00      	cmp	r3, #0
   N4 = N>>2;
 8009af2:	9307      	str	r3, [sp, #28]
      kiss_fft_scalar * OPUS_RESTRICT yp = out+(overlap>>1);
 8009af4:	9404      	str	r4, [sp, #16]
      const kiss_fft_scalar * OPUS_RESTRICT xp2 = in+stride*(N2-1);
 8009af6:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
      kiss_fft_scalar * OPUS_RESTRICT yp = out+(overlap>>1);
 8009afa:	eb00 0884 	add.w	r8, r0, r4, lsl #2
      for(i=0;i<N4;i++)
 8009afe:	dd38      	ble.n	8009b72 <clt_mdct_backward_c+0xc6>
 8009b00:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8009b04:	3b01      	subs	r3, #1
 8009b06:	005b      	lsls	r3, r3, #1
         yi = SUB32_ovflw(S_MUL(*xp1, t[i]), S_MUL(*xp2, t[N4+i]));
         /* We swap real and imag because we use an FFT instead of an IFFT. */
         yp[2*rev+1] = yr;
         yp[2*rev] = yi;
         /* Storing the pre-rotation directly in the bitrev order. */
         xp1+=2*stride;
 8009b08:	00d0      	lsls	r0, r2, #3
 8009b0a:	1c9a      	adds	r2, r3, #2
 8009b0c:	18fb      	adds	r3, r7, r3
 8009b0e:	4699      	mov	r9, r3
 8009b10:	4472      	add	r2, lr
 8009b12:	9202      	str	r2, [sp, #8]
         xp2-=2*stride;
 8009b14:	4242      	negs	r2, r0
         xp1+=2*stride;
 8009b16:	9000      	str	r0, [sp, #0]
         xp2-=2*stride;
 8009b18:	9201      	str	r2, [sp, #4]
 8009b1a:	f1a7 0a02 	sub.w	sl, r7, #2
 8009b1e:	9708      	str	r7, [sp, #32]
 8009b20:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
      : "%r"(b), "r"(SHL32(a,16))
 8009b24:	f93a 3f02 	ldrsh.w	r3, [sl, #2]!
 8009b28:	f939 2f02 	ldrsh.w	r2, [r9, #2]!
         yp[2*rev+1] = yr;
 8009b2c:	f93e 7b02 	ldrsh.w	r7, [lr], #2
         yr = ADD32_ovflw(S_MUL(*xp2, t[i]), S_MUL(*xp1, t[N4+i]));
 8009b30:	f8dc 4000 	ldr.w	r4, [ip]
 8009b34:	041b      	lsls	r3, r3, #16
 8009b36:	0412      	lsls	r2, r2, #16
  __asm__(
 8009b38:	fb84 0603 	smull	r0, r6, r4, r3
 8009b3c:	fb84 5002 	smull	r5, r0, r4, r2
  return SHL32(rd_hi,1);
 8009b40:	0076      	lsls	r6, r6, #1
 8009b42:	0040      	lsls	r0, r0, #1
 8009b44:	680c      	ldr	r4, [r1, #0]
  __asm__(
 8009b46:	fb84 b502 	smull	fp, r5, r4, r2
 8009b4a:	fb84 b203 	smull	fp, r2, r4, r3
 8009b4e:	eb06 0545 	add.w	r5, r6, r5, lsl #1
         yi = SUB32_ovflw(S_MUL(*xp1, t[i]), S_MUL(*xp2, t[N4+i]));
 8009b52:	ebc0 0042 	rsb	r0, r0, r2, lsl #1
         yp[2*rev+1] = yr;
 8009b56:	eb08 03c7 	add.w	r3, r8, r7, lsl #3
         xp2-=2*stride;
 8009b5a:	9a01      	ldr	r2, [sp, #4]
         yp[2*rev+1] = yr;
 8009b5c:	605d      	str	r5, [r3, #4]
      for(i=0;i<N4;i++)
 8009b5e:	9b02      	ldr	r3, [sp, #8]
         xp2-=2*stride;
 8009b60:	4494      	add	ip, r2
         xp1+=2*stride;
 8009b62:	9a00      	ldr	r2, [sp, #0]
      for(i=0;i<N4;i++)
 8009b64:	459e      	cmp	lr, r3
         xp1+=2*stride;
 8009b66:	4411      	add	r1, r2
         yp[2*rev] = yi;
 8009b68:	f848 0037 	str.w	r0, [r8, r7, lsl #3]
      for(i=0;i<N4;i++)
 8009b6c:	d1da      	bne.n	8009b24 <clt_mdct_backward_c+0x78>
 8009b6e:	e9dd 7b08 	ldrd	r7, fp, [sp, #32]
      }
   }

   opus_fft_impl(l->kfft[shift], (kiss_fft_cpx*)(out+(overlap>>1)));
 8009b72:	9805      	ldr	r0, [sp, #20]
 8009b74:	4641      	mov	r1, r8
 8009b76:	f7ff f821 	bl	8008bbc <opus_fft_impl>

   /* Post-rotate and de-shuffle from both ends of the buffer at once to make
      it in-place. */
   {
      kiss_fft_scalar * yp0 = out+(overlap>>1);
      kiss_fft_scalar * yp1 = out+(overlap>>1)+N2-2;
 8009b7a:	9b04      	ldr	r3, [sp, #16]
      const kiss_twiddle_scalar *t = &trig[0];
      /* Loop to (N4+1)>>1 to handle odd N4. When N4 is odd, the
         middle pair will be computed twice. */
      for(i=0;i<(N4+1)>>1;i++)
 8009b7c:	9807      	ldr	r0, [sp, #28]
      kiss_fft_scalar * yp1 = out+(overlap>>1)+N2-2;
 8009b7e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
      for(i=0;i<(N4+1)>>1;i++)
 8009b82:	1c41      	adds	r1, r0, #1
      kiss_fft_scalar * yp1 = out+(overlap>>1)+N2-2;
 8009b84:	9c06      	ldr	r4, [sp, #24]
 8009b86:	3b02      	subs	r3, #2
      for(i=0;i<(N4+1)>>1;i++)
 8009b88:	1049      	asrs	r1, r1, #1
      kiss_fft_scalar * yp1 = out+(overlap>>1)+N2-2;
 8009b8a:	4423      	add	r3, r4
      for(i=0;i<(N4+1)>>1;i++)
 8009b8c:	2900      	cmp	r1, #0
      kiss_fft_scalar * yp1 = out+(overlap>>1)+N2-2;
 8009b8e:	ea4f 0283 	mov.w	r2, r3, lsl #2
      for(i=0;i<(N4+1)>>1;i++)
 8009b92:	dd57      	ble.n	8009c44 <clt_mdct_backward_c+0x198>
 8009b94:	f100 4c00 	add.w	ip, r0, #2147483648	; 0x80000000
 8009b98:	f108 0308 	add.w	r3, r8, #8
 8009b9c:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8009ba0:	f10c 3cff 	add.w	ip, ip, #4294967295
 8009ba4:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 8009ba8:	9101      	str	r1, [sp, #4]
 8009baa:	9903      	ldr	r1, [sp, #12]
 8009bac:	f10c 0a02 	add.w	sl, ip, #2
 8009bb0:	3a08      	subs	r2, #8
 8009bb2:	440a      	add	r2, r1
 8009bb4:	44ba      	add	sl, r7
 8009bb6:	eb07 0144 	add.w	r1, r7, r4, lsl #1
 8009bba:	44bc      	add	ip, r7
 8009bbc:	3f02      	subs	r7, #2
 8009bbe:	46b9      	mov	r9, r7
 8009bc0:	9100      	str	r1, [sp, #0]
 8009bc2:	f8cd b008 	str.w	fp, [sp, #8]
      : "%r"(b), "r"(SHL32(a,16))
 8009bc6:	f939 1f02 	ldrsh.w	r1, [r9, #2]!
      {
         kiss_fft_scalar re, im, yr, yi;
         kiss_twiddle_scalar t0, t1;
         /* We swap real and imag because we're using an FFT instead of an IFFT. */
         re = yp0[1];
         im = yp0[0];
 8009bca:	e953 6702 	ldrd	r6, r7, [r3, #-8]
 8009bce:	0409      	lsls	r1, r1, #16
  __asm__(
 8009bd0:	fb87 e501 	smull	lr, r5, r7, r1
 8009bd4:	fb86 e801 	smull	lr, r8, r6, r1
      : "%r"(b), "r"(SHL32(a,16))
 8009bd8:	9900      	ldr	r1, [sp, #0]
 8009bda:	f93c 4f02 	ldrsh.w	r4, [ip, #2]!
 8009bde:	f931 ed02 	ldrsh.w	lr, [r1, #-2]!
 8009be2:	f93a 0d02 	ldrsh.w	r0, [sl, #-2]!
  return SHL32(rd_hi,1);
 8009be6:	006d      	lsls	r5, r5, #1
      : "%r"(b), "r"(SHL32(a,16))
 8009be8:	0424      	lsls	r4, r4, #16
  return SHL32(rd_hi,1);
 8009bea:	ea4f 0848 	mov.w	r8, r8, lsl #1
      : "%r"(b), "r"(SHL32(a,16))
 8009bee:	9100      	str	r1, [sp, #0]
 8009bf0:	ea4f 410e 	mov.w	r1, lr, lsl #16
  __asm__(
 8009bf4:	fb87 be04 	smull	fp, lr, r7, r4
 8009bf8:	fb86 b704 	smull	fp, r7, r6, r4
         t0 = t[i];
         t1 = t[N4+i];
         /* We'd scale up by 2 here, but instead it's done when mixing the windows */
         yr = ADD32_ovflw(S_MUL(re,t0), S_MUL(im,t1));
 8009bfc:	eb05 0547 	add.w	r5, r5, r7, lsl #1
         yi = SUB32_ovflw(S_MUL(re,t1), S_MUL(im,t0));
         /* We swap real and imag because we're using an FFT instead of an IFFT. */
         re = yp1[1];
 8009c00:	68d4      	ldr	r4, [r2, #12]
      : "%r"(b), "r"(SHL32(a,16))
 8009c02:	0400      	lsls	r0, r0, #16
         yi = SUB32_ovflw(S_MUL(re,t1), S_MUL(im,t0));
 8009c04:	ebc8 064e 	rsb	r6, r8, lr, lsl #1
         im = yp1[0];
 8009c08:	f8d2 e008 	ldr.w	lr, [r2, #8]
         yp0[0] = yr;
 8009c0c:	f843 5c08 	str.w	r5, [r3, #-8]
  __asm__(
 8009c10:	fb84 5700 	smull	r5, r7, r4, r0
 8009c14:	fb8e 8500 	smull	r8, r5, lr, r0
  return SHL32(rd_hi,1);
 8009c18:	007f      	lsls	r7, r7, #1
 8009c1a:	0068      	lsls	r0, r5, #1
  __asm__(
 8009c1c:	fb8e 5801 	smull	r5, r8, lr, r1
 8009c20:	fb84 e501 	smull	lr, r5, r4, r1
         yp1[1] = yi;

         t0 = t[(N4-i-1)];
         t1 = t[(N2-i-1)];
         /* We'd scale up by 2 here, but instead it's done when mixing the windows */
         yr = ADD32_ovflw(S_MUL(re,t0), S_MUL(im,t1));
 8009c24:	eb07 0748 	add.w	r7, r7, r8, lsl #1
         yi = SUB32_ovflw(S_MUL(re,t1), S_MUL(im,t0));
 8009c28:	ebc0 0045 	rsb	r0, r0, r5, lsl #1
      for(i=0;i<(N4+1)>>1;i++)
 8009c2c:	9901      	ldr	r1, [sp, #4]
         yp1[0] = yr;
 8009c2e:	e9c2 7602 	strd	r7, r6, [r2, #8]
 8009c32:	3308      	adds	r3, #8
         yp0[1] = yi;
 8009c34:	f843 0c0c 	str.w	r0, [r3, #-12]
      for(i=0;i<(N4+1)>>1;i++)
 8009c38:	4299      	cmp	r1, r3
 8009c3a:	f1a2 0208 	sub.w	r2, r2, #8
 8009c3e:	d1c2      	bne.n	8009bc6 <clt_mdct_backward_c+0x11a>
 8009c40:	f8dd b008 	ldr.w	fp, [sp, #8]
      }
   }

   /* Mirror on both sides for TDAC */
   {
      kiss_fft_scalar * OPUS_RESTRICT xp1 = out+overlap-1;
 8009c44:	9b14      	ldr	r3, [sp, #80]	; 0x50
      kiss_fft_scalar * OPUS_RESTRICT yp1 = out;
      const opus_val16 * OPUS_RESTRICT wp1 = window;
      const opus_val16 * OPUS_RESTRICT wp2 = window+overlap-1;

      for(i = 0; i < overlap/2; i++)
 8009c46:	eb03 77d3 	add.w	r7, r3, r3, lsr #31
      kiss_fft_scalar * OPUS_RESTRICT xp1 = out+overlap-1;
 8009c4a:	f103 4580 	add.w	r5, r3, #1073741824	; 0x40000000
      const opus_val16 * OPUS_RESTRICT wp2 = window+overlap-1;
 8009c4e:	f103 4600 	add.w	r6, r3, #2147483648	; 0x80000000
      for(i = 0; i < overlap/2; i++)
 8009c52:	107f      	asrs	r7, r7, #1
      kiss_fft_scalar * OPUS_RESTRICT xp1 = out+overlap-1;
 8009c54:	3d01      	subs	r5, #1
      const opus_val16 * OPUS_RESTRICT wp2 = window+overlap-1;
 8009c56:	3e01      	subs	r6, #1
      for(i = 0; i < overlap/2; i++)
 8009c58:	2f00      	cmp	r7, #0
      kiss_fft_scalar * OPUS_RESTRICT xp1 = out+overlap-1;
 8009c5a:	ea4f 0585 	mov.w	r5, r5, lsl #2
      const opus_val16 * OPUS_RESTRICT wp2 = window+overlap-1;
 8009c5e:	ea4f 0646 	mov.w	r6, r6, lsl #1
      for(i = 0; i < overlap/2; i++)
 8009c62:	dd24      	ble.n	8009cae <clt_mdct_backward_c+0x202>
 8009c64:	9b03      	ldr	r3, [sp, #12]
 8009c66:	3504      	adds	r5, #4
 8009c68:	3602      	adds	r6, #2
 8009c6a:	441d      	add	r5, r3
 8009c6c:	445e      	add	r6, fp
 8009c6e:	1f1a      	subs	r2, r3, #4
 8009c70:	eb0b 0747 	add.w	r7, fp, r7, lsl #1
      : "%r"(b), "r"(SHL32(a,16))
 8009c74:	f93b 1b02 	ldrsh.w	r1, [fp], #2
 8009c78:	f936 3d02 	ldrsh.w	r3, [r6, #-2]!
      {
         kiss_fft_scalar x1, x2;
         x1 = *xp1;
 8009c7c:	f855 8d04 	ldr.w	r8, [r5, #-4]!
         x2 = *yp1;
 8009c80:	f852 ef04 	ldr.w	lr, [r2, #4]!
 8009c84:	0409      	lsls	r1, r1, #16
  __asm__(
 8009c86:	fb88 0c01 	smull	r0, ip, r8, r1
 8009c8a:	fb8e 4001 	smull	r4, r0, lr, r1
  return SHL32(rd_hi,1);
 8009c8e:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 8009c92:	0041      	lsls	r1, r0, #1
      : "%r"(b), "r"(SHL32(a,16))
 8009c94:	041b      	lsls	r3, r3, #16
      for(i = 0; i < overlap/2; i++)
 8009c96:	45bb      	cmp	fp, r7
  __asm__(
 8009c98:	fb88 0403 	smull	r0, r4, r8, r3
 8009c9c:	fb8e 8003 	smull	r8, r0, lr, r3
         *yp1++ = SUB32_ovflw(MULT16_32_Q15(*wp2, x2), MULT16_32_Q15(*wp1, x1));
         *xp1-- = ADD32_ovflw(MULT16_32_Q15(*wp1, x2), MULT16_32_Q15(*wp2, x1));
 8009ca0:	eb01 0444 	add.w	r4, r1, r4, lsl #1
         *yp1++ = SUB32_ovflw(MULT16_32_Q15(*wp2, x2), MULT16_32_Q15(*wp1, x1));
 8009ca4:	ebcc 0040 	rsb	r0, ip, r0, lsl #1
 8009ca8:	6010      	str	r0, [r2, #0]
         *xp1-- = ADD32_ovflw(MULT16_32_Q15(*wp1, x2), MULT16_32_Q15(*wp2, x1));
 8009caa:	602c      	str	r4, [r5, #0]
      for(i = 0; i < overlap/2; i++)
 8009cac:	d1e2      	bne.n	8009c74 <clt_mdct_backward_c+0x1c8>
         wp1++;
         wp2--;
      }
   }
}
 8009cae:	b00b      	add	sp, #44	; 0x2c
 8009cb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08009cb4 <find_best_pitch>:
                            int max_pitch, int *best_pitch
#ifdef FIXED_POINT
                            , int yshift, opus_val32 maxcorr
#endif
                            )
{
 8009cb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009cb8:	b087      	sub	sp, #28
 8009cba:	9e12      	ldr	r6, [sp, #72]	; 0x48

   best_num[0] = -1;
   best_num[1] = -1;
   best_den[0] = 0;
   best_den[1] = 0;
   best_pitch[0] = 0;
 8009cbc:	2500      	movs	r5, #0
 8009cbe:	fab6 f686 	clz	r6, r6
   best_pitch[1] = 1;
 8009cc2:	2401      	movs	r4, #1
   best_pitch[0] = 0;
 8009cc4:	9f10      	ldr	r7, [sp, #64]	; 0x40
   xshift = celt_ilog2(maxcorr)-14;
 8009cc6:	f1c6 061f 	rsb	r6, r6, #31
   for (j=0;j<len;j++)
 8009cca:	2a00      	cmp	r2, #0
   best_pitch[1] = 1;
 8009ccc:	e9c7 5400 	strd	r5, r4, [r7]
   xshift = celt_ilog2(maxcorr)-14;
 8009cd0:	f1a6 090e 	sub.w	r9, r6, #14
{
 8009cd4:	9d11      	ldr	r5, [sp, #68]	; 0x44
   for (j=0;j<len;j++)
 8009cd6:	dd0c      	ble.n	8009cf2 <find_best_pitch+0x3e>
 8009cd8:	f1a1 0c02 	sub.w	ip, r1, #2
 8009cdc:	eb0c 0e42 	add.w	lr, ip, r2, lsl #1
      Syy = ADD32(Syy, SHR32(MULT16_16(y[j],y[j]), yshift));
 8009ce0:	f93c 7f02 	ldrsh.w	r7, [ip, #2]!
 8009ce4:	fb07 f707 	mul.w	r7, r7, r7
   for (j=0;j<len;j++)
 8009ce8:	45e6      	cmp	lr, ip
      Syy = ADD32(Syy, SHR32(MULT16_16(y[j],y[j]), yshift));
 8009cea:	fa47 f705 	asr.w	r7, r7, r5
 8009cee:	443c      	add	r4, r7
   for (j=0;j<len;j++)
 8009cf0:	d1f6      	bne.n	8009ce0 <find_best_pitch+0x2c>
   for (i=0;i<max_pitch;i++)
 8009cf2:	2b00      	cmp	r3, #0
 8009cf4:	dd65      	ble.n	8009dc2 <find_best_pitch+0x10e>
   best_num[1] = -1;
 8009cf6:	f04f 3bff 	mov.w	fp, #4294967295
 8009cfa:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
 8009cfe:	3804      	subs	r0, #4
 8009d00:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8009d04:	445a      	add	r2, fp
 8009d06:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 8009d0a:	9302      	str	r3, [sp, #8]
   {
      if (xcorr[i]>0)
      {
         opus_val16 num;
         opus_val32 xcorr16;
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
 8009d0c:	f1c6 030e 	rsb	r3, r6, #14
   best_den[1] = 0;
 8009d10:	f04f 0e00 	mov.w	lr, #0
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
 8009d14:	9305      	str	r3, [sp, #20]
 8009d16:	4613      	mov	r3, r2
 8009d18:	3902      	subs	r1, #2
   best_num[0] = -1;
 8009d1a:	e9cd be03 	strd	fp, lr, [sp, #12]
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
 8009d1e:	9101      	str	r1, [sp, #4]
 8009d20:	4672      	mov	r2, lr
 8009d22:	469c      	mov	ip, r3
 8009d24:	e01f      	b.n	8009d66 <find_best_pitch+0xb2>
         {
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
            {
               best_num[1] = best_num[0];
               best_den[1] = best_den[0];
               best_pitch[1] = best_pitch[0];
 8009d26:	9e10      	ldr	r6, [sp, #64]	; 0x40
 8009d28:	468e      	mov	lr, r1
 8009d2a:	6836      	ldr	r6, [r6, #0]
 8009d2c:	9910      	ldr	r1, [sp, #64]	; 0x40
 8009d2e:	f8dd b00c 	ldr.w	fp, [sp, #12]
 8009d32:	604e      	str	r6, [r1, #4]
               best_num[0] = num;
 8009d34:	9303      	str	r3, [sp, #12]
               best_den[0] = Syy;
               best_pitch[0] = i;
 8009d36:	600a      	str	r2, [r1, #0]
 8009d38:	9404      	str	r4, [sp, #16]
               best_den[1] = Syy;
               best_pitch[1] = i;
            }
         }
      }
      Syy += SHR32(MULT16_16(y[i+len],y[i+len]),yshift) - SHR32(MULT16_16(y[i],y[i]),yshift);
 8009d3a:	9901      	ldr	r1, [sp, #4]
 8009d3c:	f93c 3f02 	ldrsh.w	r3, [ip, #2]!
 8009d40:	f931 6f02 	ldrsh.w	r6, [r1, #2]!
 8009d44:	fb03 f303 	mul.w	r3, r3, r3
 8009d48:	fb06 f606 	mul.w	r6, r6, r6
 8009d4c:	412b      	asrs	r3, r5
 8009d4e:	412e      	asrs	r6, r5
 8009d50:	1b9e      	subs	r6, r3, r6
 8009d52:	4434      	add	r4, r6
   for (i=0;i<max_pitch;i++)
 8009d54:	9b02      	ldr	r3, [sp, #8]
      Syy = MAX32(1, Syy);
 8009d56:	2c01      	cmp	r4, #1
 8009d58:	bfb8      	it	lt
 8009d5a:	2401      	movlt	r4, #1
   for (i=0;i<max_pitch;i++)
 8009d5c:	4283      	cmp	r3, r0
      Syy += SHR32(MULT16_16(y[i+len],y[i+len]),yshift) - SHR32(MULT16_16(y[i],y[i]),yshift);
 8009d5e:	9101      	str	r1, [sp, #4]
   for (i=0;i<max_pitch;i++)
 8009d60:	f102 0201 	add.w	r2, r2, #1
 8009d64:	d02d      	beq.n	8009dc2 <find_best_pitch+0x10e>
      if (xcorr[i]>0)
 8009d66:	f850 6f04 	ldr.w	r6, [r0, #4]!
 8009d6a:	2e00      	cmp	r6, #0
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
 8009d6c:	fa46 f309 	asr.w	r3, r6, r9
      if (xcorr[i]>0)
 8009d70:	dde3      	ble.n	8009d3a <find_best_pitch+0x86>
         xcorr16 = EXTRACT16(VSHR32(xcorr[i], xshift));
 8009d72:	f1b9 0f00 	cmp.w	r9, #0
 8009d76:	bfdc      	itt	le
 8009d78:	9b05      	ldrle	r3, [sp, #20]
 8009d7a:	fa06 f303 	lslle.w	r3, r6, r3
 8009d7e:	b21b      	sxth	r3, r3
         num = MULT16_16_Q15(xcorr16,xcorr16);
 8009d80:	fb03 f303 	mul.w	r3, r3, r3
 8009d84:	f343 33cf 	sbfx	r3, r3, #15, #16
      : "%r"(b), "r"(SHL32(a,16))
 8009d88:	041e      	lsls	r6, r3, #16
  __asm__(
 8009d8a:	fb8e 8706 	smull	r8, r7, lr, r6
  return SHL32(rd_hi,1);
 8009d8e:	007f      	lsls	r7, r7, #1
      : "%r"(b), "r"(SHL32(a,16))
 8009d90:	ea4f 480b 	mov.w	r8, fp, lsl #16
  __asm__(
 8009d94:	fb84 1a08 	smull	r1, sl, r4, r8
         if (MULT16_32_Q15(num,best_den[1]) > MULT16_32_Q15(best_num[1],Syy))
 8009d98:	ebb7 0f4a 	cmp.w	r7, sl, lsl #1
      : "%r"(b), "r"(SHL32(a,16))
 8009d9c:	9f03      	ldr	r7, [sp, #12]
 8009d9e:	ea4f 4707 	mov.w	r7, r7, lsl #16
 8009da2:	ddca      	ble.n	8009d3a <find_best_pitch+0x86>
  __asm__(
 8009da4:	9904      	ldr	r1, [sp, #16]
 8009da6:	fb81 8e06 	smull	r8, lr, r1, r6
  return SHL32(rd_hi,1);
 8009daa:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
  __asm__(
 8009dae:	fb84 8607 	smull	r8, r6, r4, r7
            if (MULT16_32_Q15(num,best_den[0]) > MULT16_32_Q15(best_num[0],Syy))
 8009db2:	ebbe 0f46 	cmp.w	lr, r6, lsl #1
 8009db6:	dcb6      	bgt.n	8009d26 <find_best_pitch+0x72>
               best_num[1] = num;
 8009db8:	469b      	mov	fp, r3
               best_pitch[1] = i;
 8009dba:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8009dbc:	46a6      	mov	lr, r4
 8009dbe:	605a      	str	r2, [r3, #4]
 8009dc0:	e7bb      	b.n	8009d3a <find_best_pitch+0x86>
   }
}
 8009dc2:	b007      	add	sp, #28
 8009dc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08009dc8 <pitch_downsample>:
}


void pitch_downsample(celt_sig * OPUS_RESTRICT x[], opus_val16 * OPUS_RESTRICT x_lp,
      int len, int C, int arch)
{
 8009dc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   for (i=0;i<len;i++)
 8009dcc:	f1b2 0900 	subs.w	r9, r2, #0
 8009dd0:	b08d      	sub	sp, #52	; 0x34
 8009dd2:	460d      	mov	r5, r1
 8009dd4:	469a      	mov	sl, r3
   opus_val16 lpc[4];
   opus_val16 lpc2[5];
   opus_val16 c1 = QCONST16(.8f,15);
#ifdef FIXED_POINT
   int shift;
   opus_val32 maxabs = celt_maxabs32(x[0], len);
 8009dd6:	6807      	ldr	r7, [r0, #0]
 8009dd8:	f340 813b 	ble.w	800a052 <pitch_downsample+0x28a>
   opus_val32 minval = 0;
 8009ddc:	2300      	movs	r3, #0
   opus_val32 maxval = 0;
 8009dde:	461c      	mov	r4, r3
 8009de0:	ea4f 0c89 	mov.w	ip, r9, lsl #2
 8009de4:	f1ac 0c04 	sub.w	ip, ip, #4
 8009de8:	eb07 0e0c 	add.w	lr, r7, ip
 8009dec:	1f3a      	subs	r2, r7, #4
      maxval = MAX32(maxval, x[i]);
 8009dee:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8009df2:	428c      	cmp	r4, r1
 8009df4:	bfb8      	it	lt
 8009df6:	460c      	movlt	r4, r1
      minval = MIN32(minval, x[i]);
 8009df8:	428b      	cmp	r3, r1
 8009dfa:	bfa8      	it	ge
 8009dfc:	460b      	movge	r3, r1
   for (i=0;i<len;i++)
 8009dfe:	4596      	cmp	lr, r2
 8009e00:	d1f5      	bne.n	8009dee <pitch_downsample+0x26>
   return MAX32(maxval, -minval);
 8009e02:	425b      	negs	r3, r3
 8009e04:	42a3      	cmp	r3, r4
 8009e06:	bfb8      	it	lt
 8009e08:	4623      	movlt	r3, r4
   if (C==2)
 8009e0a:	f1ba 0f02 	cmp.w	sl, #2
 8009e0e:	f000 80d4 	beq.w	8009fba <pitch_downsample+0x1f2>
   {
      opus_val32 maxabs_1 = celt_maxabs32(x[1], len);
      maxabs = MAX32(maxabs, maxabs_1);
   }
   if (maxabs<1)
 8009e12:	2b00      	cmp	r3, #0
 8009e14:	f340 8113 	ble.w	800a03e <pitch_downsample+0x276>
   return EC_ILOG(x)-1;
 8009e18:	fab3 f183 	clz	r1, r3
 8009e1c:	f1c1 011f 	rsb	r1, r1, #31
      maxabs=1;
   shift = celt_ilog2(maxabs)-10;
 8009e20:	b289      	uxth	r1, r1
 8009e22:	390a      	subs	r1, #10
   if (shift<0)
      shift=0;
   if (C==2)
 8009e24:	f1ba 0f02 	cmp.w	sl, #2
 8009e28:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
 8009e2c:	f000 80c3 	beq.w	8009fb6 <pitch_downsample+0x1ee>
 8009e30:	e9d7 3200 	ldrd	r3, r2, [r7]
 8009e34:	eb03 0e62 	add.w	lr, r3, r2, asr #1
      shift++;
#endif
   for (i=1;i<len>>1;i++)
 8009e38:	ea4f 0469 	mov.w	r4, r9, asr #1
 8009e3c:	ea4f 0e6e 	mov.w	lr, lr, asr #1
 8009e40:	fa4e fe01 	asr.w	lr, lr, r1
 8009e44:	2c01      	cmp	r4, #1
 8009e46:	fa0f fe8e 	sxth.w	lr, lr
 8009e4a:	f340 80fa 	ble.w	800a042 <pitch_downsample+0x27a>
 8009e4e:	4693      	mov	fp, r2
 8009e50:	46a8      	mov	r8, r5
 8009e52:	46ac      	mov	ip, r5
 8009e54:	eb07 09c4 	add.w	r9, r7, r4, lsl #3
 8009e58:	f1a9 0908 	sub.w	r9, r9, #8
      x_lp[i] = SHR32(HALF32(HALF32(x[0][(2*i-1)]+x[0][(2*i+1)])+x[0][2*i]), shift);
 8009e5c:	68fb      	ldr	r3, [r7, #12]
 8009e5e:	f857 2f08 	ldr.w	r2, [r7, #8]!
 8009e62:	449b      	add	fp, r3
 8009e64:	eb02 026b 	add.w	r2, r2, fp, asr #1
 8009e68:	1052      	asrs	r2, r2, #1
 8009e6a:	410a      	asrs	r2, r1
   for (i=1;i<len>>1;i++)
 8009e6c:	45b9      	cmp	r9, r7
 8009e6e:	469b      	mov	fp, r3
      x_lp[i] = SHR32(HALF32(HALF32(x[0][(2*i-1)]+x[0][(2*i+1)])+x[0][2*i]), shift);
 8009e70:	f82c 2f02 	strh.w	r2, [ip, #2]!
   for (i=1;i<len>>1;i++)
 8009e74:	d1f2      	bne.n	8009e5c <pitch_downsample+0x94>
   x_lp[0] = SHR32(HALF32(HALF32(x[0][1])+x[0][0]), shift);
   if (C==2)
 8009e76:	f1ba 0f02 	cmp.w	sl, #2
   x_lp[0] = SHR32(HALF32(HALF32(x[0][1])+x[0][0]), shift);
 8009e7a:	f8a5 e000 	strh.w	lr, [r5]
   if (C==2)
 8009e7e:	f000 80b9 	beq.w	8009ff4 <pitch_downsample+0x22c>
      for (i=1;i<len>>1;i++)
         x_lp[i] += SHR32(HALF32(HALF32(x[1][(2*i-1)]+x[1][(2*i+1)])+x[1][2*i]), shift);
      x_lp[0] += SHR32(HALF32(HALF32(x[1][1])+x[1][0]), shift);
   }

   _celt_autocorr(x_lp, ac, NULL, 0,
 8009e82:	f04f 0804 	mov.w	r8, #4
 8009e86:	2300      	movs	r3, #0
 8009e88:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8009e8a:	f8cd 8000 	str.w	r8, [sp]
 8009e8e:	e9cd 4201 	strd	r4, r2, [sp, #4]
 8009e92:	a907      	add	r1, sp, #28
 8009e94:	461a      	mov	r2, r3
 8009e96:	4628      	mov	r0, r5
 8009e98:	f7fd feda 	bl	8007c50 <_celt_autocorr>
   /* Lag windowing */
   for (i=1;i<=4;i++)
   {
      /*ac[i] *= exp(-.5*(2*M_PI*.002*i)*(2*M_PI*.002*i));*/
#ifdef FIXED_POINT
      ac[i] -= MULT16_32_Q15(2*i*i, ac[i]);
 8009e9c:	e9dd 7608 	ldrd	r7, r6, [sp, #32]
 8009ea0:	e9dd 030a 	ldrd	r0, r3, [sp, #40]	; 0x28
   ac[0] += SHR32(ac[0],13);
 8009ea4:	f8dd e01c 	ldr.w	lr, [sp, #28]
#else
      ac[i] -= ac[i]*(.008f*i)*(.008f*i);
#endif
   }

   _celt_lpc(lpc, ac, 4);
 8009ea8:	4642      	mov	r2, r8
   ac[0] += SHR32(ac[0],13);
 8009eaa:	eb0e 3e6e 	add.w	lr, lr, lr, asr #13
   _celt_lpc(lpc, ac, 4);
 8009eae:	a907      	add	r1, sp, #28
 8009eb0:	f44f 3800 	mov.w	r8, #131072	; 0x20000
 8009eb4:	fb87 9c08 	smull	r9, ip, r7, r8
 8009eb8:	f44f 2800 	mov.w	r8, #524288	; 0x80000
      ac[i] -= MULT16_32_Q15(2*i*i, ac[i]);
 8009ebc:	eba7 0c4c 	sub.w	ip, r7, ip, lsl #1
 8009ec0:	fb86 9708 	smull	r9, r7, r6, r8
 8009ec4:	f44f 1890 	mov.w	r8, #1179648	; 0x120000
 8009ec8:	eba6 0747 	sub.w	r7, r6, r7, lsl #1
 8009ecc:	fb80 9608 	smull	r9, r6, r0, r8
 8009ed0:	eba0 0646 	sub.w	r6, r0, r6, lsl #1
 8009ed4:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8009ed8:	fb83 9800 	smull	r9, r8, r3, r0
   _celt_lpc(lpc, ac, 4);
 8009edc:	a805      	add	r0, sp, #20
      ac[i] -= MULT16_32_Q15(2*i*i, ac[i]);
 8009ede:	eba3 0348 	sub.w	r3, r3, r8, lsl #1
 8009ee2:	e9cd c708 	strd	ip, r7, [sp, #32]
 8009ee6:	e9cd 630a 	strd	r6, r3, [sp, #40]	; 0x28
   ac[0] += SHR32(ac[0],13);
 8009eea:	f8cd e01c 	str.w	lr, [sp, #28]
   _celt_lpc(lpc, ac, 4);
 8009eee:	f7fd f9ab 	bl	8007248 <_celt_lpc>
   for (i=0;i<4;i++)
   {
      tmp = MULT16_16_Q15(QCONST16(.9f,15), tmp);
      lpc[i] = MULT16_16_Q15(lpc[i], tmp);
 8009ef2:	f246 71ac 	movw	r1, #26540	; 0x67ac
 8009ef6:	f645 524d 	movw	r2, #23885	; 0x5d4d
 8009efa:	f247 3032 	movw	r0, #29490	; 0x7332
 8009efe:	f245 33f8 	movw	r3, #21496	; 0x53f8
   }
   /* Add a zero */
   lpc2[0] = lpc[0] + QCONST16(.8f,SIG_SHIFT);
   lpc2[1] = lpc[1] + MULT16_16_Q15(c1,lpc[0]);
 8009f02:	f246 6a66 	movw	sl, #26214	; 0x6666
      lpc[i] = MULT16_16_Q15(lpc[i], tmp);
 8009f06:	f8bd 7014 	ldrh.w	r7, [sp, #20]
 8009f0a:	f8bd c016 	ldrh.w	ip, [sp, #22]
 8009f0e:	f8bd e018 	ldrh.w	lr, [sp, #24]
 8009f12:	f8bd 801a 	ldrh.w	r8, [sp, #26]
 8009f16:	fb1c fc01 	smulbb	ip, ip, r1
 8009f1a:	fb1e fe02 	smulbb	lr, lr, r2
 8009f1e:	fb17 f700 	smulbb	r7, r7, r0
 8009f22:	fb18 f803 	smulbb	r8, r8, r3
 8009f26:	13ff      	asrs	r7, r7, #15
 8009f28:	ea4f 3cec 	mov.w	ip, ip, asr #15
 8009f2c:	ea4f 3eee 	mov.w	lr, lr, asr #15
   lpc2[1] = lpc[1] + MULT16_16_Q15(c1,lpc[0]);
 8009f30:	fb0a f107 	mul.w	r1, sl, r7
   lpc2[2] = lpc[2] + MULT16_16_Q15(c1,lpc[1]);
 8009f34:	fb0a f20c 	mul.w	r2, sl, ip
   lpc2[3] = lpc[3] + MULT16_16_Q15(c1,lpc[2]);
 8009f38:	fb0a f30e 	mul.w	r3, sl, lr
      lpc[i] = MULT16_16_Q15(lpc[i], tmp);
 8009f3c:	ea4f 38e8 	mov.w	r8, r8, asr #15
   lpc2[4] = MULT16_16_Q15(c1,lpc[3]);
 8009f40:	fb0a fa08 	mul.w	sl, sl, r8
   lpc2[0] = lpc[0] + QCONST16(.8f,SIG_SHIFT);
 8009f44:	f607 47cd 	addw	r7, r7, #3277	; 0xccd
   lpc2[1] = lpc[1] + MULT16_16_Q15(c1,lpc[0]);
 8009f48:	eb0c 3ce1 	add.w	ip, ip, r1, asr #15
   lpc2[2] = lpc[2] + MULT16_16_Q15(c1,lpc[1]);
 8009f4c:	eb0e 3ee2 	add.w	lr, lr, r2, asr #15
   lpc2[3] = lpc[3] + MULT16_16_Q15(c1,lpc[2]);
 8009f50:	eb08 38e3 	add.w	r8, r8, r3, asr #15
   for (i=0;i<N;i++)
 8009f54:	2c00      	cmp	r4, #0
   lpc2[0] = lpc[0] + QCONST16(.8f,SIG_SHIFT);
 8009f56:	b23f      	sxth	r7, r7
   lpc2[1] = lpc[1] + MULT16_16_Q15(c1,lpc[0]);
 8009f58:	fa0f fc8c 	sxth.w	ip, ip
   lpc2[2] = lpc[2] + MULT16_16_Q15(c1,lpc[1]);
 8009f5c:	fa0f fe8e 	sxth.w	lr, lr
   lpc2[3] = lpc[3] + MULT16_16_Q15(c1,lpc[2]);
 8009f60:	fa0f f888 	sxth.w	r8, r8
   lpc2[4] = MULT16_16_Q15(c1,lpc[3]);
 8009f64:	ea4f 3aea 	mov.w	sl, sl, asr #15
   for (i=0;i<N;i++)
 8009f68:	dd22      	ble.n	8009fb0 <pitch_downsample+0x1e8>
   mem4=0;
 8009f6a:	f04f 0b00 	mov.w	fp, #0
 8009f6e:	1ea9      	subs	r1, r5, #2
 8009f70:	eb01 0944 	add.w	r9, r1, r4, lsl #1
   mem3=0;
 8009f74:	465a      	mov	r2, fp
   mem2=0;
 8009f76:	465e      	mov	r6, fp
   mem1=0;
 8009f78:	465d      	mov	r5, fp
   mem0=0;
 8009f7a:	465c      	mov	r4, fp
 8009f7c:	e003      	b.n	8009f86 <pitch_downsample+0x1be>
   for (i=0;i<N;i++)
 8009f7e:	4632      	mov	r2, r6
 8009f80:	462e      	mov	r6, r5
 8009f82:	4625      	mov	r5, r4
      mem0 = x[i];
 8009f84:	4604      	mov	r4, r0
      sum = MAC16_16(sum,num0,mem0);
 8009f86:	fb07 f304 	mul.w	r3, r7, r4
      opus_val32 sum = SHL32(EXTEND32(x[i]), SIG_SHIFT);
 8009f8a:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
      sum = MAC16_16(sum,num0,mem0);
 8009f8e:	eb03 3300 	add.w	r3, r3, r0, lsl #12
      sum = MAC16_16(sum,num1,mem1);
 8009f92:	fb0c 3305 	mla	r3, ip, r5, r3
      sum = MAC16_16(sum,num2,mem2);
 8009f96:	fb0e 3306 	mla	r3, lr, r6, r3
      sum = MAC16_16(sum,num3,mem3);
 8009f9a:	fb08 3302 	mla	r3, r8, r2, r3
      sum = MAC16_16(sum,num4,mem4);
 8009f9e:	fb0b 330a 	mla	r3, fp, sl, r3
      x[i] = ROUND16(sum, SIG_SHIFT);
 8009fa2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8009fa6:	131b      	asrs	r3, r3, #12
   for (i=0;i<N;i++)
 8009fa8:	4589      	cmp	r9, r1
      x[i] = ROUND16(sum, SIG_SHIFT);
 8009faa:	800b      	strh	r3, [r1, #0]
 8009fac:	4693      	mov	fp, r2
   for (i=0;i<N;i++)
 8009fae:	d1e6      	bne.n	8009f7e <pitch_downsample+0x1b6>
   celt_fir5(x_lp, lpc2, len>>1);
}
 8009fb0:	b00d      	add	sp, #52	; 0x34
 8009fb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009fb6:	3101      	adds	r1, #1
 8009fb8:	e73a      	b.n	8009e30 <pitch_downsample+0x68>
   opus_val32 minval = 0;
 8009fba:	f04f 0e00 	mov.w	lr, #0
   opus_val32 maxval = 0;
 8009fbe:	4674      	mov	r4, lr
      opus_val32 maxabs_1 = celt_maxabs32(x[1], len);
 8009fc0:	6842      	ldr	r2, [r0, #4]
 8009fc2:	4494      	add	ip, r2
 8009fc4:	3a04      	subs	r2, #4
      maxval = MAX32(maxval, x[i]);
 8009fc6:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8009fca:	428c      	cmp	r4, r1
 8009fcc:	bfb8      	it	lt
 8009fce:	460c      	movlt	r4, r1
      minval = MIN32(minval, x[i]);
 8009fd0:	458e      	cmp	lr, r1
 8009fd2:	bfa8      	it	ge
 8009fd4:	468e      	movge	lr, r1
   for (i=0;i<len;i++)
 8009fd6:	4594      	cmp	ip, r2
 8009fd8:	d1f5      	bne.n	8009fc6 <pitch_downsample+0x1fe>
 8009fda:	42a3      	cmp	r3, r4
 8009fdc:	bfb8      	it	lt
 8009fde:	4623      	movlt	r3, r4
 8009fe0:	f1ce 0e00 	rsb	lr, lr, #0
 8009fe4:	4573      	cmp	r3, lr
 8009fe6:	bfb8      	it	lt
 8009fe8:	4673      	movlt	r3, lr
   if (maxabs<1)
 8009fea:	2b00      	cmp	r3, #0
 8009fec:	f73f af14 	bgt.w	8009e18 <pitch_downsample+0x50>
 8009ff0:	2101      	movs	r1, #1
 8009ff2:	e71d      	b.n	8009e30 <pitch_downsample+0x68>
         x_lp[i] += SHR32(HALF32(HALF32(x[1][(2*i-1)]+x[1][(2*i+1)])+x[1][2*i]), shift);
 8009ff4:	6847      	ldr	r7, [r0, #4]
 8009ff6:	f1a5 0c02 	sub.w	ip, r5, #2
 8009ffa:	463a      	mov	r2, r7
 8009ffc:	687e      	ldr	r6, [r7, #4]
 8009ffe:	eb0c 0c44 	add.w	ip, ip, r4, lsl #1
 800a002:	68d0      	ldr	r0, [r2, #12]
 800a004:	f852 3f08 	ldr.w	r3, [r2, #8]!
 800a008:	eb00 0e06 	add.w	lr, r0, r6
 800a00c:	eb03 036e 	add.w	r3, r3, lr, asr #1
 800a010:	105b      	asrs	r3, r3, #1
 800a012:	f838 ef02 	ldrh.w	lr, [r8, #2]!
 800a016:	410b      	asrs	r3, r1
 800a018:	4473      	add	r3, lr
      for (i=1;i<len>>1;i++)
 800a01a:	45c4      	cmp	ip, r8
 800a01c:	4606      	mov	r6, r0
         x_lp[i] += SHR32(HALF32(HALF32(x[1][(2*i-1)]+x[1][(2*i+1)])+x[1][2*i]), shift);
 800a01e:	f8a8 3000 	strh.w	r3, [r8]
      for (i=1;i<len>>1;i++)
 800a022:	d1ee      	bne.n	800a002 <pitch_downsample+0x23a>
 800a024:	f9b5 e000 	ldrsh.w	lr, [r5]
      x_lp[0] += SHR32(HALF32(HALF32(x[1][1])+x[1][0]), shift);
 800a028:	e9d7 3200 	ldrd	r3, r2, [r7]
 800a02c:	eb03 0362 	add.w	r3, r3, r2, asr #1
 800a030:	105b      	asrs	r3, r3, #1
 800a032:	fa43 f101 	asr.w	r1, r3, r1
 800a036:	448e      	add	lr, r1
 800a038:	f8a5 e000 	strh.w	lr, [r5]
 800a03c:	e721      	b.n	8009e82 <pitch_downsample+0xba>
      shift=0;
 800a03e:	2100      	movs	r1, #0
 800a040:	e6f6      	b.n	8009e30 <pitch_downsample+0x68>
   if (C==2)
 800a042:	f1ba 0f02 	cmp.w	sl, #2
   x_lp[0] = SHR32(HALF32(HALF32(x[0][1])+x[0][0]), shift);
 800a046:	f8a5 e000 	strh.w	lr, [r5]
   if (C==2)
 800a04a:	f47f af1a 	bne.w	8009e82 <pitch_downsample+0xba>
 800a04e:	6847      	ldr	r7, [r0, #4]
 800a050:	e7ea      	b.n	800a028 <pitch_downsample+0x260>
      shift=0;
 800a052:	f1a3 0102 	sub.w	r1, r3, #2
 800a056:	fab1 f181 	clz	r1, r1
 800a05a:	0949      	lsrs	r1, r1, #5
 800a05c:	e6e8      	b.n	8009e30 <pitch_downsample+0x68>
 800a05e:	bf00      	nop

0800a060 <celt_pitch_xcorr_c>:
#else
void
#endif
celt_pitch_xcorr_c(const opus_val16 *_x, const opus_val16 *_y,
      opus_val32 *xcorr, int len, int max_pitch, int arch)
{
 800a060:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a064:	b091      	sub	sp, #68	; 0x44
#ifdef FIXED_POINT
   opus_val32 maxcorr=1;
#endif
   celt_assert(max_pitch>0);
   celt_sig_assert((((unsigned char *)_x-(unsigned char *)NULL)&3)==0);
   for (i=0;i<max_pitch-3;i+=4)
 800a066:	9c1a      	ldr	r4, [sp, #104]	; 0x68
{
 800a068:	9005      	str	r0, [sp, #20]
   for (i=0;i<max_pitch-3;i+=4)
 800a06a:	2c03      	cmp	r4, #3
{
 800a06c:	e9cd 120d 	strd	r1, r2, [sp, #52]	; 0x34
 800a070:	9301      	str	r3, [sp, #4]
   for (i=0;i<max_pitch-3;i+=4)
 800a072:	f340 810a 	ble.w	800a28a <celt_pitch_xcorr_c+0x22a>
 800a076:	9203      	str	r2, [sp, #12]
   opus_val32 maxcorr=1;
 800a078:	2201      	movs	r2, #1
 800a07a:	460f      	mov	r7, r1
 800a07c:	4605      	mov	r5, r0
 800a07e:	9202      	str	r2, [sp, #8]
 800a080:	1f1a      	subs	r2, r3, #4
 800a082:	0892      	lsrs	r2, r2, #2
 800a084:	1c53      	adds	r3, r2, #1
 800a086:	00de      	lsls	r6, r3, #3
 800a088:	1f20      	subs	r0, r4, #4
 800a08a:	009c      	lsls	r4, r3, #2
 800a08c:	463b      	mov	r3, r7
 800a08e:	f105 0110 	add.w	r1, r5, #16
 800a092:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 800a096:	9207      	str	r2, [sp, #28]
 800a098:	19aa      	adds	r2, r5, r6
 800a09a:	0880      	lsrs	r0, r0, #2
 800a09c:	330e      	adds	r3, #14
 800a09e:	920c      	str	r2, [sp, #48]	; 0x30
 800a0a0:	1c62      	adds	r2, r4, #1
 800a0a2:	9208      	str	r2, [sp, #32]
 800a0a4:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800a0a8:	1ca2      	adds	r2, r4, #2
 800a0aa:	960a      	str	r6, [sp, #40]	; 0x28
 800a0ac:	940b      	str	r4, [sp, #44]	; 0x2c
 800a0ae:	900f      	str	r0, [sp, #60]	; 0x3c
 800a0b0:	9209      	str	r2, [sp, #36]	; 0x24
 800a0b2:	9306      	str	r3, [sp, #24]
 800a0b4:	f107 0b06 	add.w	fp, r7, #6
 800a0b8:	9b01      	ldr	r3, [sp, #4]
 800a0ba:	465a      	mov	r2, fp
 800a0bc:	2b03      	cmp	r3, #3
   y_0=*y++;
 800a0be:	f93b 6c06 	ldrsh.w	r6, [fp, #-6]
   y_1=*y++;
 800a0c2:	f93b ec04 	ldrsh.w	lr, [fp, #-4]
   y_2=*y++;
 800a0c6:	f93b cc02 	ldrsh.w	ip, [fp, #-2]
   for (j=0;j<len-3;j+=4)
 800a0ca:	f340 80ce 	ble.w	800a26a <celt_pitch_xcorr_c+0x20a>
   {
      opus_val32 sum[4]={0,0,0,0};
 800a0ce:	2300      	movs	r3, #0
 800a0d0:	4698      	mov	r8, r3
 800a0d2:	4699      	mov	r9, r3
 800a0d4:	4619      	mov	r1, r3
 800a0d6:	f10b 0208 	add.w	r2, fp, #8
 800a0da:	9204      	str	r2, [sp, #16]
 800a0dc:	4615      	mov	r5, r2
 800a0de:	9a05      	ldr	r2, [sp, #20]
 800a0e0:	9807      	ldr	r0, [sp, #28]
 800a0e2:	f102 0408 	add.w	r4, r2, #8
      tmp = *x++;
 800a0e6:	f934 2c08 	ldrsh.w	r2, [r4, #-8]
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 800a0ea:	f935 7c08 	ldrsh.w	r7, [r5, #-8]
      sum[0] = MAC16_16(sum[0],tmp,y_0);
 800a0ee:	fb02 1106 	mla	r1, r2, r6, r1
      sum[1] = MAC16_16(sum[1],tmp,y_1);
 800a0f2:	fb02 990e 	mla	r9, r2, lr, r9
      sum[2] = MAC16_16(sum[2],tmp,y_2);
 800a0f6:	fb02 880c 	mla	r8, r2, ip, r8
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 800a0fa:	fb02 3307 	mla	r3, r2, r7, r3
      y_0=*y++;
 800a0fe:	f935 6c06 	ldrsh.w	r6, [r5, #-6]
      tmp=*x++;
 800a102:	f934 2c06 	ldrsh.w	r2, [r4, #-6]
 800a106:	3408      	adds	r4, #8
      sum[0] = MAC16_16(sum[0],tmp,y_1);
 800a108:	fb0e 1102 	mla	r1, lr, r2, r1
      sum[1] = MAC16_16(sum[1],tmp,y_2);
 800a10c:	fb0c 9902 	mla	r9, ip, r2, r9
      sum[2] = MAC16_16(sum[2],tmp,y_3);
 800a110:	fb07 8802 	mla	r8, r7, r2, r8
      sum[3] = MAC16_16(sum[3],tmp,y_0);
 800a114:	fb02 3306 	mla	r3, r2, r6, r3
      y_1=*y++;
 800a118:	f935 ec04 	ldrsh.w	lr, [r5, #-4]
      tmp=*x++;
 800a11c:	f934 2c0c 	ldrsh.w	r2, [r4, #-12]
 800a120:	3508      	adds	r5, #8
      sum[0] = MAC16_16(sum[0],tmp,y_2);
 800a122:	fb0c 1102 	mla	r1, ip, r2, r1
      sum[1] = MAC16_16(sum[1],tmp,y_3);
 800a126:	fb07 9902 	mla	r9, r7, r2, r9
      sum[2] = MAC16_16(sum[2],tmp,y_0);
 800a12a:	fb06 8802 	mla	r8, r6, r2, r8
      sum[3] = MAC16_16(sum[3],tmp,y_1);
 800a12e:	fb02 330e 	mla	r3, r2, lr, r3
      y_2=*y++;
 800a132:	f935 cc0a 	ldrsh.w	ip, [r5, #-10]
      tmp=*x++;
 800a136:	f934 2c0a 	ldrsh.w	r2, [r4, #-10]
   for (j=0;j<len-3;j+=4)
 800a13a:	42a0      	cmp	r0, r4
      sum[0] = MAC16_16(sum[0],tmp,y_3);
 800a13c:	fb07 1102 	mla	r1, r7, r2, r1
      sum[1] = MAC16_16(sum[1],tmp,y_0);
 800a140:	fb06 9902 	mla	r9, r6, r2, r9
      sum[2] = MAC16_16(sum[2],tmp,y_1);
 800a144:	fb0e 8802 	mla	r8, lr, r2, r8
      sum[3] = MAC16_16(sum[3],tmp,y_2);
 800a148:	fb02 330c 	mla	r3, r2, ip, r3
   for (j=0;j<len-3;j+=4)
 800a14c:	d1cb      	bne.n	800a0e6 <celt_pitch_xcorr_c+0x86>
 800a14e:	e9dd a508 	ldrd	sl, r5, [sp, #32]
 800a152:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800a154:	445a      	add	r2, fp
      tmp=*x++;
 800a156:	e9dd b00b 	ldrd	fp, r0, [sp, #44]	; 0x2c
   if (j++<len)
 800a15a:	9c01      	ldr	r4, [sp, #4]
 800a15c:	455c      	cmp	r4, fp
 800a15e:	dd0e      	ble.n	800a17e <celt_pitch_xcorr_c+0x11e>
      opus_val16 tmp = *x++;
 800a160:	f9b0 4000 	ldrsh.w	r4, [r0]
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 800a164:	f9b2 7000 	ldrsh.w	r7, [r2]
      sum[0] = MAC16_16(sum[0],tmp,y_0);
 800a168:	fb04 1106 	mla	r1, r4, r6, r1
      sum[1] = MAC16_16(sum[1],tmp,y_1);
 800a16c:	fb04 990e 	mla	r9, r4, lr, r9
      sum[2] = MAC16_16(sum[2],tmp,y_2);
 800a170:	fb04 880c 	mla	r8, r4, ip, r8
      sum[3] = MAC16_16(sum[3],tmp,y_3);
 800a174:	fb04 3307 	mla	r3, r4, r7, r3
 800a178:	9c01      	ldr	r4, [sp, #4]
      opus_val16 tmp = *x++;
 800a17a:	3002      	adds	r0, #2
      y_3=*y++;
 800a17c:	3202      	adds	r2, #2
   if (j++<len)
 800a17e:	4554      	cmp	r4, sl
 800a180:	dd0e      	ble.n	800a1a0 <celt_pitch_xcorr_c+0x140>
      opus_val16 tmp=*x++;
 800a182:	f9b0 4000 	ldrsh.w	r4, [r0]
      y_0=*y++;
 800a186:	f9b2 6000 	ldrsh.w	r6, [r2]
      sum[0] = MAC16_16(sum[0],tmp,y_1);
 800a18a:	fb04 110e 	mla	r1, r4, lr, r1
      sum[1] = MAC16_16(sum[1],tmp,y_2);
 800a18e:	fb04 990c 	mla	r9, r4, ip, r9
      sum[2] = MAC16_16(sum[2],tmp,y_3);
 800a192:	fb07 8804 	mla	r8, r7, r4, r8
      sum[3] = MAC16_16(sum[3],tmp,y_0);
 800a196:	fb04 3306 	mla	r3, r4, r6, r3
 800a19a:	9c01      	ldr	r4, [sp, #4]
      opus_val16 tmp=*x++;
 800a19c:	3002      	adds	r0, #2
      y_0=*y++;
 800a19e:	3202      	adds	r2, #2
   if (j<len)
 800a1a0:	42ac      	cmp	r4, r5
 800a1a2:	dd0a      	ble.n	800a1ba <celt_pitch_xcorr_c+0x15a>
      opus_val16 tmp=*x++;
 800a1a4:	f9b0 0000 	ldrsh.w	r0, [r0]
      sum[3] = MAC16_16(sum[3],tmp,y_1);
 800a1a8:	8812      	ldrh	r2, [r2, #0]
      sum[0] = MAC16_16(sum[0],tmp,y_2);
 800a1aa:	fb00 110c 	mla	r1, r0, ip, r1
      sum[1] = MAC16_16(sum[1],tmp,y_3);
 800a1ae:	fb07 9900 	mla	r9, r7, r0, r9
      sum[2] = MAC16_16(sum[2],tmp,y_0);
 800a1b2:	fb00 8806 	mla	r8, r0, r6, r8
      sum[3] = MAC16_16(sum[3],tmp,y_1);
 800a1b6:	fb10 3302 	smlabb	r3, r0, r2, r3
 800a1ba:	4299      	cmp	r1, r3
 800a1bc:	460a      	mov	r2, r1
 800a1be:	bfb8      	it	lt
 800a1c0:	461a      	movlt	r2, r3
 800a1c2:	9802      	ldr	r0, [sp, #8]
 800a1c4:	f8dd b010 	ldr.w	fp, [sp, #16]
 800a1c8:	4282      	cmp	r2, r0
 800a1ca:	bfb8      	it	lt
 800a1cc:	4602      	movlt	r2, r0
 800a1ce:	454a      	cmp	r2, r9
 800a1d0:	bfb8      	it	lt
 800a1d2:	464a      	movlt	r2, r9
      xcorr[i+3]=sum[3];
#ifdef FIXED_POINT
      sum[0] = MAX32(sum[0], sum[1]);
      sum[2] = MAX32(sum[2], sum[3]);
      sum[0] = MAX32(sum[0], sum[2]);
      maxcorr = MAX32(maxcorr, sum[0]);
 800a1d4:	4542      	cmp	r2, r8
 800a1d6:	bfb8      	it	lt
 800a1d8:	4642      	movlt	r2, r8
      xcorr[i]=sum[0];
 800a1da:	9803      	ldr	r0, [sp, #12]
      maxcorr = MAX32(maxcorr, sum[0]);
 800a1dc:	9202      	str	r2, [sp, #8]
      xcorr[i+3]=sum[3];
 800a1de:	e9c0 8302 	strd	r8, r3, [r0, #8]
 800a1e2:	f100 0310 	add.w	r3, r0, #16
 800a1e6:	9303      	str	r3, [sp, #12]
   for (i=0;i<max_pitch-3;i+=4)
 800a1e8:	9b06      	ldr	r3, [sp, #24]
      xcorr[i]=sum[0];
 800a1ea:	6001      	str	r1, [r0, #0]
   for (i=0;i<max_pitch-3;i+=4)
 800a1ec:	455b      	cmp	r3, fp
      xcorr[i+1]=sum[1];
 800a1ee:	f8c0 9004 	str.w	r9, [r0, #4]
   for (i=0;i<max_pitch-3;i+=4)
 800a1f2:	f47f af61 	bne.w	800a0b8 <celt_pitch_xcorr_c+0x58>
 800a1f6:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 800a1f8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800a1fa:	3701      	adds	r7, #1
 800a1fc:	00bf      	lsls	r7, r7, #2
#endif
   }
   /* In case max_pitch isn't a multiple of 4, do non-unrolled version. */
   for (;i<max_pitch;i++)
 800a1fe:	42bb      	cmp	r3, r7
 800a200:	dd2f      	ble.n	800a262 <celt_pitch_xcorr_c+0x202>
 800a202:	4619      	mov	r1, r3
 800a204:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a206:	f107 4c00 	add.w	ip, r7, #2147483648	; 0x80000000
 800a20a:	eb03 0681 	add.w	r6, r3, r1, lsl #2
 800a20e:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 800a212:	9901      	ldr	r1, [sp, #4]
 800a214:	9b05      	ldr	r3, [sp, #20]
 800a216:	4688      	mov	r8, r1
 800a218:	4699      	mov	r9, r3
 800a21a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800a21c:	f10c 3cff 	add.w	ip, ip, #4294967295
 800a220:	eb03 0541 	add.w	r5, r3, r1, lsl #1
 800a224:	f8dd e008 	ldr.w	lr, [sp, #8]
 800a228:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
 800a22c:	3d02      	subs	r5, #2
   for (i=0;i<N;i++)
 800a22e:	f1b8 0f00 	cmp.w	r8, #0
 800a232:	dd28      	ble.n	800a286 <celt_pitch_xcorr_c+0x226>
 800a234:	4661      	mov	r1, ip
   opus_val32 xy=0;
 800a236:	2200      	movs	r2, #0
 800a238:	f1a9 0302 	sub.w	r3, r9, #2
      xy = MAC16_16(xy, x[i], y[i]);
 800a23c:	f833 4f02 	ldrh.w	r4, [r3, #2]!
 800a240:	f831 0f02 	ldrh.w	r0, [r1, #2]!
   for (i=0;i<N;i++)
 800a244:	429d      	cmp	r5, r3
      xy = MAC16_16(xy, x[i], y[i]);
 800a246:	fb14 2200 	smlabb	r2, r4, r0, r2
   for (i=0;i<N;i++)
 800a24a:	d1f7      	bne.n	800a23c <celt_pitch_xcorr_c+0x1dc>
   {
      opus_val32 sum;
      sum = celt_inner_prod(_x, _y+i, len, arch);
      xcorr[i] = sum;
#ifdef FIXED_POINT
      maxcorr = MAX32(maxcorr, sum);
 800a24c:	4596      	cmp	lr, r2
      xcorr[i] = sum;
 800a24e:	f847 2b04 	str.w	r2, [r7], #4
      maxcorr = MAX32(maxcorr, sum);
 800a252:	bfb8      	it	lt
 800a254:	4696      	movlt	lr, r2
   for (;i<max_pitch;i++)
 800a256:	42be      	cmp	r6, r7
 800a258:	f10c 0c02 	add.w	ip, ip, #2
 800a25c:	d1e7      	bne.n	800a22e <celt_pitch_xcorr_c+0x1ce>
 800a25e:	f8cd e008 	str.w	lr, [sp, #8]
   }
#ifdef FIXED_POINT
   return maxcorr;
#endif
#endif
}
 800a262:	9802      	ldr	r0, [sp, #8]
 800a264:	b011      	add	sp, #68	; 0x44
 800a266:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   for (j=0;j<len-3;j+=4)
 800a26a:	2700      	movs	r7, #0
 800a26c:	f102 0408 	add.w	r4, r2, #8
 800a270:	9805      	ldr	r0, [sp, #20]
      opus_val32 sum[4]={0,0,0,0};
 800a272:	463b      	mov	r3, r7
 800a274:	46b8      	mov	r8, r7
 800a276:	46b9      	mov	r9, r7
 800a278:	4639      	mov	r1, r7
 800a27a:	46bb      	mov	fp, r7
 800a27c:	2502      	movs	r5, #2
 800a27e:	f04f 0a01 	mov.w	sl, #1
 800a282:	9404      	str	r4, [sp, #16]
 800a284:	e769      	b.n	800a15a <celt_pitch_xcorr_c+0xfa>
   opus_val32 xy=0;
 800a286:	2200      	movs	r2, #0
 800a288:	e7e0      	b.n	800a24c <celt_pitch_xcorr_c+0x1ec>
   opus_val32 maxcorr=1;
 800a28a:	2301      	movs	r3, #1
   for (i=0;i<max_pitch-3;i+=4)
 800a28c:	2700      	movs	r7, #0
   opus_val32 maxcorr=1;
 800a28e:	9302      	str	r3, [sp, #8]
 800a290:	4623      	mov	r3, r4
 800a292:	e7b4      	b.n	800a1fe <celt_pitch_xcorr_c+0x19e>

0800a294 <pitch_search>:

void pitch_search(const opus_val16 * OPUS_RESTRICT x_lp, opus_val16 * OPUS_RESTRICT y,
                  int len, int max_pitch, int *pitch, int arch)
{
 800a294:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a298:	469a      	mov	sl, r3
   int i, j;
   int lag;
   int best_pitch[2]={0,0};
 800a29a:	2300      	movs	r3, #0
{
 800a29c:	b08f      	sub	sp, #60	; 0x3c

   celt_assert(len>0);
   celt_assert(max_pitch>0);
   lag = len+max_pitch;

   ALLOC(x_lp4, len>>2, opus_val16);
 800a29e:	1096      	asrs	r6, r2, #2
   lag = len+max_pitch;
 800a2a0:	eb02 0e0a 	add.w	lr, r2, sl
{
 800a2a4:	4693      	mov	fp, r2
 800a2a6:	af04      	add	r7, sp, #16
   ALLOC(x_lp4, len>>2, opus_val16);
 800a2a8:	0072      	lsls	r2, r6, #1
   ALLOC(y_lp4, lag>>2, opus_val16);
 800a2aa:	ea4f 0eae 	mov.w	lr, lr, asr #2
 800a2ae:	ea4f 044e 	mov.w	r4, lr, lsl #1
   ALLOC(xcorr, max_pitch>>1, opus_val32);
 800a2b2:	ea4f 056a 	mov.w	r5, sl, asr #1
   ALLOC(x_lp4, len>>2, opus_val16);
 800a2b6:	617a      	str	r2, [r7, #20]
 800a2b8:	3208      	adds	r2, #8
 800a2ba:	f022 0207 	bic.w	r2, r2, #7
   ALLOC(y_lp4, lag>>2, opus_val16);
 800a2be:	61fc      	str	r4, [r7, #28]
   ALLOC(xcorr, max_pitch>>1, opus_val32);
 800a2c0:	60bd      	str	r5, [r7, #8]
   ALLOC(y_lp4, lag>>2, opus_val16);
 800a2c2:	3408      	adds	r4, #8
   ALLOC(xcorr, max_pitch>>1, opus_val32);
 800a2c4:	00ad      	lsls	r5, r5, #2
   ALLOC(x_lp4, len>>2, opus_val16);
 800a2c6:	ebad 0d02 	sub.w	sp, sp, r2
   ALLOC(y_lp4, lag>>2, opus_val16);
 800a2ca:	f024 0407 	bic.w	r4, r4, #7
   ALLOC(xcorr, max_pitch>>1, opus_val32);
 800a2ce:	f105 020a 	add.w	r2, r5, #10
 800a2d2:	f022 0207 	bic.w	r2, r2, #7
   ALLOC(x_lp4, len>>2, opus_val16);
 800a2d6:	f10d 0c10 	add.w	ip, sp, #16
   ALLOC(y_lp4, lag>>2, opus_val16);
 800a2da:	ebad 0d04 	sub.w	sp, sp, r4
 800a2de:	f10d 0810 	add.w	r8, sp, #16
   ALLOC(xcorr, max_pitch>>1, opus_val32);
 800a2e2:	ebad 0d02 	sub.w	sp, sp, r2
 800a2e6:	aa04      	add	r2, sp, #16

   /* Downsample by 2 again */
   for (j=0;j<len>>2;j++)
 800a2e8:	429e      	cmp	r6, r3
   ALLOC(xcorr, max_pitch>>1, opus_val32);
 800a2ea:	61bd      	str	r5, [r7, #24]
{
 800a2ec:	60f9      	str	r1, [r7, #12]
 800a2ee:	4605      	mov	r5, r0
   ALLOC(xcorr, max_pitch>>1, opus_val32);
 800a2f0:	613a      	str	r2, [r7, #16]
   int best_pitch[2]={0,0};
 800a2f2:	e9c7 3308 	strd	r3, r3, [r7, #32]
   for (j=0;j<len>>2;j++)
 800a2f6:	f340 8121 	ble.w	800a53c <pitch_search+0x2a8>
 800a2fa:	f1ac 0402 	sub.w	r4, ip, #2
 800a2fe:	4622      	mov	r2, r4
      x_lp4[j] = x_lp[2*j];
 800a300:	f835 1023 	ldrh.w	r1, [r5, r3, lsl #2]
   for (j=0;j<len>>2;j++)
 800a304:	3301      	adds	r3, #1
 800a306:	429e      	cmp	r6, r3
      x_lp4[j] = x_lp[2*j];
 800a308:	f822 1f02 	strh.w	r1, [r2, #2]!
   for (j=0;j<len>>2;j++)
 800a30c:	d1f8      	bne.n	800a300 <pitch_search+0x6c>
   for (j=0;j<lag>>2;j++)
 800a30e:	f1be 0f00 	cmp.w	lr, #0
 800a312:	dd10      	ble.n	800a336 <pitch_search+0xa2>
 800a314:	f1a8 0202 	sub.w	r2, r8, #2
 800a318:	4611      	mov	r1, r2
   for (j=0;j<len>>2;j++)
 800a31a:	2300      	movs	r3, #0
 800a31c:	68fc      	ldr	r4, [r7, #12]
      y_lp4[j] = y[2*j];
 800a31e:	f834 0023 	ldrh.w	r0, [r4, r3, lsl #2]
   for (j=0;j<lag>>2;j++)
 800a322:	3301      	adds	r3, #1
 800a324:	459e      	cmp	lr, r3
      y_lp4[j] = y[2*j];
 800a326:	f821 0f02 	strh.w	r0, [r1, #2]!
   for (j=0;j<lag>>2;j++)
 800a32a:	dcf8      	bgt.n	800a31e <pitch_search+0x8a>
   for (i=0;i<len;i++)
 800a32c:	2e00      	cmp	r6, #0
 800a32e:	f340 8111 	ble.w	800a554 <pitch_search+0x2c0>
 800a332:	f1ac 0402 	sub.w	r4, ip, #2
   for (j=0;j<len>>2;j++)
 800a336:	2000      	movs	r0, #0
 800a338:	4601      	mov	r1, r0
 800a33a:	4603      	mov	r3, r0
      maxval = MAX16(maxval, x[i]);
 800a33c:	f934 2f02 	ldrsh.w	r2, [r4, #2]!
   for (i=0;i<len;i++)
 800a340:	3301      	adds	r3, #1
      maxval = MAX16(maxval, x[i]);
 800a342:	4291      	cmp	r1, r2
 800a344:	bfb8      	it	lt
 800a346:	4611      	movlt	r1, r2
      minval = MIN16(minval, x[i]);
 800a348:	4290      	cmp	r0, r2
 800a34a:	bfa8      	it	ge
 800a34c:	4610      	movge	r0, r2
   for (i=0;i<len;i++)
 800a34e:	429e      	cmp	r6, r3
 800a350:	dcf4      	bgt.n	800a33c <pitch_search+0xa8>
 800a352:	2901      	cmp	r1, #1
 800a354:	bfb8      	it	lt
 800a356:	2101      	movlt	r1, #1
 800a358:	4240      	negs	r0, r0
 800a35a:	4281      	cmp	r1, r0
 800a35c:	bfb8      	it	lt
 800a35e:	4601      	movlt	r1, r0
 800a360:	f1be 0f00 	cmp.w	lr, #0
 800a364:	f340 80f8 	ble.w	800a558 <pitch_search+0x2c4>
 800a368:	f1a8 0202 	sub.w	r2, r8, #2
   opus_val16 minval = 0;
 800a36c:	2300      	movs	r3, #0
   opus_val16 maxval = 0;
 800a36e:	461c      	mov	r4, r3
 800a370:	69f8      	ldr	r0, [r7, #28]
 800a372:	f1a0 0902 	sub.w	r9, r0, #2
 800a376:	44c1      	add	r9, r8
      maxval = MAX16(maxval, x[i]);
 800a378:	f932 0f02 	ldrsh.w	r0, [r2, #2]!
 800a37c:	4284      	cmp	r4, r0
 800a37e:	bfb8      	it	lt
 800a380:	4604      	movlt	r4, r0
      minval = MIN16(minval, x[i]);
 800a382:	4283      	cmp	r3, r0
 800a384:	bfa8      	it	ge
 800a386:	4603      	movge	r3, r0
   for (i=0;i<len;i++)
 800a388:	4591      	cmp	r9, r2
 800a38a:	d1f5      	bne.n	800a378 <pitch_search+0xe4>
 800a38c:	425b      	negs	r3, r3

#ifdef FIXED_POINT
   xmax = celt_maxabs16(x_lp4, len>>2);
   ymax = celt_maxabs16(y_lp4, lag>>2);
   shift = celt_ilog2(MAX32(1, MAX32(xmax, ymax)))-11;
 800a38e:	42a3      	cmp	r3, r4
 800a390:	bfb8      	it	lt
 800a392:	4623      	movlt	r3, r4
 800a394:	428b      	cmp	r3, r1
 800a396:	bfb8      	it	lt
 800a398:	460b      	movlt	r3, r1
   return EC_ILOG(x)-1;
 800a39a:	fab3 f483 	clz	r4, r3
 800a39e:	f1c4 041f 	rsb	r4, r4, #31
 800a3a2:	b2a4      	uxth	r4, r4
 800a3a4:	3c0b      	subs	r4, #11
   if (shift>0)
 800a3a6:	2c00      	cmp	r4, #0
 800a3a8:	f340 80c1 	ble.w	800a52e <pitch_search+0x29a>
   {
      for (j=0;j<len>>2;j++)
 800a3ac:	2e00      	cmp	r6, #0
 800a3ae:	dd0a      	ble.n	800a3c6 <pitch_search+0x132>
 800a3b0:	697b      	ldr	r3, [r7, #20]
 800a3b2:	1e99      	subs	r1, r3, #2
 800a3b4:	4461      	add	r1, ip
 800a3b6:	f1ac 0302 	sub.w	r3, ip, #2
         x_lp4[j] = SHR16(x_lp4[j], shift);
 800a3ba:	f933 2f02 	ldrsh.w	r2, [r3, #2]!
 800a3be:	4122      	asrs	r2, r4
      for (j=0;j<len>>2;j++)
 800a3c0:	4299      	cmp	r1, r3
         x_lp4[j] = SHR16(x_lp4[j], shift);
 800a3c2:	801a      	strh	r2, [r3, #0]
      for (j=0;j<len>>2;j++)
 800a3c4:	d1f9      	bne.n	800a3ba <pitch_search+0x126>
      for (j=0;j<lag>>2;j++)
 800a3c6:	f1be 0f00 	cmp.w	lr, #0
 800a3ca:	dd0a      	ble.n	800a3e2 <pitch_search+0x14e>
 800a3cc:	69fb      	ldr	r3, [r7, #28]
 800a3ce:	1e99      	subs	r1, r3, #2
 800a3d0:	4441      	add	r1, r8
 800a3d2:	f1a8 0302 	sub.w	r3, r8, #2
         y_lp4[j] = SHR16(y_lp4[j], shift);
 800a3d6:	f933 2f02 	ldrsh.w	r2, [r3, #2]!
 800a3da:	4122      	asrs	r2, r4
      for (j=0;j<lag>>2;j++)
 800a3dc:	4299      	cmp	r1, r3
         y_lp4[j] = SHR16(y_lp4[j], shift);
 800a3de:	801a      	strh	r2, [r3, #0]
      for (j=0;j<lag>>2;j++)
 800a3e0:	d1f9      	bne.n	800a3d6 <pitch_search+0x142>
      /* Use double the shift for a MAC */
      shift *= 2;
 800a3e2:	0064      	lsls	r4, r4, #1
 800a3e4:	1c63      	adds	r3, r4, #1
 800a3e6:	693a      	ldr	r2, [r7, #16]
 800a3e8:	607b      	str	r3, [r7, #4]
#endif

   /* Coarse search with 4x decimation */

#ifdef FIXED_POINT
   maxcorr =
 800a3ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
#endif
   celt_pitch_xcorr(x_lp4, y_lp4, xcorr, len>>2, max_pitch>>2, arch);
 800a3ec:	ea4f 0aaa 	mov.w	sl, sl, asr #2
   maxcorr =
 800a3f0:	9301      	str	r3, [sp, #4]
 800a3f2:	4660      	mov	r0, ip
 800a3f4:	4633      	mov	r3, r6
 800a3f6:	4641      	mov	r1, r8
 800a3f8:	f8cd a000 	str.w	sl, [sp]
 800a3fc:	f7ff fe30 	bl	800a060 <celt_pitch_xcorr_c>

   find_best_pitch(xcorr, y_lp4, len>>2, max_pitch>>2, best_pitch
 800a400:	f04f 0900 	mov.w	r9, #0
 800a404:	4632      	mov	r2, r6
 800a406:	693e      	ldr	r6, [r7, #16]
 800a408:	9002      	str	r0, [sp, #8]
 800a40a:	f107 0020 	add.w	r0, r7, #32
 800a40e:	4653      	mov	r3, sl
 800a410:	9000      	str	r0, [sp, #0]
 800a412:	4641      	mov	r1, r8
 800a414:	f8cd 9004 	str.w	r9, [sp, #4]
 800a418:	4630      	mov	r0, r6
 800a41a:	f7ff fc4b 	bl	8009cb4 <find_best_pitch>

   /* Finer search with 2x decimation */
#ifdef FIXED_POINT
   maxcorr=1;
#endif
   for (i=0;i<max_pitch>>1;i++)
 800a41e:	68bb      	ldr	r3, [r7, #8]
 800a420:	ea4f 0b6b 	mov.w	fp, fp, asr #1
 800a424:	454b      	cmp	r3, r9
 800a426:	f340 8091 	ble.w	800a54c <pitch_search+0x2b8>
   {
      opus_val32 sum;
      xcorr[i] = 0;
      if (abs(i-2*best_pitch[0])>2 && abs(i-2*best_pitch[1])>2)
 800a42a:	e9d7 1308 	ldrd	r1, r3, [r7, #32]
   maxcorr=1;
 800a42e:	f04f 0a01 	mov.w	sl, #1
 800a432:	69b8      	ldr	r0, [r7, #24]
      if (abs(i-2*best_pitch[0])>2 && abs(i-2*best_pitch[1])>2)
 800a434:	fa01 f10a 	lsl.w	r1, r1, sl
 800a438:	eba1 0343 	sub.w	r3, r1, r3, lsl #1
 800a43c:	3804      	subs	r0, #4
 800a43e:	61bb      	str	r3, [r7, #24]
 800a440:	68fb      	ldr	r3, [r7, #12]
 800a442:	3d02      	subs	r5, #2
 800a444:	1830      	adds	r0, r6, r0
      xcorr[i] = 0;
 800a446:	464a      	mov	r2, r9
 800a448:	617d      	str	r5, [r7, #20]
 800a44a:	61f8      	str	r0, [r7, #28]
 800a44c:	f1c1 0800 	rsb	r8, r1, #0
 800a450:	eb05 0c4b 	add.w	ip, r5, fp, lsl #1
 800a454:	f1a6 0e04 	sub.w	lr, r6, #4
 800a458:	f1a3 0902 	sub.w	r9, r3, #2
      if (abs(i-2*best_pitch[0])>2 && abs(i-2*best_pitch[1])>2)
 800a45c:	ea88 73e8 	eor.w	r3, r8, r8, asr #31
 800a460:	eba3 73e8 	sub.w	r3, r3, r8, asr #31
 800a464:	2b02      	cmp	r3, #2
      xcorr[i] = 0;
 800a466:	f84e 2f04 	str.w	r2, [lr, #4]!
      if (abs(i-2*best_pitch[0])>2 && abs(i-2*best_pitch[1])>2)
 800a46a:	dd06      	ble.n	800a47a <pitch_search+0x1e6>
 800a46c:	69bb      	ldr	r3, [r7, #24]
 800a46e:	4443      	add	r3, r8
 800a470:	2b00      	cmp	r3, #0
 800a472:	bfb8      	it	lt
 800a474:	425b      	neglt	r3, r3
 800a476:	2b02      	cmp	r3, #2
 800a478:	dc17      	bgt.n	800a4aa <pitch_search+0x216>
         continue;
#ifdef FIXED_POINT
      sum = 0;
      for (j=0;j<len>>1;j++)
 800a47a:	f1bb 0f00 	cmp.w	fp, #0
 800a47e:	dd53      	ble.n	800a528 <pitch_search+0x294>
 800a480:	464e      	mov	r6, r9
 800a482:	2500      	movs	r5, #0
 800a484:	6978      	ldr	r0, [r7, #20]
         sum += SHR32(MULT16_16(x_lp[j],y[i+j]), shift);
 800a486:	f830 3f02 	ldrh.w	r3, [r0, #2]!
 800a48a:	f836 1f02 	ldrh.w	r1, [r6, #2]!
      for (j=0;j<len>>1;j++)
 800a48e:	4584      	cmp	ip, r0
         sum += SHR32(MULT16_16(x_lp[j],y[i+j]), shift);
 800a490:	fb13 f301 	smulbb	r3, r3, r1
 800a494:	fa43 f304 	asr.w	r3, r3, r4
 800a498:	441d      	add	r5, r3
      for (j=0;j<len>>1;j++)
 800a49a:	d1f4      	bne.n	800a486 <pitch_search+0x1f2>
 800a49c:	ea45 73e5 	orr.w	r3, r5, r5, asr #31
#else
      sum = celt_inner_prod(x_lp, y+i, len>>1, arch);
#endif
      xcorr[i] = MAX32(-1, sum);
#ifdef FIXED_POINT
      maxcorr = MAX32(maxcorr, sum);
 800a4a0:	45aa      	cmp	sl, r5
 800a4a2:	bfb8      	it	lt
 800a4a4:	46aa      	movlt	sl, r5
      xcorr[i] = MAX32(-1, sum);
 800a4a6:	f8ce 3000 	str.w	r3, [lr]
   for (i=0;i<max_pitch>>1;i++)
 800a4aa:	69fb      	ldr	r3, [r7, #28]
 800a4ac:	f108 0801 	add.w	r8, r8, #1
 800a4b0:	4573      	cmp	r3, lr
 800a4b2:	f109 0902 	add.w	r9, r9, #2
 800a4b6:	d1d1      	bne.n	800a45c <pitch_search+0x1c8>
 800a4b8:	68bc      	ldr	r4, [r7, #8]
#endif
   }
   find_best_pitch(xcorr, y, len>>1, max_pitch>>1, best_pitch
 800a4ba:	687b      	ldr	r3, [r7, #4]
 800a4bc:	693d      	ldr	r5, [r7, #16]
 800a4be:	9301      	str	r3, [sp, #4]
 800a4c0:	f107 0320 	add.w	r3, r7, #32
 800a4c4:	9300      	str	r3, [sp, #0]
 800a4c6:	f8cd a008 	str.w	sl, [sp, #8]
 800a4ca:	4623      	mov	r3, r4
 800a4cc:	465a      	mov	r2, fp
 800a4ce:	68f9      	ldr	r1, [r7, #12]
 800a4d0:	4628      	mov	r0, r5
 800a4d2:	f7ff fbef 	bl	8009cb4 <find_best_pitch>
                   , shift+1, maxcorr
#endif
                   );

   /* Refine by pseudo-interpolation */
   if (best_pitch[0]>0 && best_pitch[0]<(max_pitch>>1)-1)
 800a4d6:	6a3b      	ldr	r3, [r7, #32]
 800a4d8:	2b00      	cmp	r3, #0
 800a4da:	dd1c      	ble.n	800a516 <pitch_search+0x282>
   ALLOC(xcorr, max_pitch>>1, opus_val32);
 800a4dc:	1e62      	subs	r2, r4, #1
   if (best_pitch[0]>0 && best_pitch[0]<(max_pitch>>1)-1)
 800a4de:	429a      	cmp	r2, r3
 800a4e0:	dd19      	ble.n	800a516 <pitch_search+0x282>
 800a4e2:	eb05 0183 	add.w	r1, r5, r3, lsl #2
   {
      opus_val32 a, b, c;
      a = xcorr[best_pitch[0]-1];
 800a4e6:	f851 2c04 	ldr.w	r2, [r1, #-4]
      b = xcorr[best_pitch[0]];
      c = xcorr[best_pitch[0]+1];
 800a4ea:	684c      	ldr	r4, [r1, #4]
      b = xcorr[best_pitch[0]];
 800a4ec:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
      if ((c-a) > MULT16_32_Q15(QCONST16(.7f,15),b-a))
 800a4f0:	1aa6      	subs	r6, r4, r2
 800a4f2:	1a8d      	subs	r5, r1, r2
 800a4f4:	481a      	ldr	r0, [pc, #104]	; (800a560 <pitch_search+0x2cc>)
 800a4f6:	fb85 ec00 	smull	lr, ip, r5, r0
 800a4fa:	ebb6 0f4c 	cmp.w	r6, ip, lsl #1
 800a4fe:	dc1b      	bgt.n	800a538 <pitch_search+0x2a4>
         offset = 1;
      else if ((a-c) > MULT16_32_Q15(QCONST16(.7f,15),b-c))
 800a500:	1b12      	subs	r2, r2, r4
 800a502:	1b09      	subs	r1, r1, r4
 800a504:	fb81 5400 	smull	r5, r4, r1, r0
 800a508:	ebb2 0f44 	cmp.w	r2, r4, lsl #1
 800a50c:	bfcc      	ite	gt
 800a50e:	f04f 32ff 	movgt.w	r2, #4294967295
 800a512:	2200      	movle	r2, #0
 800a514:	e000      	b.n	800a518 <pitch_search+0x284>
         offset = -1;
      else
         offset = 0;
   } else {
      offset = 0;
 800a516:	2200      	movs	r2, #0
   }
   *pitch = 2*best_pitch[0]-offset;
 800a518:	ebc2 0343 	rsb	r3, r2, r3, lsl #1
 800a51c:	6d3a      	ldr	r2, [r7, #80]	; 0x50

   RESTORE_STACK;
}
 800a51e:	372c      	adds	r7, #44	; 0x2c
   *pitch = 2*best_pitch[0]-offset;
 800a520:	6013      	str	r3, [r2, #0]
}
 800a522:	46bd      	mov	sp, r7
 800a524:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for (j=0;j<len>>1;j++)
 800a528:	2300      	movs	r3, #0
 800a52a:	461d      	mov	r5, r3
 800a52c:	e7b8      	b.n	800a4a0 <pitch_search+0x20c>
 800a52e:	2301      	movs	r3, #1
      shift = 0;
 800a530:	2400      	movs	r4, #0
 800a532:	607b      	str	r3, [r7, #4]
 800a534:	693a      	ldr	r2, [r7, #16]
 800a536:	e758      	b.n	800a3ea <pitch_search+0x156>
         offset = 1;
 800a538:	2201      	movs	r2, #1
 800a53a:	e7ed      	b.n	800a518 <pitch_search+0x284>
   for (j=0;j<lag>>2;j++)
 800a53c:	f1be 0f00 	cmp.w	lr, #0
 800a540:	f73f aee8 	bgt.w	800a314 <pitch_search+0x80>
      shift = 0;
 800a544:	461c      	mov	r4, r3
   for (j=0;j<lag>>2;j++)
 800a546:	2301      	movs	r3, #1
 800a548:	607b      	str	r3, [r7, #4]
 800a54a:	e74e      	b.n	800a3ea <pitch_search+0x156>
   maxcorr=1;
 800a54c:	f04f 0a01 	mov.w	sl, #1
 800a550:	461c      	mov	r4, r3
 800a552:	e7b2      	b.n	800a4ba <pitch_search+0x226>
   for (i=0;i<len;i++)
 800a554:	2101      	movs	r1, #1
 800a556:	e709      	b.n	800a36c <pitch_search+0xd8>
 800a558:	2400      	movs	r4, #0
 800a55a:	4623      	mov	r3, r4
 800a55c:	e717      	b.n	800a38e <pitch_search+0xfa>
 800a55e:	bf00      	nop
 800a560:	599a0000 	.word	0x599a0000

0800a564 <unquant_coarse_energy>:
      }
   }
}

void unquant_coarse_energy(const CELTMode *m, int start, int end, opus_val16 *oldEBands, int intra, ec_dec *dec, int C, int LM)
{
 800a564:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   const unsigned char *prob_model = e_prob_model[LM][intra];
 800a568:	2454      	movs	r4, #84	; 0x54
 800a56a:	f04f 082a 	mov.w	r8, #42	; 0x2a
{
 800a56e:	b087      	sub	sp, #28
 800a570:	9f13      	ldr	r7, [sp, #76]	; 0x4c
 800a572:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
   const unsigned char *prob_model = e_prob_model[LM][intra];
 800a576:	fb04 f407 	mul.w	r4, r4, r7
 800a57a:	fb08 440c 	mla	r4, r8, ip, r4
 800a57e:	4e84      	ldr	r6, [pc, #528]	; (800a790 <unquant_coarse_energy+0x22c>)
{
 800a580:	9005      	str	r0, [sp, #20]
   const unsigned char *prob_model = e_prob_model[LM][intra];
 800a582:	eb06 0804 	add.w	r8, r6, r4
{
 800a586:	460d      	mov	r5, r1
 800a588:	9202      	str	r2, [sp, #8]
 800a58a:	469b      	mov	fp, r3
 800a58c:	9e11      	ldr	r6, [sp, #68]	; 0x44
   opus_val16 coef;
   opus_val16 beta;
   opus_int32 budget;
   opus_int32 tell;

   if (intra)
 800a58e:	f1bc 0f00 	cmp.w	ip, #0
 800a592:	f040 80f6 	bne.w	800a782 <unquant_coarse_energy+0x21e>
   {
      coef = 0;
      beta = beta_intra;
   } else {
      beta = beta_coef[LM];
 800a596:	4a7f      	ldr	r2, [pc, #508]	; (800a794 <unquant_coarse_energy+0x230>)
      coef = pred_coef[LM];
 800a598:	4b7f      	ldr	r3, [pc, #508]	; (800a798 <unquant_coarse_energy+0x234>)
      beta = beta_coef[LM];
 800a59a:	f932 2017 	ldrsh.w	r2, [r2, r7, lsl #1]
      coef = pred_coef[LM];
 800a59e:	f933 9017 	ldrsh.w	r9, [r3, r7, lsl #1]
 800a5a2:	9b02      	ldr	r3, [sp, #8]
      beta = beta_coef[LM];
 800a5a4:	9201      	str	r2, [sp, #4]
   }

   budget = dec->storage*8;
 800a5a6:	6877      	ldr	r7, [r6, #4]

   /* Decode at a fixed coarse resolution */
   for (i=start;i<end;i++)
 800a5a8:	429d      	cmp	r5, r3
   budget = dec->storage*8;
 800a5aa:	ea4f 07c7 	mov.w	r7, r7, lsl #3
   for (i=start;i<end;i++)
 800a5ae:	da7d      	bge.n	800a6ac <unquant_coarse_energy+0x148>
   opus_val32 prev[2] = {0, 0};
 800a5b0:	2300      	movs	r3, #0
 800a5b2:	461c      	mov	r4, r3
         }
         else
            qi = -1;
         q = (opus_val32)SHL32(EXTEND32(qi),DB_SHIFT);

         oldEBands[i+c*m->nbEBands] = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
 800a5b4:	f8df a1ec 	ldr.w	sl, [pc, #492]	; 800a7a4 <unquant_coarse_energy+0x240>
   opus_val32 prev[2] = {0, 0};
 800a5b8:	9303      	str	r3, [sp, #12]
  return _this->nbits_total-EC_ILOG(_this->rng);
 800a5ba:	69f3      	ldr	r3, [r6, #28]
 800a5bc:	6971      	ldr	r1, [r6, #20]
 800a5be:	fab3 f383 	clz	r3, r3
 800a5c2:	f1c3 0320 	rsb	r3, r3, #32
 800a5c6:	1ac9      	subs	r1, r1, r3
         if(budget-tell>=15)
 800a5c8:	1a79      	subs	r1, r7, r1
 800a5ca:	290e      	cmp	r1, #14
 800a5cc:	dc71      	bgt.n	800a6b2 <unquant_coarse_energy+0x14e>
         else if(budget-tell>=2)
 800a5ce:	2901      	cmp	r1, #1
 800a5d0:	f300 8082 	bgt.w	800a6d8 <unquant_coarse_energy+0x174>
         else if(budget-tell>=1)
 800a5d4:	f000 80b1 	beq.w	800a73a <unquant_coarse_energy+0x1d6>
 800a5d8:	f06f 0203 	mvn.w	r2, #3
 800a5dc:	486f      	ldr	r0, [pc, #444]	; (800a79c <unquant_coarse_energy+0x238>)
         oldEBands[i+c*m->nbEBands] = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
 800a5de:	f93b 3015 	ldrsh.w	r3, [fp, r5, lsl #1]
         tmp = PSHR32(MULT16_16(coef,oldEBands[i+c*m->nbEBands]),8) + prev[c] + SHL32(q,7);
 800a5e2:	2180      	movs	r1, #128	; 0x80
         oldEBands[i+c*m->nbEBands] = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
 800a5e4:	4553      	cmp	r3, sl
 800a5e6:	bfb8      	it	lt
 800a5e8:	4653      	movlt	r3, sl
         tmp = PSHR32(MULT16_16(coef,oldEBands[i+c*m->nbEBands]),8) + prev[c] + SHL32(q,7);
 800a5ea:	fb13 1309 	smlabb	r3, r3, r9, r1
#ifdef FIXED_POINT
         tmp = MAX32(-QCONST32(28.f, DB_SHIFT+7), tmp);
 800a5ee:	f8df c1b8 	ldr.w	ip, [pc, #440]	; 800a7a8 <unquant_coarse_energy+0x244>
         tmp = PSHR32(MULT16_16(coef,oldEBands[i+c*m->nbEBands]),8) + prev[c] + SHL32(q,7);
 800a5f2:	eb04 2123 	add.w	r1, r4, r3, asr #8
 800a5f6:	180b      	adds	r3, r1, r0
         tmp = MAX32(-QCONST32(28.f, DB_SHIFT+7), tmp);
 800a5f8:	4563      	cmp	r3, ip
 800a5fa:	bfb8      	it	lt
 800a5fc:	4663      	movlt	r3, ip
#endif
         oldEBands[i+c*m->nbEBands] = PSHR32(tmp, 7);
 800a5fe:	3340      	adds	r3, #64	; 0x40
 800a600:	11db      	asrs	r3, r3, #7
 800a602:	f82b 3015 	strh.w	r3, [fp, r5, lsl #1]
         prev[c] = prev[c] + SHL32(q,7) - MULT16_16(beta,PSHR32(q,8));
      } while (++c < C);
 800a606:	9b12      	ldr	r3, [sp, #72]	; 0x48
         prev[c] = prev[c] + SHL32(q,7) - MULT16_16(beta,PSHR32(q,8));
 800a608:	9901      	ldr	r1, [sp, #4]
 800a60a:	4404      	add	r4, r0
      } while (++c < C);
 800a60c:	2b01      	cmp	r3, #1
         prev[c] = prev[c] + SHL32(q,7) - MULT16_16(beta,PSHR32(q,8));
 800a60e:	fb02 4411 	mls	r4, r2, r1, r4
      } while (++c < C);
 800a612:	dd47      	ble.n	800a6a4 <unquant_coarse_energy+0x140>
 800a614:	69f3      	ldr	r3, [r6, #28]
 800a616:	6971      	ldr	r1, [r6, #20]
 800a618:	fab3 f383 	clz	r3, r3
 800a61c:	f1c3 0320 	rsb	r3, r3, #32
 800a620:	1ac9      	subs	r1, r1, r3
         if(budget-tell>=15)
 800a622:	1a79      	subs	r1, r7, r1
 800a624:	290e      	cmp	r1, #14
 800a626:	dc65      	bgt.n	800a6f4 <unquant_coarse_energy+0x190>
         else if(budget-tell>=2)
 800a628:	2901      	cmp	r1, #1
 800a62a:	dc77      	bgt.n	800a71c <unquant_coarse_energy+0x1b8>
         else if(budget-tell>=1)
 800a62c:	f000 809f 	beq.w	800a76e <unquant_coarse_energy+0x20a>
 800a630:	f06f 0303 	mvn.w	r3, #3
 800a634:	4859      	ldr	r0, [pc, #356]	; (800a79c <unquant_coarse_energy+0x238>)
 800a636:	9304      	str	r3, [sp, #16]
         oldEBands[i+c*m->nbEBands] = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
 800a638:	9b05      	ldr	r3, [sp, #20]
         tmp = PSHR32(MULT16_16(coef,oldEBands[i+c*m->nbEBands]),8) + prev[c] + SHL32(q,7);
 800a63a:	f04f 0c80 	mov.w	ip, #128	; 0x80
         oldEBands[i+c*m->nbEBands] = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
 800a63e:	689a      	ldr	r2, [r3, #8]
         tmp = PSHR32(MULT16_16(coef,oldEBands[i+c*m->nbEBands]),8) + prev[c] + SHL32(q,7);
 800a640:	9903      	ldr	r1, [sp, #12]
         oldEBands[i+c*m->nbEBands] = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
 800a642:	442a      	add	r2, r5
 800a644:	f93b 3012 	ldrsh.w	r3, [fp, r2, lsl #1]
         tmp = MAX32(-QCONST32(28.f, DB_SHIFT+7), tmp);
 800a648:	f8df e15c 	ldr.w	lr, [pc, #348]	; 800a7a8 <unquant_coarse_energy+0x244>
         oldEBands[i+c*m->nbEBands] = MAX16(-QCONST16(9.f,DB_SHIFT), oldEBands[i+c*m->nbEBands]);
 800a64c:	4553      	cmp	r3, sl
 800a64e:	bfb8      	it	lt
 800a650:	4653      	movlt	r3, sl
         tmp = PSHR32(MULT16_16(coef,oldEBands[i+c*m->nbEBands]),8) + prev[c] + SHL32(q,7);
 800a652:	fb13 c309 	smlabb	r3, r3, r9, ip
 800a656:	eb01 2323 	add.w	r3, r1, r3, asr #8
 800a65a:	4403      	add	r3, r0
         tmp = MAX32(-QCONST32(28.f, DB_SHIFT+7), tmp);
 800a65c:	459e      	cmp	lr, r3
 800a65e:	bfb8      	it	lt
 800a660:	469e      	movlt	lr, r3
      } while (++c < C);
 800a662:	9b12      	ldr	r3, [sp, #72]	; 0x48
         oldEBands[i+c*m->nbEBands] = PSHR32(tmp, 7);
 800a664:	f10e 0e40 	add.w	lr, lr, #64	; 0x40
 800a668:	ea4f 1eee 	mov.w	lr, lr, asr #7
      } while (++c < C);
 800a66c:	2b02      	cmp	r3, #2
         oldEBands[i+c*m->nbEBands] = PSHR32(tmp, 7);
 800a66e:	f82b e012 	strh.w	lr, [fp, r2, lsl #1]
      } while (++c < C);
 800a672:	d00f      	beq.n	800a694 <unquant_coarse_energy+0x130>
 800a674:	69f3      	ldr	r3, [r6, #28]
 800a676:	6972      	ldr	r2, [r6, #20]
 800a678:	fab3 f383 	clz	r3, r3
 800a67c:	f1c3 0320 	rsb	r3, r3, #32
 800a680:	1ad3      	subs	r3, r2, r3
         if(budget-tell>=15)
 800a682:	1aff      	subs	r7, r7, r3
 800a684:	2f0e      	cmp	r7, #14
 800a686:	dc61      	bgt.n	800a74c <unquant_coarse_energy+0x1e8>
         else if(budget-tell>=2)
 800a688:	2f01      	cmp	r7, #1
            qi = ec_dec_icdf(dec, small_energy_icdf, 2);
 800a68a:	4630      	mov	r0, r6
         else if(budget-tell>=2)
 800a68c:	dc6b      	bgt.n	800a766 <unquant_coarse_energy+0x202>
            qi = -ec_dec_bit_logp(dec, 1);
 800a68e:	2101      	movs	r1, #1
 800a690:	f7fd ff2a 	bl	80084e8 <ec_dec_bit_logp>
         prev[c] = prev[c] + SHL32(q,7) - MULT16_16(beta,PSHR32(q,8));
 800a694:	460b      	mov	r3, r1
 800a696:	4403      	add	r3, r0
 800a698:	4618      	mov	r0, r3
 800a69a:	9a04      	ldr	r2, [sp, #16]
 800a69c:	9b01      	ldr	r3, [sp, #4]
 800a69e:	fb02 0313 	mls	r3, r2, r3, r0
 800a6a2:	9303      	str	r3, [sp, #12]
   for (i=start;i<end;i++)
 800a6a4:	9b02      	ldr	r3, [sp, #8]
 800a6a6:	3501      	adds	r5, #1
 800a6a8:	42ab      	cmp	r3, r5
 800a6aa:	d186      	bne.n	800a5ba <unquant_coarse_energy+0x56>
   }
}
 800a6ac:	b007      	add	sp, #28
 800a6ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            pi = 2*IMIN(i,20);
 800a6b2:	2d14      	cmp	r5, #20
 800a6b4:	462b      	mov	r3, r5
 800a6b6:	bfa8      	it	ge
 800a6b8:	2314      	movge	r3, #20
                  prob_model[pi]<<7, prob_model[pi+1]<<6);
 800a6ba:	eb08 0243 	add.w	r2, r8, r3, lsl #1
 800a6be:	7852      	ldrb	r2, [r2, #1]
 800a6c0:	f818 1013 	ldrb.w	r1, [r8, r3, lsl #1]
            qi = ec_laplace_decode(dec,
 800a6c4:	0192      	lsls	r2, r2, #6
 800a6c6:	01c9      	lsls	r1, r1, #7
 800a6c8:	4630      	mov	r0, r6
 800a6ca:	f7fe ff35 	bl	8009538 <ec_laplace_decode>
 800a6ce:	0282      	lsls	r2, r0, #10
 800a6d0:	f342 220f 	sbfx	r2, r2, #8, #16
 800a6d4:	0440      	lsls	r0, r0, #17
 800a6d6:	e782      	b.n	800a5de <unquant_coarse_energy+0x7a>
            qi = ec_dec_icdf(dec, small_energy_icdf, 2);
 800a6d8:	2202      	movs	r2, #2
 800a6da:	4931      	ldr	r1, [pc, #196]	; (800a7a0 <unquant_coarse_energy+0x23c>)
 800a6dc:	4630      	mov	r0, r6
 800a6de:	f7fd ff55 	bl	800858c <ec_dec_icdf>
            qi = (qi>>1)^-(qi&1);
 800a6e2:	f340 0300 	sbfx	r3, r0, #0, #1
 800a6e6:	ea83 0060 	eor.w	r0, r3, r0, asr #1
 800a6ea:	0282      	lsls	r2, r0, #10
 800a6ec:	f342 220f 	sbfx	r2, r2, #8, #16
 800a6f0:	0440      	lsls	r0, r0, #17
 800a6f2:	e774      	b.n	800a5de <unquant_coarse_energy+0x7a>
            pi = 2*IMIN(i,20);
 800a6f4:	2d14      	cmp	r5, #20
 800a6f6:	462b      	mov	r3, r5
 800a6f8:	bfa8      	it	ge
 800a6fa:	2314      	movge	r3, #20
                  prob_model[pi]<<7, prob_model[pi+1]<<6);
 800a6fc:	eb08 0243 	add.w	r2, r8, r3, lsl #1
 800a700:	f818 1013 	ldrb.w	r1, [r8, r3, lsl #1]
 800a704:	7852      	ldrb	r2, [r2, #1]
            qi = ec_laplace_decode(dec,
 800a706:	01c9      	lsls	r1, r1, #7
 800a708:	0192      	lsls	r2, r2, #6
 800a70a:	4630      	mov	r0, r6
 800a70c:	f7fe ff14 	bl	8009538 <ec_laplace_decode>
 800a710:	0281      	lsls	r1, r0, #10
 800a712:	f341 230f 	sbfx	r3, r1, #8, #16
 800a716:	9304      	str	r3, [sp, #16]
 800a718:	0440      	lsls	r0, r0, #17
 800a71a:	e78d      	b.n	800a638 <unquant_coarse_energy+0xd4>
            qi = ec_dec_icdf(dec, small_energy_icdf, 2);
 800a71c:	4920      	ldr	r1, [pc, #128]	; (800a7a0 <unquant_coarse_energy+0x23c>)
 800a71e:	2202      	movs	r2, #2
 800a720:	4630      	mov	r0, r6
 800a722:	f7fd ff33 	bl	800858c <ec_dec_icdf>
            qi = (qi>>1)^-(qi&1);
 800a726:	f340 0300 	sbfx	r3, r0, #0, #1
 800a72a:	ea83 0060 	eor.w	r0, r3, r0, asr #1
 800a72e:	0281      	lsls	r1, r0, #10
 800a730:	f341 230f 	sbfx	r3, r1, #8, #16
 800a734:	9304      	str	r3, [sp, #16]
 800a736:	0440      	lsls	r0, r0, #17
 800a738:	e77e      	b.n	800a638 <unquant_coarse_energy+0xd4>
            qi = -ec_dec_bit_logp(dec, 1);
 800a73a:	4630      	mov	r0, r6
 800a73c:	f7fd fed4 	bl	80084e8 <ec_dec_bit_logp>
 800a740:	4240      	negs	r0, r0
 800a742:	0282      	lsls	r2, r0, #10
 800a744:	f342 220f 	sbfx	r2, r2, #8, #16
 800a748:	0440      	lsls	r0, r0, #17
 800a74a:	e748      	b.n	800a5de <unquant_coarse_energy+0x7a>
            pi = 2*IMIN(i,20);
 800a74c:	2d14      	cmp	r5, #20
 800a74e:	bfa8      	it	ge
 800a750:	2514      	movge	r5, #20
                  prob_model[pi]<<7, prob_model[pi+1]<<6);
 800a752:	eb08 0345 	add.w	r3, r8, r5, lsl #1
 800a756:	785a      	ldrb	r2, [r3, #1]
 800a758:	f818 1015 	ldrb.w	r1, [r8, r5, lsl #1]
            qi = ec_laplace_decode(dec,
 800a75c:	4630      	mov	r0, r6
 800a75e:	0192      	lsls	r2, r2, #6
 800a760:	01c9      	lsls	r1, r1, #7
 800a762:	f7fe fee9 	bl	8009538 <ec_laplace_decode>
            qi = ec_dec_icdf(dec, small_energy_icdf, 2);
 800a766:	2202      	movs	r2, #2
 800a768:	490d      	ldr	r1, [pc, #52]	; (800a7a0 <unquant_coarse_energy+0x23c>)
 800a76a:	f7fd ff0f 	bl	800858c <ec_dec_icdf>
            qi = -ec_dec_bit_logp(dec, 1);
 800a76e:	4630      	mov	r0, r6
 800a770:	f7fd feba 	bl	80084e8 <ec_dec_bit_logp>
 800a774:	4240      	negs	r0, r0
 800a776:	0281      	lsls	r1, r0, #10
 800a778:	f341 230f 	sbfx	r3, r1, #8, #16
 800a77c:	9304      	str	r3, [sp, #16]
 800a77e:	0440      	lsls	r0, r0, #17
 800a780:	e75a      	b.n	800a638 <unquant_coarse_energy+0xd4>
      beta = beta_intra;
 800a782:	f241 3333 	movw	r3, #4915	; 0x1333
      coef = 0;
 800a786:	f04f 0900 	mov.w	r9, #0
      beta = beta_intra;
 800a78a:	9301      	str	r3, [sp, #4]
 800a78c:	4613      	mov	r3, r2
 800a78e:	e70a      	b.n	800a5a6 <unquant_coarse_energy+0x42>
 800a790:	080166e4 	.word	0x080166e4
 800a794:	080166c0 	.word	0x080166c0
 800a798:	08016834 	.word	0x08016834
 800a79c:	fffe0000 	.word	0xfffe0000
 800a7a0:	0801683c 	.word	0x0801683c
 800a7a4:	ffffdc00 	.word	0xffffdc00
 800a7a8:	ffc80000 	.word	0xffc80000

0800a7ac <unquant_fine_energy>:

void unquant_fine_energy(const CELTMode *m, int start, int end, opus_val16 *oldEBands, int *fine_quant, ec_dec *dec, int C)
{
 800a7ac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   int i, c;
   /* Decode finer resolution */
   for (i=start;i<end;i++)
 800a7b0:	4291      	cmp	r1, r2
{
 800a7b2:	e9dd 570a 	ldrd	r5, r7, [sp, #40]	; 0x28
 800a7b6:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
   for (i=start;i<end;i++)
 800a7ba:	da2a      	bge.n	800a812 <unquant_fine_energy+0x66>
 800a7bc:	460e      	mov	r6, r1
 800a7be:	4682      	mov	sl, r0
 800a7c0:	469b      	mov	fp, r3
 800a7c2:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
 800a7c6:	f1a5 0904 	sub.w	r9, r5, #4
 800a7ca:	3b01      	subs	r3, #1
 800a7cc:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 800a7d0:	eb09 0982 	add.w	r9, r9, r2, lsl #2
   {
      if (fine_quant[i] <= 0)
 800a7d4:	f855 1f04 	ldr.w	r1, [r5, #4]!
 800a7d8:	2900      	cmp	r1, #0
 800a7da:	dd16      	ble.n	800a80a <unquant_fine_energy+0x5e>
         continue;
      c=0;
 800a7dc:	2400      	movs	r4, #0
      do {
         int q2;
         opus_val16 offset;
         q2 = ec_dec_bits(dec, fine_quant[i]);
 800a7de:	4638      	mov	r0, r7
 800a7e0:	f7fe f84c 	bl	800887c <ec_dec_bits>
#ifdef FIXED_POINT
         offset = SUB16(SHR32(SHL32(EXTEND32(q2),DB_SHIFT)+QCONST16(.5f,DB_SHIFT),fine_quant[i]),QCONST16(.5f,DB_SHIFT));
#else
         offset = (q2+.5f)*(1<<(14-fine_quant[i]))*(1.f/16384) - .5f;
#endif
         oldEBands[i+c*m->nbEBands] += offset;
 800a7e4:	f8da 3008 	ldr.w	r3, [sl, #8]
         offset = SUB16(SHR32(SHL32(EXTEND32(q2),DB_SHIFT)+QCONST16(.5f,DB_SHIFT),fine_quant[i]),QCONST16(.5f,DB_SHIFT));
 800a7e8:	6829      	ldr	r1, [r5, #0]
         oldEBands[i+c*m->nbEBands] += offset;
 800a7ea:	fb03 6304 	mla	r3, r3, r4, r6
         offset = SUB16(SHR32(SHL32(EXTEND32(q2),DB_SHIFT)+QCONST16(.5f,DB_SHIFT),fine_quant[i]),QCONST16(.5f,DB_SHIFT));
 800a7ee:	0280      	lsls	r0, r0, #10
 800a7f0:	f500 7000 	add.w	r0, r0, #512	; 0x200
         oldEBands[i+c*m->nbEBands] += offset;
 800a7f4:	f83b 2013 	ldrh.w	r2, [fp, r3, lsl #1]
         offset = SUB16(SHR32(SHL32(EXTEND32(q2),DB_SHIFT)+QCONST16(.5f,DB_SHIFT),fine_quant[i]),QCONST16(.5f,DB_SHIFT));
 800a7f8:	4108      	asrs	r0, r1
 800a7fa:	f5a0 7000 	sub.w	r0, r0, #512	; 0x200
      } while (++c < C);
 800a7fe:	3401      	adds	r4, #1
         oldEBands[i+c*m->nbEBands] += offset;
 800a800:	4410      	add	r0, r2
      } while (++c < C);
 800a802:	4544      	cmp	r4, r8
         oldEBands[i+c*m->nbEBands] += offset;
 800a804:	f82b 0013 	strh.w	r0, [fp, r3, lsl #1]
      } while (++c < C);
 800a808:	dbe9      	blt.n	800a7de <unquant_fine_energy+0x32>
   for (i=start;i<end;i++)
 800a80a:	454d      	cmp	r5, r9
 800a80c:	f106 0601 	add.w	r6, r6, #1
 800a810:	d1e0      	bne.n	800a7d4 <unquant_fine_energy+0x28>
   }
}
 800a812:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a816:	bf00      	nop

0800a818 <unquant_energy_finalise>:

void unquant_energy_finalise(const CELTMode *m, int start, int end, opus_val16 *oldEBands, int *fine_quant,  int *fine_priority, int bits_left, ec_dec *dec, int C)
{
 800a818:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a81c:	460c      	mov	r4, r1
 800a81e:	b085      	sub	sp, #20
 800a820:	9102      	str	r1, [sp, #8]
 800a822:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 800a826:	990e      	ldr	r1, [sp, #56]	; 0x38
 800a828:	3c01      	subs	r4, #1
 800a82a:	469b      	mov	fp, r3
 800a82c:	eb01 0384 	add.w	r3, r1, r4, lsl #2
 800a830:	9303      	str	r3, [sp, #12]
   int i, prio, c;

   /* Use up the remaining bits */
   for (prio=0;prio<2;prio++)
 800a832:	2300      	movs	r3, #0
 800a834:	9301      	str	r3, [sp, #4]
 800a836:	465b      	mov	r3, fp
 800a838:	4683      	mov	fp, r0
 800a83a:	469a      	mov	sl, r3
{
 800a83c:	9e10      	ldr	r6, [sp, #64]	; 0x40
 800a83e:	9f12      	ldr	r7, [sp, #72]	; 0x48
         do {
            int q2;
            opus_val16 offset;
            q2 = ec_dec_bits(dec, 1);
#ifdef FIXED_POINT
            offset = SHR16(SHL16(q2,DB_SHIFT)-QCONST16(.5f,DB_SHIFT),fine_quant[i]+1);
 800a840:	f8df 8098 	ldr.w	r8, [pc, #152]	; 800a8dc <unquant_energy_finalise+0xc4>
{
 800a844:	9200      	str	r2, [sp, #0]
      for (i=start;i<end && bits_left>=C ;i++)
 800a846:	9b02      	ldr	r3, [sp, #8]
 800a848:	4293      	cmp	r3, r2
 800a84a:	da3e      	bge.n	800a8ca <unquant_energy_finalise+0xb2>
 800a84c:	42b7      	cmp	r7, r6
 800a84e:	dc3c      	bgt.n	800a8ca <unquant_energy_finalise+0xb2>
 800a850:	461d      	mov	r5, r3
 800a852:	f8dd 900c 	ldr.w	r9, [sp, #12]
 800a856:	e005      	b.n	800a864 <unquant_energy_finalise+0x4c>
 800a858:	9b00      	ldr	r3, [sp, #0]
 800a85a:	3501      	adds	r5, #1
 800a85c:	42ab      	cmp	r3, r5
 800a85e:	d034      	beq.n	800a8ca <unquant_energy_finalise+0xb2>
 800a860:	42be      	cmp	r6, r7
 800a862:	db32      	blt.n	800a8ca <unquant_energy_finalise+0xb2>
         if (fine_quant[i] >= MAX_FINE_BITS || fine_priority[i]!=prio)
 800a864:	f859 1f04 	ldr.w	r1, [r9, #4]!
 800a868:	2907      	cmp	r1, #7
 800a86a:	dcf5      	bgt.n	800a858 <unquant_energy_finalise+0x40>
 800a86c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800a86e:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
 800a872:	9b01      	ldr	r3, [sp, #4]
 800a874:	4299      	cmp	r1, r3
 800a876:	d1ef      	bne.n	800a858 <unquant_energy_finalise+0x40>
         c=0;
 800a878:	2400      	movs	r4, #0
 800a87a:	9712      	str	r7, [sp, #72]	; 0x48
 800a87c:	465f      	mov	r7, fp
 800a87e:	46cb      	mov	fp, r9
 800a880:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
            q2 = ec_dec_bits(dec, 1);
 800a884:	2101      	movs	r1, #1
 800a886:	9811      	ldr	r0, [sp, #68]	; 0x44
 800a888:	f7fd fff8 	bl	800887c <ec_dec_bits>
#else
            offset = (q2-.5f)*(1<<(14-fine_quant[i]-1))*(1.f/16384);
#endif
            oldEBands[i+c*m->nbEBands] += offset;
 800a88c:	68b9      	ldr	r1, [r7, #8]
            offset = SHR16(SHL16(q2,DB_SHIFT)-QCONST16(.5f,DB_SHIFT),fine_quant[i]+1);
 800a88e:	ea08 2380 	and.w	r3, r8, r0, lsl #10
            oldEBands[i+c*m->nbEBands] += offset;
 800a892:	fb01 5c04 	mla	ip, r1, r4, r5
            offset = SHR16(SHL16(q2,DB_SHIFT)-QCONST16(.5f,DB_SHIFT),fine_quant[i]+1);
 800a896:	f8db 1000 	ldr.w	r1, [fp]
 800a89a:	b21b      	sxth	r3, r3
            oldEBands[i+c*m->nbEBands] += offset;
 800a89c:	f83a 001c 	ldrh.w	r0, [sl, ip, lsl #1]
            offset = SHR16(SHL16(q2,DB_SHIFT)-QCONST16(.5f,DB_SHIFT),fine_quant[i]+1);
 800a8a0:	f5a3 7300 	sub.w	r3, r3, #512	; 0x200
 800a8a4:	3101      	adds	r1, #1
 800a8a6:	410b      	asrs	r3, r1
            bits_left--;
         } while (++c < C);
 800a8a8:	3401      	adds	r4, #1
            oldEBands[i+c*m->nbEBands] += offset;
 800a8aa:	4403      	add	r3, r0
         } while (++c < C);
 800a8ac:	45a1      	cmp	r9, r4
            bits_left--;
 800a8ae:	f106 36ff 	add.w	r6, r6, #4294967295
            oldEBands[i+c*m->nbEBands] += offset;
 800a8b2:	f82a 301c 	strh.w	r3, [sl, ip, lsl #1]
         } while (++c < C);
 800a8b6:	dce5      	bgt.n	800a884 <unquant_energy_finalise+0x6c>
      for (i=start;i<end && bits_left>=C ;i++)
 800a8b8:	9b00      	ldr	r3, [sp, #0]
 800a8ba:	3501      	adds	r5, #1
 800a8bc:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
 800a8c0:	42ab      	cmp	r3, r5
 800a8c2:	46d9      	mov	r9, fp
 800a8c4:	46bb      	mov	fp, r7
 800a8c6:	9f12      	ldr	r7, [sp, #72]	; 0x48
 800a8c8:	d1ca      	bne.n	800a860 <unquant_energy_finalise+0x48>
   for (prio=0;prio<2;prio++)
 800a8ca:	9b01      	ldr	r3, [sp, #4]
 800a8cc:	b91b      	cbnz	r3, 800a8d6 <unquant_energy_finalise+0xbe>
 800a8ce:	2301      	movs	r3, #1
 800a8d0:	9a00      	ldr	r2, [sp, #0]
 800a8d2:	9301      	str	r3, [sp, #4]
 800a8d4:	e7b7      	b.n	800a846 <unquant_energy_finalise+0x2e>
      }
   }
}
 800a8d6:	b005      	add	sp, #20
 800a8d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a8dc:	03fffc00 	.word	0x03fffc00

0800a8e0 <clt_compute_allocation>:
   return codedBands;
}

int clt_compute_allocation(const CELTMode *m, int start, int end, const int *offsets, const int *cap, int alloc_trim, int *intensity, int *dual_stereo,
      opus_int32 total, opus_int32 *balance, int *pulses, int *ebits, int *fine_priority, int C, int LM, ec_ctx *ec, int encode, int prev, int signalBandwidth)
{
 800a8e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a8e4:	b09d      	sub	sp, #116	; 0x74
 800a8e6:	4681      	mov	r9, r0
 800a8e8:	af00      	add	r7, sp, #0
 800a8ea:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 800a8ee:	647b      	str	r3, [r7, #68]	; 0x44
   VARDECL(int, thresh);
   VARDECL(int, trim_offset);
   SAVE_STACK;

   total = IMAX(total, 0);
   len = m->nbEBands;
 800a8f0:	f8d9 3008 	ldr.w	r3, [r9, #8]
   skip_start = start;
   /* Reserve a bit to signal the end of manually skipped bands. */
   skip_rsv = total >= 1<<BITRES ? 1<<BITRES : 0;
 800a8f4:	2807      	cmp	r0, #7
   len = m->nbEBands;
 800a8f6:	62bb      	str	r3, [r7, #40]	; 0x28
   total = IMAX(total, 0);
 800a8f8:	ea20 73e0 	bic.w	r3, r0, r0, asr #31
 800a8fc:	65fb      	str	r3, [r7, #92]	; 0x5c
 800a8fe:	bfc5      	ittet	gt
 800a900:	3b08      	subgt	r3, #8
 800a902:	65fb      	strgt	r3, [r7, #92]	; 0x5c
   skip_rsv = total >= 1<<BITRES ? 1<<BITRES : 0;
 800a904:	2300      	movle	r3, #0
 800a906:	2308      	movgt	r3, #8
 800a908:	607b      	str	r3, [r7, #4]
   total -= skip_rsv;
   /* Reserve bits for the intensity and dual stereo parameters. */
   intensity_rsv = dual_stereo_rsv = 0;
   if (C==2)
 800a90a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
{
 800a90e:	66b9      	str	r1, [r7, #104]	; 0x68
   if (C==2)
 800a910:	2b02      	cmp	r3, #2
{
 800a912:	657a      	str	r2, [r7, #84]	; 0x54
   if (C==2)
 800a914:	f000 8621 	beq.w	800b55a <clt_compute_allocation+0xc7a>
   intensity_rsv = dual_stereo_rsv = 0;
 800a918:	2300      	movs	r3, #0
   {
      intensity_rsv = LOG2_FRAC_TABLE[end-start];
      if (intensity_rsv>total)
         intensity_rsv = 0;
 800a91a:	e9c7 3304 	strd	r3, r3, [r7, #16]
         total -= intensity_rsv;
         dual_stereo_rsv = total>=1<<BITRES ? 1<<BITRES : 0;
         total -= dual_stereo_rsv;
      }
   }
   ALLOC(bits1, len, int);
 800a91e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   ALLOC(bits2, len, int);
   ALLOC(thresh, len, int);
   ALLOC(trim_offset, len, int);

   for (j=start;j<end;j++)
 800a920:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   ALLOC(bits1, len, int);
 800a922:	009b      	lsls	r3, r3, #2
 800a924:	330a      	adds	r3, #10
 800a926:	f023 0307 	bic.w	r3, r3, #7
 800a92a:	ebad 0d03 	sub.w	sp, sp, r3
 800a92e:	f8c7 d034 	str.w	sp, [r7, #52]	; 0x34
   ALLOC(bits2, len, int);
 800a932:	ebad 0d03 	sub.w	sp, sp, r3
 800a936:	f8c7 d030 	str.w	sp, [r7, #48]	; 0x30
   ALLOC(thresh, len, int);
 800a93a:	ebad 0d03 	sub.w	sp, sp, r3
 800a93e:	f8c7 d038 	str.w	sp, [r7, #56]	; 0x38
   ALLOC(trim_offset, len, int);
 800a942:	ebad 0d03 	sub.w	sp, sp, r3
 800a946:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800a94a:	466e      	mov	r6, sp
 800a94c:	00db      	lsls	r3, r3, #3
 800a94e:	667b      	str	r3, [r7, #100]	; 0x64
   for (j=start;j<end;j++)
 800a950:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800a952:	4293      	cmp	r3, r2
 800a954:	f280 861f 	bge.w	800b596 <clt_compute_allocation+0xcb6>
 800a958:	4619      	mov	r1, r3
 800a95a:	4615      	mov	r5, r2
 800a95c:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 800a960:	1e6c      	subs	r4, r5, #1
   {
      /* Below this threshold, we're sure not to allocate any PVQ bits */
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
 800a962:	f8d9 3018 	ldr.w	r3, [r9, #24]
 800a966:	f1a2 0a05 	sub.w	sl, r2, #5
 800a96a:	f101 0c01 	add.w	ip, r1, #1
 800a96e:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 800a972:	0048      	lsls	r0, r1, #1
 800a974:	4564      	cmp	r4, ip
 800a976:	643c      	str	r4, [r7, #64]	; 0x40
 800a978:	663b      	str	r3, [r7, #96]	; 0x60
 800a97a:	64b8      	str	r0, [r7, #72]	; 0x48
 800a97c:	eb03 0800 	add.w	r8, r3, r0
 800a980:	ebaa 0a02 	sub.w	sl, sl, r2
 800a984:	f102 0b03 	add.w	fp, r2, #3
 800a988:	460c      	mov	r4, r1
 800a98a:	f340 860f 	ble.w	800b5ac <clt_compute_allocation+0xccc>
 800a98e:	eba5 0e01 	sub.w	lr, r5, r1
 800a992:	f933 1011 	ldrsh.w	r1, [r3, r1, lsl #1]
 800a996:	f8d7 50c0 	ldr.w	r5, [r7, #192]	; 0xc0
 800a99a:	f10e 3eff 	add.w	lr, lr, #4294967295
 800a99e:	66fe      	str	r6, [r7, #108]	; 0x6c
 800a9a0:	f8c7 9058 	str.w	r9, [r7, #88]	; 0x58
 800a9a4:	f9b8 2002 	ldrsh.w	r2, [r8, #2]
 800a9a8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800a9aa:	1a51      	subs	r1, r2, r1
 800a9ac:	eb01 0041 	add.w	r0, r1, r1, lsl #1
 800a9b0:	40a8      	lsls	r0, r5
 800a9b2:	f340 005b 	sbfx	r0, r0, #1, #28
 800a9b6:	4298      	cmp	r0, r3
 800a9b8:	bfb8      	it	lt
 800a9ba:	4618      	movlt	r0, r3
      /* Tilt of the allocation curve */
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
 800a9bc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
 800a9c0:	6bbe      	ldr	r6, [r7, #56]	; 0x38
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
 800a9c2:	fb01 f303 	mul.w	r3, r1, r3
 800a9c6:	fb0a f303 	mul.w	r3, sl, r3
 800a9ca:	fb0e f303 	mul.w	r3, lr, r3
            *(1<<(LM+BITRES))>>6;
      /* Giving less resolution to single-coefficient bands because they get
         more benefit from having one coarse value per coefficient*/
      if ((m->eBands[j+1]-m->eBands[j])<<LM==1)
 800a9ce:	40a9      	lsls	r1, r5
 800a9d0:	2901      	cmp	r1, #1
         trim_offset[j] -= C<<BITRES;
 800a9d2:	bf08      	it	eq
 800a9d4:	6e79      	ldreq	r1, [r7, #100]	; 0x64
            *(1<<(LM+BITRES))>>6;
 800a9d6:	fa03 f30b 	lsl.w	r3, r3, fp
 800a9da:	ea4f 13a3 	mov.w	r3, r3, asr #6
         trim_offset[j] -= C<<BITRES;
 800a9de:	bf08      	it	eq
 800a9e0:	1a5b      	subeq	r3, r3, r1
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
 800a9e2:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
 800a9e4:	f846 0024 	str.w	r0, [r6, r4, lsl #2]
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
 800a9e8:	f841 3024 	str.w	r3, [r1, r4, lsl #2]
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
 800a9ec:	f9b8 1004 	ldrsh.w	r1, [r8, #4]
 800a9f0:	6e7e      	ldr	r6, [r7, #100]	; 0x64
 800a9f2:	1a8a      	subs	r2, r1, r2
 800a9f4:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 800a9f8:	40a8      	lsls	r0, r5
 800a9fa:	f340 005b 	sbfx	r0, r0, #1, #28
 800a9fe:	42b0      	cmp	r0, r6
 800aa00:	bfb8      	it	lt
 800aa02:	4630      	movlt	r0, r6
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
 800aa04:	f8d7 60bc 	ldr.w	r6, [r7, #188]	; 0xbc
 800aa08:	f10e 33ff 	add.w	r3, lr, #4294967295
 800aa0c:	fb02 f906 	mul.w	r9, r2, r6
 800aa10:	fb0a f909 	mul.w	r9, sl, r9
 800aa14:	fb03 f309 	mul.w	r3, r3, r9
      if ((m->eBands[j+1]-m->eBands[j])<<LM==1)
 800aa18:	40aa      	lsls	r2, r5
 800aa1a:	2a01      	cmp	r2, #1
         trim_offset[j] -= C<<BITRES;
 800aa1c:	bf08      	it	eq
 800aa1e:	6e7a      	ldreq	r2, [r7, #100]	; 0x64
            *(1<<(LM+BITRES))>>6;
 800aa20:	fa03 f30b 	lsl.w	r3, r3, fp
 800aa24:	ea4f 13a3 	mov.w	r3, r3, asr #6
         trim_offset[j] -= C<<BITRES;
 800aa28:	bf08      	it	eq
 800aa2a:	1a9b      	subeq	r3, r3, r2
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
 800aa2c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
 800aa2e:	6bbe      	ldr	r6, [r7, #56]	; 0x38
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
 800aa30:	f842 302c 	str.w	r3, [r2, ip, lsl #2]
 800aa34:	6c3b      	ldr	r3, [r7, #64]	; 0x40
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
 800aa36:	f846 002c 	str.w	r0, [r6, ip, lsl #2]
 800aa3a:	f10c 0c02 	add.w	ip, ip, #2
 800aa3e:	459c      	cmp	ip, r3
 800aa40:	f104 0402 	add.w	r4, r4, #2
 800aa44:	f108 0804 	add.w	r8, r8, #4
 800aa48:	f1ae 0e02 	sub.w	lr, lr, #2
 800aa4c:	dbaa      	blt.n	800a9a4 <clt_compute_allocation+0xc4>
 800aa4e:	6efe      	ldr	r6, [r7, #108]	; 0x6c
 800aa50:	f8d7 9058 	ldr.w	r9, [r7, #88]	; 0x58
 800aa54:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800aa56:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aa58:	f8c7 906c 	str.w	r9, [r7, #108]	; 0x6c
 800aa5c:	eb03 0c84 	add.w	ip, r3, r4, lsl #2
 800aa60:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aa62:	f8d7 8064 	ldr.w	r8, [r7, #100]	; 0x64
 800aa66:	4699      	mov	r9, r3
 800aa68:	1b18      	subs	r0, r3, r4
 800aa6a:	f8d7 e0c0 	ldr.w	lr, [r7, #192]	; 0xc0
 800aa6e:	eb02 0544 	add.w	r5, r2, r4, lsl #1
 800aa72:	f1ac 0c04 	sub.w	ip, ip, #4
 800aa76:	3801      	subs	r0, #1
 800aa78:	f9b5 3000 	ldrsh.w	r3, [r5]
 800aa7c:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
 800aa80:	3502      	adds	r5, #2
 800aa82:	1ad2      	subs	r2, r2, r3
 800aa84:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 800aa88:	fa01 f10e 	lsl.w	r1, r1, lr
 800aa8c:	f341 015b 	sbfx	r1, r1, #1, #28
 800aa90:	4541      	cmp	r1, r8
 800aa92:	bfb8      	it	lt
 800aa94:	4641      	movlt	r1, r8
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
 800aa96:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
      thresh[j] = IMAX((C)<<BITRES, (3*(m->eBands[j+1]-m->eBands[j])<<LM<<BITRES)>>4);
 800aa9a:	f84c 1f04 	str.w	r1, [ip, #4]!
      trim_offset[j] = C*(m->eBands[j+1]-m->eBands[j])*(alloc_trim-5-LM)*(end-j-1)
 800aa9e:	fb02 f303 	mul.w	r3, r2, r3
 800aaa2:	fb0a f303 	mul.w	r3, sl, r3
 800aaa6:	fb00 f303 	mul.w	r3, r0, r3
      if ((m->eBands[j+1]-m->eBands[j])<<LM==1)
 800aaaa:	fa02 f20e 	lsl.w	r2, r2, lr
            *(1<<(LM+BITRES))>>6;
 800aaae:	fa03 f30b 	lsl.w	r3, r3, fp
 800aab2:	119b      	asrs	r3, r3, #6
      if ((m->eBands[j+1]-m->eBands[j])<<LM==1)
 800aab4:	2a01      	cmp	r2, #1
         trim_offset[j] -= C<<BITRES;
 800aab6:	bf08      	it	eq
 800aab8:	eba3 0308 	subeq.w	r3, r3, r8
 800aabc:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
   for (j=start;j<end;j++)
 800aac0:	3401      	adds	r4, #1
 800aac2:	45a1      	cmp	r9, r4
 800aac4:	f100 30ff 	add.w	r0, r0, #4294967295
 800aac8:	dcd6      	bgt.n	800aa78 <clt_compute_allocation+0x198>
 800aaca:	f8d7 906c 	ldr.w	r9, [r7, #108]	; 0x6c
 800aace:	6c39      	ldr	r1, [r7, #64]	; 0x40
   }
   lo = 1;
 800aad0:	2301      	movs	r3, #1
 800aad2:	46b0      	mov	r8, r6
 800aad4:	663b      	str	r3, [r7, #96]	; 0x60
 800aad6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aad8:	6bbc      	ldr	r4, [r7, #56]	; 0x38
 800aada:	009a      	lsls	r2, r3, #2
 800aadc:	1f13      	subs	r3, r2, #4
 800aade:	18e3      	adds	r3, r4, r3
 800aae0:	623b      	str	r3, [r7, #32]
 800aae2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   hi = m->nbAllocVectors - 1;
 800aae4:	f8d9 0028 	ldr.w	r0, [r9, #40]	; 0x28
 800aae8:	4413      	add	r3, r2
 800aaea:	61fb      	str	r3, [r7, #28]
 800aaec:	1e43      	subs	r3, r0, #1
 800aaee:	65bb      	str	r3, [r7, #88]	; 0x58
 800aaf0:	f8d7 e098 	ldr.w	lr, [r7, #152]	; 0x98
 800aaf4:	004b      	lsls	r3, r1, #1
 800aaf6:	62f9      	str	r1, [r7, #44]	; 0x2c
 800aaf8:	61ba      	str	r2, [r7, #24]
 800aafa:	6538      	str	r0, [r7, #80]	; 0x50
 800aafc:	627b      	str	r3, [r7, #36]	; 0x24
   do
   {
      int done = 0;
      int psum = 0;
 800aafe:	2000      	movs	r0, #0
      int mid = (lo+hi) >> 1;
 800ab00:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800ab02:	6dbb      	ldr	r3, [r7, #88]	; 0x58
      for (j=end;j-->start;)
 800ab04:	69fc      	ldr	r4, [r7, #28]
      int mid = (lo+hi) >> 1;
 800ab06:	4413      	add	r3, r2
      {
         int bitsj;
         int N = m->eBands[j+1]-m->eBands[j];
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
 800ab08:	6aba      	ldr	r2, [r7, #40]	; 0x28
      int mid = (lo+hi) >> 1;
 800ab0a:	105b      	asrs	r3, r3, #1
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
 800ab0c:	fb02 fc03 	mul.w	ip, r2, r3
      for (j=end;j-->start;)
 800ab10:	e9d7 5208 	ldrd	r5, r2, [r7, #32]
      int mid = (lo+hi) >> 1;
 800ab14:	64fb      	str	r3, [r7, #76]	; 0x4c
      int done = 0;
 800ab16:	4606      	mov	r6, r0
      for (j=end;j-->start;)
 800ab18:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800ab1a:	66fc      	str	r4, [r7, #108]	; 0x6c
 800ab1c:	e006      	b.n	800ab2c <clt_compute_allocation+0x24c>
         if (bitsj > 0)
            bitsj = IMAX(0, bitsj + trim_offset[j]);
         bitsj += offsets[j];
         if (bitsj >= thresh[j] || done)
 800ab1e:	bbae      	cbnz	r6, 800ab8c <clt_compute_allocation+0x2ac>
         {
            done = 1;
            /* Don't allocate more than we can actually use */
            psum += IMIN(bitsj, cap[j]);
         } else {
            if (bitsj >= C<<BITRES)
 800ab20:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800ab22:	459a      	cmp	sl, r3
               psum += C<<BITRES;
 800ab24:	bfa8      	it	ge
 800ab26:	18c0      	addge	r0, r0, r3
 800ab28:	3901      	subs	r1, #1
 800ab2a:	3a02      	subs	r2, #2
      for (j=end;j-->start;)
 800ab2c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ab2e:	4299      	cmp	r1, r3
 800ab30:	dd34      	ble.n	800ab9c <clt_compute_allocation+0x2bc>
         int N = m->eBands[j+1]-m->eBands[j];
 800ab32:	f8d9 3018 	ldr.w	r3, [r9, #24]
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
 800ab36:	f8d7 40bc 	ldr.w	r4, [r7, #188]	; 0xbc
         int N = m->eBands[j+1]-m->eBands[j];
 800ab3a:	eb03 0a02 	add.w	sl, r3, r2
 800ab3e:	f933 b002 	ldrsh.w	fp, [r3, r2]
 800ab42:	f9ba a002 	ldrsh.w	sl, [sl, #2]
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
 800ab46:	f8d9 302c 	ldr.w	r3, [r9, #44]	; 0x2c
         int N = m->eBands[j+1]-m->eBands[j];
 800ab4a:	ebaa 0a0b 	sub.w	sl, sl, fp
         bitsj = C*N*m->allocVectors[mid*len+j]<<LM>>2;
 800ab4e:	4463      	add	r3, ip
 800ab50:	fb04 fa0a 	mul.w	sl, r4, sl
 800ab54:	440b      	add	r3, r1
 800ab56:	f813 bc01 	ldrb.w	fp, [r3, #-1]
 800ab5a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800ab5e:	fb0b fa0a 	mul.w	sl, fp, sl
 800ab62:	fa0a fa03 	lsl.w	sl, sl, r3
 800ab66:	ea4f 0aaa 	mov.w	sl, sl, asr #2
         if (bitsj > 0)
 800ab6a:	f1ba 0f00 	cmp.w	sl, #0
 800ab6e:	dd04      	ble.n	800ab7a <clt_compute_allocation+0x29a>
            bitsj = IMAX(0, bitsj + trim_offset[j]);
 800ab70:	f858 3012 	ldr.w	r3, [r8, r2, lsl #1]
 800ab74:	449a      	add	sl, r3
 800ab76:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
         bitsj += offsets[j];
 800ab7a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ab7c:	f853 bd04 	ldr.w	fp, [r3, #-4]!
 800ab80:	66fb      	str	r3, [r7, #108]	; 0x6c
         if (bitsj >= thresh[j] || done)
 800ab82:	f855 3904 	ldr.w	r3, [r5], #-4
         bitsj += offsets[j];
 800ab86:	44da      	add	sl, fp
         if (bitsj >= thresh[j] || done)
 800ab88:	4553      	cmp	r3, sl
 800ab8a:	dcc8      	bgt.n	800ab1e <clt_compute_allocation+0x23e>
            psum += IMIN(bitsj, cap[j]);
 800ab8c:	f85e 3012 	ldr.w	r3, [lr, r2, lsl #1]
            done = 1;
 800ab90:	2601      	movs	r6, #1
            psum += IMIN(bitsj, cap[j]);
 800ab92:	459a      	cmp	sl, r3
 800ab94:	bfd4      	ite	le
 800ab96:	4450      	addle	r0, sl
 800ab98:	18c0      	addgt	r0, r0, r3
 800ab9a:	e7c5      	b.n	800ab28 <clt_compute_allocation+0x248>
         }
      }
      if (psum > total)
 800ab9c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ab9e:	4298      	cmp	r0, r3
         hi = mid - 1;
 800aba0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
      if (psum > total)
 800aba2:	f340 80d2 	ble.w	800ad4a <clt_compute_allocation+0x46a>
      else
         lo = mid + 1;
      /*printf ("lo = %d, hi = %d\n", lo, hi);*/
   }
   while (lo <= hi);
 800aba6:	6e3a      	ldr	r2, [r7, #96]	; 0x60
         hi = mid - 1;
 800aba8:	3b01      	subs	r3, #1
   while (lo <= hi);
 800abaa:	429a      	cmp	r2, r3
         hi = mid - 1;
 800abac:	65bb      	str	r3, [r7, #88]	; 0x58
   while (lo <= hi);
 800abae:	dda6      	ble.n	800aafe <clt_compute_allocation+0x21e>
 800abb0:	4611      	mov	r1, r2
   hi = lo--;
   /*printf ("interp between %d and %d\n", lo, hi);*/
   for (j=start;j<end;j++)
 800abb2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800abb4:	6d78      	ldr	r0, [r7, #84]	; 0x54
 800abb6:	4646      	mov	r6, r8
 800abb8:	4283      	cmp	r3, r0
   hi = lo--;
 800abba:	f101 3bff 	add.w	fp, r1, #4294967295
   for (j=start;j<end;j++)
 800abbe:	f280 80d3 	bge.w	800ad68 <clt_compute_allocation+0x488>
   {
      int bits1j, bits2j;
      int N = m->eBands[j+1]-m->eBands[j];
 800abc2:	f8d9 2018 	ldr.w	r2, [r9, #24]
 800abc6:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800abc8:	f103 0e01 	add.w	lr, r3, #1
 800abcc:	1815      	adds	r5, r2, r0
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800abce:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800abd0:	f8d9 402c 	ldr.w	r4, [r9, #44]	; 0x2c
 800abd4:	fb0b fc00 	mul.w	ip, fp, r0
      bits2j = hi>=m->nbAllocVectors ?
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800abd8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
      int N = m->eBands[j+1]-m->eBands[j];
 800abda:	60fa      	str	r2, [r7, #12]
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800abdc:	fb00 f101 	mul.w	r1, r0, r1
 800abe0:	61f9      	str	r1, [r7, #28]
 800abe2:	6c39      	ldr	r1, [r7, #64]	; 0x40
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800abe4:	60bc      	str	r4, [r7, #8]
 800abe6:	4571      	cmp	r1, lr
 800abe8:	f8c7 c020 	str.w	ip, [r7, #32]
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800abec:	4619      	mov	r1, r3
 800abee:	65bb      	str	r3, [r7, #88]	; 0x58
 800abf0:	f340 80c4 	ble.w	800ad7c <clt_compute_allocation+0x49c>
 800abf4:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 800abf8:	6a38      	ldr	r0, [r7, #32]
 800abfa:	69fa      	ldr	r2, [r7, #28]
 800abfc:	1820      	adds	r0, r4, r0
 800abfe:	18a2      	adds	r2, r4, r2
 800ac00:	64f8      	str	r0, [r7, #76]	; 0x4c
 800ac02:	62ba      	str	r2, [r7, #40]	; 0x28
 800ac04:	66fe      	str	r6, [r7, #108]	; 0x6c
 800ac06:	4670      	mov	r0, lr
 800ac08:	f8c7 9000 	str.w	r9, [r7]
 800ac0c:	f8d7 c0c0 	ldr.w	ip, [r7, #192]	; 0xc0
 800ac10:	e07b      	b.n	800ad0a <clt_compute_allocation+0x42a>
 800ac12:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800ac16:	f853 8021 	ldr.w	r8, [r3, r1, lsl #2]
      if (bits1j > 0)
 800ac1a:	f1be 0f00 	cmp.w	lr, #0
 800ac1e:	dd05      	ble.n	800ac2c <clt_compute_allocation+0x34c>
         bits1j = IMAX(0, bits1j + trim_offset[j]);
 800ac20:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ac22:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800ac26:	449e      	add	lr, r3
 800ac28:	ea2e 7eee 	bic.w	lr, lr, lr, asr #31
      if (bits2j > 0)
 800ac2c:	f1b8 0f00 	cmp.w	r8, #0
 800ac30:	dd05      	ble.n	800ac3e <clt_compute_allocation+0x35e>
         bits2j = IMAX(0, bits2j + trim_offset[j]);
 800ac32:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ac34:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800ac38:	4498      	add	r8, r3
 800ac3a:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
 800ac3e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ac40:	f8d7 60bc 	ldr.w	r6, [r7, #188]	; 0xbc
 800ac44:	f853 9021 	ldr.w	r9, [r3, r1, lsl #2]
      int N = m->eBands[j+1]-m->eBands[j];
 800ac48:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
      if (lo > 0)
 800ac4c:	f1bb 0f00 	cmp.w	fp, #0
      int N = m->eBands[j+1]-m->eBands[j];
 800ac50:	eba3 0202 	sub.w	r2, r3, r2
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ac54:	fb06 f202 	mul.w	r2, r6, r2
 800ac58:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
         bits1j += offsets[j];
 800ac5a:	bfc8      	it	gt
 800ac5c:	44ce      	addgt	lr, r9
      bits2j += offsets[j];
 800ac5e:	44c8      	add	r8, r9
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ac60:	f816 a000 	ldrb.w	sl, [r6, r0]
      if (offsets[j]>0)
         skip_start = j;
      bits2j = IMAX(0,bits2j-bits1j);
 800ac64:	eba8 080e 	sub.w	r8, r8, lr
      bits1[j] = bits1j;
      bits2[j] = bits2j;
 800ac68:	6b3e      	ldr	r6, [r7, #48]	; 0x30
      bits2j = IMAX(0,bits2j-bits1j);
 800ac6a:	ea28 78e8 	bic.w	r8, r8, r8, asr #31
      bits2[j] = bits2j;
 800ac6e:	f846 8024 	str.w	r8, [r6, r4, lsl #2]
      if (offsets[j]>0)
 800ac72:	6dbe      	ldr	r6, [r7, #88]	; 0x58
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ac74:	fb02 fa0a 	mul.w	sl, r2, sl
      if (offsets[j]>0)
 800ac78:	f1b9 0f00 	cmp.w	r9, #0
 800ac7c:	bfd8      	it	le
 800ac7e:	4631      	movle	r1, r6
      bits1[j] = bits1j;
 800ac80:	6b7e      	ldr	r6, [r7, #52]	; 0x34
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ac82:	fa0a fa0c 	lsl.w	sl, sl, ip
      bits1[j] = bits1j;
 800ac86:	f846 e024 	str.w	lr, [r6, r4, lsl #2]
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ac8a:	6d3e      	ldr	r6, [r7, #80]	; 0x50
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ac8c:	ea4f 0aaa 	mov.w	sl, sl, asr #2
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ac90:	46b6      	mov	lr, r6
 800ac92:	6e3e      	ldr	r6, [r7, #96]	; 0x60
 800ac94:	45b6      	cmp	lr, r6
 800ac96:	dd69      	ble.n	800ad6c <clt_compute_allocation+0x48c>
 800ac98:	6abe      	ldr	r6, [r7, #40]	; 0x28
 800ac9a:	f816 e000 	ldrb.w	lr, [r6, r0]
 800ac9e:	fb02 fe0e 	mul.w	lr, r2, lr
 800aca2:	fa0e fe0c 	lsl.w	lr, lr, ip
 800aca6:	ea4f 0eae 	mov.w	lr, lr, asr #2
      if (bits1j > 0)
 800acaa:	f1ba 0f00 	cmp.w	sl, #0
 800acae:	dd05      	ble.n	800acbc <clt_compute_allocation+0x3dc>
         bits1j = IMAX(0, bits1j + trim_offset[j]);
 800acb0:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800acb2:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 800acb6:	4492      	add	sl, r2
 800acb8:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
      if (bits2j > 0)
 800acbc:	f1be 0f00 	cmp.w	lr, #0
 800acc0:	dd05      	ble.n	800acce <clt_compute_allocation+0x3ee>
         bits2j = IMAX(0, bits2j + trim_offset[j]);
 800acc2:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800acc4:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 800acc8:	4496      	add	lr, r2
 800acca:	ea2e 7eee 	bic.w	lr, lr, lr, asr #31
 800acce:	6c7a      	ldr	r2, [r7, #68]	; 0x44
      if (lo > 0)
 800acd0:	f1bb 0f00 	cmp.w	fp, #0
 800acd4:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
      bits2[j] = bits2j;
 800acd8:	6b3e      	ldr	r6, [r7, #48]	; 0x30
         bits1j += offsets[j];
 800acda:	bfc8      	it	gt
 800acdc:	4492      	addgt	sl, r2
      if (offsets[j]>0)
 800acde:	2a00      	cmp	r2, #0
 800ace0:	bfc8      	it	gt
 800ace2:	4601      	movgt	r1, r0
      bits2j += offsets[j];
 800ace4:	4496      	add	lr, r2
      bits1[j] = bits1j;
 800ace6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
      bits2j = IMAX(0,bits2j-bits1j);
 800ace8:	ebae 0e0a 	sub.w	lr, lr, sl
      bits1[j] = bits1j;
 800acec:	f842 a020 	str.w	sl, [r2, r0, lsl #2]
      bits2j = IMAX(0,bits2j-bits1j);
 800acf0:	ea2e 7eee 	bic.w	lr, lr, lr, asr #31
 800acf4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
      bits2[j] = bits2j;
 800acf6:	f846 e020 	str.w	lr, [r6, r0, lsl #2]
 800acfa:	3002      	adds	r0, #2
 800acfc:	4282      	cmp	r2, r0
      if (offsets[j]>0)
 800acfe:	65b9      	str	r1, [r7, #88]	; 0x58
 800ad00:	f105 0504 	add.w	r5, r5, #4
 800ad04:	f104 0102 	add.w	r1, r4, #2
 800ad08:	dd35      	ble.n	800ad76 <clt_compute_allocation+0x496>
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ad0a:	6cfc      	ldr	r4, [r7, #76]	; 0x4c
      int N = m->eBands[j+1]-m->eBands[j];
 800ad0c:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ad10:	f814 e001 	ldrb.w	lr, [r4, r1]
 800ad14:	f8d7 40bc 	ldr.w	r4, [r7, #188]	; 0xbc
      int N = m->eBands[j+1]-m->eBands[j];
 800ad18:	1ad3      	subs	r3, r2, r3
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ad1a:	fb04 f803 	mul.w	r8, r4, r3
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ad1e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ad20:	fb08 fe0e 	mul.w	lr, r8, lr
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ad24:	461e      	mov	r6, r3
 800ad26:	6e3b      	ldr	r3, [r7, #96]	; 0x60
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ad28:	fa0e fe0c 	lsl.w	lr, lr, ip
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ad2c:	429e      	cmp	r6, r3
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ad2e:	ea4f 0eae 	mov.w	lr, lr, asr #2
 800ad32:	460c      	mov	r4, r1
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ad34:	f77f af6d 	ble.w	800ac12 <clt_compute_allocation+0x332>
 800ad38:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ad3a:	5c5b      	ldrb	r3, [r3, r1]
 800ad3c:	fb08 f803 	mul.w	r8, r8, r3
 800ad40:	fa08 f80c 	lsl.w	r8, r8, ip
 800ad44:	ea4f 08a8 	mov.w	r8, r8, asr #2
 800ad48:	e767      	b.n	800ac1a <clt_compute_allocation+0x33a>
   while (lo <= hi);
 800ad4a:	6dba      	ldr	r2, [r7, #88]	; 0x58
         lo = mid + 1;
 800ad4c:	3301      	adds	r3, #1
   while (lo <= hi);
 800ad4e:	429a      	cmp	r2, r3
         lo = mid + 1;
 800ad50:	663b      	str	r3, [r7, #96]	; 0x60
   while (lo <= hi);
 800ad52:	f6bf aed4 	bge.w	800aafe <clt_compute_allocation+0x21e>
 800ad56:	4619      	mov	r1, r3
   for (j=start;j<end;j++)
 800ad58:	6d78      	ldr	r0, [r7, #84]	; 0x54
 800ad5a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ad5c:	4646      	mov	r6, r8
 800ad5e:	4283      	cmp	r3, r0
   hi = lo--;
 800ad60:	f101 3bff 	add.w	fp, r1, #4294967295
   for (j=start;j<end;j++)
 800ad64:	f6ff af2d 	blt.w	800abc2 <clt_compute_allocation+0x2e2>
 800ad68:	65bb      	str	r3, [r7, #88]	; 0x58
 800ad6a:	e073      	b.n	800ae54 <clt_compute_allocation+0x574>
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ad6c:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 800ad70:	f852 e020 	ldr.w	lr, [r2, r0, lsl #2]
 800ad74:	e799      	b.n	800acaa <clt_compute_allocation+0x3ca>
 800ad76:	6efe      	ldr	r6, [r7, #108]	; 0x6c
 800ad78:	f8d7 9000 	ldr.w	r9, [r7]
 800ad7c:	6a3b      	ldr	r3, [r7, #32]
 800ad7e:	68fa      	ldr	r2, [r7, #12]
 800ad80:	440b      	add	r3, r1
 800ad82:	469e      	mov	lr, r3
 800ad84:	eb02 0541 	add.w	r5, r2, r1, lsl #1
 800ad88:	68bb      	ldr	r3, [r7, #8]
 800ad8a:	69fa      	ldr	r2, [r7, #28]
 800ad8c:	ea4f 0c81 	mov.w	ip, r1, lsl #2
 800ad90:	441a      	add	r2, r3
 800ad92:	449e      	add	lr, r3
 800ad94:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ad96:	f1ac 0c04 	sub.w	ip, ip, #4
 800ad9a:	4463      	add	r3, ip
 800ad9c:	461c      	mov	r4, r3
 800ad9e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ada0:	f8c7 904c 	str.w	r9, [r7, #76]	; 0x4c
 800ada4:	eb03 080c 	add.w	r8, r3, ip
 800ada8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800adaa:	f8d7 9058 	ldr.w	r9, [r7, #88]	; 0x58
 800adae:	449c      	add	ip, r3
 800adb0:	66fc      	str	r4, [r7, #108]	; 0x6c
 800adb2:	65ba      	str	r2, [r7, #88]	; 0x58
 800adb4:	f8d7 a0c0 	ldr.w	sl, [r7, #192]	; 0xc0
 800adb8:	e028      	b.n	800ae0c <clt_compute_allocation+0x52c>
 800adba:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800adbe:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
      if (bits1j > 0)
 800adc2:	2a00      	cmp	r2, #0
 800adc4:	dd04      	ble.n	800add0 <clt_compute_allocation+0x4f0>
         bits1j = IMAX(0, bits1j + trim_offset[j]);
 800adc6:	f856 0021 	ldr.w	r0, [r6, r1, lsl #2]
 800adca:	4402      	add	r2, r0
 800adcc:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
      if (bits2j > 0)
 800add0:	2b00      	cmp	r3, #0
 800add2:	dd04      	ble.n	800adde <clt_compute_allocation+0x4fe>
         bits2j = IMAX(0, bits2j + trim_offset[j]);
 800add4:	f856 0021 	ldr.w	r0, [r6, r1, lsl #2]
 800add8:	4403      	add	r3, r0
 800adda:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800adde:	6efc      	ldr	r4, [r7, #108]	; 0x6c
      if (lo > 0)
 800ade0:	f1bb 0f00 	cmp.w	fp, #0
 800ade4:	f854 0f04 	ldr.w	r0, [r4, #4]!
         bits1j += offsets[j];
 800ade8:	bfc8      	it	gt
 800adea:	1812      	addgt	r2, r2, r0
      bits2j += offsets[j];
 800adec:	4403      	add	r3, r0
      bits2j = IMAX(0,bits2j-bits1j);
 800adee:	1a9b      	subs	r3, r3, r2
 800adf0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
      bits2[j] = bits2j;
 800adf4:	f84c 3f04 	str.w	r3, [ip, #4]!
   for (j=start;j<end;j++)
 800adf8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
      if (offsets[j]>0)
 800adfa:	2800      	cmp	r0, #0
 800adfc:	bfc8      	it	gt
 800adfe:	4689      	movgt	r9, r1
   for (j=start;j<end;j++)
 800ae00:	3101      	adds	r1, #1
 800ae02:	4299      	cmp	r1, r3
 800ae04:	66fc      	str	r4, [r7, #108]	; 0x6c
      bits1[j] = bits1j;
 800ae06:	f848 2f04 	str.w	r2, [r8, #4]!
   for (j=start;j<end;j++)
 800ae0a:	da1f      	bge.n	800ae4c <clt_compute_allocation+0x56c>
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ae0c:	6d38      	ldr	r0, [r7, #80]	; 0x50
      int N = m->eBands[j+1]-m->eBands[j];
 800ae0e:	f9b5 2000 	ldrsh.w	r2, [r5]
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ae12:	4604      	mov	r4, r0
      int N = m->eBands[j+1]-m->eBands[j];
 800ae14:	f9b5 3002 	ldrsh.w	r3, [r5, #2]
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ae18:	6e38      	ldr	r0, [r7, #96]	; 0x60
      int N = m->eBands[j+1]-m->eBands[j];
 800ae1a:	1a9b      	subs	r3, r3, r2
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ae1c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ae20:	4284      	cmp	r4, r0
      bits1j = C*N*m->allocVectors[lo*len+j]<<LM>>2;
 800ae22:	fb02 f303 	mul.w	r3, r2, r3
 800ae26:	f81e 2b01 	ldrb.w	r2, [lr], #1
 800ae2a:	f105 0502 	add.w	r5, r5, #2
 800ae2e:	fb03 f202 	mul.w	r2, r3, r2
 800ae32:	fa02 f20a 	lsl.w	r2, r2, sl
 800ae36:	ea4f 02a2 	mov.w	r2, r2, asr #2
            cap[j] : C*N*m->allocVectors[hi*len+j]<<LM>>2;
 800ae3a:	ddbe      	ble.n	800adba <clt_compute_allocation+0x4da>
 800ae3c:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800ae3e:	5c40      	ldrb	r0, [r0, r1]
 800ae40:	fb03 f300 	mul.w	r3, r3, r0
 800ae44:	fa03 f30a 	lsl.w	r3, r3, sl
 800ae48:	109b      	asrs	r3, r3, #2
 800ae4a:	e7ba      	b.n	800adc2 <clt_compute_allocation+0x4e2>
 800ae4c:	f8c7 9058 	str.w	r9, [r7, #88]	; 0x58
 800ae50:	f8d7 904c 	ldr.w	r9, [r7, #76]	; 0x4c
   stereo = C>1;
 800ae54:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800ae58:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800ae5a:	2b01      	cmp	r3, #1
 800ae5c:	bfd4      	ite	le
 800ae5e:	2300      	movle	r3, #0
 800ae60:	2301      	movgt	r3, #1
 800ae62:	62bb      	str	r3, [r7, #40]	; 0x28
   logM = LM<<BITRES;
 800ae64:	2306      	movs	r3, #6
 800ae66:	647b      	str	r3, [r7, #68]	; 0x44
   hi = 1<<ALLOC_STEPS;
 800ae68:	2340      	movs	r3, #64	; 0x40
 800ae6a:	4611      	mov	r1, r2
 800ae6c:	653b      	str	r3, [r7, #80]	; 0x50
 800ae6e:	69bb      	ldr	r3, [r7, #24]
 800ae70:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800ae72:	4419      	add	r1, r3
 800ae74:	64f9      	str	r1, [r7, #76]	; 0x4c
 800ae76:	4611      	mov	r1, r2
   lo = 0;
 800ae78:	f04f 0800 	mov.w	r8, #0
   logM = LM<<BITRES;
 800ae7c:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 800ae80:	4419      	add	r1, r3
 800ae82:	00d2      	lsls	r2, r2, #3
 800ae84:	633a      	str	r2, [r7, #48]	; 0x30
 800ae86:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ae88:	f8c7 9020 	str.w	r9, [r7, #32]
 800ae8c:	eb02 0a03 	add.w	sl, r2, r3
 800ae90:	f8c7 a038 	str.w	sl, [r7, #56]	; 0x38
 800ae94:	f8d7 9068 	ldr.w	r9, [r7, #104]	; 0x68
 800ae98:	f8d7 a098 	ldr.w	sl, [r7, #152]	; 0x98
 800ae9c:	6639      	str	r1, [r7, #96]	; 0x60
      done = 0;
 800ae9e:	f04f 0e00 	mov.w	lr, #0
      psum = 0;
 800aea2:	46f4      	mov	ip, lr
      int mid = (lo+hi)>>1;
 800aea4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800aea6:	6bbc      	ldr	r4, [r7, #56]	; 0x38
 800aea8:	eb08 0003 	add.w	r0, r8, r3
 800aeac:	6e3e      	ldr	r6, [r7, #96]	; 0x60
 800aeae:	6cfd      	ldr	r5, [r7, #76]	; 0x4c
 800aeb0:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800aeb2:	1040      	asrs	r0, r0, #1
 800aeb4:	66fc      	str	r4, [r7, #108]	; 0x6c
      for (j=end;j-->start;)
 800aeb6:	3901      	subs	r1, #1
 800aeb8:	1c4b      	adds	r3, r1, #1
 800aeba:	4599      	cmp	r9, r3
 800aebc:	da19      	bge.n	800aef2 <clt_compute_allocation+0x612>
         int tmp = bits1[j] + (mid*(opus_int32)bits2[j]>>ALLOC_STEPS);
 800aebe:	f855 2d04 	ldr.w	r2, [r5, #-4]!
 800aec2:	6efc      	ldr	r4, [r7, #108]	; 0x6c
 800aec4:	fb02 fb00 	mul.w	fp, r2, r0
 800aec8:	f854 3d04 	ldr.w	r3, [r4, #-4]!
         if (tmp >= thresh[j] || done)
 800aecc:	f856 2d04 	ldr.w	r2, [r6, #-4]!
         int tmp = bits1[j] + (mid*(opus_int32)bits2[j]>>ALLOC_STEPS);
 800aed0:	eb03 13ab 	add.w	r3, r3, fp, asr #6
         if (tmp >= thresh[j] || done)
 800aed4:	4293      	cmp	r3, r2
         int tmp = bits1[j] + (mid*(opus_int32)bits2[j]>>ALLOC_STEPS);
 800aed6:	66fc      	str	r4, [r7, #108]	; 0x6c
         if (tmp >= thresh[j] || done)
 800aed8:	da52      	bge.n	800af80 <clt_compute_allocation+0x6a0>
 800aeda:	f1be 0f00 	cmp.w	lr, #0
 800aede:	d14f      	bne.n	800af80 <clt_compute_allocation+0x6a0>
            if (tmp >= alloc_floor)
 800aee0:	6e7a      	ldr	r2, [r7, #100]	; 0x64
      for (j=end;j-->start;)
 800aee2:	3901      	subs	r1, #1
            if (tmp >= alloc_floor)
 800aee4:	4293      	cmp	r3, r2
      for (j=end;j-->start;)
 800aee6:	f101 0301 	add.w	r3, r1, #1
               psum += alloc_floor;
 800aeea:	bfa8      	it	ge
 800aeec:	4494      	addge	ip, r2
      for (j=end;j-->start;)
 800aeee:	4599      	cmp	r9, r3
 800aef0:	dbe5      	blt.n	800aebe <clt_compute_allocation+0x5de>
         lo = mid;
 800aef2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800aef4:	4563      	cmp	r3, ip
 800aef6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800aef8:	bfb8      	it	lt
 800aefa:	4603      	movlt	r3, r0
 800aefc:	653b      	str	r3, [r7, #80]	; 0x50
   for (i=0;i<ALLOC_STEPS;i++)
 800aefe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
         lo = mid;
 800af00:	bfa8      	it	ge
 800af02:	4680      	movge	r8, r0
   for (i=0;i<ALLOC_STEPS;i++)
 800af04:	3b01      	subs	r3, #1
 800af06:	647b      	str	r3, [r7, #68]	; 0x44
 800af08:	d1c9      	bne.n	800ae9e <clt_compute_allocation+0x5be>
   for (j=end;j-->start;)
 800af0a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800af0c:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800af0e:	f8d7 a038 	ldr.w	sl, [r7, #56]	; 0x38
 800af12:	428b      	cmp	r3, r1
 800af14:	f8d7 9020 	ldr.w	r9, [r7, #32]
   psum = 0;
 800af18:	6c7d      	ldr	r5, [r7, #68]	; 0x44
   for (j=end;j-->start;)
 800af1a:	da3a      	bge.n	800af92 <clt_compute_allocation+0x6b2>
 800af1c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800af1e:	6e3e      	ldr	r6, [r7, #96]	; 0x60
 800af20:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 800af24:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 800af28:	69bb      	ldr	r3, [r7, #24]
   done = 0;
 800af2a:	46ae      	mov	lr, r5
 800af2c:	18d4      	adds	r4, r2, r3
 800af2e:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800af32:	468b      	mov	fp, r1
 800af34:	18d0      	adds	r0, r2, r3
 800af36:	e012      	b.n	800af5e <clt_compute_allocation+0x67e>
      if (tmp < thresh[j] && !done)
 800af38:	f1be 0f00 	cmp.w	lr, #0
 800af3c:	d105      	bne.n	800af4a <clt_compute_allocation+0x66a>
            tmp = 0;
 800af3e:	6e79      	ldr	r1, [r7, #100]	; 0x64
 800af40:	460a      	mov	r2, r1
 800af42:	4299      	cmp	r1, r3
 800af44:	bfc8      	it	gt
 800af46:	2200      	movgt	r2, #0
 800af48:	4613      	mov	r3, r2
      tmp = IMIN(tmp, cap[j]);
 800af4a:	f854 1d04 	ldr.w	r1, [r4, #-4]!
 800af4e:	428b      	cmp	r3, r1
 800af50:	bfa8      	it	ge
 800af52:	460b      	movge	r3, r1
   for (j=end;j-->start;)
 800af54:	45d3      	cmp	fp, sl
      bits[j] = tmp;
 800af56:	f840 3d04 	str.w	r3, [r0, #-4]!
      psum += tmp;
 800af5a:	441d      	add	r5, r3
   for (j=end;j-->start;)
 800af5c:	d019      	beq.n	800af92 <clt_compute_allocation+0x6b2>
      int tmp = bits1[j] + ((opus_int32)lo*bits2[j]>>ALLOC_STEPS);
 800af5e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800af60:	f85a cd04 	ldr.w	ip, [sl, #-4]!
 800af64:	f852 3d04 	ldr.w	r3, [r2, #-4]!
      if (tmp < thresh[j] && !done)
 800af68:	f856 1d04 	ldr.w	r1, [r6, #-4]!
      int tmp = bits1[j] + ((opus_int32)lo*bits2[j]>>ALLOC_STEPS);
 800af6c:	fb03 f308 	mul.w	r3, r3, r8
 800af70:	eb0c 13a3 	add.w	r3, ip, r3, asr #6
      if (tmp < thresh[j] && !done)
 800af74:	4299      	cmp	r1, r3
      int tmp = bits1[j] + ((opus_int32)lo*bits2[j]>>ALLOC_STEPS);
 800af76:	64fa      	str	r2, [r7, #76]	; 0x4c
      if (tmp < thresh[j] && !done)
 800af78:	dcde      	bgt.n	800af38 <clt_compute_allocation+0x658>
         done = 1;
 800af7a:	f04f 0e01 	mov.w	lr, #1
 800af7e:	e7e4      	b.n	800af4a <clt_compute_allocation+0x66a>
            psum += IMIN(tmp, cap[j]);
 800af80:	f85a 2021 	ldr.w	r2, [sl, r1, lsl #2]
            done = 1;
 800af84:	f04f 0e01 	mov.w	lr, #1
            psum += IMIN(tmp, cap[j]);
 800af88:	4293      	cmp	r3, r2
 800af8a:	bfd4      	ite	le
 800af8c:	449c      	addle	ip, r3
 800af8e:	4494      	addgt	ip, r2
 800af90:	e791      	b.n	800aeb6 <clt_compute_allocation+0x5d6>
      if (j<=skip_start)
 800af92:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af94:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800af96:	4293      	cmp	r3, r2
 800af98:	f340 830b 	ble.w	800b5b2 <clt_compute_allocation+0xcd2>
 800af9c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
         intensity_rsv = LOG2_FRAC_TABLE[j-start];
 800af9e:	4b47      	ldr	r3, [pc, #284]	; (800b0bc <clt_compute_allocation+0x7dc>)
 800afa0:	f102 0802 	add.w	r8, r2, #2
 800afa4:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800afa6:	f8c7 904c 	str.w	r9, [r7, #76]	; 0x4c
 800afaa:	1a9b      	subs	r3, r3, r2
 800afac:	643b      	str	r3, [r7, #64]	; 0x40
 800afae:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800afb0:	69ba      	ldr	r2, [r7, #24]
 800afb2:	3308      	adds	r3, #8
 800afb4:	647b      	str	r3, [r7, #68]	; 0x44
 800afb6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800afba:	f8d7 b014 	ldr.w	fp, [r7, #20]
 800afbe:	189e      	adds	r6, r3, r2
 800afc0:	f8d7 902c 	ldr.w	r9, [r7, #44]	; 0x2c
 800afc4:	66fe      	str	r6, [r7, #108]	; 0x6c
      percoeff = celt_udiv(left, m->eBands[codedBands]-m->eBands[start]);
 800afc6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800afc8:	699c      	ldr	r4, [r3, #24]
 800afca:	f109 0301 	add.w	r3, r9, #1
 800afce:	653b      	str	r3, [r7, #80]	; 0x50
 800afd0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800afd2:	f934 2008 	ldrsh.w	r2, [r4, r8]
 800afd6:	f934 e003 	ldrsh.w	lr, [r4, r3]
      left = total-psum;
 800afda:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800afdc:	eba3 0c05 	sub.w	ip, r3, r5
      percoeff = celt_udiv(left, m->eBands[codedBands]-m->eBands[start]);
 800afe0:	eba2 030e 	sub.w	r3, r2, lr
   if (d>256)
 800afe4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800afe8:	f240 81c9 	bls.w	800b37e <clt_compute_allocation+0xa9e>
      return n/d;
 800afec:	fbbc f1f3 	udiv	r1, ip, r3
      band_bits = (int)(bits[j] + percoeff*band_width + rem);
 800aff0:	6efe      	ldr	r6, [r7, #108]	; 0x6c
      rem = IMAX(left-(m->eBands[j]-m->eBands[start]),0);
 800aff2:	f1a8 0a02 	sub.w	sl, r8, #2
 800aff6:	f934 400a 	ldrsh.w	r4, [r4, sl]
      left -= (m->eBands[codedBands]-m->eBands[start])*percoeff;
 800affa:	fb01 c313 	mls	r3, r1, r3, ip
      band_bits = (int)(bits[j] + percoeff*band_width + rem);
 800affe:	f856 0d04 	ldr.w	r0, [r6, #-4]!
      band_width = m->eBands[codedBands]-m->eBands[j];
 800b002:	1b12      	subs	r2, r2, r4
      band_bits = (int)(bits[j] + percoeff*band_width + rem);
 800b004:	66fe      	str	r6, [r7, #108]	; 0x6c
 800b006:	fb02 0101 	mla	r1, r2, r1, r0
      if (band_bits >= IMAX(thresh[j], alloc_floor+(1<<BITRES)))
 800b00a:	6e3e      	ldr	r6, [r7, #96]	; 0x60
      rem = IMAX(left-(m->eBands[j]-m->eBands[start]),0);
 800b00c:	eba4 040e 	sub.w	r4, r4, lr
 800b010:	1b1c      	subs	r4, r3, r4
      if (band_bits >= IMAX(thresh[j], alloc_floor+(1<<BITRES)))
 800b012:	f856 ed04 	ldr.w	lr, [r6, #-4]!
 800b016:	6c7b      	ldr	r3, [r7, #68]	; 0x44
      band_bits = (int)(bits[j] + percoeff*band_width + rem);
 800b018:	2c00      	cmp	r4, #0
 800b01a:	bfac      	ite	ge
 800b01c:	190c      	addge	r4, r1, r4
 800b01e:	1c0c      	addlt	r4, r1, #0
      if (band_bits >= IMAX(thresh[j], alloc_floor+(1<<BITRES)))
 800b020:	459e      	cmp	lr, r3
 800b022:	bfb8      	it	lt
 800b024:	469e      	movlt	lr, r3
 800b026:	4574      	cmp	r4, lr
 800b028:	663e      	str	r6, [r7, #96]	; 0x60
      rem = IMAX(left-(m->eBands[j]-m->eBands[start]),0);
 800b02a:	4653      	mov	r3, sl
      if (band_bits >= IMAX(thresh[j], alloc_floor+(1<<BITRES)))
 800b02c:	db2e      	blt.n	800b08c <clt_compute_allocation+0x7ac>
         if (encode)
 800b02e:	f8d7 10c8 	ldr.w	r1, [r7, #200]	; 0xc8
 800b032:	2900      	cmp	r1, #0
 800b034:	f000 81fc 	beq.w	800b430 <clt_compute_allocation+0xb50>
            if (codedBands > 17)
 800b038:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800b03a:	2911      	cmp	r1, #17
 800b03c:	f340 81b8 	ble.w	800b3b0 <clt_compute_allocation+0xad0>
            if (codedBands<=start+2 || (band_bits > (depth_threshold*band_width<<LM<<BITRES)>>4 && j<=signalBandwidth))
 800b040:	6eb8      	ldr	r0, [r7, #104]	; 0x68
               depth_threshold = j<prev ? 7 : 9;
 800b042:	f8d7 10cc 	ldr.w	r1, [r7, #204]	; 0xcc
            if (codedBands<=start+2 || (band_bits > (depth_threshold*band_width<<LM<<BITRES)>>4 && j<=signalBandwidth))
 800b046:	6d3e      	ldr	r6, [r7, #80]	; 0x50
 800b048:	3002      	adds	r0, #2
               depth_threshold = j<prev ? 7 : 9;
 800b04a:	4549      	cmp	r1, r9
 800b04c:	bfd4      	ite	le
 800b04e:	2109      	movle	r1, #9
 800b050:	2107      	movgt	r1, #7
            if (codedBands<=start+2 || (band_bits > (depth_threshold*band_width<<LM<<BITRES)>>4 && j<=signalBandwidth))
 800b052:	42b0      	cmp	r0, r6
 800b054:	f280 81b4 	bge.w	800b3c0 <clt_compute_allocation+0xae0>
 800b058:	fb01 f202 	mul.w	r2, r1, r2
 800b05c:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
 800b060:	408a      	lsls	r2, r1
 800b062:	f342 025b 	sbfx	r2, r2, #1, #28
 800b066:	4294      	cmp	r4, r2
 800b068:	dd04      	ble.n	800b074 <clt_compute_allocation+0x794>
 800b06a:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 800b06e:	454a      	cmp	r2, r9
 800b070:	f280 81a6 	bge.w	800b3c0 <clt_compute_allocation+0xae0>
            ec_enc_bit_logp(ec, 0, 1);
 800b074:	2201      	movs	r2, #1
 800b076:	2100      	movs	r1, #0
 800b078:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
 800b07c:	653b      	str	r3, [r7, #80]	; 0x50
 800b07e:	f7fd fcaf 	bl	80089e0 <ec_enc_bit_logp>
 800b082:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b084:	6efa      	ldr	r2, [r7, #108]	; 0x6c
         psum += 1<<BITRES;
 800b086:	3508      	adds	r5, #8
 800b088:	6810      	ldr	r0, [r2, #0]
         band_bits -= 1<<BITRES;
 800b08a:	3c08      	subs	r4, #8
      psum -= bits[j]+intensity_rsv;
 800b08c:	4458      	add	r0, fp
 800b08e:	1a2d      	subs	r5, r5, r0
      if (intensity_rsv > 0)
 800b090:	f1bb 0f00 	cmp.w	fp, #0
 800b094:	d003      	beq.n	800b09e <clt_compute_allocation+0x7be>
         intensity_rsv = LOG2_FRAC_TABLE[j-start];
 800b096:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800b098:	f812 b009 	ldrb.w	fp, [r2, r9]
 800b09c:	445d      	add	r5, fp
      if (band_bits >= alloc_floor)
 800b09e:	6e79      	ldr	r1, [r7, #100]	; 0x64
 800b0a0:	428c      	cmp	r4, r1
 800b0a2:	db0d      	blt.n	800b0c0 <clt_compute_allocation+0x7e0>
 800b0a4:	4698      	mov	r8, r3
      if (j<=skip_start)
 800b0a6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
      j = codedBands-1;
 800b0a8:	f109 32ff 	add.w	r2, r9, #4294967295
 800b0ac:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
      if (j<=skip_start)
 800b0ae:	4293      	cmp	r3, r2
         psum += alloc_floor;
 800b0b0:	440d      	add	r5, r1
 800b0b2:	6001      	str	r1, [r0, #0]
      if (j<=skip_start)
 800b0b4:	d00d      	beq.n	800b0d2 <clt_compute_allocation+0x7f2>
 800b0b6:	4691      	mov	r9, r2
 800b0b8:	e785      	b.n	800afc6 <clt_compute_allocation+0x6e6>
 800b0ba:	bf00      	nop
 800b0bc:	08016840 	.word	0x08016840
 800b0c0:	2100      	movs	r1, #0
 800b0c2:	4698      	mov	r8, r3
 800b0c4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
      j = codedBands-1;
 800b0c6:	f109 32ff 	add.w	r2, r9, #4294967295
 800b0ca:	6019      	str	r1, [r3, #0]
      if (j<=skip_start)
 800b0cc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800b0ce:	429a      	cmp	r2, r3
 800b0d0:	d1f1      	bne.n	800b0b6 <clt_compute_allocation+0x7d6>
 800b0d2:	f8c7 902c 	str.w	r9, [r7, #44]	; 0x2c
 800b0d6:	f8d7 904c 	ldr.w	r9, [r7, #76]	; 0x4c
 800b0da:	f8c7 b014 	str.w	fp, [r7, #20]
         total += skip_rsv;
 800b0de:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800b0e0:	687a      	ldr	r2, [r7, #4]
 800b0e2:	4413      	add	r3, r2
 800b0e4:	65fb      	str	r3, [r7, #92]	; 0x5c
   if (intensity_rsv > 0)
 800b0e6:	697b      	ldr	r3, [r7, #20]
 800b0e8:	2b00      	cmp	r3, #0
 800b0ea:	f000 81b7 	beq.w	800b45c <clt_compute_allocation+0xb7c>
      if (encode)
 800b0ee:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800b0f2:	2b00      	cmp	r3, #0
 800b0f4:	f040 8256 	bne.w	800b5a4 <clt_compute_allocation+0xcc4>
         *intensity = start+ec_dec_uint(ec, codedBands+1-start);
 800b0f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0fa:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 800b0fc:	1c59      	adds	r1, r3, #1
 800b0fe:	1b09      	subs	r1, r1, r4
 800b100:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
 800b104:	f7fd fa9a 	bl	800863c <ec_dec_uint>
 800b108:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800b10c:	4420      	add	r0, r4
 800b10e:	6018      	str	r0, [r3, #0]
   if (*intensity <= start)
 800b110:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800b112:	4283      	cmp	r3, r0
 800b114:	f2c0 817a 	blt.w	800b40c <clt_compute_allocation+0xb2c>
      total += dual_stereo_rsv;
 800b118:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800b11a:	693a      	ldr	r2, [r7, #16]
 800b11c:	4413      	add	r3, r2
 800b11e:	65fb      	str	r3, [r7, #92]	; 0x5c
      *dual_stereo = 0;
 800b120:	2300      	movs	r3, #0
 800b122:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 800b126:	6013      	str	r3, [r2, #0]
   percoeff = celt_udiv(left, m->eBands[codedBands]-m->eBands[start]);
 800b128:	f8d9 2018 	ldr.w	r2, [r9, #24]
   left = total-psum;
 800b12c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   percoeff = celt_udiv(left, m->eBands[codedBands]-m->eBands[start]);
 800b12e:	6cb8      	ldr	r0, [r7, #72]	; 0x48
   left = total-psum;
 800b130:	1b5d      	subs	r5, r3, r5
   percoeff = celt_udiv(left, m->eBands[codedBands]-m->eBands[start]);
 800b132:	f932 100a 	ldrsh.w	r1, [r2, sl]
 800b136:	5e13      	ldrsh	r3, [r2, r0]
 800b138:	663a      	str	r2, [r7, #96]	; 0x60
 800b13a:	1ac9      	subs	r1, r1, r3
   if (d>256)
 800b13c:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 800b140:	eb02 0800 	add.w	r8, r2, r0
 800b144:	f240 81e8 	bls.w	800b518 <clt_compute_allocation+0xc38>
      return n/d;
 800b148:	fbb5 fcf1 	udiv	ip, r5, r1
   for (j=start;j<codedBands;j++)
 800b14c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   left -= (m->eBands[codedBands]-m->eBands[start])*percoeff;
 800b14e:	fb0c 5511 	mls	r5, ip, r1, r5
   for (j=start;j<codedBands;j++)
 800b152:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800b154:	428b      	cmp	r3, r1
 800b156:	f280 81fd 	bge.w	800b554 <clt_compute_allocation+0xc74>
 800b15a:	f103 4b80 	add.w	fp, r3, #1073741824	; 0x40000000
 800b15e:	f10b 3bff 	add.w	fp, fp, #4294967295
 800b162:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800b166:	ea4f 038b 	mov.w	r3, fp, lsl #2
 800b16a:	18d4      	adds	r4, r2, r3
 800b16c:	4620      	mov	r0, r4
 800b16e:	46c3      	mov	fp, r8
 800b170:	4646      	mov	r6, r8
 800b172:	f1a2 0e04 	sub.w	lr, r2, #4
 800b176:	66fb      	str	r3, [r7, #108]	; 0x6c
 800b178:	eb0e 0e81 	add.w	lr, lr, r1, lsl #2
      bits[j] += ((int)percoeff*(m->eBands[j+1]-m->eBands[j]));
 800b17c:	f9b6 3002 	ldrsh.w	r3, [r6, #2]
 800b180:	f9b6 1000 	ldrsh.w	r1, [r6]
 800b184:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800b188:	1a5b      	subs	r3, r3, r1
 800b18a:	fb0c 2303 	mla	r3, ip, r3, r2
   for (j=start;j<codedBands;j++)
 800b18e:	4586      	cmp	lr, r0
 800b190:	f106 0602 	add.w	r6, r6, #2
      bits[j] += ((int)percoeff*(m->eBands[j+1]-m->eBands[j]));
 800b194:	6003      	str	r3, [r0, #0]
   for (j=start;j<codedBands;j++)
 800b196:	d1f1      	bne.n	800b17c <clt_compute_allocation+0x89c>
 800b198:	4641      	mov	r1, r8
 800b19a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800b19c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b19e:	eb03 0042 	add.w	r0, r3, r2, lsl #1
      int tmp = (int)IMIN(left, m->eBands[j+1]-m->eBands[j]);
 800b1a2:	f9b1 2000 	ldrsh.w	r2, [r1]
 800b1a6:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
 800b1aa:	3102      	adds	r1, #2
 800b1ac:	1a9b      	subs	r3, r3, r2
 800b1ae:	42ab      	cmp	r3, r5
 800b1b0:	bfa8      	it	ge
 800b1b2:	462b      	movge	r3, r5
      bits[j] += tmp;
 800b1b4:	f854 2f04 	ldr.w	r2, [r4, #4]!
      left -= tmp;
 800b1b8:	1aed      	subs	r5, r5, r3
   for (j=start;j<codedBands;j++)
 800b1ba:	4288      	cmp	r0, r1
      bits[j] += tmp;
 800b1bc:	4413      	add	r3, r2
 800b1be:	6023      	str	r3, [r4, #0]
   for (j=start;j<codedBands;j++)
 800b1c0:	d1ef      	bne.n	800b1a2 <clt_compute_allocation+0x8c2>
 800b1c2:	f04f 0a00 	mov.w	sl, #0
 800b1c6:	6efd      	ldr	r5, [r7, #108]	; 0x6c
 800b1c8:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b1cc:	3504      	adds	r5, #4
 800b1ce:	195c      	adds	r4, r3, r5
 800b1d0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
         extra_fine = IMIN(excess>>(stereo+BITRES),MAX_FINE_BITS-ebits[j]);
 800b1d4:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 800b1d6:	441d      	add	r5, r3
 800b1d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b1da:	f8d7 e0bc 	ldr.w	lr, [r7, #188]	; 0xbc
 800b1de:	3303      	adds	r3, #3
 800b1e0:	e9c7 9316 	strd	r9, r3, [r7, #88]	; 0x58
      N0 = m->eBands[j+1]-m->eBands[j];
 800b1e4:	f9bb 3000 	ldrsh.w	r3, [fp]
 800b1e8:	f9bb 8002 	ldrsh.w	r8, [fp, #2]
      bit = (opus_int32)bits[j]+balance;
 800b1ec:	6820      	ldr	r0, [r4, #0]
      N0 = m->eBands[j+1]-m->eBands[j];
 800b1ee:	eba8 0803 	sub.w	r8, r8, r3
      N=N0<<LM;
 800b1f2:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
      bit = (opus_int32)bits[j]+balance;
 800b1f6:	4450      	add	r0, sl
      N=N0<<LM;
 800b1f8:	fa08 f803 	lsl.w	r8, r8, r3
 800b1fc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
      if (N>1)
 800b1fe:	f1b8 0f01 	cmp.w	r8, #1
 800b202:	ebab 0603 	sub.w	r6, fp, r3
 800b206:	f10b 0b02 	add.w	fp, fp, #2
 800b20a:	f340 812f 	ble.w	800b46c <clt_compute_allocation+0xb8c>
         excess = MAX32(bit-cap[j],0);
 800b20e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
         den=(C*N+ ((C==2 && N>2 && !*dual_stereo && j<*intensity) ? 1 : 0));
 800b212:	f1be 0f02 	cmp.w	lr, #2
         excess = MAX32(bit-cap[j],0);
 800b216:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
 800b21a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800b21c:	eba0 0202 	sub.w	r2, r0, r2
 800b220:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b222:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
 800b226:	f933 9006 	ldrsh.w	r9, [r3, r6]
 800b22a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
         bits[j] = bit-excess;
 800b22c:	eba0 0002 	sub.w	r0, r0, r2
 800b230:	6020      	str	r0, [r4, #0]
 800b232:	4499      	add	r9, r3
         den=(C*N+ ((C==2 && N>2 && !*dual_stereo && j<*intensity) ? 1 : 0));
 800b234:	fb08 f60e 	mul.w	r6, r8, lr
 800b238:	f000 814b 	beq.w	800b4d2 <clt_compute_allocation+0xbf2>
         offset = (NClogN>>1)-den*FINE_OFFSET;
 800b23c:	f06f 0314 	mvn.w	r3, #20
         NClogN = den*(m->logN[j] + logM);
 800b240:	fb09 f906 	mul.w	r9, r9, r6
         offset = (NClogN>>1)-den*FINE_OFFSET;
 800b244:	fb03 fc06 	mul.w	ip, r3, r6
         if (N==2)
 800b248:	f1b8 0f02 	cmp.w	r8, #2
 800b24c:	ea4f 03c6 	mov.w	r3, r6, lsl #3
 800b250:	66fb      	str	r3, [r7, #108]	; 0x6c
         offset = (NClogN>>1)-den*FINE_OFFSET;
 800b252:	eb0c 0c69 	add.w	ip, ip, r9, asr #1
         if (N==2)
 800b256:	f000 815c 	beq.w	800b512 <clt_compute_allocation+0xc32>
         if (bits[j] + offset < den*2<<BITRES)
 800b25a:	eb00 030c 	add.w	r3, r0, ip
 800b25e:	ebb3 1f06 	cmp.w	r3, r6, lsl #4
 800b262:	ea4f 0846 	mov.w	r8, r6, lsl #1
 800b266:	f280 812b 	bge.w	800b4c0 <clt_compute_allocation+0xbe0>
            offset += NClogN>>2;
 800b26a:	eb0c 0ca9 	add.w	ip, ip, r9, asr #2
 800b26e:	eb00 030c 	add.w	r3, r0, ip
         ebits[j] = IMAX(0, (bits[j] + offset + (den<<(BITRES-1))));
 800b272:	eb03 0386 	add.w	r3, r3, r6, lsl #2
   if (d>256)
 800b276:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 800b27a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800b27e:	f240 8104 	bls.w	800b48a <clt_compute_allocation+0xbaa>
      return n/d;
 800b282:	fbb3 f3f6 	udiv	r3, r3, r6
         ebits[j] = celt_udiv(ebits[j], den)>>BITRES;
 800b286:	08db      	lsrs	r3, r3, #3
         if (C*ebits[j] > (bits[j]>>BITRES))
 800b288:	fb03 f60e 	mul.w	r6, r3, lr
         ebits[j] = celt_udiv(ebits[j], den)>>BITRES;
 800b28c:	602b      	str	r3, [r5, #0]
         if (C*ebits[j] > (bits[j]>>BITRES))
 800b28e:	6820      	ldr	r0, [r4, #0]
 800b290:	ebb6 0fe0 	cmp.w	r6, r0, asr #3
 800b294:	dd03      	ble.n	800b29e <clt_compute_allocation+0x9be>
            ebits[j] = bits[j] >> stereo >> BITRES;
 800b296:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b298:	fa40 f303 	asr.w	r3, r0, r3
 800b29c:	10db      	asrs	r3, r3, #3
         ebits[j] = IMIN(ebits[j], MAX_FINE_BITS);
 800b29e:	2b08      	cmp	r3, #8
 800b2a0:	bfa8      	it	ge
 800b2a2:	2308      	movge	r3, #8
         fine_priority[j] = ebits[j]*(den<<BITRES) >= bits[j]+offset;
 800b2a4:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
         ebits[j] = IMIN(ebits[j], MAX_FINE_BITS);
 800b2a6:	602b      	str	r3, [r5, #0]
         fine_priority[j] = ebits[j]*(den<<BITRES) >= bits[j]+offset;
 800b2a8:	fb00 f003 	mul.w	r0, r0, r3
 800b2ac:	6823      	ldr	r3, [r4, #0]
 800b2ae:	4463      	add	r3, ip
 800b2b0:	4298      	cmp	r0, r3
 800b2b2:	bfb4      	ite	lt
 800b2b4:	2300      	movlt	r3, #0
 800b2b6:	2301      	movge	r3, #1
 800b2b8:	f8d7 00b8 	ldr.w	r0, [r7, #184]	; 0xb8
 800b2bc:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
         bits[j] -= C*ebits[j]<<BITRES;
 800b2c0:	6828      	ldr	r0, [r5, #0]
 800b2c2:	6823      	ldr	r3, [r4, #0]
 800b2c4:	fb00 f00e 	mul.w	r0, r0, lr
 800b2c8:	eba3 00c0 	sub.w	r0, r3, r0, lsl #3
 800b2cc:	6020      	str	r0, [r4, #0]
      if(excess > 0)
 800b2ce:	2a00      	cmp	r2, #0
 800b2d0:	f000 80ca 	beq.w	800b468 <clt_compute_allocation+0xb88>
         extra_fine = IMIN(excess>>(stereo+BITRES),MAX_FINE_BITS-ebits[j]);
 800b2d4:	682b      	ldr	r3, [r5, #0]
 800b2d6:	6df8      	ldr	r0, [r7, #92]	; 0x5c
         fine_priority[j] = extra_bits >= excess-balance;
 800b2d8:	eba2 0c0a 	sub.w	ip, r2, sl
         extra_fine = IMIN(excess>>(stereo+BITRES),MAX_FINE_BITS-ebits[j]);
 800b2dc:	fa42 f600 	asr.w	r6, r2, r0
 800b2e0:	f1c3 0008 	rsb	r0, r3, #8
 800b2e4:	4286      	cmp	r6, r0
 800b2e6:	bfa8      	it	ge
 800b2e8:	4606      	movge	r6, r0
         extra_bits = extra_fine*C<<BITRES;
 800b2ea:	fb06 f00e 	mul.w	r0, r6, lr
 800b2ee:	ea4f 0ac0 	mov.w	sl, r0, lsl #3
         fine_priority[j] = extra_bits >= excess-balance;
 800b2f2:	45e2      	cmp	sl, ip
 800b2f4:	bfb4      	ite	lt
 800b2f6:	2000      	movlt	r0, #0
 800b2f8:	2001      	movge	r0, #1
         ebits[j] += extra_fine;
 800b2fa:	4433      	add	r3, r6
 800b2fc:	602b      	str	r3, [r5, #0]
         fine_priority[j] = extra_bits >= excess-balance;
 800b2fe:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
         excess -= extra_bits;
 800b302:	eba2 0a0a 	sub.w	sl, r2, sl
         fine_priority[j] = extra_bits >= excess-balance;
 800b306:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
   for (j=start;j<codedBands;j++)
 800b30a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b30c:	3101      	adds	r1, #1
 800b30e:	4299      	cmp	r1, r3
 800b310:	f104 0404 	add.w	r4, r4, #4
 800b314:	f105 0504 	add.w	r5, r5, #4
 800b318:	f47f af64 	bne.w	800b1e4 <clt_compute_allocation+0x904>
 800b31c:	66b9      	str	r1, [r7, #104]	; 0x68
   *_balance = balance;
 800b31e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800b322:	f8c3 a000 	str.w	sl, [r3]
   for (;j<end;j++)
 800b326:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b328:	4619      	mov	r1, r3
 800b32a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800b32c:	4299      	cmp	r1, r3
 800b32e:	dd21      	ble.n	800b374 <clt_compute_allocation+0xa94>
      bits[j] = 0;
 800b330:	2100      	movs	r1, #0
 800b332:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
 800b336:	3a01      	subs	r2, #1
 800b338:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800b33c:	0092      	lsls	r2, r2, #2
 800b33e:	1898      	adds	r0, r3, r2
 800b340:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800b344:	6abe      	ldr	r6, [r7, #40]	; 0x28
 800b346:	189c      	adds	r4, r3, r2
 800b348:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800b34c:	1f1d      	subs	r5, r3, #4
 800b34e:	441a      	add	r2, r3
 800b350:	69bb      	ldr	r3, [r7, #24]
 800b352:	441d      	add	r5, r3
      ebits[j] = bits[j] >> stereo >> BITRES;
 800b354:	f852 3f04 	ldr.w	r3, [r2, #4]!
 800b358:	4133      	asrs	r3, r6
 800b35a:	10db      	asrs	r3, r3, #3
 800b35c:	f840 3f04 	str.w	r3, [r0, #4]!
      bits[j] = 0;
 800b360:	6011      	str	r1, [r2, #0]
      fine_priority[j] = ebits[j]<1;
 800b362:	6803      	ldr	r3, [r0, #0]
 800b364:	2b00      	cmp	r3, #0
 800b366:	bfcc      	ite	gt
 800b368:	2300      	movgt	r3, #0
 800b36a:	2301      	movle	r3, #1
   for (;j<end;j++)
 800b36c:	42aa      	cmp	r2, r5
      fine_priority[j] = ebits[j]<1;
 800b36e:	f844 3f04 	str.w	r3, [r4, #4]!
   for (;j<end;j++)
 800b372:	d1ef      	bne.n	800b354 <clt_compute_allocation+0xa74>
   codedBands = interp_bits2pulses(m, start, end, skip_start, bits1, bits2, thresh, cap,
         total, balance, skip_rsv, intensity, intensity_rsv, dual_stereo, dual_stereo_rsv,
         pulses, ebits, fine_priority, C, LM, ec, encode, prev, signalBandwidth);
   RESTORE_STACK;
   return codedBands;
}
 800b374:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b376:	3774      	adds	r7, #116	; 0x74
 800b378:	46bd      	mov	sp, r7
 800b37a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      t = EC_ILOG(d&-d);
 800b37e:	4259      	negs	r1, r3
 800b380:	4019      	ands	r1, r3
 800b382:	fab1 f181 	clz	r1, r1
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800b386:	4e8e      	ldr	r6, [pc, #568]	; (800b5c0 <clt_compute_allocation+0xce0>)
      t = EC_ILOG(d&-d);
 800b388:	f1c1 0120 	rsb	r1, r1, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800b38c:	fa23 f001 	lsr.w	r0, r3, r1
 800b390:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 800b394:	3901      	subs	r1, #1
 800b396:	fa2c f101 	lsr.w	r1, ip, r1
 800b39a:	fba1 0100 	umull	r0, r1, r1, r0
      return q+(n-q*d >= d);
 800b39e:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
 800b3a2:	fb03 c011 	mls	r0, r3, r1, ip
 800b3a6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800b3a8:	4283      	cmp	r3, r0
 800b3aa:	bf98      	it	ls
 800b3ac:	3101      	addls	r1, #1
 800b3ae:	e61f      	b.n	800aff0 <clt_compute_allocation+0x710>
            if (codedBands<=start+2 || (band_bits > (depth_threshold*band_width<<LM<<BITRES)>>4 && j<=signalBandwidth))
 800b3b0:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 800b3b2:	6d3e      	ldr	r6, [r7, #80]	; 0x50
 800b3b4:	3002      	adds	r0, #2
 800b3b6:	42b0      	cmp	r0, r6
               depth_threshold = 0;
 800b3b8:	f04f 0100 	mov.w	r1, #0
            if (codedBands<=start+2 || (band_bits > (depth_threshold*band_width<<LM<<BITRES)>>4 && j<=signalBandwidth))
 800b3bc:	f6ff ae4c 	blt.w	800b058 <clt_compute_allocation+0x778>
               ec_enc_bit_logp(ec, 1, 1);
 800b3c0:	2201      	movs	r2, #1
 800b3c2:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
 800b3c6:	4611      	mov	r1, r2
 800b3c8:	f8d7 904c 	ldr.w	r9, [r7, #76]	; 0x4c
 800b3cc:	f7fd fb08 	bl	80089e0 <ec_enc_bit_logp>
   if (intensity_rsv > 0)
 800b3d0:	465b      	mov	r3, fp
 800b3d2:	2b00      	cmp	r3, #0
 800b3d4:	d03f      	beq.n	800b456 <clt_compute_allocation+0xb76>
         *intensity = IMIN(*intensity, codedBands);
 800b3d6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
         ec_enc_uint(ec, *intensity-start, codedBands+1-start);
 800b3da:	6eb8      	ldr	r0, [r7, #104]	; 0x68
         *intensity = IMIN(*intensity, codedBands);
 800b3dc:	6819      	ldr	r1, [r3, #0]
         ec_enc_uint(ec, *intensity-start, codedBands+1-start);
 800b3de:	6d3b      	ldr	r3, [r7, #80]	; 0x50
         *intensity = IMIN(*intensity, codedBands);
 800b3e0:	f8d7 40a0 	ldr.w	r4, [r7, #160]	; 0xa0
 800b3e4:	4299      	cmp	r1, r3
 800b3e6:	bfa8      	it	ge
 800b3e8:	4619      	movge	r1, r3
         ec_enc_uint(ec, *intensity-start, codedBands+1-start);
 800b3ea:	1c5a      	adds	r2, r3, #1
 800b3ec:	1a12      	subs	r2, r2, r0
         *intensity = IMIN(*intensity, codedBands);
 800b3ee:	6021      	str	r1, [r4, #0]
         ec_enc_uint(ec, *intensity-start, codedBands+1-start);
 800b3f0:	1a09      	subs	r1, r1, r0
 800b3f2:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
 800b3f6:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b3f8:	f7fd fb5e 	bl	8008ab8 <ec_enc_uint>
 800b3fc:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800b400:	46c2      	mov	sl, r8
 800b402:	6818      	ldr	r0, [r3, #0]
   if (*intensity <= start)
 800b404:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800b406:	4283      	cmp	r3, r0
 800b408:	f6bf ae86 	bge.w	800b118 <clt_compute_allocation+0x838>
   if (dual_stereo_rsv > 0)
 800b40c:	693b      	ldr	r3, [r7, #16]
 800b40e:	2b00      	cmp	r3, #0
 800b410:	f43f ae86 	beq.w	800b120 <clt_compute_allocation+0x840>
      if (encode)
 800b414:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800b418:	2b00      	cmp	r3, #0
 800b41a:	f000 80b3 	beq.w	800b584 <clt_compute_allocation+0xca4>
         ec_enc_bit_logp(ec, *dual_stereo, 1);
 800b41e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800b422:	2201      	movs	r2, #1
 800b424:	6819      	ldr	r1, [r3, #0]
 800b426:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
 800b42a:	f7fd fad9 	bl	80089e0 <ec_enc_bit_logp>
 800b42e:	e67b      	b.n	800b128 <clt_compute_allocation+0x848>
         } else if (ec_dec_bit_logp(ec, 1)) {
 800b430:	2101      	movs	r1, #1
 800b432:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
 800b436:	f8c7 a038 	str.w	sl, [r7, #56]	; 0x38
 800b43a:	f7fd f855 	bl	80084e8 <ec_dec_bit_logp>
 800b43e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b440:	2800      	cmp	r0, #0
 800b442:	f43f ae1f 	beq.w	800b084 <clt_compute_allocation+0x7a4>
 800b446:	465b      	mov	r3, fp
 800b448:	f8d7 904c 	ldr.w	r9, [r7, #76]	; 0x4c
   if (intensity_rsv > 0)
 800b44c:	b11b      	cbz	r3, 800b456 <clt_compute_allocation+0xb76>
 800b44e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b450:	46c2      	mov	sl, r8
 800b452:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b454:	e650      	b.n	800b0f8 <clt_compute_allocation+0x818>
 800b456:	46c2      	mov	sl, r8
 800b458:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b45a:	62fb      	str	r3, [r7, #44]	; 0x2c
      *intensity = 0;
 800b45c:	2300      	movs	r3, #0
 800b45e:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 800b462:	4618      	mov	r0, r3
 800b464:	6013      	str	r3, [r2, #0]
 800b466:	e653      	b.n	800b110 <clt_compute_allocation+0x830>
      if(excess > 0)
 800b468:	4692      	mov	sl, r2
 800b46a:	e74e      	b.n	800b30a <clt_compute_allocation+0xa2a>
         excess = MAX32(0,bit-(C<<BITRES));
 800b46c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800b46e:	1ac2      	subs	r2, r0, r3
         ebits[j] = 0;
 800b470:	2300      	movs	r3, #0
         excess = MAX32(0,bit-(C<<BITRES));
 800b472:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
         bits[j] = bit-excess;
 800b476:	1a80      	subs	r0, r0, r2
 800b478:	6020      	str	r0, [r4, #0]
         ebits[j] = 0;
 800b47a:	602b      	str	r3, [r5, #0]
         fine_priority[j] = 1;
 800b47c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800b480:	4618      	mov	r0, r3
 800b482:	2301      	movs	r3, #1
 800b484:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
 800b488:	e721      	b.n	800b2ce <clt_compute_allocation+0x9ee>
      t = EC_ILOG(d&-d);
 800b48a:	4270      	negs	r0, r6
 800b48c:	4030      	ands	r0, r6
 800b48e:	fab0 f080 	clz	r0, r0
 800b492:	f1c0 0020 	rsb	r0, r0, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800b496:	fa26 f800 	lsr.w	r8, r6, r0
 800b49a:	66b8      	str	r0, [r7, #104]	; 0x68
 800b49c:	4848      	ldr	r0, [pc, #288]	; (800b5c0 <clt_compute_allocation+0xce0>)
 800b49e:	f850 9028 	ldr.w	r9, [r0, r8, lsl #2]
 800b4a2:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 800b4a4:	f100 38ff 	add.w	r8, r0, #4294967295
 800b4a8:	fa23 f808 	lsr.w	r8, r3, r8
 800b4ac:	fba8 8909 	umull	r8, r9, r8, r9
      return q+(n-q*d >= d);
 800b4b0:	fb06 3319 	mls	r3, r6, r9, r3
 800b4b4:	429e      	cmp	r6, r3
 800b4b6:	bf8c      	ite	hi
 800b4b8:	464b      	movhi	r3, r9
 800b4ba:	f109 0301 	addls.w	r3, r9, #1
 800b4be:	e6e2      	b.n	800b286 <clt_compute_allocation+0x9a6>
         else if (bits[j] + offset < den*3<<BITRES)
 800b4c0:	44b0      	add	r8, r6
 800b4c2:	ebb3 0fc8 	cmp.w	r3, r8, lsl #3
            offset += NClogN>>3;
 800b4c6:	bfbc      	itt	lt
 800b4c8:	eb0c 0ce9 	addlt.w	ip, ip, r9, asr #3
 800b4cc:	eb00 030c 	addlt.w	r3, r0, ip
 800b4d0:	e6cf      	b.n	800b272 <clt_compute_allocation+0x992>
         den=(C*N+ ((C==2 && N>2 && !*dual_stereo && j<*intensity) ? 1 : 0));
 800b4d2:	f1b8 0f02 	cmp.w	r8, #2
 800b4d6:	d014      	beq.n	800b502 <clt_compute_allocation+0xc22>
 800b4d8:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800b4dc:	681b      	ldr	r3, [r3, #0]
 800b4de:	b92b      	cbnz	r3, 800b4ec <clt_compute_allocation+0xc0c>
 800b4e0:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800b4e4:	681b      	ldr	r3, [r3, #0]
 800b4e6:	428b      	cmp	r3, r1
 800b4e8:	dd00      	ble.n	800b4ec <clt_compute_allocation+0xc0c>
 800b4ea:	3601      	adds	r6, #1
         offset = (NClogN>>1)-den*FINE_OFFSET;
 800b4ec:	f06f 0314 	mvn.w	r3, #20
         NClogN = den*(m->logN[j] + logM);
 800b4f0:	fb09 f906 	mul.w	r9, r9, r6
         offset = (NClogN>>1)-den*FINE_OFFSET;
 800b4f4:	fb03 fc06 	mul.w	ip, r3, r6
 800b4f8:	00f3      	lsls	r3, r6, #3
 800b4fa:	66fb      	str	r3, [r7, #108]	; 0x6c
 800b4fc:	eb0c 0c69 	add.w	ip, ip, r9, asr #1
 800b500:	e6ab      	b.n	800b25a <clt_compute_allocation+0x97a>
 800b502:	2320      	movs	r3, #32
         NClogN = den*(m->logN[j] + logM);
 800b504:	ea4f 0989 	mov.w	r9, r9, lsl #2
         offset = (NClogN>>1)-den*FINE_OFFSET;
 800b508:	ea4f 0c69 	mov.w	ip, r9, asr #1
 800b50c:	f1ac 0c54 	sub.w	ip, ip, #84	; 0x54
 800b510:	66fb      	str	r3, [r7, #108]	; 0x6c
            offset += den<<BITRES>>2;
 800b512:	eb0c 0ca3 	add.w	ip, ip, r3, asr #2
 800b516:	e6a0      	b.n	800b25a <clt_compute_allocation+0x97a>
      t = EC_ILOG(d&-d);
 800b518:	424b      	negs	r3, r1
 800b51a:	400b      	ands	r3, r1
 800b51c:	fab3 f383 	clz	r3, r3
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800b520:	4a27      	ldr	r2, [pc, #156]	; (800b5c0 <clt_compute_allocation+0xce0>)
      t = EC_ILOG(d&-d);
 800b522:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800b526:	fa21 f003 	lsr.w	r0, r1, r3
 800b52a:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 800b52e:	3b01      	subs	r3, #1
 800b530:	fa25 f303 	lsr.w	r3, r5, r3
 800b534:	fba3 2302 	umull	r2, r3, r3, r2
      return q+(n-q*d >= d);
 800b538:	fb01 5c13 	mls	ip, r1, r3, r5
 800b53c:	4561      	cmp	r1, ip
 800b53e:	bf8c      	ite	hi
 800b540:	469c      	movhi	ip, r3
 800b542:	f103 0c01 	addls.w	ip, r3, #1
   for (j=start;j<codedBands;j++)
 800b546:	6ebb      	ldr	r3, [r7, #104]	; 0x68
   left -= (m->eBands[codedBands]-m->eBands[start])*percoeff;
 800b548:	fb0c 5511 	mls	r5, ip, r1, r5
   for (j=start;j<codedBands;j++)
 800b54c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800b54e:	428b      	cmp	r3, r1
 800b550:	f6ff ae03 	blt.w	800b15a <clt_compute_allocation+0x87a>
   balance = 0;
 800b554:	f04f 0a00 	mov.w	sl, #0
 800b558:	e6e1      	b.n	800b31e <clt_compute_allocation+0xa3e>
      intensity_rsv = LOG2_FRAC_TABLE[end-start];
 800b55a:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 800b55c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b55e:	4a19      	ldr	r2, [pc, #100]	; (800b5c4 <clt_compute_allocation+0xce4>)
 800b560:	1a5b      	subs	r3, r3, r1
 800b562:	5cd3      	ldrb	r3, [r2, r3]
      if (intensity_rsv>total)
 800b564:	6df9      	ldr	r1, [r7, #92]	; 0x5c
      intensity_rsv = LOG2_FRAC_TABLE[end-start];
 800b566:	617b      	str	r3, [r7, #20]
      if (intensity_rsv>total)
 800b568:	428b      	cmp	r3, r1
 800b56a:	f73f a9d5 	bgt.w	800a918 <clt_compute_allocation+0x38>
         total -= intensity_rsv;
 800b56e:	1acb      	subs	r3, r1, r3
         dual_stereo_rsv = total>=1<<BITRES ? 1<<BITRES : 0;
 800b570:	2b07      	cmp	r3, #7
         total -= intensity_rsv;
 800b572:	65fb      	str	r3, [r7, #92]	; 0x5c
 800b574:	bfc5      	ittet	gt
 800b576:	3b08      	subgt	r3, #8
 800b578:	65fb      	strgt	r3, [r7, #92]	; 0x5c
         dual_stereo_rsv = total>=1<<BITRES ? 1<<BITRES : 0;
 800b57a:	2300      	movle	r3, #0
 800b57c:	2308      	movgt	r3, #8
 800b57e:	613b      	str	r3, [r7, #16]
 800b580:	f7ff b9cd 	b.w	800a91e <clt_compute_allocation+0x3e>
         *dual_stereo = ec_dec_bit_logp(ec, 1);
 800b584:	2101      	movs	r1, #1
 800b586:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
 800b58a:	f7fc ffad 	bl	80084e8 <ec_dec_bit_logp>
 800b58e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800b592:	6018      	str	r0, [r3, #0]
 800b594:	e5c8      	b.n	800b128 <clt_compute_allocation+0x848>
 800b596:	005b      	lsls	r3, r3, #1
 800b598:	64bb      	str	r3, [r7, #72]	; 0x48
 800b59a:	1e53      	subs	r3, r2, #1
 800b59c:	643b      	str	r3, [r7, #64]	; 0x40
 800b59e:	4619      	mov	r1, r3
 800b5a0:	f7ff ba96 	b.w	800aad0 <clt_compute_allocation+0x1f0>
      if (encode)
 800b5a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5a6:	46d0      	mov	r8, sl
 800b5a8:	653b      	str	r3, [r7, #80]	; 0x50
 800b5aa:	e714      	b.n	800b3d6 <clt_compute_allocation+0xaf6>
 800b5ac:	461a      	mov	r2, r3
 800b5ae:	f7ff ba52 	b.w	800aa56 <clt_compute_allocation+0x176>
      if (j<=skip_start)
 800b5b2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b5b4:	62fb      	str	r3, [r7, #44]	; 0x2c
 800b5b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5b8:	f103 0a02 	add.w	sl, r3, #2
 800b5bc:	e58f      	b.n	800b0de <clt_compute_allocation+0x7fe>
 800b5be:	bf00      	nop
 800b5c0:	0801649c 	.word	0x0801649c
 800b5c4:	08016840 	.word	0x08016840

0800b5c8 <exp_rotation1>:
#include "mips/vq_mipsr1.h"
#endif

#ifndef OVERRIDE_vq_exp_rotation1
static void exp_rotation1(celt_norm *X, int len, int stride, opus_val16 c, opus_val16 s)
{
 800b5c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800b5cc:	f9bd 5020 	ldrsh.w	r5, [sp, #32]
   int i;
   opus_val16 ms;
   celt_norm *Xptr;
   Xptr = X;
   ms = NEG16(s);
   for (i=0;i<len-stride;i++)
 800b5d0:	1a89      	subs	r1, r1, r2
   ms = NEG16(s);
 800b5d2:	426e      	negs	r6, r5
   for (i=0;i<len-stride;i++)
 800b5d4:	2900      	cmp	r1, #0
   ms = NEG16(s);
 800b5d6:	b236      	sxth	r6, r6
   for (i=0;i<len-stride;i++)
 800b5d8:	dd21      	ble.n	800b61e <exp_rotation1+0x56>
 800b5da:	eb00 0e42 	add.w	lr, r0, r2, lsl #1
 800b5de:	eb00 0841 	add.w	r8, r0, r1, lsl #1
 800b5e2:	f1ae 0e02 	sub.w	lr, lr, #2
 800b5e6:	f1a8 0802 	sub.w	r8, r8, #2
 800b5ea:	f1a0 0c02 	sub.w	ip, r0, #2
   {
      celt_norm x1, x2;
      x1 = Xptr[0];
 800b5ee:	f93c 4f02 	ldrsh.w	r4, [ip, #2]!
      x2 = Xptr[stride];
 800b5f2:	f93e 7f02 	ldrsh.w	r7, [lr, #2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b5f6:	fb04 fa05 	mul.w	sl, r4, r5
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b5fa:	fb07 f906 	mul.w	r9, r7, r6
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b5fe:	fb07 a703 	mla	r7, r7, r3, sl
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b602:	fb04 9403 	mla	r4, r4, r3, r9
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b606:	f507 4780 	add.w	r7, r7, #16384	; 0x4000
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b60a:	f504 4480 	add.w	r4, r4, #16384	; 0x4000
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b60e:	13ff      	asrs	r7, r7, #15
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b610:	13e4      	asrs	r4, r4, #15
   for (i=0;i<len-stride;i++)
 800b612:	45e0      	cmp	r8, ip
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b614:	f8ae 7000 	strh.w	r7, [lr]
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b618:	f8ac 4000 	strh.w	r4, [ip]
   for (i=0;i<len-stride;i++)
 800b61c:	d1e7      	bne.n	800b5ee <exp_rotation1+0x26>
   }
   Xptr = &X[len-2*stride-1];
 800b61e:	1a89      	subs	r1, r1, r2
 800b620:	f101 4400 	add.w	r4, r1, #2147483648	; 0x80000000
 800b624:	3c01      	subs	r4, #1
   for (i=len-2*stride-1;i>=0;i--)
 800b626:	2900      	cmp	r1, #0
   Xptr = &X[len-2*stride-1];
 800b628:	eb00 0044 	add.w	r0, r0, r4, lsl #1
   for (i=len-2*stride-1;i>=0;i--)
 800b62c:	dd1d      	ble.n	800b66a <exp_rotation1+0xa2>
 800b62e:	0049      	lsls	r1, r1, #1
 800b630:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 800b634:	f1c1 0702 	rsb	r7, r1, #2
 800b638:	4407      	add	r7, r0
 800b63a:	1c94      	adds	r4, r2, #2
 800b63c:	3002      	adds	r0, #2
   {
      celt_norm x1, x2;
      x1 = Xptr[0];
 800b63e:	f930 2d02 	ldrsh.w	r2, [r0, #-2]!
      x2 = Xptr[stride];
 800b642:	f934 1d02 	ldrsh.w	r1, [r4, #-2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b646:	fb02 fe05 	mul.w	lr, r2, r5
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b64a:	fb01 fc06 	mul.w	ip, r1, r6
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b64e:	fb01 e103 	mla	r1, r1, r3, lr
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b652:	fb02 c203 	mla	r2, r2, r3, ip
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b656:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b65a:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b65e:	13c9      	asrs	r1, r1, #15
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b660:	13d2      	asrs	r2, r2, #15
   for (i=len-2*stride-1;i>=0;i--)
 800b662:	42b8      	cmp	r0, r7
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b664:	8021      	strh	r1, [r4, #0]
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b666:	8002      	strh	r2, [r0, #0]
   for (i=len-2*stride-1;i>=0;i--)
 800b668:	d1e9      	bne.n	800b63e <exp_rotation1+0x76>
   }
}
 800b66a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b66e:	bf00      	nop

0800b670 <exp_rotation.part.2.constprop.3>:
#endif /* OVERRIDE_vq_exp_rotation1 */

void exp_rotation(celt_norm *X, int len, int dir, int stride, int K, int spread)
 800b670:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b674:	460c      	mov	r4, r1
 800b676:	b089      	sub	sp, #36	; 0x24
 800b678:	9912      	ldr	r1, [sp, #72]	; 0x48
   int stride2=0;
   int factor;

   if (2*K>=len || spread==SPREAD_NONE)
      return;
   factor = SPREAD_FACTOR[spread-1];
 800b67a:	4d61      	ldr	r5, [pc, #388]	; (800b800 <exp_rotation.part.2.constprop.3+0x190>)
 800b67c:	3901      	subs	r1, #1

   gain = celt_div((opus_val32)MULT16_16(Q15_ONE,len),(opus_val32)(len+factor*K));
 800b67e:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
void exp_rotation(celt_norm *X, int len, int dir, int stride, int K, int spread)
 800b682:	4680      	mov	r8, r0
   gain = celt_div((opus_val32)MULT16_16(Q15_ONE,len),(opus_val32)(len+factor*K));
 800b684:	fb01 4003 	mla	r0, r1, r3, r4
void exp_rotation(celt_norm *X, int len, int dir, int stride, int K, int spread)
 800b688:	4693      	mov	fp, r2
   gain = celt_div((opus_val32)MULT16_16(Q15_ONE,len),(opus_val32)(len+factor*K));
 800b68a:	f7fe f9d1 	bl	8009a30 <celt_rcp>
 800b68e:	b223      	sxth	r3, r4
 800b690:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
 800b694:	fb83 0100 	smull	r0, r1, r3, r0
 800b698:	0fc3      	lsrs	r3, r0, #31
 800b69a:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
   theta = HALF16(MULT16_16_Q15(gain,gain));
 800b69e:	fb13 f303 	smulbb	r3, r3, r3
 800b6a2:	141e      	asrs	r6, r3, #16

   c = celt_cos_norm(EXTEND32(theta));
 800b6a4:	4630      	mov	r0, r6
 800b6a6:	f7fe f94b 	bl	8009940 <celt_cos_norm>
 800b6aa:	4605      	mov	r5, r0
   s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */
 800b6ac:	f5c6 40ff 	rsb	r0, r6, #32640	; 0x7f80
 800b6b0:	307f      	adds	r0, #127	; 0x7f
 800b6b2:	f7fe f945 	bl	8009940 <celt_cos_norm>

   if (len>=8*stride)
 800b6b6:	ebb4 0fcb 	cmp.w	r4, fp, lsl #3
   s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */
 800b6ba:	4607      	mov	r7, r0
   if (len>=8*stride)
 800b6bc:	f2c0 8081 	blt.w	800b7c2 <exp_rotation.part.2.constprop.3+0x152>
   {
      stride2 = 1;
      /* This is just a simple (equivalent) way of computing sqrt(len/stride) with rounding.
         It's basically incrementing long as (stride2+0.5)^2 < len/stride. */
      while ((stride2*stride2+stride2)*stride + (stride>>2) < len)
 800b6c0:	ea4f 01ab 	mov.w	r1, fp, asr #2
      stride2 = 1;
 800b6c4:	f04f 0901 	mov.w	r9, #1
 800b6c8:	e000      	b.n	800b6cc <exp_rotation.part.2.constprop.3+0x5c>
         stride2++;
 800b6ca:	4691      	mov	r9, r2
      while ((stride2*stride2+stride2)*stride + (stride>>2) < len)
 800b6cc:	f109 0201 	add.w	r2, r9, #1
 800b6d0:	fb02 f309 	mul.w	r3, r2, r9
 800b6d4:	fb0b 1303 	mla	r3, fp, r3, r1
 800b6d8:	429c      	cmp	r4, r3
 800b6da:	dcf6      	bgt.n	800b6ca <exp_rotation.part.2.constprop.3+0x5a>
   if (d>256)
 800b6dc:	f5bb 7f80 	cmp.w	fp, #256	; 0x100
 800b6e0:	d974      	bls.n	800b7cc <exp_rotation.part.2.constprop.3+0x15c>
      return n/d;
 800b6e2:	fbb4 f3fb 	udiv	r3, r4, fp
 800b6e6:	9307      	str	r3, [sp, #28]
   }
   /*NOTE: As a minor optimization, we could be passing around log2(B), not B, for both this and for
      extract_collapse_mask().*/
   len = celt_udiv(len, stride);
   for (i=0;i<stride;i++)
 800b6e8:	f1bb 0f00 	cmp.w	fp, #0
 800b6ec:	dd5e      	ble.n	800b7ac <exp_rotation.part.2.constprop.3+0x13c>
 800b6ee:	9a07      	ldr	r2, [sp, #28]
 800b6f0:	f8cd b014 	str.w	fp, [sp, #20]
 800b6f4:	ebc2 73c2 	rsb	r3, r2, r2, lsl #31
 800b6f8:	005b      	lsls	r3, r3, #1
 800b6fa:	9306      	str	r3, [sp, #24]
 800b6fc:	3302      	adds	r3, #2
 800b6fe:	9304      	str	r3, [sp, #16]
   for (i=0;i<len-stride;i++)
 800b700:	1e53      	subs	r3, r2, #1
 800b702:	9302      	str	r3, [sp, #8]
   for (i=len-2*stride-1;i>=0;i--)
 800b704:	1ed3      	subs	r3, r2, #3
   for (i=0;i<stride;i++)
 800b706:	f04f 0a00 	mov.w	sl, #0
 800b70a:	469b      	mov	fp, r3
 800b70c:	eb08 0842 	add.w	r8, r8, r2, lsl #1
 800b710:	427e      	negs	r6, r7
 800b712:	0052      	lsls	r2, r2, #1
 800b714:	f1a8 0802 	sub.w	r8, r8, #2
 800b718:	b236      	sxth	r6, r6
 800b71a:	9203      	str	r2, [sp, #12]
 800b71c:	9b04      	ldr	r3, [sp, #16]
 800b71e:	eb03 0408 	add.w	r4, r3, r8
   {
      if (dir < 0)
      {
         if (stride2)
 800b722:	f1b9 0f00 	cmp.w	r9, #0
 800b726:	d144      	bne.n	800b7b2 <exp_rotation.part.2.constprop.3+0x142>
   for (i=0;i<len-stride;i++)
 800b728:	9b02      	ldr	r3, [sp, #8]
 800b72a:	2b00      	cmp	r3, #0
 800b72c:	dd19      	ble.n	800b762 <exp_rotation.part.2.constprop.3+0xf2>
 800b72e:	9b06      	ldr	r3, [sp, #24]
 800b730:	4443      	add	r3, r8
 800b732:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
      x2 = Xptr[stride];
 800b736:	f934 1f02 	ldrsh.w	r1, [r4, #2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b73a:	fb03 f007 	mul.w	r0, r3, r7
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b73e:	fb01 f206 	mul.w	r2, r1, r6
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b742:	fb01 0105 	mla	r1, r1, r5, r0
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b746:	fb03 2205 	mla	r2, r3, r5, r2
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b74a:	f501 4380 	add.w	r3, r1, #16384	; 0x4000
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b74e:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
 800b752:	13d2      	asrs	r2, r2, #15
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b754:	f343 33cf 	sbfx	r3, r3, #15, #16
   for (i=0;i<len-stride;i++)
 800b758:	4544      	cmp	r4, r8
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b75a:	f824 2c02 	strh.w	r2, [r4, #-2]
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b75e:	8023      	strh	r3, [r4, #0]
   for (i=0;i<len-stride;i++)
 800b760:	d1e9      	bne.n	800b736 <exp_rotation.part.2.constprop.3+0xc6>
   for (i=len-2*stride-1;i>=0;i--)
 800b762:	f1bb 0f00 	cmp.w	fp, #0
 800b766:	db1a      	blt.n	800b79e <exp_rotation.part.2.constprop.3+0x12e>
 800b768:	4641      	mov	r1, r8
 800b76a:	4658      	mov	r0, fp
 800b76c:	f931 3d02 	ldrsh.w	r3, [r1, #-2]!
      x1 = Xptr[0];
 800b770:	f931 4c02 	ldrsh.w	r4, [r1, #-2]
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b774:	fb03 fc06 	mul.w	ip, r3, r6
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b778:	fb04 f207 	mul.w	r2, r4, r7
 800b77c:	fb03 2205 	mla	r2, r3, r5, r2
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b780:	fb04 c405 	mla	r4, r4, r5, ip
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b784:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
 800b788:	13d2      	asrs	r2, r2, #15
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b78a:	f504 4480 	add.w	r4, r4, #16384	; 0x4000
   for (i=len-2*stride-1;i>=0;i--)
 800b78e:	3801      	subs	r0, #1
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800b790:	800a      	strh	r2, [r1, #0]
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b792:	f344 33cf 	sbfx	r3, r4, #15, #16
   for (i=len-2*stride-1;i>=0;i--)
 800b796:	1c42      	adds	r2, r0, #1
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800b798:	f821 3d02 	strh.w	r3, [r1, #-2]!
   for (i=len-2*stride-1;i>=0;i--)
 800b79c:	d1e8      	bne.n	800b770 <exp_rotation.part.2.constprop.3+0x100>
 800b79e:	9b03      	ldr	r3, [sp, #12]
   for (i=0;i<stride;i++)
 800b7a0:	f10a 0a01 	add.w	sl, sl, #1
 800b7a4:	4498      	add	r8, r3
 800b7a6:	9b05      	ldr	r3, [sp, #20]
 800b7a8:	4553      	cmp	r3, sl
 800b7aa:	d1b7      	bne.n	800b71c <exp_rotation.part.2.constprop.3+0xac>
         exp_rotation1(X+i*len, len, 1, c, -s);
         if (stride2)
            exp_rotation1(X+i*len, len, stride2, s, -c);
      }
   }
}
 800b7ac:	b009      	add	sp, #36	; 0x24
 800b7ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            exp_rotation1(X+i*len, len, stride2, s, c);
 800b7b2:	9500      	str	r5, [sp, #0]
 800b7b4:	463b      	mov	r3, r7
 800b7b6:	464a      	mov	r2, r9
 800b7b8:	9907      	ldr	r1, [sp, #28]
 800b7ba:	4620      	mov	r0, r4
 800b7bc:	f7ff ff04 	bl	800b5c8 <exp_rotation1>
 800b7c0:	e7b2      	b.n	800b728 <exp_rotation.part.2.constprop.3+0xb8>
   if (d>256)
 800b7c2:	f5bb 7f80 	cmp.w	fp, #256	; 0x100
   int stride2=0;
 800b7c6:	f04f 0900 	mov.w	r9, #0
 800b7ca:	d88a      	bhi.n	800b6e2 <exp_rotation.part.2.constprop.3+0x72>
      t = EC_ILOG(d&-d);
 800b7cc:	f1cb 0300 	rsb	r3, fp, #0
 800b7d0:	ea03 030b 	and.w	r3, r3, fp
 800b7d4:	fab3 f383 	clz	r3, r3
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800b7d8:	490a      	ldr	r1, [pc, #40]	; (800b804 <exp_rotation.part.2.constprop.3+0x194>)
      t = EC_ILOG(d&-d);
 800b7da:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800b7de:	fa2b f003 	lsr.w	r0, fp, r3
 800b7e2:	1e5a      	subs	r2, r3, #1
 800b7e4:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 800b7e8:	fa24 f202 	lsr.w	r2, r4, r2
 800b7ec:	fba2 2303 	umull	r2, r3, r2, r3
      return q+(n-q*d >= d);
 800b7f0:	fb0b 4413 	mls	r4, fp, r3, r4
 800b7f4:	45a3      	cmp	fp, r4
 800b7f6:	bf98      	it	ls
 800b7f8:	3301      	addls	r3, #1
 800b7fa:	9307      	str	r3, [sp, #28]
 800b7fc:	e774      	b.n	800b6e8 <exp_rotation.part.2.constprop.3+0x78>
 800b7fe:	bf00      	nop
 800b800:	08016858 	.word	0x08016858
 800b804:	0801649c 	.word	0x0801649c

0800b808 <op_pvq_search_c>:
   } while (++i<B);
   return collapse_mask;
}

opus_val16 op_pvq_search_c(celt_norm *X, int *iy, int K, int N, int arch)
{
 800b808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b80c:	b08b      	sub	sp, #44	; 0x2c
 800b80e:	4604      	mov	r4, r0
 800b810:	af00      	add	r7, sp, #0
 800b812:	468c      	mov	ip, r1
 800b814:	6179      	str	r1, [r7, #20]
   ALLOC(y, N, celt_norm);
   ALLOC(signx, N, int);

   /* Get rid of the sign */
   sum = 0;
   j=0; do {
 800b816:	2100      	movs	r1, #0
 800b818:	3c02      	subs	r4, #2
{
 800b81a:	4691      	mov	r9, r2
      signx[j] = X[j]<0;
      /* OPT: Make sure the compiler doesn't use a branch on ABS16(). */
      X[j] = ABS16(X[j]);
      iy[j] = 0;
 800b81c:	468e      	mov	lr, r1
   ALLOC(signx, N, int);
 800b81e:	4622      	mov	r2, r4
   ALLOC(y, N, celt_norm);
 800b820:	005d      	lsls	r5, r3, #1
{
 800b822:	469b      	mov	fp, r3
 800b824:	61b8      	str	r0, [r7, #24]
   ALLOC(signx, N, int);
 800b826:	009b      	lsls	r3, r3, #2
   ALLOC(y, N, celt_norm);
 800b828:	f105 0008 	add.w	r0, r5, #8
 800b82c:	f020 0007 	bic.w	r0, r0, #7
   ALLOC(signx, N, int);
 800b830:	330a      	adds	r3, #10
   ALLOC(y, N, celt_norm);
 800b832:	ebad 0d00 	sub.w	sp, sp, r0
   ALLOC(signx, N, int);
 800b836:	f023 0307 	bic.w	r3, r3, #7
   ALLOC(y, N, celt_norm);
 800b83a:	f8c7 d01c 	str.w	sp, [r7, #28]
   ALLOC(signx, N, int);
 800b83e:	ebad 0d03 	sub.w	sp, sp, r3
 800b842:	f1ad 0604 	sub.w	r6, sp, #4
 800b846:	f1ac 0004 	sub.w	r0, ip, #4
 800b84a:	603e      	str	r6, [r7, #0]
 800b84c:	6078      	str	r0, [r7, #4]
      signx[j] = X[j]<0;
 800b84e:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
      y[j] = 0;
   } while (++j<N);
 800b852:	3101      	adds	r1, #1
      X[j] = ABS16(X[j]);
 800b854:	ea83 7ce3 	eor.w	ip, r3, r3, asr #31
 800b858:	ebac 7ce3 	sub.w	ip, ip, r3, asr #31
   } while (++j<N);
 800b85c:	458b      	cmp	fp, r1
      signx[j] = X[j]<0;
 800b85e:	ea4f 73d3 	mov.w	r3, r3, lsr #31
      X[j] = ABS16(X[j]);
 800b862:	f8a2 c000 	strh.w	ip, [r2]
      signx[j] = X[j]<0;
 800b866:	f846 3f04 	str.w	r3, [r6, #4]!
      iy[j] = 0;
 800b86a:	f840 ef04 	str.w	lr, [r0, #4]!
   } while (++j<N);
 800b86e:	dcee      	bgt.n	800b84e <op_pvq_search_c+0x46>
      y[j] = 0;
 800b870:	f1bb 0f00 	cmp.w	fp, #0
 800b874:	bfcc      	ite	gt
 800b876:	462a      	movgt	r2, r5
 800b878:	2202      	movle	r2, #2
 800b87a:	2100      	movs	r1, #0
 800b87c:	69f8      	ldr	r0, [r7, #28]
 800b87e:	f008 fc53 	bl	8014128 <memset>
   xy = yy = 0;

   pulsesLeft = K;

   /* Do a pre-search by projecting on the pyramid */
   if (K > (N>>1))
 800b882:	ebb9 0f6b 	cmp.w	r9, fp, asr #1
 800b886:	f340 80ad 	ble.w	800b9e4 <op_pvq_search_c+0x1dc>
   sum = 0;
 800b88a:	2000      	movs	r0, #0
 800b88c:	4622      	mov	r2, r4
   {
      opus_val16 rcp;
      j=0; do {
 800b88e:	4603      	mov	r3, r0
         sum += X[j];
 800b890:	f932 1f02 	ldrsh.w	r1, [r2, #2]!
      }  while (++j<N);
 800b894:	3301      	adds	r3, #1
 800b896:	459b      	cmp	fp, r3
         sum += X[j];
 800b898:	4408      	add	r0, r1
      }  while (++j<N);
 800b89a:	dcf9      	bgt.n	800b890 <op_pvq_search_c+0x88>

      /* If X is too small, just replace it with a pulse at 0 */
#ifdef FIXED_POINT
      if (sum <= K)
 800b89c:	4581      	cmp	r9, r0
 800b89e:	f280 80b4 	bge.w	800ba0a <op_pvq_search_c+0x202>
            X[j]=0;
         while (++j<N);
         sum = QCONST16(1.f,14);
      }
#ifdef FIXED_POINT
      rcp = EXTRACT16(MULT16_32_Q16(K, celt_rcp(sum)));
 800b8a2:	f7fe f8c5 	bl	8009a30 <celt_rcp>
   xy = yy = 0;
 800b8a6:	2200      	movs	r2, #0
      rcp = EXTRACT16(MULT16_32_Q16(K, celt_rcp(sum)));
 800b8a8:	464d      	mov	r5, r9
   xy = yy = 0;
 800b8aa:	4692      	mov	sl, r2
#else
      /* Using K+e with e < 1 guarantees we cannot get more than K pulses. */
      rcp = EXTRACT16(MULT16_32_Q16(K+0.8f, celt_rcp(sum)));
#endif
      j=0; do {
 800b8ac:	4616      	mov	r6, r2
      : "%r"(b),"r"(SHL32(a,16))
 800b8ae:	ea4f 4309 	mov.w	r3, r9, lsl #16
  __asm__(
 800b8b2:	fb80 c103 	smull	ip, r1, r0, r3
 800b8b6:	69fb      	ldr	r3, [r7, #28]
      rcp = EXTRACT16(MULT16_32_Q16(K, celt_rcp(sum)));
 800b8b8:	f8d7 8004 	ldr.w	r8, [r7, #4]
 800b8bc:	f1a3 0e02 	sub.w	lr, r3, #2
 800b8c0:	b208      	sxth	r0, r1
#ifdef FIXED_POINT
         /* It's really important to round *towards zero* here */
         iy[j] = MULT16_16_Q15(X[j],rcp);
 800b8c2:	f934 cf02 	ldrsh.w	ip, [r4, #2]!
         y[j] = (celt_norm)iy[j];
         yy = MAC16_16(yy, y[j],y[j]);
         xy = MAC16_16(xy, X[j],y[j]);
         y[j] *= 2;
         pulsesLeft -= iy[j];
      }  while (++j<N);
 800b8c6:	3601      	adds	r6, #1
         iy[j] = MULT16_16_Q15(X[j],rcp);
 800b8c8:	fb0c f300 	mul.w	r3, ip, r0
 800b8cc:	13db      	asrs	r3, r3, #15
         yy = MAC16_16(yy, y[j],y[j]);
 800b8ce:	b299      	uxth	r1, r3
 800b8d0:	fb11 2201 	smlabb	r2, r1, r1, r2
      }  while (++j<N);
 800b8d4:	45b3      	cmp	fp, r6
         y[j] *= 2;
 800b8d6:	ea4f 0141 	mov.w	r1, r1, lsl #1
         iy[j] = MULT16_16_Q15(X[j],rcp);
 800b8da:	f848 3f04 	str.w	r3, [r8, #4]!
         xy = MAC16_16(xy, X[j],y[j]);
 800b8de:	fb1c aa03 	smlabb	sl, ip, r3, sl
         pulsesLeft -= iy[j];
 800b8e2:	eba5 0503 	sub.w	r5, r5, r3
         yy = MAC16_16(yy, y[j],y[j]);
 800b8e6:	b212      	sxth	r2, r2
         y[j] *= 2;
 800b8e8:	f82e 1f02 	strh.w	r1, [lr, #2]!
      }  while (++j<N);
 800b8ec:	dce9      	bgt.n	800b8c2 <op_pvq_search_c+0xba>
   /* This should never happen, but just in case it does (e.g. on silence)
      we fill the first bin with pulses. */
#ifdef FIXED_POINT_DEBUG
   celt_sig_assert(pulsesLeft<=N+3);
#endif
   if (pulsesLeft > N+3)
 800b8ee:	f10b 0303 	add.w	r3, fp, #3
 800b8f2:	429d      	cmp	r5, r3
 800b8f4:	dc7d      	bgt.n	800b9f2 <op_pvq_search_c+0x1ea>
      yy = MAC16_16(yy, tmp, y[0]);
      iy[0] += pulsesLeft;
      pulsesLeft=0;
   }

   for (i=0;i<pulsesLeft;i++)
 800b8f6:	2d00      	cmp	r5, #0
 800b8f8:	dd61      	ble.n	800b9be <op_pvq_search_c+0x1b6>
 800b8fa:	4610      	mov	r0, r2

      /* Calculations for position 0 are out of the loop, in part to reduce
         mispredicted branches (since the if condition is usually false)
         in the loop. */
      /* Temporary sums of the new pulse(s) */
      Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[0])),rshift));
 800b8fc:	69bb      	ldr	r3, [r7, #24]
 800b8fe:	eba9 0905 	sub.w	r9, r9, r5
 800b902:	f9b3 3000 	ldrsh.w	r3, [r3]
 800b906:	3501      	adds	r5, #1
 800b908:	60fb      	str	r3, [r7, #12]
 800b90a:	eb05 0309 	add.w	r3, r5, r9
 800b90e:	60bb      	str	r3, [r7, #8]
 800b910:	f109 0301 	add.w	r3, r9, #1
 800b914:	627b      	str	r3, [r7, #36]	; 0x24
 800b916:	f8c7 b010 	str.w	fp, [r7, #16]
   return EC_ILOG(x)-1;
 800b91a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      /* Approximate score: we maximise Rxy/sqrt(Ryy) (we're guaranteed that
         Rxy is positive because the sign is pre-computed) */
      Rxy = MULT16_16_Q15(Rxy,Rxy);
      best_den = Ryy;
      best_num = Rxy;
      j=1;
 800b91c:	2101      	movs	r1, #1
 800b91e:	e9d7 6206 	ldrd	r6, r2, [r7, #24]
 800b922:	fab3 f883 	clz	r8, r3
      best_id = 0;
 800b926:	f04f 0b00 	mov.w	fp, #0
 800b92a:	4615      	mov	r5, r2
      Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[0])),rshift));
 800b92c:	68fb      	ldr	r3, [r7, #12]
      rshift = 1+celt_ilog2(K-pulsesLeft+i+1);
 800b92e:	f1c8 0820 	rsb	r8, r8, #32
      Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[0])),rshift));
 800b932:	eb0a 0403 	add.w	r4, sl, r3
 800b936:	fa44 f408 	asr.w	r4, r4, r8
      Rxy = MULT16_16_Q15(Rxy,Rxy);
 800b93a:	fb14 f404 	smulbb	r4, r4, r4
      yy = ADD16(yy, 1);
 800b93e:	4408      	add	r0, r1
      Ryy = ADD16(yy, y[0]);
 800b940:	f8b2 9000 	ldrh.w	r9, [r2]
      yy = ADD16(yy, 1);
 800b944:	b280      	uxth	r0, r0
      Ryy = ADD16(yy, y[0]);
 800b946:	4481      	add	r9, r0
 800b948:	f8c7 b020 	str.w	fp, [r7, #32]
 800b94c:	f8d7 b010 	ldr.w	fp, [r7, #16]
      best_num = Rxy;
 800b950:	f344 34cf 	sbfx	r4, r4, #15, #16
      Ryy = ADD16(yy, y[0]);
 800b954:	fa0f f989 	sxth.w	r9, r9
      do {
         /* Temporary sums of the new pulse(s) */
         Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[j])),rshift));
 800b958:	f936 3f02 	ldrsh.w	r3, [r6, #2]!
         /* We're multiplying y[j] by two so we don't have to do it here */
         Ryy = ADD16(yy, y[j]);
 800b95c:	f835 2f02 	ldrh.w	r2, [r5, #2]!
         Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[j])),rshift));
 800b960:	4453      	add	r3, sl
 800b962:	fa43 f308 	asr.w	r3, r3, r8

         /* Approximate score: we maximise Rxy/sqrt(Ryy) (we're guaranteed that
            Rxy is positive because the sign is pre-computed) */
         Rxy = MULT16_16_Q15(Rxy,Rxy);
 800b966:	fb13 f303 	smulbb	r3, r3, r3
         Ryy = ADD16(yy, y[j]);
 800b96a:	4402      	add	r2, r0
         Rxy = MULT16_16_Q15(Rxy,Rxy);
 800b96c:	f343 33cf 	sbfx	r3, r3, #15, #16
         Ryy = ADD16(yy, y[j]);
 800b970:	b212      	sxth	r2, r2
            we can do it without any division */
         /* OPT: It's not clear whether a cmov is faster than a branch here
            since the condition is more often false than true and using
            a cmov introduces data dependencies across iterations. The optimal
            choice may be architecture-dependent. */
         if (opus_unlikely(MULT16_16(best_den, Rxy) > MULT16_16(Ryy, best_num)))
 800b972:	fb03 fc09 	mul.w	ip, r3, r9
 800b976:	fb04 fe02 	mul.w	lr, r4, r2
 800b97a:	45e6      	cmp	lr, ip
 800b97c:	db55      	blt.n	800ba2a <op_pvq_search_c+0x222>
         {
            best_den = Ryy;
            best_num = Rxy;
            best_id = j;
         }
      } while (++j<N);
 800b97e:	3101      	adds	r1, #1
 800b980:	458b      	cmp	fp, r1
 800b982:	dce9      	bgt.n	800b958 <op_pvq_search_c+0x150>

      /* Updating the sums of the new pulse(s) */
      xy = ADD32(xy, EXTEND32(X[best_id]));
      /* We're multiplying y[j] by two so we don't have to do it here */
      yy = ADD16(yy, y[best_id]);
 800b984:	e9d7 5b07 	ldrd	r5, fp, [r7, #28]

      /* Only now that we've made the final choice, update y/iy */
      /* Multiplying y[j] by 2 so we don't have to do it everywhere else */
      y[best_id] += 2;
      iy[best_id]++;
 800b988:	697e      	ldr	r6, [r7, #20]
      xy = ADD32(xy, EXTEND32(X[best_id]));
 800b98a:	69b9      	ldr	r1, [r7, #24]
      iy[best_id]++;
 800b98c:	f856 302b 	ldr.w	r3, [r6, fp, lsl #2]
 800b990:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 800b992:	3301      	adds	r3, #1
      yy = ADD16(yy, y[best_id]);
 800b994:	f835 201b 	ldrh.w	r2, [r5, fp, lsl #1]
      xy = ADD32(xy, EXTEND32(X[best_id]));
 800b998:	f931 101b 	ldrsh.w	r1, [r1, fp, lsl #1]
      iy[best_id]++;
 800b99c:	f846 302b 	str.w	r3, [r6, fp, lsl #2]
   for (i=0;i<pulsesLeft;i++)
 800b9a0:	68bb      	ldr	r3, [r7, #8]
 800b9a2:	3401      	adds	r4, #1
      yy = ADD16(yy, y[best_id]);
 800b9a4:	4410      	add	r0, r2
   for (i=0;i<pulsesLeft;i++)
 800b9a6:	42a3      	cmp	r3, r4
      y[best_id] += 2;
 800b9a8:	f102 0202 	add.w	r2, r2, #2
 800b9ac:	627c      	str	r4, [r7, #36]	; 0x24
      yy = ADD16(yy, y[best_id]);
 800b9ae:	b200      	sxth	r0, r0
      y[best_id] += 2;
 800b9b0:	f825 201b 	strh.w	r2, [r5, fp, lsl #1]
      xy = ADD32(xy, EXTEND32(X[best_id]));
 800b9b4:	448a      	add	sl, r1
   for (i=0;i<pulsesLeft;i++)
 800b9b6:	d1b0      	bne.n	800b91a <op_pvq_search_c+0x112>
 800b9b8:	4602      	mov	r2, r0
 800b9ba:	f8d7 b010 	ldr.w	fp, [r7, #16]
   }

   /* Put the original sign back */
   j=0;
 800b9be:	2400      	movs	r4, #0
 800b9c0:	e9d7 5100 	ldrd	r5, r1, [r7]
   do {
      /*iy[j] = signx[j] ? -iy[j] : iy[j];*/
      /* OPT: The is more likely to be compiled without a branch than the code above
         but has the same performance otherwise. */
      iy[j] = (iy[j]^-signx[j]) + signx[j];
 800b9c4:	f855 0f04 	ldr.w	r0, [r5, #4]!
 800b9c8:	f851 6f04 	ldr.w	r6, [r1, #4]!
 800b9cc:	4243      	negs	r3, r0
 800b9ce:	4073      	eors	r3, r6
   } while (++j<N);
 800b9d0:	3401      	adds	r4, #1
      iy[j] = (iy[j]^-signx[j]) + signx[j];
 800b9d2:	4403      	add	r3, r0
   } while (++j<N);
 800b9d4:	45a3      	cmp	fp, r4
      iy[j] = (iy[j]^-signx[j]) + signx[j];
 800b9d6:	600b      	str	r3, [r1, #0]
   } while (++j<N);
 800b9d8:	dcf4      	bgt.n	800b9c4 <op_pvq_search_c+0x1bc>
   RESTORE_STACK;
   return yy;
}
 800b9da:	4610      	mov	r0, r2
 800b9dc:	372c      	adds	r7, #44	; 0x2c
 800b9de:	46bd      	mov	sp, r7
 800b9e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b9e4:	464d      	mov	r5, r9
   xy = yy = 0;
 800b9e6:	2200      	movs	r2, #0
   if (pulsesLeft > N+3)
 800b9e8:	f10b 0303 	add.w	r3, fp, #3
 800b9ec:	429d      	cmp	r5, r3
   xy = yy = 0;
 800b9ee:	4692      	mov	sl, r2
   if (pulsesLeft > N+3)
 800b9f0:	dd81      	ble.n	800b8f6 <op_pvq_search_c+0xee>
      yy = MAC16_16(yy, tmp, y[0]);
 800b9f2:	69fb      	ldr	r3, [r7, #28]
      yy = MAC16_16(yy, tmp, tmp);
 800b9f4:	b2a9      	uxth	r1, r5
      yy = MAC16_16(yy, tmp, y[0]);
 800b9f6:	881b      	ldrh	r3, [r3, #0]
 800b9f8:	440b      	add	r3, r1
 800b9fa:	fb13 2201 	smlabb	r2, r3, r1, r2
      iy[0] += pulsesLeft;
 800b9fe:	6979      	ldr	r1, [r7, #20]
      yy = MAC16_16(yy, tmp, y[0]);
 800ba00:	b212      	sxth	r2, r2
      iy[0] += pulsesLeft;
 800ba02:	680b      	ldr	r3, [r1, #0]
 800ba04:	442b      	add	r3, r5
 800ba06:	600b      	str	r3, [r1, #0]
 800ba08:	e7d9      	b.n	800b9be <op_pvq_search_c+0x1b6>
         X[0] = QCONST16(1.f,14);
 800ba0a:	f44f 4680 	mov.w	r6, #16384	; 0x4000
 800ba0e:	69b8      	ldr	r0, [r7, #24]
            X[j]=0;
 800ba10:	f1bb 0f01 	cmp.w	fp, #1
 800ba14:	f1a5 0202 	sub.w	r2, r5, #2
         X[0] = QCONST16(1.f,14);
 800ba18:	f820 6b02 	strh.w	r6, [r0], #2
 800ba1c:	bfd8      	it	le
 800ba1e:	2202      	movle	r2, #2
 800ba20:	2100      	movs	r1, #0
 800ba22:	f008 fb81 	bl	8014128 <memset>
         sum = QCONST16(1.f,14);
 800ba26:	4630      	mov	r0, r6
 800ba28:	e73b      	b.n	800b8a2 <op_pvq_search_c+0x9a>
         Ryy = ADD16(yy, y[j]);
 800ba2a:	4691      	mov	r9, r2
         if (opus_unlikely(MULT16_16(best_den, Rxy) > MULT16_16(Ryy, best_num)))
 800ba2c:	461c      	mov	r4, r3
 800ba2e:	6239      	str	r1, [r7, #32]
 800ba30:	e7a5      	b.n	800b97e <op_pvq_search_c+0x176>
 800ba32:	bf00      	nop

0800ba34 <alg_quant>:

unsigned alg_quant(celt_norm *X, int N, int K, int spread, int B, ec_enc *enc,
      opus_val16 gain, int resynth, int arch)
{
 800ba34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ba38:	460c      	mov	r4, r1
 800ba3a:	b091      	sub	sp, #68	; 0x44
 800ba3c:	4611      	mov	r1, r2
 800ba3e:	af02      	add	r7, sp, #8
 800ba40:	62fa      	str	r2, [r7, #44]	; 0x2c

   celt_assert2(K>0, "alg_quant() needs at least one pulse");
   celt_assert2(N>1, "alg_quant() needs at least two dimensions");

   /* Covers vectorization by up to 4. */
   ALLOC(iy, N+3, int);
 800ba42:	00a2      	lsls	r2, r4, #2
 800ba44:	3216      	adds	r2, #22
 800ba46:	f022 0207 	bic.w	r2, r2, #7
 800ba4a:	ebad 0d02 	sub.w	sp, sp, r2
   if (2*K>=len || spread==SPREAD_NONE)
 800ba4e:	004a      	lsls	r2, r1, #1
   ALLOC(iy, N+3, int);
 800ba50:	a902      	add	r1, sp, #8
 800ba52:	6379      	str	r1, [r7, #52]	; 0x34
{
 800ba54:	f9b7 1068 	ldrsh.w	r1, [r7, #104]	; 0x68
   if (2*K>=len || spread==SPREAD_NONE)
 800ba58:	4294      	cmp	r4, r2
 800ba5a:	623a      	str	r2, [r7, #32]
{
 800ba5c:	6338      	str	r0, [r7, #48]	; 0x30
 800ba5e:	61fb      	str	r3, [r7, #28]
 800ba60:	6e3e      	ldr	r6, [r7, #96]	; 0x60
 800ba62:	61b9      	str	r1, [r7, #24]
   if (2*K>=len || spread==SPREAD_NONE)
 800ba64:	dd02      	ble.n	800ba6c <alg_quant+0x38>
 800ba66:	2b00      	cmp	r3, #0
 800ba68:	f040 809c 	bne.w	800bba4 <alg_quant+0x170>

   exp_rotation(X, N, 1, B, K, spread);

   yy = op_pvq_search(X, iy, K, N, arch);
 800ba6c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800ba6e:	f8d7 902c 	ldr.w	r9, [r7, #44]	; 0x2c
 800ba72:	f8d7 8034 	ldr.w	r8, [r7, #52]	; 0x34
 800ba76:	9300      	str	r3, [sp, #0]
 800ba78:	464a      	mov	r2, r9
 800ba7a:	4623      	mov	r3, r4
 800ba7c:	4641      	mov	r1, r8
 800ba7e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800ba80:	f7ff fec2 	bl	800b808 <op_pvq_search_c>

   encode_pulses(iy, N, K, enc);
 800ba84:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   yy = op_pvq_search(X, iy, K, N, arch);
 800ba86:	4605      	mov	r5, r0
   encode_pulses(iy, N, K, enc);
 800ba88:	464a      	mov	r2, r9
 800ba8a:	4621      	mov	r1, r4
 800ba8c:	4640      	mov	r0, r8
 800ba8e:	f7fc f9f9 	bl	8007e84 <encode_pulses>

   if (resynth)
 800ba92:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ba94:	2b00      	cmp	r3, #0
 800ba96:	d13f      	bne.n	800bb18 <alg_quant+0xe4>
   if (B<=1)
 800ba98:	2e01      	cmp	r6, #1
 800ba9a:	dd7a      	ble.n	800bb92 <alg_quant+0x15e>
   if (d>256)
 800ba9c:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 800baa0:	dc37      	bgt.n	800bb12 <alg_quant+0xde>
      t = EC_ILOG(d&-d);
 800baa2:	4273      	negs	r3, r6
 800baa4:	4033      	ands	r3, r6
 800baa6:	fab3 f383 	clz	r3, r3
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800baaa:	49a0      	ldr	r1, [pc, #640]	; (800bd2c <alg_quant+0x2f8>)
      t = EC_ILOG(d&-d);
 800baac:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800bab0:	fa26 f003 	lsr.w	r0, r6, r3
 800bab4:	1e5a      	subs	r2, r3, #1
 800bab6:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 800baba:	fa24 f202 	lsr.w	r2, r4, r2
 800babe:	fba2 2303 	umull	r2, r3, r2, r3
      return q+(n-q*d >= d);
 800bac2:	fb06 4413 	mls	r4, r6, r3, r4
 800bac6:	42a6      	cmp	r6, r4
 800bac8:	bf8c      	ite	hi
 800baca:	461c      	movhi	r4, r3
 800bacc:	1c5c      	addls	r4, r3, #1
   i=0; do {
 800bace:	f04f 0c00 	mov.w	ip, #0
   collapse_mask = 0;
 800bad2:	4660      	mov	r0, ip
 800bad4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bad6:	ea4f 0884 	mov.w	r8, r4, lsl #2
 800bada:	f1a3 0e04 	sub.w	lr, r3, #4
      unsigned tmp=0;
 800bade:	2200      	movs	r2, #0
   collapse_mask = 0;
 800bae0:	4671      	mov	r1, lr
      j=0; do {
 800bae2:	4613      	mov	r3, r2
         tmp |= iy[i*N0+j];
 800bae4:	f851 5f04 	ldr.w	r5, [r1, #4]!
      } while (++j<N0);
 800bae8:	3301      	adds	r3, #1
 800baea:	429c      	cmp	r4, r3
         tmp |= iy[i*N0+j];
 800baec:	ea42 0205 	orr.w	r2, r2, r5
      } while (++j<N0);
 800baf0:	dcf8      	bgt.n	800bae4 <alg_quant+0xb0>
      collapse_mask |= (tmp!=0)<<i;
 800baf2:	3200      	adds	r2, #0
 800baf4:	bf18      	it	ne
 800baf6:	2201      	movne	r2, #1
 800baf8:	fa02 f20c 	lsl.w	r2, r2, ip
   } while (++i<B);
 800bafc:	f10c 0c01 	add.w	ip, ip, #1
 800bb00:	4566      	cmp	r6, ip
      collapse_mask |= (tmp!=0)<<i;
 800bb02:	ea40 0002 	orr.w	r0, r0, r2
 800bb06:	44c6      	add	lr, r8
   } while (++i<B);
 800bb08:	d1e9      	bne.n	800bade <alg_quant+0xaa>
   }

   collapse_mask = extract_collapse_mask(iy, N, B);
   RESTORE_STACK;
   return collapse_mask;
}
 800bb0a:	373c      	adds	r7, #60	; 0x3c
 800bb0c:	46bd      	mov	sp, r7
 800bb0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return n/d;
 800bb12:	fbb4 f4f6 	udiv	r4, r4, r6
 800bb16:	e7da      	b.n	800bace <alg_quant+0x9a>
 800bb18:	fab5 f185 	clz	r1, r5
   k = celt_ilog2(Ryy)>>1;
 800bb1c:	f1c1 011f 	rsb	r1, r1, #31
 800bb20:	ea4f 0861 	mov.w	r8, r1, asr #1
   t = VSHR32(Ryy, 2*(k-7));
 800bb24:	f1b8 0f07 	cmp.w	r8, #7
 800bb28:	f1a8 0307 	sub.w	r3, r8, #7
 800bb2c:	dc36      	bgt.n	800bb9c <alg_quant+0x168>
 800bb2e:	ebc3 73c3 	rsb	r3, r3, r3, lsl #31
 800bb32:	0058      	lsls	r0, r3, #1
 800bb34:	fa05 f000 	lsl.w	r0, r5, r0
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
 800bb38:	f7fd fe8e 	bl	8009858 <celt_rsqrt_norm>
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
 800bb3c:	2301      	movs	r3, #1
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
 800bb3e:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
   i=0;
 800bb42:	2200      	movs	r2, #0
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
 800bb44:	69b9      	ldr	r1, [r7, #24]
 800bb46:	fb00 cc01 	mla	ip, r0, r1, ip
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
 800bb4a:	eb08 0103 	add.w	r1, r8, r3
 800bb4e:	408b      	lsls	r3, r1
 800bb50:	ea4f 0e63 	mov.w	lr, r3, asr #1
 800bb54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
 800bb56:	f34c 3ccf 	sbfx	ip, ip, #15, #16
 800bb5a:	1f1d      	subs	r5, r3, #4
 800bb5c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bb5e:	1e98      	subs	r0, r3, #2
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
 800bb60:	f855 3f04 	ldr.w	r3, [r5, #4]!
   while (++i < N);
 800bb64:	3201      	adds	r2, #1
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
 800bb66:	fb13 e30c 	smlabb	r3, r3, ip, lr
   while (++i < N);
 800bb6a:	4294      	cmp	r4, r2
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
 800bb6c:	fa43 f301 	asr.w	r3, r3, r1
 800bb70:	f820 3f02 	strh.w	r3, [r0, #2]!
   while (++i < N);
 800bb74:	dcf4      	bgt.n	800bb60 <alg_quant+0x12c>
   if (2*K>=len || spread==SPREAD_NONE)
 800bb76:	6a3b      	ldr	r3, [r7, #32]
 800bb78:	429c      	cmp	r4, r3
 800bb7a:	dd8d      	ble.n	800ba98 <alg_quant+0x64>
 800bb7c:	69fb      	ldr	r3, [r7, #28]
 800bb7e:	2b00      	cmp	r3, #0
 800bb80:	d08a      	beq.n	800ba98 <alg_quant+0x64>
 800bb82:	9300      	str	r3, [sp, #0]
 800bb84:	4632      	mov	r2, r6
 800bb86:	e9d7 300b 	ldrd	r3, r0, [r7, #44]	; 0x2c
 800bb8a:	4621      	mov	r1, r4
 800bb8c:	f7ff fd70 	bl	800b670 <exp_rotation.part.2.constprop.3>
 800bb90:	e782      	b.n	800ba98 <alg_quant+0x64>
      return 1;
 800bb92:	2001      	movs	r0, #1
}
 800bb94:	373c      	adds	r7, #60	; 0x3c
 800bb96:	46bd      	mov	sp, r7
 800bb98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   t = VSHR32(Ryy, 2*(k-7));
 800bb9c:	005b      	lsls	r3, r3, #1
 800bb9e:	fa45 f003 	asr.w	r0, r5, r3
 800bba2:	e7c9      	b.n	800bb38 <alg_quant+0x104>
 800bba4:	461a      	mov	r2, r3
   factor = SPREAD_FACTOR[spread-1];
 800bba6:	4b62      	ldr	r3, [pc, #392]	; (800bd30 <alg_quant+0x2fc>)
 800bba8:	3a01      	subs	r2, #1
   gain = celt_div((opus_val32)MULT16_16(Q15_ONE,len),(opus_val32)(len+factor*K));
 800bbaa:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800bbae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bbb0:	fb00 4003 	mla	r0, r0, r3, r4
 800bbb4:	f7fd ff3c 	bl	8009a30 <celt_rcp>
 800bbb8:	b223      	sxth	r3, r4
 800bbba:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
 800bbbe:	fb83 0100 	smull	r0, r1, r3, r0
 800bbc2:	0fc3      	lsrs	r3, r0, #31
 800bbc4:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
   theta = HALF16(MULT16_16_Q15(gain,gain));
 800bbc8:	fb13 f303 	smulbb	r3, r3, r3
 800bbcc:	ea4f 4823 	mov.w	r8, r3, asr #16
   c = celt_cos_norm(EXTEND32(theta));
 800bbd0:	4640      	mov	r0, r8
 800bbd2:	f7fd feb5 	bl	8009940 <celt_cos_norm>
 800bbd6:	4605      	mov	r5, r0
   s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */
 800bbd8:	f5c8 40ff 	rsb	r0, r8, #32640	; 0x7f80
 800bbdc:	307f      	adds	r0, #127	; 0x7f
 800bbde:	f7fd feaf 	bl	8009940 <celt_cos_norm>
   if (len>=8*stride)
 800bbe2:	ebb4 0fc6 	cmp.w	r4, r6, lsl #3
   s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */
 800bbe6:	4681      	mov	r9, r0
   if (len>=8*stride)
 800bbe8:	f2c0 8085 	blt.w	800bcf6 <alg_quant+0x2c2>
      while ((stride2*stride2+stride2)*stride + (stride>>2) < len)
 800bbec:	10b1      	asrs	r1, r6, #2
      stride2 = 1;
 800bbee:	2201      	movs	r2, #1
 800bbf0:	e000      	b.n	800bbf4 <alg_quant+0x1c0>
         stride2++;
 800bbf2:	4602      	mov	r2, r0
      while ((stride2*stride2+stride2)*stride + (stride>>2) < len)
 800bbf4:	1c50      	adds	r0, r2, #1
 800bbf6:	fb00 f302 	mul.w	r3, r0, r2
 800bbfa:	fb06 1303 	mla	r3, r6, r3, r1
 800bbfe:	429c      	cmp	r4, r3
 800bc00:	dcf7      	bgt.n	800bbf2 <alg_quant+0x1be>
 800bc02:	627a      	str	r2, [r7, #36]	; 0x24
   if (d>256)
 800bc04:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 800bc08:	d978      	bls.n	800bcfc <alg_quant+0x2c8>
      return n/d;
 800bc0a:	fbb4 f3f6 	udiv	r3, r4, r6
 800bc0e:	62bb      	str	r3, [r7, #40]	; 0x28
   for (i=0;i<stride;i++)
 800bc10:	2e00      	cmp	r6, #0
 800bc12:	f77f af2b 	ble.w	800ba6c <alg_quant+0x38>
 800bc16:	2000      	movs	r0, #0
 800bc18:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800bc1a:	607c      	str	r4, [r7, #4]
 800bc1c:	ebc2 73c2 	rsb	r3, r2, r2, lsl #31
 800bc20:	0059      	lsls	r1, r3, #1
 800bc22:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bc24:	663e      	str	r6, [r7, #96]	; 0x60
 800bc26:	469c      	mov	ip, r3
            exp_rotation1(X+i*len, len, stride2, s, -c);
 800bc28:	426b      	negs	r3, r5
 800bc2a:	b21b      	sxth	r3, r3
 800bc2c:	60bb      	str	r3, [r7, #8]
   for (i=len-2*stride-1;i>=0;i--)
 800bc2e:	1ed3      	subs	r3, r2, #3
 800bc30:	4604      	mov	r4, r0
 800bc32:	461e      	mov	r6, r3
 800bc34:	eb0c 0a42 	add.w	sl, ip, r2, lsl #1
 800bc38:	60f9      	str	r1, [r7, #12]
 800bc3a:	f1c9 0800 	rsb	r8, r9, #0
 800bc3e:	3102      	adds	r1, #2
 800bc40:	0052      	lsls	r2, r2, #1
 800bc42:	6139      	str	r1, [r7, #16]
 800bc44:	fa0f f888 	sxth.w	r8, r8
 800bc48:	f1aa 0a02 	sub.w	sl, sl, #2
 800bc4c:	617a      	str	r2, [r7, #20]
 800bc4e:	693b      	ldr	r3, [r7, #16]
 800bc50:	eb03 000a 	add.w	r0, r3, sl
   for (i=0;i<len-stride;i++)
 800bc54:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc56:	2b01      	cmp	r3, #1
 800bc58:	dd1a      	ble.n	800bc90 <alg_quant+0x25c>
   Xptr = X;
 800bc5a:	4601      	mov	r1, r0
 800bc5c:	68fb      	ldr	r3, [r7, #12]
 800bc5e:	4453      	add	r3, sl
 800bc60:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
      x2 = Xptr[stride];
 800bc64:	f931 cf02 	ldrsh.w	ip, [r1, #2]!
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800bc68:	fb03 fe08 	mul.w	lr, r3, r8
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800bc6c:	fb0c f209 	mul.w	r2, ip, r9
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800bc70:	fb0c ec05 	mla	ip, ip, r5, lr
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800bc74:	fb03 2205 	mla	r2, r3, r5, r2
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800bc78:	f50c 4380 	add.w	r3, ip, #16384	; 0x4000
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800bc7c:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
 800bc80:	13d2      	asrs	r2, r2, #15
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800bc82:	f343 33cf 	sbfx	r3, r3, #15, #16
   for (i=0;i<len-stride;i++)
 800bc86:	4551      	cmp	r1, sl
      *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800bc88:	f821 2c02 	strh.w	r2, [r1, #-2]
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800bc8c:	800b      	strh	r3, [r1, #0]
   for (i=0;i<len-stride;i++)
 800bc8e:	d1e9      	bne.n	800bc64 <alg_quant+0x230>
   for (i=len-2*stride-1;i>=0;i--)
 800bc90:	2e00      	cmp	r6, #0
 800bc92:	db1d      	blt.n	800bcd0 <alg_quant+0x29c>
 800bc94:	46d6      	mov	lr, sl
 800bc96:	46b3      	mov	fp, r6
 800bc98:	f93e 3d02 	ldrsh.w	r3, [lr, #-2]!
      x1 = Xptr[0];
 800bc9c:	f93e 1c02 	ldrsh.w	r1, [lr, #-2]
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800bca0:	fb03 fc09 	mul.w	ip, r3, r9
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800bca4:	fb01 f208 	mul.w	r2, r1, r8
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800bca8:	fb01 c105 	mla	r1, r1, r5, ip
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800bcac:	fb03 2205 	mla	r2, r3, r5, r2
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800bcb0:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800bcb4:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
   for (i=len-2*stride-1;i>=0;i--)
 800bcb8:	f10b 3bff 	add.w	fp, fp, #4294967295
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800bcbc:	13d2      	asrs	r2, r2, #15
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800bcbe:	f341 33cf 	sbfx	r3, r1, #15, #16
   for (i=len-2*stride-1;i>=0;i--)
 800bcc2:	f1bb 3fff 	cmp.w	fp, #4294967295
      Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));
 800bcc6:	f8ae 2000 	strh.w	r2, [lr]
      *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));
 800bcca:	f82e 3d02 	strh.w	r3, [lr, #-2]!
   for (i=len-2*stride-1;i>=0;i--)
 800bcce:	d1e5      	bne.n	800bc9c <alg_quant+0x268>
         if (stride2)
 800bcd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bcd2:	b943      	cbnz	r3, 800bce6 <alg_quant+0x2b2>
 800bcd4:	697b      	ldr	r3, [r7, #20]
   for (i=0;i<stride;i++)
 800bcd6:	3401      	adds	r4, #1
 800bcd8:	449a      	add	sl, r3
 800bcda:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800bcdc:	42a3      	cmp	r3, r4
 800bcde:	d1b6      	bne.n	800bc4e <alg_quant+0x21a>
 800bce0:	687c      	ldr	r4, [r7, #4]
 800bce2:	461e      	mov	r6, r3
 800bce4:	e6c2      	b.n	800ba6c <alg_quant+0x38>
 800bce6:	461a      	mov	r2, r3
            exp_rotation1(X+i*len, len, stride2, s, -c);
 800bce8:	68bb      	ldr	r3, [r7, #8]
 800bcea:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800bcec:	9300      	str	r3, [sp, #0]
 800bcee:	464b      	mov	r3, r9
 800bcf0:	f7ff fc6a 	bl	800b5c8 <exp_rotation1>
 800bcf4:	e7ee      	b.n	800bcd4 <alg_quant+0x2a0>
   int stride2=0;
 800bcf6:	2300      	movs	r3, #0
 800bcf8:	627b      	str	r3, [r7, #36]	; 0x24
 800bcfa:	e783      	b.n	800bc04 <alg_quant+0x1d0>
      t = EC_ILOG(d&-d);
 800bcfc:	4273      	negs	r3, r6
 800bcfe:	4033      	ands	r3, r6
 800bd00:	fab3 f383 	clz	r3, r3
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800bd04:	4909      	ldr	r1, [pc, #36]	; (800bd2c <alg_quant+0x2f8>)
      t = EC_ILOG(d&-d);
 800bd06:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800bd0a:	fa26 f003 	lsr.w	r0, r6, r3
 800bd0e:	1e5a      	subs	r2, r3, #1
 800bd10:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 800bd14:	fa24 f202 	lsr.w	r2, r4, r2
 800bd18:	fba2 0103 	umull	r0, r1, r2, r3
      return q+(n-q*d >= d);
 800bd1c:	460b      	mov	r3, r1
 800bd1e:	fb06 4211 	mls	r2, r6, r1, r4
 800bd22:	4296      	cmp	r6, r2
 800bd24:	bf98      	it	ls
 800bd26:	3301      	addls	r3, #1
 800bd28:	62bb      	str	r3, [r7, #40]	; 0x28
 800bd2a:	e771      	b.n	800bc10 <alg_quant+0x1dc>
 800bd2c:	0801649c 	.word	0x0801649c
 800bd30:	08016858 	.word	0x08016858

0800bd34 <alg_unquant>:

/** Decode pulse vector and combine the result with the pitch vector to produce
    the final normalised signal in the current band. */
unsigned alg_unquant(celt_norm *X, int N, int K, int spread, int B,
      ec_dec *dec, opus_val16 gain)
{
 800bd34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bd38:	b085      	sub	sp, #20
   VARDECL(int, iy);
   SAVE_STACK;

   celt_assert2(K>0, "alg_unquant() needs at least one pulse");
   celt_assert2(N>1, "alg_unquant() needs at least two dimensions");
   ALLOC(iy, N, int);
 800bd3a:	008c      	lsls	r4, r1, #2
 800bd3c:	340a      	adds	r4, #10
 800bd3e:	f024 0407 	bic.w	r4, r4, #7
{
 800bd42:	af02      	add	r7, sp, #8
   ALLOC(iy, N, int);
 800bd44:	ebad 0d04 	sub.w	sp, sp, r4
 800bd48:	ac02      	add	r4, sp, #8
{
 800bd4a:	607b      	str	r3, [r7, #4]
 800bd4c:	4680      	mov	r8, r0
   Ryy = decode_pulses(iy, N, K, dec);
 800bd4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bd50:	4620      	mov	r0, r4
{
 800bd52:	460e      	mov	r6, r1
 800bd54:	4691      	mov	r9, r2
 800bd56:	6b3d      	ldr	r5, [r7, #48]	; 0x30
 800bd58:	f9b7 b038 	ldrsh.w	fp, [r7, #56]	; 0x38
   Ryy = decode_pulses(iy, N, K, dec);
 800bd5c:	f7fc f8f8 	bl	8007f50 <decode_pulses>
 800bd60:	fab0 f180 	clz	r1, r0
   k = celt_ilog2(Ryy)>>1;
 800bd64:	f1c1 011f 	rsb	r1, r1, #31
 800bd68:	ea4f 0a61 	mov.w	sl, r1, asr #1
   t = VSHR32(Ryy, 2*(k-7));
 800bd6c:	f1ba 0f07 	cmp.w	sl, #7
 800bd70:	dd64      	ble.n	800be3c <alg_unquant+0x108>
 800bd72:	f1aa 0307 	sub.w	r3, sl, #7
 800bd76:	005b      	lsls	r3, r3, #1
 800bd78:	4118      	asrs	r0, r3
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
 800bd7a:	f7fd fd6d 	bl	8009858 <celt_rsqrt_norm>
 800bd7e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
 800bd82:	f04f 0e01 	mov.w	lr, #1
 800bd86:	3c04      	subs	r4, #4
 800bd88:	46a4      	mov	ip, r4
   i=0;
 800bd8a:	2200      	movs	r2, #0
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
 800bd8c:	fb00 3b0b 	mla	fp, r0, fp, r3
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
 800bd90:	eb0a 010e 	add.w	r1, sl, lr
 800bd94:	fa0e fe01 	lsl.w	lr, lr, r1
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
 800bd98:	f34b 3bcf 	sbfx	fp, fp, #15, #16
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
 800bd9c:	ea4f 0e6e 	mov.w	lr, lr, asr #1
 800bda0:	f1a8 0002 	sub.w	r0, r8, #2
 800bda4:	f85c 3f04 	ldr.w	r3, [ip, #4]!
   while (++i < N);
 800bda8:	3201      	adds	r2, #1
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
 800bdaa:	fb13 e30b 	smlabb	r3, r3, fp, lr
   while (++i < N);
 800bdae:	4296      	cmp	r6, r2
      X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));
 800bdb0:	fa43 f301 	asr.w	r3, r3, r1
 800bdb4:	f820 3f02 	strh.w	r3, [r0, #2]!
   while (++i < N);
 800bdb8:	dcf4      	bgt.n	800bda4 <alg_unquant+0x70>
   if (2*K>=len || spread==SPREAD_NONE)
 800bdba:	ebb6 0f49 	cmp.w	r6, r9, lsl #1
 800bdbe:	dd02      	ble.n	800bdc6 <alg_unquant+0x92>
 800bdc0:	687b      	ldr	r3, [r7, #4]
 800bdc2:	2b00      	cmp	r3, #0
 800bdc4:	d147      	bne.n	800be56 <alg_unquant+0x122>
   if (B<=1)
 800bdc6:	2d01      	cmp	r5, #1
 800bdc8:	dd40      	ble.n	800be4c <alg_unquant+0x118>
   if (d>256)
 800bdca:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 800bdce:	dc3a      	bgt.n	800be46 <alg_unquant+0x112>
      t = EC_ILOG(d&-d);
 800bdd0:	426b      	negs	r3, r5
 800bdd2:	402b      	ands	r3, r5
 800bdd4:	fab3 f383 	clz	r3, r3
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800bdd8:	4923      	ldr	r1, [pc, #140]	; (800be68 <alg_unquant+0x134>)
      t = EC_ILOG(d&-d);
 800bdda:	f1c3 0320 	rsb	r3, r3, #32
      q = (opus_uint64)SMALL_DIV_TABLE[d>>t]*(n>>(t-1))>>32;
 800bdde:	fa25 f003 	lsr.w	r0, r5, r3
 800bde2:	1e5a      	subs	r2, r3, #1
 800bde4:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 800bde8:	fa26 f202 	lsr.w	r2, r6, r2
 800bdec:	fba2 2303 	umull	r2, r3, r2, r3
      return q+(n-q*d >= d);
 800bdf0:	fb05 6c13 	mls	ip, r5, r3, r6
 800bdf4:	4565      	cmp	r5, ip
 800bdf6:	bf8c      	ite	hi
 800bdf8:	469c      	movhi	ip, r3
 800bdfa:	f103 0c01 	addls.w	ip, r3, #1
   i=0; do {
 800bdfe:	f04f 0e00 	mov.w	lr, #0
   collapse_mask = 0;
 800be02:	4670      	mov	r0, lr
 800be04:	ea4f 088c 	mov.w	r8, ip, lsl #2
      unsigned tmp=0;
 800be08:	2200      	movs	r2, #0
   collapse_mask = 0;
 800be0a:	4621      	mov	r1, r4
      j=0; do {
 800be0c:	4613      	mov	r3, r2
         tmp |= iy[i*N0+j];
 800be0e:	f851 6f04 	ldr.w	r6, [r1, #4]!
      } while (++j<N0);
 800be12:	3301      	adds	r3, #1
 800be14:	459c      	cmp	ip, r3
         tmp |= iy[i*N0+j];
 800be16:	ea42 0206 	orr.w	r2, r2, r6
      } while (++j<N0);
 800be1a:	dcf8      	bgt.n	800be0e <alg_unquant+0xda>
      collapse_mask |= (tmp!=0)<<i;
 800be1c:	3200      	adds	r2, #0
 800be1e:	bf18      	it	ne
 800be20:	2201      	movne	r2, #1
 800be22:	fa02 f20e 	lsl.w	r2, r2, lr
   } while (++i<B);
 800be26:	f10e 0e01 	add.w	lr, lr, #1
 800be2a:	4575      	cmp	r5, lr
      collapse_mask |= (tmp!=0)<<i;
 800be2c:	ea40 0002 	orr.w	r0, r0, r2
 800be30:	4444      	add	r4, r8
   } while (++i<B);
 800be32:	d1e9      	bne.n	800be08 <alg_unquant+0xd4>
   normalise_residual(iy, X, N, Ryy, gain);
   exp_rotation(X, N, -1, B, K, spread);
   collapse_mask = extract_collapse_mask(iy, N, B);
   RESTORE_STACK;
   return collapse_mask;
}
 800be34:	370c      	adds	r7, #12
 800be36:	46bd      	mov	sp, r7
 800be38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   t = VSHR32(Ryy, 2*(k-7));
 800be3c:	f1ca 0307 	rsb	r3, sl, #7
 800be40:	005b      	lsls	r3, r3, #1
 800be42:	4098      	lsls	r0, r3
 800be44:	e799      	b.n	800bd7a <alg_unquant+0x46>
      return n/d;
 800be46:	fbb6 fcf5 	udiv	ip, r6, r5
 800be4a:	e7d8      	b.n	800bdfe <alg_unquant+0xca>
      return 1;
 800be4c:	2001      	movs	r0, #1
}
 800be4e:	370c      	adds	r7, #12
 800be50:	46bd      	mov	sp, r7
 800be52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800be56:	9300      	str	r3, [sp, #0]
 800be58:	4640      	mov	r0, r8
 800be5a:	464b      	mov	r3, r9
 800be5c:	462a      	mov	r2, r5
 800be5e:	4631      	mov	r1, r6
 800be60:	f7ff fc06 	bl	800b670 <exp_rotation.part.2.constprop.3>
 800be64:	e7af      	b.n	800bdc6 <alg_unquant+0x92>
 800be66:	bf00      	nop
 800be68:	0801649c 	.word	0x0801649c

0800be6c <renormalise_vector>:
   for (i=0;i<N;i++)
 800be6c:	2900      	cmp	r1, #0
 800be6e:	dd3c      	ble.n	800beea <renormalise_vector+0x7e>

#ifndef OVERRIDE_renormalise_vector
void renormalise_vector(celt_norm *X, int N, opus_val16 gain, int arch)
{
 800be70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800be72:	4604      	mov	r4, r0
 800be74:	4617      	mov	r7, r2
   opus_val32 xy=0;
 800be76:	2000      	movs	r0, #0
 800be78:	004e      	lsls	r6, r1, #1
 800be7a:	19a1      	adds	r1, r4, r6
 800be7c:	3902      	subs	r1, #2
 800be7e:	1ea3      	subs	r3, r4, #2
      xy = MAC16_16(xy, x[i], y[i]);
 800be80:	f933 5f02 	ldrsh.w	r5, [r3, #2]!
   for (i=0;i<N;i++)
 800be84:	4299      	cmp	r1, r3
      xy = MAC16_16(xy, x[i], y[i]);
 800be86:	fb05 0005 	mla	r0, r5, r5, r0
   for (i=0;i<N;i++)
 800be8a:	d1f9      	bne.n	800be80 <renormalise_vector+0x14>
#endif
   opus_val32 E;
   opus_val16 g;
   opus_val32 t;
   celt_norm *xptr;
   E = EPSILON + celt_inner_prod(X, X, N, arch);
 800be8c:	3001      	adds	r0, #1
 800be8e:	fab0 f280 	clz	r2, r0
#ifdef FIXED_POINT
   k = celt_ilog2(E)>>1;
 800be92:	f1c2 021f 	rsb	r2, r2, #31
 800be96:	1055      	asrs	r5, r2, #1
#endif
   t = VSHR32(E, 2*(k-7));
 800be98:	2d07      	cmp	r5, #7
 800be9a:	f1a5 0307 	sub.w	r3, r5, #7
 800be9e:	dd17      	ble.n	800bed0 <renormalise_vector+0x64>
 800bea0:	005b      	lsls	r3, r3, #1
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
 800bea2:	4118      	asrs	r0, r3
 800bea4:	f7fd fcd8 	bl	8009858 <celt_rsqrt_norm>
 800bea8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800beac:	fb07 3000 	mla	r0, r7, r0, r3
 800beb0:	f340 30cf 	sbfx	r0, r0, #15, #16

   xptr = X;
   for (i=0;i<N;i++)
   {
      *xptr = EXTRACT16(PSHR32(MULT16_16(g, *xptr), k+1));
 800beb4:	2101      	movs	r1, #1
 800beb6:	186a      	adds	r2, r5, r1
 800beb8:	4091      	lsls	r1, r2
 800beba:	19a5      	adds	r5, r4, r6
 800bebc:	1049      	asrs	r1, r1, #1
 800bebe:	8823      	ldrh	r3, [r4, #0]
 800bec0:	fb13 1300 	smlabb	r3, r3, r0, r1
 800bec4:	4113      	asrs	r3, r2
 800bec6:	f824 3b02 	strh.w	r3, [r4], #2
   for (i=0;i<N;i++)
 800beca:	42ac      	cmp	r4, r5
 800becc:	d1f7      	bne.n	800bebe <renormalise_vector+0x52>
      xptr++;
   }
   /*return celt_sqrt(E);*/
}
 800bece:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   g = MULT16_16_P15(celt_rsqrt_norm(t),gain);
 800bed0:	ebc3 73c3 	rsb	r3, r3, r3, lsl #31
 800bed4:	005b      	lsls	r3, r3, #1
 800bed6:	4098      	lsls	r0, r3
 800bed8:	f7fd fcbe 	bl	8009858 <celt_rsqrt_norm>
 800bedc:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800bee0:	fb00 2007 	mla	r0, r0, r7, r2
 800bee4:	f340 30cf 	sbfx	r0, r0, #15, #16
 800bee8:	e7e4      	b.n	800beb4 <renormalise_vector+0x48>
 800beea:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800beee:	f7fd bcb3 	b.w	8009858 <celt_rsqrt_norm>
 800bef2:	bf00      	nop

0800bef4 <stereo_itheta>:
#endif /* OVERRIDE_renormalise_vector */

int stereo_itheta(const celt_norm *X, const celt_norm *Y, int stereo, int N, int arch)
{
 800bef4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   int itheta;
   opus_val16 mid, side;
   opus_val32 Emid, Eside;

   Emid = Eside = EPSILON;
   if (stereo)
 800bef6:	2a00      	cmp	r2, #0
 800bef8:	d14d      	bne.n	800bf96 <stereo_itheta+0xa2>
 800befa:	2b00      	cmp	r3, #0
 800befc:	f340 8096 	ble.w	800c02c <stereo_itheta+0x138>
   opus_val32 xy=0;
 800bf00:	4694      	mov	ip, r2
 800bf02:	005b      	lsls	r3, r3, #1
 800bf04:	18c5      	adds	r5, r0, r3
 800bf06:	3d02      	subs	r5, #2
 800bf08:	3802      	subs	r0, #2
      xy = MAC16_16(xy, x[i], y[i]);
 800bf0a:	f930 4f02 	ldrsh.w	r4, [r0, #2]!
   for (i=0;i<N;i++)
 800bf0e:	4285      	cmp	r5, r0
      xy = MAC16_16(xy, x[i], y[i]);
 800bf10:	fb04 cc04 	mla	ip, r4, r4, ip
   for (i=0;i<N;i++)
 800bf14:	d1f9      	bne.n	800bf0a <stereo_itheta+0x16>
 800bf16:	3902      	subs	r1, #2
 800bf18:	18cc      	adds	r4, r1, r3
         s = SUB16(SHR16(X[i],1),SHR16(Y[i],1));
         Emid = MAC16_16(Emid, m, m);
         Eside = MAC16_16(Eside, s, s);
      }
   } else {
      Emid += celt_inner_prod(X, X, N, arch);
 800bf1a:	f10c 0c01 	add.w	ip, ip, #1
      xy = MAC16_16(xy, x[i], y[i]);
 800bf1e:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
   for (i=0;i<N;i++)
 800bf22:	428c      	cmp	r4, r1
      xy = MAC16_16(xy, x[i], y[i]);
 800bf24:	fb03 2203 	mla	r2, r3, r3, r2
   for (i=0;i<N;i++)
 800bf28:	d1f9      	bne.n	800bf1e <stereo_itheta+0x2a>
 800bf2a:	1c57      	adds	r7, r2, #1
      Eside += celt_inner_prod(Y, Y, N, arch);
   }
   mid = celt_sqrt(Emid);
 800bf2c:	4660      	mov	r0, ip
 800bf2e:	f7fd fcc5 	bl	80098bc <celt_sqrt>
 800bf32:	b204      	sxth	r4, r0
   side = celt_sqrt(Eside);
 800bf34:	4638      	mov	r0, r7
 800bf36:	f7fd fcc1 	bl	80098bc <celt_sqrt>
 800bf3a:	b205      	sxth	r5, r0
#undef M4

/* atan2() approximation valid for positive input values */
static OPUS_INLINE opus_val16 celt_atan2p(opus_val16 y, opus_val16 x)
{
   if (y < x)
 800bf3c:	42ac      	cmp	r4, r5
 800bf3e:	dd46      	ble.n	800bfce <stereo_itheta+0xda>
   {
      opus_val32 arg;
      arg = celt_div(SHL32(EXTEND32(y),15),x);
 800bf40:	4620      	mov	r0, r4
 800bf42:	f7fd fd75 	bl	8009a30 <celt_rcp>
      if (arg >= 32767)
         arg = 32767;
      return SHR16(celt_atan01(EXTRACT16(arg)),1);
 800bf46:	f647 71ff 	movw	r1, #32767	; 0x7fff
      arg = celt_div(SHL32(EXTEND32(y),15),x);
 800bf4a:	03ec      	lsls	r4, r5, #15
 800bf4c:	fb84 4500 	smull	r4, r5, r4, r0
 800bf50:	0fe3      	lsrs	r3, r4, #31
 800bf52:	ea43 0345 	orr.w	r3, r3, r5, lsl #1
      return SHR16(celt_atan01(EXTRACT16(arg)),1);
 800bf56:	428b      	cmp	r3, r1
 800bf58:	bfa8      	it	ge
 800bf5a:	460b      	movge	r3, r1
   return MULT16_16_P15(x, ADD32(M1, MULT16_16_P15(x, ADD32(M2, MULT16_16_P15(x, ADD32(M3, MULT16_16_P15(M4, x)))))));
 800bf5c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800bf60:	f241 3248 	movw	r2, #4936	; 0x1348
      return SHR16(celt_atan01(EXTRACT16(arg)),1);
 800bf64:	b21b      	sxth	r3, r3
   return MULT16_16_P15(x, ADD32(M1, MULT16_16_P15(x, ADD32(M2, MULT16_16_P15(x, ADD32(M3, MULT16_16_P15(M4, x)))))));
 800bf66:	fb13 0202 	smlabb	r2, r3, r2, r0
 800bf6a:	13d2      	asrs	r2, r2, #15
 800bf6c:	f5a2 523a 	sub.w	r2, r2, #11904	; 0x2e80
 800bf70:	3a27      	subs	r2, #39	; 0x27
 800bf72:	fb13 0202 	smlabb	r2, r3, r2, r0
 800bf76:	13d2      	asrs	r2, r2, #15
 800bf78:	3a15      	subs	r2, #21
 800bf7a:	fb13 0202 	smlabb	r2, r3, r2, r0
 800bf7e:	eb01 32e2 	add.w	r2, r1, r2, asr #15
 800bf82:	fb13 0002 	smlabb	r0, r3, r2, r0
#ifdef FIXED_POINT
   /* 0.63662 = 2/pi */
   itheta = MULT16_16_Q15(QCONST16(0.63662f,15),celt_atan2p(side, mid));
 800bf86:	f245 137d 	movw	r3, #20861	; 0x517d
      return SHR16(celt_atan01(EXTRACT16(arg)),1);
 800bf8a:	f340 400e 	sbfx	r0, r0, #16, #15
 800bf8e:	fb10 f003 	smulbb	r0, r0, r3
 800bf92:	13c0      	asrs	r0, r0, #15
#else
   itheta = (int)floor(.5f+16384*0.63662f*fast_atan2f(side,mid));
#endif

   return itheta;
}
 800bf94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   Emid = Eside = EPSILON;
 800bf96:	2701      	movs	r7, #1
      for (i=0;i<N;i++)
 800bf98:	2b00      	cmp	r3, #0
   Emid = Eside = EPSILON;
 800bf9a:	46bc      	mov	ip, r7
      for (i=0;i<N;i++)
 800bf9c:	ddc6      	ble.n	800bf2c <stereo_itheta+0x38>
 800bf9e:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 800bfa2:	1e9a      	subs	r2, r3, #2
 800bfa4:	1e86      	subs	r6, r0, #2
 800bfa6:	3902      	subs	r1, #2
         m = ADD16(SHR16(X[i],1),SHR16(Y[i],1));
 800bfa8:	f936 3f02 	ldrsh.w	r3, [r6, #2]!
 800bfac:	f931 5f02 	ldrsh.w	r5, [r1, #2]!
 800bfb0:	f3c3 034f 	ubfx	r3, r3, #1, #16
 800bfb4:	f3c5 054f 	ubfx	r5, r5, #1, #16
 800bfb8:	195c      	adds	r4, r3, r5
         s = SUB16(SHR16(X[i],1),SHR16(Y[i],1));
 800bfba:	1b5b      	subs	r3, r3, r5
         m = ADD16(SHR16(X[i],1),SHR16(Y[i],1));
 800bfbc:	b224      	sxth	r4, r4
         s = SUB16(SHR16(X[i],1),SHR16(Y[i],1));
 800bfbe:	b21b      	sxth	r3, r3
      for (i=0;i<N;i++)
 800bfc0:	42b2      	cmp	r2, r6
         Emid = MAC16_16(Emid, m, m);
 800bfc2:	fb04 cc04 	mla	ip, r4, r4, ip
         Eside = MAC16_16(Eside, s, s);
 800bfc6:	fb03 7703 	mla	r7, r3, r3, r7
      for (i=0;i<N;i++)
 800bfca:	d1ed      	bne.n	800bfa8 <stereo_itheta+0xb4>
 800bfcc:	e7ae      	b.n	800bf2c <stereo_itheta+0x38>
   } else {
      opus_val32 arg;
      arg = celt_div(SHL32(EXTEND32(x),15),y);
 800bfce:	4628      	mov	r0, r5
 800bfd0:	f7fd fd2e 	bl	8009a30 <celt_rcp>
      if (arg >= 32767)
         arg = 32767;
      return 25736-SHR16(celt_atan01(EXTRACT16(arg)),1);
 800bfd4:	f647 71ff 	movw	r1, #32767	; 0x7fff
      arg = celt_div(SHL32(EXTEND32(x),15),y);
 800bfd8:	03e4      	lsls	r4, r4, #15
 800bfda:	fb84 4500 	smull	r4, r5, r4, r0
 800bfde:	0fe3      	lsrs	r3, r4, #31
 800bfe0:	ea43 0345 	orr.w	r3, r3, r5, lsl #1
      return 25736-SHR16(celt_atan01(EXTRACT16(arg)),1);
 800bfe4:	428b      	cmp	r3, r1
 800bfe6:	bfa8      	it	ge
 800bfe8:	460b      	movge	r3, r1
   return MULT16_16_P15(x, ADD32(M1, MULT16_16_P15(x, ADD32(M2, MULT16_16_P15(x, ADD32(M3, MULT16_16_P15(M4, x)))))));
 800bfea:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800bfee:	f241 3248 	movw	r2, #4936	; 0x1348
      return 25736-SHR16(celt_atan01(EXTRACT16(arg)),1);
 800bff2:	b21b      	sxth	r3, r3
   return MULT16_16_P15(x, ADD32(M1, MULT16_16_P15(x, ADD32(M2, MULT16_16_P15(x, ADD32(M3, MULT16_16_P15(M4, x)))))));
 800bff4:	fb13 0202 	smlabb	r2, r3, r2, r0
 800bff8:	13d2      	asrs	r2, r2, #15
 800bffa:	f5a2 523a 	sub.w	r2, r2, #11904	; 0x2e80
 800bffe:	3a27      	subs	r2, #39	; 0x27
 800c000:	fb13 0202 	smlabb	r2, r3, r2, r0
 800c004:	13d2      	asrs	r2, r2, #15
 800c006:	3a15      	subs	r2, #21
 800c008:	fb13 0202 	smlabb	r2, r3, r2, r0
 800c00c:	eb01 32e2 	add.w	r2, r1, r2, asr #15
 800c010:	fb13 0002 	smlabb	r0, r3, r2, r0
   itheta = MULT16_16_Q15(QCONST16(0.63662f,15),celt_atan2p(side, mid));
 800c014:	f245 137d 	movw	r3, #20861	; 0x517d
      return 25736-SHR16(celt_atan01(EXTRACT16(arg)),1);
 800c018:	f340 400e 	sbfx	r0, r0, #16, #15
 800c01c:	f5c0 40c9 	rsb	r0, r0, #25728	; 0x6480
 800c020:	3008      	adds	r0, #8
 800c022:	b200      	sxth	r0, r0
 800c024:	fb10 f003 	smulbb	r0, r0, r3
 800c028:	13c0      	asrs	r0, r0, #15
}
 800c02a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c02c:	2701      	movs	r7, #1
      Emid += celt_inner_prod(X, X, N, arch);
 800c02e:	46bc      	mov	ip, r7
 800c030:	e77c      	b.n	800bf2c <stereo_itheta+0x38>
 800c032:	bf00      	nop

0800c034 <silk_CNG_Reset>:
    silk_decoder_state          *psDec                          /* I/O  Decoder state                               */
)
{
    opus_int i, NLSF_step_Q15, NLSF_acc_Q15;

    NLSF_step_Q15 = silk_DIV32_16( silk_int16_MAX, psDec->LPC_order + 1 );
 800c034:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800c038:	f8d0 1924 	ldr.w	r1, [r0, #2340]	; 0x924
{
 800c03c:	b410      	push	{r4}
    NLSF_step_Q15 = silk_DIV32_16( silk_int16_MAX, psDec->LPC_order + 1 );
 800c03e:	1c4b      	adds	r3, r1, #1
    NLSF_acc_Q15 = 0;
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c040:	2900      	cmp	r1, #0
    NLSF_step_Q15 = silk_DIV32_16( silk_int16_MAX, psDec->LPC_order + 1 );
 800c042:	fb92 f2f3 	sdiv	r2, r2, r3
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c046:	dd4c      	ble.n	800c0e2 <silk_CNG_Reset+0xae>
 800c048:	2901      	cmp	r1, #1
        NLSF_acc_Q15 += NLSF_step_Q15;
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c04a:	f8a0 2fd4 	strh.w	r2, [r0, #4052]	; 0xfd4
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c04e:	d048      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c050:	0053      	lsls	r3, r2, #1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c052:	2902      	cmp	r1, #2
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c054:	f8a0 3fd6 	strh.w	r3, [r0, #4054]	; 0xfd6
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c058:	d043      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c05a:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c05c:	2903      	cmp	r1, #3
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c05e:	f8a0 3fd8 	strh.w	r3, [r0, #4056]	; 0xfd8
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c062:	d03e      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c064:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c066:	2904      	cmp	r1, #4
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c068:	f8a0 3fda 	strh.w	r3, [r0, #4058]	; 0xfda
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c06c:	d039      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c06e:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c070:	2905      	cmp	r1, #5
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c072:	f8a0 3fdc 	strh.w	r3, [r0, #4060]	; 0xfdc
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c076:	d034      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c078:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c07a:	2906      	cmp	r1, #6
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c07c:	f8a0 3fde 	strh.w	r3, [r0, #4062]	; 0xfde
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c080:	d02f      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c082:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c084:	2907      	cmp	r1, #7
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c086:	f8a0 3fe0 	strh.w	r3, [r0, #4064]	; 0xfe0
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c08a:	d02a      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c08c:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c08e:	2908      	cmp	r1, #8
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c090:	f8a0 3fe2 	strh.w	r3, [r0, #4066]	; 0xfe2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c094:	d025      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c096:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c098:	2909      	cmp	r1, #9
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c09a:	f8a0 3fe4 	strh.w	r3, [r0, #4068]	; 0xfe4
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c09e:	d020      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c0a0:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0a2:	290a      	cmp	r1, #10
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c0a4:	f8a0 3fe6 	strh.w	r3, [r0, #4070]	; 0xfe6
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0a8:	d01b      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c0aa:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0ac:	290b      	cmp	r1, #11
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c0ae:	f8a0 3fe8 	strh.w	r3, [r0, #4072]	; 0xfe8
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0b2:	d016      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c0b4:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0b6:	290c      	cmp	r1, #12
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c0b8:	f8a0 3fea 	strh.w	r3, [r0, #4074]	; 0xfea
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0bc:	d011      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c0be:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0c0:	290d      	cmp	r1, #13
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c0c2:	f8a0 3fec 	strh.w	r3, [r0, #4076]	; 0xfec
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0c6:	d00c      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c0c8:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0ca:	290e      	cmp	r1, #14
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c0cc:	f8a0 3fee 	strh.w	r3, [r0, #4078]	; 0xfee
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0d0:	d007      	beq.n	800c0e2 <silk_CNG_Reset+0xae>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c0d2:	4413      	add	r3, r2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c0d4:	290f      	cmp	r1, #15
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c0d6:	f8a0 3ff0 	strh.w	r3, [r0, #4080]	; 0xff0
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c0da:	bf1c      	itt	ne
 800c0dc:	189b      	addne	r3, r3, r2
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c0de:	f8a0 3ff2 	strhne.w	r3, [r0, #4082]	; 0xff2
    }
    psDec->sCNG.CNG_smth_Gain_Q16 = 0;
 800c0e2:	2400      	movs	r4, #0
 800c0e4:	f241 0134 	movw	r1, #4148	; 0x1034
    psDec->sCNG.rand_seed = 3176576;
 800c0e8:	f241 0338 	movw	r3, #4152	; 0x1038
 800c0ec:	4a02      	ldr	r2, [pc, #8]	; (800c0f8 <silk_CNG_Reset+0xc4>)
    psDec->sCNG.CNG_smth_Gain_Q16 = 0;
 800c0ee:	5044      	str	r4, [r0, r1]
    psDec->sCNG.rand_seed = 3176576;
 800c0f0:	50c2      	str	r2, [r0, r3]
}
 800c0f2:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c0f6:	4770      	bx	lr
 800c0f8:	00307880 	.word	0x00307880

0800c0fc <silk_CNG>:
    silk_decoder_state          *psDec,                         /* I/O  Decoder state                               */
    silk_decoder_control        *psDecCtrl,                     /* I/O  Decoder control                             */
    opus_int16                  frame[],                        /* I/O  Signal                                      */
    opus_int                    length                          /* I    Length of residual                          */
)
{
 800c0fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c100:	b09f      	sub	sp, #124	; 0x7c
 800c102:	4604      	mov	r4, r0
    opus_int32 LPC_pred_Q10, max_Gain_Q16, gain_Q16, gain_Q10;
    opus_int16 A_Q12[ MAX_LPC_ORDER ];
    silk_CNG_struct *psCNG = &psDec->sCNG;
    SAVE_STACK;

    if( psDec->fs_kHz != psCNG->fs_kHz ) {
 800c104:	f241 053c 	movw	r5, #4156	; 0x103c
 800c108:	f8d0 090c 	ldr.w	r0, [r0, #2316]	; 0x90c
 800c10c:	5966      	ldr	r6, [r4, r5]
{
 800c10e:	af00      	add	r7, sp, #0
    if( psDec->fs_kHz != psCNG->fs_kHz ) {
 800c110:	42b0      	cmp	r0, r6
{
 800c112:	64fa      	str	r2, [r7, #76]	; 0x4c
 800c114:	468b      	mov	fp, r1
 800c116:	461d      	mov	r5, r3
 800c118:	f8d4 2924 	ldr.w	r2, [r4, #2340]	; 0x924
    if( psDec->fs_kHz != psCNG->fs_kHz ) {
 800c11c:	d060      	beq.n	800c1e0 <silk_CNG+0xe4>
    NLSF_step_Q15 = silk_DIV32_16( silk_int16_MAX, psDec->LPC_order + 1 );
 800c11e:	f647 71ff 	movw	r1, #32767	; 0x7fff
 800c122:	1c53      	adds	r3, r2, #1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c124:	2a00      	cmp	r2, #0
    NLSF_step_Q15 = silk_DIV32_16( silk_int16_MAX, psDec->LPC_order + 1 );
 800c126:	fb91 f1f3 	sdiv	r1, r1, r3
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c12a:	dd4c      	ble.n	800c1c6 <silk_CNG+0xca>
 800c12c:	2a01      	cmp	r2, #1
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c12e:	f8a4 1fd4 	strh.w	r1, [r4, #4052]	; 0xfd4
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c132:	d048      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c134:	004b      	lsls	r3, r1, #1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c136:	2a02      	cmp	r2, #2
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c138:	f8a4 3fd6 	strh.w	r3, [r4, #4054]	; 0xfd6
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c13c:	d043      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c13e:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c140:	2a03      	cmp	r2, #3
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c142:	f8a4 3fd8 	strh.w	r3, [r4, #4056]	; 0xfd8
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c146:	d03e      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c148:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c14a:	2a04      	cmp	r2, #4
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c14c:	f8a4 3fda 	strh.w	r3, [r4, #4058]	; 0xfda
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c150:	d039      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c152:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c154:	2a05      	cmp	r2, #5
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c156:	f8a4 3fdc 	strh.w	r3, [r4, #4060]	; 0xfdc
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c15a:	d034      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c15c:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c15e:	2a06      	cmp	r2, #6
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c160:	f8a4 3fde 	strh.w	r3, [r4, #4062]	; 0xfde
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c164:	d02f      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c166:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c168:	2a07      	cmp	r2, #7
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c16a:	f8a4 3fe0 	strh.w	r3, [r4, #4064]	; 0xfe0
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c16e:	d02a      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c170:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c172:	2a08      	cmp	r2, #8
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c174:	f8a4 3fe2 	strh.w	r3, [r4, #4066]	; 0xfe2
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c178:	d025      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c17a:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c17c:	2a09      	cmp	r2, #9
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c17e:	f8a4 3fe4 	strh.w	r3, [r4, #4068]	; 0xfe4
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c182:	d020      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c184:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c186:	2a0a      	cmp	r2, #10
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c188:	f8a4 3fe6 	strh.w	r3, [r4, #4070]	; 0xfe6
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c18c:	d01b      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c18e:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c190:	2a0b      	cmp	r2, #11
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c192:	f8a4 3fe8 	strh.w	r3, [r4, #4072]	; 0xfe8
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c196:	d016      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c198:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c19a:	2a0c      	cmp	r2, #12
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c19c:	f8a4 3fea 	strh.w	r3, [r4, #4074]	; 0xfea
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c1a0:	d011      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c1a2:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c1a4:	2a0d      	cmp	r2, #13
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c1a6:	f8a4 3fec 	strh.w	r3, [r4, #4076]	; 0xfec
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c1aa:	d00c      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c1ac:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c1ae:	2a0e      	cmp	r2, #14
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c1b0:	f8a4 3fee 	strh.w	r3, [r4, #4078]	; 0xfee
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c1b4:	d007      	beq.n	800c1c6 <silk_CNG+0xca>
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c1b6:	440b      	add	r3, r1
    for( i = 0; i < psDec->LPC_order; i++ ) {
 800c1b8:	2a0f      	cmp	r2, #15
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c1ba:	f8a4 3ff0 	strh.w	r3, [r4, #4080]	; 0xff0
        NLSF_acc_Q15 += NLSF_step_Q15;
 800c1be:	bf1c      	itt	ne
 800c1c0:	185b      	addne	r3, r3, r1
        psDec->sCNG.CNG_smth_NLSF_Q15[ i ] = NLSF_acc_Q15;
 800c1c2:	f8a4 3ff2 	strhne.w	r3, [r4, #4082]	; 0xff2
    psDec->sCNG.CNG_smth_Gain_Q16 = 0;
 800c1c6:	f241 0134 	movw	r1, #4148	; 0x1034
 800c1ca:	f04f 0c00 	mov.w	ip, #0
    psDec->sCNG.rand_seed = 3176576;
 800c1ce:	f241 0338 	movw	r3, #4152	; 0x1038
        /* Reset state */
        silk_CNG_Reset( psDec );

        psCNG->fs_kHz = psDec->fs_kHz;
 800c1d2:	f241 063c 	movw	r6, #4156	; 0x103c
    psDec->sCNG.CNG_smth_Gain_Q16 = 0;
 800c1d6:	f844 c001 	str.w	ip, [r4, r1]
    psDec->sCNG.rand_seed = 3176576;
 800c1da:	4933      	ldr	r1, [pc, #204]	; (800c2a8 <silk_CNG+0x1ac>)
        psCNG->fs_kHz = psDec->fs_kHz;
 800c1dc:	51a0      	str	r0, [r4, r6]
    psDec->sCNG.rand_seed = 3176576;
 800c1de:	50e1      	str	r1, [r4, r3]
    }
    if( psDec->lossCnt == 0 && psDec->prevSignalType == TYPE_NO_VOICE_ACTIVITY ) {
 800c1e0:	f504 5882 	add.w	r8, r4, #4160	; 0x1040
 800c1e4:	f8d8 3000 	ldr.w	r3, [r8]
 800c1e8:	2b00      	cmp	r3, #0
 800c1ea:	d05f      	beq.n	800c2ac <silk_CNG+0x1b0>
 800c1ec:	f604 29d4 	addw	r9, r4, #2772	; 0xad4
    if( psDec->lossCnt ) {
        VARDECL( opus_int32, CNG_sig_Q14 );
        ALLOC( CNG_sig_Q14, length + MAX_LPC_ORDER, opus_int32 );

        /* Generate CNG excitation */
        gain_Q16 = silk_SMULWW( psDec->sPLC.randScale_Q14, psDec->sPLC.prevGain_Q16[1] );
 800c1f0:	f241 0184 	movw	r1, #4228	; 0x1084
 800c1f4:	f241 0398 	movw	r3, #4248	; 0x1098
 800c1f8:	f241 0634 	movw	r6, #4148	; 0x1034
        ALLOC( CNG_sig_Q14, length + MAX_LPC_ORDER, opus_int32 );
 800c1fc:	f105 0b10 	add.w	fp, r5, #16
 800c200:	ea4f 008b 	mov.w	r0, fp, lsl #2
 800c204:	6538      	str	r0, [r7, #80]	; 0x50
        gain_Q16 = silk_SMULWW( psDec->sPLC.randScale_Q14, psDec->sPLC.prevGain_Q16[1] );
 800c206:	f934 c001 	ldrsh.w	ip, [r4, r1]
        ALLOC( CNG_sig_Q14, length + MAX_LPC_ORDER, opus_int32 );
 800c20a:	300a      	adds	r0, #10
#undef silk_SMULWW
static OPUS_INLINE opus_int32 silk_SMULWW_armv4(opus_int32 a, opus_int32 b)
{
  unsigned rd_lo;
  int rd_hi;
  __asm__(
 800c20c:	f854 e003 	ldr.w	lr, [r4, r3]
 800c210:	fb8c 310e 	smull	r3, r1, ip, lr
    "#silk_SMULWW\n\t"
    "smull %0, %1, %2, %3\n\t"
    : "=&r"(rd_lo), "=&r"(rd_hi)
    : "%r"(a), "r"(b)
  );
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c214:	0409      	lsls	r1, r1, #16
 800c216:	eb01 4113 	add.w	r1, r1, r3, lsr #16
 800c21a:	f020 0007 	bic.w	r0, r0, #7
    if( psDec->lossCnt ) {
 800c21e:	f8c7 d010 	str.w	sp, [r7, #16]
        if( gain_Q16 >= (1 << 21) || psCNG->CNG_smth_Gain_Q16 > (1 << 23) ) {
 800c222:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
        ALLOC( CNG_sig_Q14, length + MAX_LPC_ORDER, opus_int32 );
 800c226:	ebad 0d00 	sub.w	sp, sp, r0
 800c22a:	f8c7 d034 	str.w	sp, [r7, #52]	; 0x34
 800c22e:	59a3      	ldr	r3, [r4, r6]
        if( gain_Q16 >= (1 << 21) || psCNG->CNG_smth_Gain_Q16 > (1 << 23) ) {
 800c230:	f2c0 81a4 	blt.w	800c57c <silk_CNG+0x480>
            gain_Q16 = silk_SMULTT( gain_Q16, gain_Q16 );
 800c234:	fb11 f131 	smultt	r1, r1, r1
            gain_Q16 = silk_SUB_LSHIFT32(silk_SMULTT( psCNG->CNG_smth_Gain_Q16, psCNG->CNG_smth_Gain_Q16 ), gain_Q16, 5 );
 800c238:	fb13 f333 	smultt	r3, r3, r3
 800c23c:	eba3 1341 	sub.w	r3, r3, r1, lsl #5
/*           < +/- 2.5% for output values > 120                          */
static OPUS_INLINE opus_int32 silk_SQRT_APPROX( opus_int32 x )
{
    opus_int32 y, lz, frac_Q7;

    if( x <= 0 ) {
 800c240:	2b00      	cmp	r3, #0
 800c242:	f340 81d2 	ble.w	800c5ea <silk_CNG+0x4ee>
#endif

#ifndef OVERRIDE_silk_CLZ32
static OPUS_INLINE opus_int32 silk_CLZ32(opus_int32 in32)
{
    return in32 ? 32 - EC_ILOG(in32) : 32;
 800c246:	fab3 f183 	clz	r1, r3
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
 800c24a:	f1c1 0018 	rsb	r0, r1, #24
static OPUS_INLINE opus_int32 silk_ROR32( opus_int32 a32, opus_int rot )
{
    opus_uint32 x = (opus_uint32) a32;
    opus_uint32 r = (opus_uint32) rot;
    opus_uint32 m = (opus_uint32) -rot;
    if( rot == 0 ) {
 800c24e:	2800      	cmp	r0, #0
 800c250:	f040 8389 	bne.w	800c966 <silk_CNG+0x86a>
    }

    silk_CLZ_FRAC(x, &lz, &frac_Q7);

    if( lz & 1 ) {
        y = 32768;
 800c254:	f011 0f01 	tst.w	r1, #1
 800c258:	f24b 4086 	movw	r0, #46214	; 0xb486
 800c25c:	bf18      	it	ne
 800c25e:	f44f 4000 	movne.w	r0, #32768	; 0x8000
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
 800c262:	f003 037f 	and.w	r3, r3, #127	; 0x7f

    /* get scaling right */
    y >>= silk_RSHIFT(lz, 1);

    /* increment using fractional part of input */
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
 800c266:	eb03 06c3 	add.w	r6, r3, r3, lsl #3
 800c26a:	ebc3 03c6 	rsb	r3, r3, r6, lsl #3
    y >>= silk_RSHIFT(lz, 1);
 800c26e:	1049      	asrs	r1, r1, #1
 800c270:	fa40 f101 	asr.w	r1, r0, r1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
 800c274:	ebc3 0383 	rsb	r3, r3, r3, lsl #2
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800c278:	041b      	lsls	r3, r3, #16
  __asm__(
 800c27a:	fb81 6003 	smull	r6, r0, r1, r3
 800c27e:	4401      	add	r1, r0
 800c280:	0409      	lsls	r1, r1, #16
    while( exc_mask > length ) {
 800c282:	2dfe      	cmp	r5, #254	; 0xfe
 800c284:	ea4f 1ba1 	mov.w	fp, r1, asr #6
 800c288:	f340 81b4 	ble.w	800c5f4 <silk_CNG+0x4f8>
 800c28c:	f241 0348 	movw	r3, #4168	; 0x1048
    seed = *rand_seed;
 800c290:	f241 0138 	movw	r1, #4152	; 0x1038
 800c294:	58e3      	ldr	r3, [r4, r3]
 800c296:	5866      	ldr	r6, [r4, r1]
 800c298:	657b      	str	r3, [r7, #84]	; 0x54
 800c29a:	f604 73f4 	addw	r3, r4, #4084	; 0xff4
 800c29e:	f604 71d4 	addw	r1, r4, #4052	; 0xfd4
 800c2a2:	62fb      	str	r3, [r7, #44]	; 0x2c
    exc_mask = CNG_BUF_MASK_MAX;
 800c2a4:	20ff      	movs	r0, #255	; 0xff
 800c2a6:	e1b8      	b.n	800c61a <silk_CNG+0x51e>
 800c2a8:	00307880 	.word	0x00307880
    if( psDec->lossCnt == 0 && psDec->prevSignalType == TYPE_NO_VOICE_ACTIVITY ) {
 800c2ac:	f241 0344 	movw	r3, #4164	; 0x1044
 800c2b0:	58e6      	ldr	r6, [r4, r3]
 800c2b2:	2e00      	cmp	r6, #0
 800c2b4:	f040 8154 	bne.w	800c560 <silk_CNG+0x464>
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c2b8:	2a00      	cmp	r2, #0
 800c2ba:	f340 80de 	ble.w	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c2be:	f9b4 cfd4 	ldrsh.w	ip, [r4, #4052]	; 0xfd4
 800c2c2:	f9b4 3928 	ldrsh.w	r3, [r4, #2344]	; 0x928
 800c2c6:	49ab      	ldr	r1, [pc, #684]	; (800c574 <silk_CNG+0x478>)
 800c2c8:	eba3 030c 	sub.w	r3, r3, ip
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c2cc:	2a01      	cmp	r2, #1
 800c2ce:	fb83 e001 	smull	lr, r0, r3, r1
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c2d2:	eb00 030c 	add.w	r3, r0, ip
 800c2d6:	f8a4 3fd4 	strh.w	r3, [r4, #4052]	; 0xfd4
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c2da:	f000 80ce 	beq.w	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c2de:	f9b4 cfd6 	ldrsh.w	ip, [r4, #4054]	; 0xfd6
 800c2e2:	f9b4 392a 	ldrsh.w	r3, [r4, #2346]	; 0x92a
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c2e6:	2a02      	cmp	r2, #2
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c2e8:	eba3 030c 	sub.w	r3, r3, ip
 800c2ec:	fb83 e001 	smull	lr, r0, r3, r1
 800c2f0:	eb00 030c 	add.w	r3, r0, ip
 800c2f4:	f8a4 3fd6 	strh.w	r3, [r4, #4054]	; 0xfd6
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c2f8:	f000 80bf 	beq.w	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c2fc:	f9b4 cfd8 	ldrsh.w	ip, [r4, #4056]	; 0xfd8
 800c300:	f9b4 392c 	ldrsh.w	r3, [r4, #2348]	; 0x92c
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c304:	2a03      	cmp	r2, #3
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c306:	eba3 030c 	sub.w	r3, r3, ip
 800c30a:	fb83 e001 	smull	lr, r0, r3, r1
 800c30e:	eb00 030c 	add.w	r3, r0, ip
 800c312:	f8a4 3fd8 	strh.w	r3, [r4, #4056]	; 0xfd8
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c316:	f000 80b0 	beq.w	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c31a:	f9b4 cfda 	ldrsh.w	ip, [r4, #4058]	; 0xfda
 800c31e:	f9b4 392e 	ldrsh.w	r3, [r4, #2350]	; 0x92e
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c322:	2a04      	cmp	r2, #4
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c324:	eba3 030c 	sub.w	r3, r3, ip
 800c328:	fb83 e001 	smull	lr, r0, r3, r1
 800c32c:	eb00 030c 	add.w	r3, r0, ip
 800c330:	f8a4 3fda 	strh.w	r3, [r4, #4058]	; 0xfda
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c334:	f000 80a1 	beq.w	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c338:	f9b4 cfdc 	ldrsh.w	ip, [r4, #4060]	; 0xfdc
 800c33c:	f9b4 3930 	ldrsh.w	r3, [r4, #2352]	; 0x930
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c340:	2a05      	cmp	r2, #5
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c342:	eba3 030c 	sub.w	r3, r3, ip
 800c346:	fb83 e001 	smull	lr, r0, r3, r1
 800c34a:	eb00 030c 	add.w	r3, r0, ip
 800c34e:	f8a4 3fdc 	strh.w	r3, [r4, #4060]	; 0xfdc
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c352:	f000 8092 	beq.w	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c356:	f9b4 cfde 	ldrsh.w	ip, [r4, #4062]	; 0xfde
 800c35a:	f9b4 3932 	ldrsh.w	r3, [r4, #2354]	; 0x932
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c35e:	2a06      	cmp	r2, #6
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c360:	eba3 030c 	sub.w	r3, r3, ip
 800c364:	fb83 e001 	smull	lr, r0, r3, r1
 800c368:	eb00 030c 	add.w	r3, r0, ip
 800c36c:	f8a4 3fde 	strh.w	r3, [r4, #4062]	; 0xfde
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c370:	f000 8083 	beq.w	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c374:	f9b4 cfe0 	ldrsh.w	ip, [r4, #4064]	; 0xfe0
 800c378:	f9b4 3934 	ldrsh.w	r3, [r4, #2356]	; 0x934
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c37c:	2a07      	cmp	r2, #7
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c37e:	eba3 030c 	sub.w	r3, r3, ip
 800c382:	fb83 e001 	smull	lr, r0, r3, r1
 800c386:	eb00 030c 	add.w	r3, r0, ip
 800c38a:	f8a4 3fe0 	strh.w	r3, [r4, #4064]	; 0xfe0
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c38e:	d074      	beq.n	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c390:	f9b4 cfe2 	ldrsh.w	ip, [r4, #4066]	; 0xfe2
 800c394:	f9b4 1936 	ldrsh.w	r1, [r4, #2358]	; 0x936
 800c398:	4b76      	ldr	r3, [pc, #472]	; (800c574 <silk_CNG+0x478>)
 800c39a:	eba1 010c 	sub.w	r1, r1, ip
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c39e:	2a08      	cmp	r2, #8
 800c3a0:	fb81 e003 	smull	lr, r0, r1, r3
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c3a4:	eb00 010c 	add.w	r1, r0, ip
 800c3a8:	f8a4 1fe2 	strh.w	r1, [r4, #4066]	; 0xfe2
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c3ac:	d065      	beq.n	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c3ae:	f9b4 cfe4 	ldrsh.w	ip, [r4, #4068]	; 0xfe4
 800c3b2:	f9b4 1938 	ldrsh.w	r1, [r4, #2360]	; 0x938
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c3b6:	2a09      	cmp	r2, #9
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c3b8:	eba1 010c 	sub.w	r1, r1, ip
 800c3bc:	fb81 e003 	smull	lr, r0, r1, r3
 800c3c0:	eb00 010c 	add.w	r1, r0, ip
 800c3c4:	f8a4 1fe4 	strh.w	r1, [r4, #4068]	; 0xfe4
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c3c8:	d057      	beq.n	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c3ca:	f9b4 1fe6 	ldrsh.w	r1, [r4, #4070]	; 0xfe6
 800c3ce:	f9b4 093a 	ldrsh.w	r0, [r4, #2362]	; 0x93a
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c3d2:	2a0a      	cmp	r2, #10
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c3d4:	eba0 0001 	sub.w	r0, r0, r1
 800c3d8:	fb80 ec03 	smull	lr, ip, r0, r3
 800c3dc:	4461      	add	r1, ip
 800c3de:	f8a4 1fe6 	strh.w	r1, [r4, #4070]	; 0xfe6
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c3e2:	d04a      	beq.n	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c3e4:	f9b4 1fe8 	ldrsh.w	r1, [r4, #4072]	; 0xfe8
 800c3e8:	f9b4 093c 	ldrsh.w	r0, [r4, #2364]	; 0x93c
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c3ec:	2a0b      	cmp	r2, #11
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c3ee:	eba0 0001 	sub.w	r0, r0, r1
 800c3f2:	fb80 ec03 	smull	lr, ip, r0, r3
 800c3f6:	4461      	add	r1, ip
 800c3f8:	f8a4 1fe8 	strh.w	r1, [r4, #4072]	; 0xfe8
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c3fc:	d03d      	beq.n	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c3fe:	f9b4 1fea 	ldrsh.w	r1, [r4, #4074]	; 0xfea
 800c402:	f9b4 093e 	ldrsh.w	r0, [r4, #2366]	; 0x93e
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c406:	2a0c      	cmp	r2, #12
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c408:	eba0 0001 	sub.w	r0, r0, r1
 800c40c:	fb80 ec03 	smull	lr, ip, r0, r3
 800c410:	4461      	add	r1, ip
 800c412:	f8a4 1fea 	strh.w	r1, [r4, #4074]	; 0xfea
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c416:	d030      	beq.n	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c418:	f9b4 1fec 	ldrsh.w	r1, [r4, #4076]	; 0xfec
 800c41c:	f9b4 0940 	ldrsh.w	r0, [r4, #2368]	; 0x940
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c420:	2a0d      	cmp	r2, #13
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c422:	eba0 0001 	sub.w	r0, r0, r1
 800c426:	fb80 ec03 	smull	lr, ip, r0, r3
 800c42a:	4461      	add	r1, ip
 800c42c:	f8a4 1fec 	strh.w	r1, [r4, #4076]	; 0xfec
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c430:	d023      	beq.n	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c432:	f9b4 1fee 	ldrsh.w	r1, [r4, #4078]	; 0xfee
 800c436:	f9b4 0942 	ldrsh.w	r0, [r4, #2370]	; 0x942
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c43a:	2a0e      	cmp	r2, #14
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c43c:	eba0 0001 	sub.w	r0, r0, r1
 800c440:	fb80 ec03 	smull	lr, ip, r0, r3
 800c444:	4461      	add	r1, ip
 800c446:	f8a4 1fee 	strh.w	r1, [r4, #4078]	; 0xfee
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c44a:	d016      	beq.n	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c44c:	f9b4 1ff0 	ldrsh.w	r1, [r4, #4080]	; 0xff0
 800c450:	f9b4 0944 	ldrsh.w	r0, [r4, #2372]	; 0x944
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c454:	2a0f      	cmp	r2, #15
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c456:	eba0 0001 	sub.w	r0, r0, r1
 800c45a:	fb80 ec03 	smull	lr, ip, r0, r3
 800c45e:	4461      	add	r1, ip
 800c460:	f8a4 1ff0 	strh.w	r1, [r4, #4080]	; 0xff0
        for( i = 0; i < psDec->LPC_order; i++ ) {
 800c464:	d009      	beq.n	800c47a <silk_CNG+0x37e>
            psCNG->CNG_smth_NLSF_Q15[ i ] += silk_SMULWB( (opus_int32)psDec->prevNLSF_Q15[ i ] - (opus_int32)psCNG->CNG_smth_NLSF_Q15[ i ], CNG_NLSF_SMTH_Q16 );
 800c466:	f9b4 2ff2 	ldrsh.w	r2, [r4, #4082]	; 0xff2
 800c46a:	f9b4 1946 	ldrsh.w	r1, [r4, #2374]	; 0x946
 800c46e:	1a89      	subs	r1, r1, r2
 800c470:	fb81 c003 	smull	ip, r0, r1, r3
 800c474:	4402      	add	r2, r0
 800c476:	f8a4 2ff2 	strh.w	r2, [r4, #4082]	; 0xff2
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c47a:	f8d4 a914 	ldr.w	sl, [r4, #2324]	; 0x914
 800c47e:	f1ba 0f00 	cmp.w	sl, #0
 800c482:	dd1d      	ble.n	800c4c0 <silk_CNG+0x3c4>
 800c484:	f8db 3010 	ldr.w	r3, [fp, #16]
 800c488:	f1ba 0f01 	cmp.w	sl, #1
 800c48c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800c490:	d016      	beq.n	800c4c0 <silk_CNG+0x3c4>
            if( psDecCtrl->Gains_Q16[ i ] > max_Gain_Q16 ) {
 800c492:	f8db 2014 	ldr.w	r2, [fp, #20]
 800c496:	429a      	cmp	r2, r3
 800c498:	bfd4      	ite	le
 800c49a:	461a      	movle	r2, r3
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c49c:	2601      	movgt	r6, #1
 800c49e:	f1ba 0f02 	cmp.w	sl, #2
 800c4a2:	d00d      	beq.n	800c4c0 <silk_CNG+0x3c4>
            if( psDecCtrl->Gains_Q16[ i ] > max_Gain_Q16 ) {
 800c4a4:	f8db 1018 	ldr.w	r1, [fp, #24]
 800c4a8:	4291      	cmp	r1, r2
 800c4aa:	bfd4      	ite	le
 800c4ac:	4611      	movle	r1, r2
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c4ae:	2602      	movgt	r6, #2
 800c4b0:	f1ba 0f03 	cmp.w	sl, #3
 800c4b4:	d004      	beq.n	800c4c0 <silk_CNG+0x3c4>
            if( psDecCtrl->Gains_Q16[ i ] > max_Gain_Q16 ) {
 800c4b6:	f8db 301c 	ldr.w	r3, [fp, #28]
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c4ba:	4299      	cmp	r1, r3
 800c4bc:	bfb8      	it	lt
 800c4be:	2603      	movlt	r6, #3
        silk_memmove( &psCNG->CNG_exc_buf_Q14[ psDec->subfr_length ], psCNG->CNG_exc_buf_Q14, ( psDec->nb_subfr - 1 ) * psDec->subfr_length * sizeof( opus_int32 ) );
 800c4c0:	f8d4 391c 	ldr.w	r3, [r4, #2332]	; 0x91c
 800c4c4:	f10a 32ff 	add.w	r2, sl, #4294967295
 800c4c8:	fb03 f202 	mul.w	r2, r3, r2
 800c4cc:	0099      	lsls	r1, r3, #2
 800c4ce:	f604 29d4 	addw	r9, r4, #2772	; 0xad4
 800c4d2:	0092      	lsls	r2, r2, #2
 800c4d4:	6579      	str	r1, [r7, #84]	; 0x54
 800c4d6:	eb09 0001 	add.w	r0, r9, r1
 800c4da:	4649      	mov	r1, r9
 800c4dc:	653b      	str	r3, [r7, #80]	; 0x50
 800c4de:	f007 fe0a 	bl	80140f6 <memmove>
        silk_memcpy(   psCNG->CNG_exc_buf_Q14, &psDec->exc_Q14[ subfr * psDec->subfr_length ], psDec->subfr_length * sizeof( opus_int32 ) );
 800c4e2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c4e4:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800c4e6:	fb06 f603 	mul.w	r6, r6, r3
 800c4ea:	1c71      	adds	r1, r6, #1
 800c4ec:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 800c4f0:	4648      	mov	r0, r9
 800c4f2:	f007 fdf5 	bl	80140e0 <memcpy>
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c4f6:	f1ba 0f00 	cmp.w	sl, #0
 800c4fa:	dd2a      	ble.n	800c552 <silk_CNG+0x456>
 800c4fc:	f241 0234 	movw	r2, #4148	; 0x1034
            psCNG->CNG_smth_Gain_Q16 += silk_SMULWB( psDecCtrl->Gains_Q16[ i ] - psCNG->CNG_smth_Gain_Q16, CNG_GAIN_SMTH_Q16 );
 800c500:	f8db 3010 	ldr.w	r3, [fp, #16]
 800c504:	58a2      	ldr	r2, [r4, r2]
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c506:	f1ba 0f01 	cmp.w	sl, #1
            psCNG->CNG_smth_Gain_Q16 += silk_SMULWB( psDecCtrl->Gains_Q16[ i ] - psCNG->CNG_smth_Gain_Q16, CNG_GAIN_SMTH_Q16 );
 800c50a:	eba3 0302 	sub.w	r3, r3, r2
 800c50e:	491a      	ldr	r1, [pc, #104]	; (800c578 <silk_CNG+0x47c>)
 800c510:	fb83 6001 	smull	r6, r0, r3, r1
 800c514:	4402      	add	r2, r0
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c516:	d019      	beq.n	800c54c <silk_CNG+0x450>
            psCNG->CNG_smth_Gain_Q16 += silk_SMULWB( psDecCtrl->Gains_Q16[ i ] - psCNG->CNG_smth_Gain_Q16, CNG_GAIN_SMTH_Q16 );
 800c518:	f8db 3014 	ldr.w	r3, [fp, #20]
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c51c:	f1ba 0f02 	cmp.w	sl, #2
            psCNG->CNG_smth_Gain_Q16 += silk_SMULWB( psDecCtrl->Gains_Q16[ i ] - psCNG->CNG_smth_Gain_Q16, CNG_GAIN_SMTH_Q16 );
 800c520:	eba3 0302 	sub.w	r3, r3, r2
 800c524:	fb83 6001 	smull	r6, r0, r3, r1
 800c528:	4402      	add	r2, r0
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c52a:	d00f      	beq.n	800c54c <silk_CNG+0x450>
            psCNG->CNG_smth_Gain_Q16 += silk_SMULWB( psDecCtrl->Gains_Q16[ i ] - psCNG->CNG_smth_Gain_Q16, CNG_GAIN_SMTH_Q16 );
 800c52c:	f8db 3018 	ldr.w	r3, [fp, #24]
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c530:	f1ba 0f03 	cmp.w	sl, #3
            psCNG->CNG_smth_Gain_Q16 += silk_SMULWB( psDecCtrl->Gains_Q16[ i ] - psCNG->CNG_smth_Gain_Q16, CNG_GAIN_SMTH_Q16 );
 800c534:	eba3 0302 	sub.w	r3, r3, r2
 800c538:	fb83 6001 	smull	r6, r0, r3, r1
 800c53c:	4402      	add	r2, r0
        for( i = 0; i < psDec->nb_subfr; i++ ) {
 800c53e:	d005      	beq.n	800c54c <silk_CNG+0x450>
            psCNG->CNG_smth_Gain_Q16 += silk_SMULWB( psDecCtrl->Gains_Q16[ i ] - psCNG->CNG_smth_Gain_Q16, CNG_GAIN_SMTH_Q16 );
 800c540:	f8db 301c 	ldr.w	r3, [fp, #28]
 800c544:	1a9b      	subs	r3, r3, r2
 800c546:	fb83 6001 	smull	r6, r0, r3, r1
 800c54a:	4402      	add	r2, r0
 800c54c:	f241 0334 	movw	r3, #4148	; 0x1034
 800c550:	50e2      	str	r2, [r4, r3]
    if( psDec->lossCnt ) {
 800c552:	f8d8 3000 	ldr.w	r3, [r8]
 800c556:	f8d4 2924 	ldr.w	r2, [r4, #2340]	; 0x924
 800c55a:	2b00      	cmp	r3, #0
 800c55c:	f47f ae48 	bne.w	800c1f0 <silk_CNG+0xf4>
            frame[ i ] = (opus_int16)silk_ADD_SAT16( frame[ i ], silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( CNG_sig_Q14[ MAX_LPC_ORDER + i ], gain_Q10 ), 8 ) ) );

        }
        silk_memcpy( psCNG->CNG_synth_state, &CNG_sig_Q14[ length ], MAX_LPC_ORDER * sizeof( opus_int32 ) );
    } else {
        silk_memset( psCNG->CNG_synth_state, 0, psDec->LPC_order *  sizeof( opus_int32 ) );
 800c560:	0092      	lsls	r2, r2, #2
 800c562:	f604 70f4 	addw	r0, r4, #4084	; 0xff4
 800c566:	2100      	movs	r1, #0
 800c568:	f007 fdde 	bl	8014128 <memset>
    }
    RESTORE_STACK;
}
 800c56c:	377c      	adds	r7, #124	; 0x7c
 800c56e:	46bd      	mov	sp, r7
 800c570:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c574:	3fdc0000 	.word	0x3fdc0000
 800c578:	121a0000 	.word	0x121a0000
        if( gain_Q16 >= (1 << 21) || psCNG->CNG_smth_Gain_Q16 > (1 << 23) ) {
 800c57c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800c580:	f73f ae58 	bgt.w	800c234 <silk_CNG+0x138>
  __asm__(
 800c584:	fb81 6001 	smull	r6, r0, r1, r1
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c588:	0c31      	lsrs	r1, r6, #16
  __asm__(
 800c58a:	fb83 c603 	smull	ip, r6, r3, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c58e:	ea4f 431c 	mov.w	r3, ip, lsr #16
 800c592:	eb01 4100 	add.w	r1, r1, r0, lsl #16
 800c596:	eb03 4306 	add.w	r3, r3, r6, lsl #16
            gain_Q16 = silk_SUB_LSHIFT32(silk_SMULWW( psCNG->CNG_smth_Gain_Q16, psCNG->CNG_smth_Gain_Q16 ), gain_Q16, 5 );
 800c59a:	eba3 1341 	sub.w	r3, r3, r1, lsl #5
    if( x <= 0 ) {
 800c59e:	2b00      	cmp	r3, #0
 800c5a0:	dd23      	ble.n	800c5ea <silk_CNG+0x4ee>
 800c5a2:	fab3 f083 	clz	r0, r3
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
 800c5a6:	f1c0 0118 	rsb	r1, r0, #24
 800c5aa:	2900      	cmp	r1, #0
 800c5ac:	d002      	beq.n	800c5b4 <silk_CNG+0x4b8>
        return a32;
    } else if( rot < 0 ) {
        return (opus_int32) ((x << m) | (x >> (32 - m)));
 800c5ae:	bfb8      	it	lt
 800c5b0:	3120      	addlt	r1, #32
    } else {
        return (opus_int32) ((x << (32 - r)) | (x >> r));
 800c5b2:	41cb      	rors	r3, r1
        y = 32768;
 800c5b4:	f24b 4186 	movw	r1, #46214	; 0xb486
 800c5b8:	f010 0f01 	tst.w	r0, #1
 800c5bc:	bf0c      	ite	eq
 800c5be:	460e      	moveq	r6, r1
 800c5c0:	f44f 4600 	movne.w	r6, #32768	; 0x8000
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
 800c5c4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
 800c5c8:	eb03 0cc3 	add.w	ip, r3, r3, lsl #3
    y >>= silk_RSHIFT(lz, 1);
 800c5cc:	1041      	asrs	r1, r0, #1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
 800c5ce:	ebc3 03cc 	rsb	r3, r3, ip, lsl #3
    y >>= silk_RSHIFT(lz, 1);
 800c5d2:	fa46 f101 	asr.w	r1, r6, r1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
 800c5d6:	ebc3 0383 	rsb	r3, r3, r3, lsl #2
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800c5da:	041b      	lsls	r3, r3, #16
  __asm__(
 800c5dc:	fb81 6003 	smull	r6, r0, r1, r3
 800c5e0:	4401      	add	r1, r0
 800c5e2:	0209      	lsls	r1, r1, #8
 800c5e4:	ea4f 1ba1 	mov.w	fp, r1, asr #6
 800c5e8:	e001      	b.n	800c5ee <silk_CNG+0x4f2>
    if( x <= 0 ) {
 800c5ea:	f04f 0b00 	mov.w	fp, #0
    while( exc_mask > length ) {
 800c5ee:	2dfe      	cmp	r5, #254	; 0xfe
 800c5f0:	f73f ae4c 	bgt.w	800c28c <silk_CNG+0x190>
    exc_mask = CNG_BUF_MASK_MAX;
 800c5f4:	20ff      	movs	r0, #255	; 0xff
        exc_mask = silk_RSHIFT( exc_mask, 1 );
 800c5f6:	1040      	asrs	r0, r0, #1
    while( exc_mask > length ) {
 800c5f8:	4285      	cmp	r5, r0
 800c5fa:	dbfc      	blt.n	800c5f6 <silk_CNG+0x4fa>
 800c5fc:	f241 0348 	movw	r3, #4168	; 0x1048
    seed = *rand_seed;
 800c600:	f241 0138 	movw	r1, #4152	; 0x1038
 800c604:	58e3      	ldr	r3, [r4, r3]
    for( i = 0; i < length; i++ ) {
 800c606:	2d00      	cmp	r5, #0
 800c608:	657b      	str	r3, [r7, #84]	; 0x54
 800c60a:	f604 73f4 	addw	r3, r4, #4084	; 0xff4
    seed = *rand_seed;
 800c60e:	5866      	ldr	r6, [r4, r1]
 800c610:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c612:	f604 71d4 	addw	r1, r4, #4052	; 0xfd4
    for( i = 0; i < length; i++ ) {
 800c616:	f340 81dd 	ble.w	800c9d4 <silk_CNG+0x8d8>
 800c61a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c61c:	6d3d      	ldr	r5, [r7, #80]	; 0x50
        seed = silk_RAND( seed );
 800c61e:	f8df a3e8 	ldr.w	sl, [pc, #1000]	; 800ca08 <silk_CNG+0x90c>
 800c622:	f1a5 0e04 	sub.w	lr, r5, #4
 800c626:	461d      	mov	r5, r3
 800c628:	f8df 83e0 	ldr.w	r8, [pc, #992]	; 800ca0c <silk_CNG+0x910>
 800c62c:	633b      	str	r3, [r7, #48]	; 0x30
 800c62e:	449e      	add	lr, r3
 800c630:	f103 0c3c 	add.w	ip, r3, #60	; 0x3c
 800c634:	fb0a 8606 	mla	r6, sl, r6, r8
        idx = (opus_int)( silk_RSHIFT( seed, 24 ) & exc_mask );
 800c638:	ea00 6326 	and.w	r3, r0, r6, asr #24
        exc_Q14[ i ] = exc_buf_Q14[ idx ];
 800c63c:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 800c640:	f84c 3f04 	str.w	r3, [ip, #4]!
    for( i = 0; i < length; i++ ) {
 800c644:	45f4      	cmp	ip, lr
 800c646:	d1f5      	bne.n	800c634 <silk_CNG+0x538>
    *rand_seed = seed;
 800c648:	f241 0038 	movw	r0, #4152	; 0x1038
        silk_NLSF2A( A_Q12, psCNG->CNG_smth_NLSF_Q15, psDec->LPC_order, psDec->arch );
 800c64c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    *rand_seed = seed;
 800c64e:	5026      	str	r6, [r4, r0]
        silk_NLSF2A( A_Q12, psCNG->CNG_smth_NLSF_Q15, psDec->LPC_order, psDec->arch );
 800c650:	f107 0058 	add.w	r0, r7, #88	; 0x58
 800c654:	633d      	str	r5, [r7, #48]	; 0x30
 800c656:	f000 fd6b 	bl	800d130 <silk_NLSF2A>
        silk_memcpy( CNG_sig_Q14, psCNG->CNG_synth_state, MAX_LPC_ORDER * sizeof( opus_int32 ) );
 800c65a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c65c:	f8d7 e034 	ldr.w	lr, [r7, #52]	; 0x34
 800c660:	461e      	mov	r6, r3
 800c662:	6b3d      	ldr	r5, [r7, #48]	; 0x30
 800c664:	f103 0840 	add.w	r8, r3, #64	; 0x40
 800c668:	46f4      	mov	ip, lr
 800c66a:	6830      	ldr	r0, [r6, #0]
 800c66c:	6871      	ldr	r1, [r6, #4]
 800c66e:	68b2      	ldr	r2, [r6, #8]
 800c670:	68f3      	ldr	r3, [r6, #12]
 800c672:	3610      	adds	r6, #16
 800c674:	4546      	cmp	r6, r8
 800c676:	f10e 0e10 	add.w	lr, lr, #16
 800c67a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 800c67e:	d1f3      	bne.n	800c668 <silk_CNG+0x56c>
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800c680:	f9b7 a06e 	ldrsh.w	sl, [r7, #110]	; 0x6e
 800c684:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 800c688:	f8c7 a024 	str.w	sl, [r7, #36]	; 0x24
 800c68c:	f9b7 a070 	ldrsh.w	sl, [r7, #112]	; 0x70
 800c690:	63bb      	str	r3, [r7, #56]	; 0x38
 800c692:	f8c7 a020 	str.w	sl, [r7, #32]
 800c696:	f9b7 a072 	ldrsh.w	sl, [r7, #114]	; 0x72
 800c69a:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 800c69e:	f8c7 a008 	str.w	sl, [r7, #8]
 800c6a2:	f9b7 a074 	ldrsh.w	sl, [r7, #116]	; 0x74
 800c6a6:	62bb      	str	r3, [r7, #40]	; 0x28
 800c6a8:	f8c7 a004 	str.w	sl, [r7, #4]
 800c6ac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c6ae:	f9b7 a076 	ldrsh.w	sl, [r7, #118]	; 0x76
 800c6b2:	633d      	str	r5, [r7, #48]	; 0x30
 800c6b4:	f8c7 a000 	str.w	sl, [r7]
 800c6b8:	f1a3 0a40 	sub.w	sl, r3, #64	; 0x40
 800c6bc:	4653      	mov	r3, sl
            LPC_pred_Q10 = silk_RSHIFT( psDec->LPC_order, 1 );
 800c6be:	f8d4 5924 	ldr.w	r5, [r4, #2340]	; 0x924
 800c6c2:	f9b7 4060 	ldrsh.w	r4, [r7, #96]	; 0x60
 800c6c6:	657d      	str	r5, [r7, #84]	; 0x54
 800c6c8:	106d      	asrs	r5, r5, #1
 800c6ca:	653d      	str	r5, [r7, #80]	; 0x50
 800c6cc:	6b7d      	ldr	r5, [r7, #52]	; 0x34
 800c6ce:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 800c6d2:	441d      	add	r5, r3
 800c6d4:	0424      	lsls	r4, r4, #16
 800c6d6:	f9b7 8058 	ldrsh.w	r8, [r7, #88]	; 0x58
 800c6da:	f9b7 e05a 	ldrsh.w	lr, [r7, #90]	; 0x5a
 800c6de:	f9b7 c05c 	ldrsh.w	ip, [r7, #92]	; 0x5c
 800c6e2:	f9b7 605e 	ldrsh.w	r6, [r7, #94]	; 0x5e
 800c6e6:	f9b7 0062 	ldrsh.w	r0, [r7, #98]	; 0x62
 800c6ea:	f9b7 1064 	ldrsh.w	r1, [r7, #100]	; 0x64
 800c6ee:	f9b7 906a 	ldrsh.w	r9, [r7, #106]	; 0x6a
 800c6f2:	f8c7 a00c 	str.w	sl, [r7, #12]
 800c6f6:	63fd      	str	r5, [r7, #60]	; 0x3c
 800c6f8:	f8d7 a04c 	ldr.w	sl, [r7, #76]	; 0x4c
 800c6fc:	643c      	str	r4, [r7, #64]	; 0x40
 800c6fe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c700:	0412      	lsls	r2, r2, #16
 800c702:	64fa      	str	r2, [r7, #76]	; 0x4c
 800c704:	041a      	lsls	r2, r3, #16
 800c706:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c708:	0409      	lsls	r1, r1, #16
 800c70a:	64b9      	str	r1, [r7, #72]	; 0x48
 800c70c:	0419      	lsls	r1, r3, #16
 800c70e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c710:	6179      	str	r1, [r7, #20]
 800c712:	0419      	lsls	r1, r3, #16
 800c714:	6a3b      	ldr	r3, [r7, #32]
 800c716:	61b9      	str	r1, [r7, #24]
 800c718:	0419      	lsls	r1, r3, #16
 800c71a:	68bb      	ldr	r3, [r7, #8]
 800c71c:	61f9      	str	r1, [r7, #28]
 800c71e:	0419      	lsls	r1, r3, #16
 800c720:	687b      	ldr	r3, [r7, #4]
 800c722:	0400      	lsls	r0, r0, #16
 800c724:	ea4f 4808 	mov.w	r8, r8, lsl #16
 800c728:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 800c72c:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 800c730:	6239      	str	r1, [r7, #32]
 800c732:	0419      	lsls	r1, r3, #16
 800c734:	6478      	str	r0, [r7, #68]	; 0x44
 800c736:	6279      	str	r1, [r7, #36]	; 0x24
 800c738:	4670      	mov	r0, lr
 800c73a:	4661      	mov	r1, ip
 800c73c:	4644      	mov	r4, r8
 800c73e:	683b      	ldr	r3, [r7, #0]
 800c740:	6b3d      	ldr	r5, [r7, #48]	; 0x30
 800c742:	041b      	lsls	r3, r3, #16
 800c744:	0436      	lsls	r6, r6, #16
 800c746:	ea4f 4909 	mov.w	r9, r9, lsl #16
 800c74a:	62bb      	str	r3, [r7, #40]	; 0x28
 800c74c:	63ba      	str	r2, [r7, #56]	; 0x38
  __asm__(
 800c74e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 800c750:	fb83 ec04 	smull	lr, ip, r3, r4
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i -  1 ], A_Q12[ 0 ] );
 800c754:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c756:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c758:	eb03 0e0c 	add.w	lr, r3, ip
 800c75c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800c75e:	fb83 8c00 	smull	r8, ip, r3, r0
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i -  2 ], A_Q12[ 1 ] );
 800c762:	44f4      	add	ip, lr
 800c764:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800c766:	fb83 8e01 	smull	r8, lr, r3, r1
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i -  3 ], A_Q12[ 2 ] );
 800c76a:	44f4      	add	ip, lr
 800c76c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800c76e:	fb83 8e06 	smull	r8, lr, r3, r6
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i -  4 ], A_Q12[ 3 ] );
 800c772:	44e6      	add	lr, ip
 800c774:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800c776:	fb83 8c02 	smull	r8, ip, r3, r2
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i -  5 ], A_Q12[ 4 ] );
 800c77a:	44e6      	add	lr, ip
 800c77c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800c77e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800c780:	fb83 8c02 	smull	r8, ip, r3, r2
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i -  6 ], A_Q12[ 5 ] );
 800c784:	44f4      	add	ip, lr
 800c786:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800c788:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800c78a:	fb83 8e02 	smull	r8, lr, r3, r2
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i -  7 ], A_Q12[ 6 ] );
 800c78e:	44f4      	add	ip, lr
 800c790:	6a2b      	ldr	r3, [r5, #32]
 800c792:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800c794:	fb83 8e02 	smull	r8, lr, r3, r2
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i -  8 ], A_Q12[ 7 ] );
 800c798:	44e6      	add	lr, ip
 800c79a:	69eb      	ldr	r3, [r5, #28]
 800c79c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c79e:	fb83 8c02 	smull	r8, ip, r3, r2
 800c7a2:	69ab      	ldr	r3, [r5, #24]
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i -  9 ], A_Q12[ 8 ] );
 800c7a4:	44e6      	add	lr, ip
 800c7a6:	fb83 8c09 	smull	r8, ip, r3, r9
            if( psDec->LPC_order == 16 ) {
 800c7aa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i - 10 ], A_Q12[ 9 ] );
 800c7ac:	44f4      	add	ip, lr
            if( psDec->LPC_order == 16 ) {
 800c7ae:	2b10      	cmp	r3, #16
 800c7b0:	d11d      	bne.n	800c7ee <silk_CNG+0x6f2>
 800c7b2:	696b      	ldr	r3, [r5, #20]
 800c7b4:	697a      	ldr	r2, [r7, #20]
 800c7b6:	fb83 8e02 	smull	r8, lr, r3, r2
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i - 11 ], A_Q12[ 10 ] );
 800c7ba:	44f4      	add	ip, lr
 800c7bc:	692b      	ldr	r3, [r5, #16]
 800c7be:	69ba      	ldr	r2, [r7, #24]
 800c7c0:	fb83 8e02 	smull	r8, lr, r3, r2
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i - 12 ], A_Q12[ 11 ] );
 800c7c4:	44f4      	add	ip, lr
 800c7c6:	68eb      	ldr	r3, [r5, #12]
 800c7c8:	69fa      	ldr	r2, [r7, #28]
 800c7ca:	fb83 8e02 	smull	r8, lr, r3, r2
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i - 13 ], A_Q12[ 12 ] );
 800c7ce:	44f4      	add	ip, lr
 800c7d0:	68ab      	ldr	r3, [r5, #8]
 800c7d2:	6a3a      	ldr	r2, [r7, #32]
 800c7d4:	fb83 8e02 	smull	r8, lr, r3, r2
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i - 14 ], A_Q12[ 13 ] );
 800c7d8:	44e6      	add	lr, ip
 800c7da:	686b      	ldr	r3, [r5, #4]
 800c7dc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800c7de:	fb83 8c02 	smull	r8, ip, r3, r2
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i - 15 ], A_Q12[ 14 ] );
 800c7e2:	44e6      	add	lr, ip
 800c7e4:	682b      	ldr	r3, [r5, #0]
 800c7e6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c7e8:	fb83 8c02 	smull	r8, ip, r3, r2
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, CNG_sig_Q14[ MAX_LPC_ORDER + i - 16 ], A_Q12[ 15 ] );
 800c7ec:	44f4      	add	ip, lr
            CNG_sig_Q14[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( CNG_sig_Q14[ MAX_LPC_ORDER + i ], silk_LSHIFT_SAT32( LPC_pred_Q10, 4 ) );
 800c7ee:	f1bc 6f00 	cmp.w	ip, #134217728	; 0x8000000
 800c7f2:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800c7f4:	f280 80bb 	bge.w	800c96e <silk_CNG+0x872>
 800c7f8:	f1bc 4f78 	cmp.w	ip, #4160749568	; 0xf8000000
 800c7fc:	f2c0 80d1 	blt.w	800c9a2 <silk_CNG+0x8a6>
 800c800:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
 800c804:	eb13 0f0c 	cmn.w	r3, ip
 800c808:	f100 80bb 	bmi.w	800c982 <silk_CNG+0x886>
 800c80c:	ea13 0f0c 	tst.w	r3, ip
 800c810:	f100 80a6 	bmi.w	800c960 <silk_CNG+0x864>
 800c814:	4463      	add	r3, ip
  __asm__(
 800c816:	fb83 ce0b 	smull	ip, lr, r3, fp
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c81a:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800c81e:	eb0c 4c0e 	add.w	ip, ip, lr, lsl #16
            frame[ i ] = (opus_int16)silk_ADD_SAT16( frame[ i ], silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( CNG_sig_Q14[ MAX_LPC_ORDER + i ], gain_Q10 ), 8 ) ) );
 800c822:	ea4f 1cec 	mov.w	ip, ip, asr #7
 800c826:	f10c 0c01 	add.w	ip, ip, #1
 800c82a:	f5bc 3f80 	cmp.w	ip, #65536	; 0x10000
            CNG_sig_Q14[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( CNG_sig_Q14[ MAX_LPC_ORDER + i ], silk_LSHIFT_SAT32( LPC_pred_Q10, 4 ) );
 800c82e:	642b      	str	r3, [r5, #64]	; 0x40
            frame[ i ] = (opus_int16)silk_ADD_SAT16( frame[ i ], silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( CNG_sig_Q14[ MAX_LPC_ORDER + i ], gain_Q10 ), 8 ) ) );
 800c830:	f9ba e000 	ldrsh.w	lr, [sl]
 800c834:	f280 80af 	bge.w	800c996 <silk_CNG+0x89a>
  __asm__(
 800c838:	fb83 c80b 	smull	ip, r8, r3, fp
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c83c:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800c840:	eb0c 4c08 	add.w	ip, ip, r8, lsl #16
 800c844:	ea4f 1cec 	mov.w	ip, ip, asr #7
 800c848:	f10c 0c01 	add.w	ip, ip, #1
 800c84c:	f51c 3f80 	cmn.w	ip, #65536	; 0x10000
 800c850:	f2c0 80a4 	blt.w	800c99c <silk_CNG+0x8a0>
  __asm__(
 800c854:	fb83 c80b 	smull	ip, r8, r3, fp
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c858:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800c85c:	eb0c 4c08 	add.w	ip, ip, r8, lsl #16
 800c860:	ea4f 1cec 	mov.w	ip, ip, asr #7
 800c864:	f10c 0c01 	add.w	ip, ip, #1
 800c868:	ea4f 0c6c 	mov.w	ip, ip, asr #1
 800c86c:	44f4      	add	ip, lr
 800c86e:	f5bc 4f00 	cmp.w	ip, #32768	; 0x8000
 800c872:	f280 808d 	bge.w	800c990 <silk_CNG+0x894>
  __asm__(
 800c876:	fb83 c80b 	smull	ip, r8, r3, fp
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c87a:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800c87e:	eb0c 4c08 	add.w	ip, ip, r8, lsl #16
 800c882:	ea4f 1cec 	mov.w	ip, ip, asr #7
 800c886:	f10c 0c01 	add.w	ip, ip, #1
 800c88a:	f5bc 3f80 	cmp.w	ip, #65536	; 0x10000
 800c88e:	f280 808f 	bge.w	800c9b0 <silk_CNG+0x8b4>
  __asm__(
 800c892:	fb83 c80b 	smull	ip, r8, r3, fp
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c896:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800c89a:	eb0c 4c08 	add.w	ip, ip, r8, lsl #16
 800c89e:	ea4f 1cec 	mov.w	ip, ip, asr #7
 800c8a2:	f10c 0c01 	add.w	ip, ip, #1
 800c8a6:	f51c 3f80 	cmn.w	ip, #65536	; 0x10000
 800c8aa:	f2c0 808a 	blt.w	800c9c2 <silk_CNG+0x8c6>
  __asm__(
 800c8ae:	fb83 c80b 	smull	ip, r8, r3, fp
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c8b2:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800c8b6:	eb0c 4c08 	add.w	ip, ip, r8, lsl #16
 800c8ba:	ea4f 1cec 	mov.w	ip, ip, asr #7
 800c8be:	f10c 0c01 	add.w	ip, ip, #1
 800c8c2:	ea4f 0c6c 	mov.w	ip, ip, asr #1
 800c8c6:	44f4      	add	ip, lr
 800c8c8:	f51c 4f00 	cmn.w	ip, #32768	; 0x8000
 800c8cc:	db76      	blt.n	800c9bc <silk_CNG+0x8c0>
  __asm__(
 800c8ce:	fb83 c80b 	smull	ip, r8, r3, fp
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c8d2:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800c8d6:	eb0c 4c08 	add.w	ip, ip, r8, lsl #16
 800c8da:	ea4f 1cec 	mov.w	ip, ip, asr #7
 800c8de:	f10c 0c01 	add.w	ip, ip, #1
 800c8e2:	f5bc 3f80 	cmp.w	ip, #65536	; 0x10000
 800c8e6:	fa1f fe8e 	uxth.w	lr, lr
 800c8ea:	da6d      	bge.n	800c9c8 <silk_CNG+0x8cc>
  __asm__(
 800c8ec:	fb83 c80b 	smull	ip, r8, r3, fp
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c8f0:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800c8f4:	eb0c 4c08 	add.w	ip, ip, r8, lsl #16
 800c8f8:	ea4f 1cec 	mov.w	ip, ip, asr #7
 800c8fc:	f10c 0c01 	add.w	ip, ip, #1
 800c900:	f51c 3f80 	cmn.w	ip, #65536	; 0x10000
 800c904:	db63      	blt.n	800c9ce <silk_CNG+0x8d2>
  __asm__(
 800c906:	fb83 c80b 	smull	ip, r8, r3, fp
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800c90a:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800c90e:	eb0c 4308 	add.w	r3, ip, r8, lsl #16
 800c912:	11db      	asrs	r3, r3, #7
 800c914:	3301      	adds	r3, #1
 800c916:	f3c3 034f 	ubfx	r3, r3, #1, #16
 800c91a:	449e      	add	lr, r3
 800c91c:	fa0f fe8e 	sxth.w	lr, lr
        for( i = 0; i < length; i++ ) {
 800c920:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c922:	3504      	adds	r5, #4
 800c924:	429d      	cmp	r5, r3
            frame[ i ] = (opus_int16)silk_ADD_SAT16( frame[ i ], silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( CNG_sig_Q14[ MAX_LPC_ORDER + i ], gain_Q10 ), 8 ) ) );
 800c926:	f82a eb02 	strh.w	lr, [sl], #2
        for( i = 0; i < length; i++ ) {
 800c92a:	f47f af10 	bne.w	800c74e <silk_CNG+0x652>
        silk_memcpy( psCNG->CNG_synth_state, &CNG_sig_Q14[ length ], MAX_LPC_ORDER * sizeof( opus_int32 ) );
 800c92e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c930:	68fa      	ldr	r2, [r7, #12]
 800c932:	6afd      	ldr	r5, [r7, #44]	; 0x2c
 800c934:	4413      	add	r3, r2
 800c936:	469b      	mov	fp, r3
 800c938:	f103 0640 	add.w	r6, r3, #64	; 0x40
 800c93c:	465c      	mov	r4, fp
 800c93e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800c940:	42b4      	cmp	r4, r6
 800c942:	6028      	str	r0, [r5, #0]
 800c944:	6069      	str	r1, [r5, #4]
 800c946:	60aa      	str	r2, [r5, #8]
 800c948:	60eb      	str	r3, [r5, #12]
 800c94a:	f10b 0b10 	add.w	fp, fp, #16
 800c94e:	f105 0510 	add.w	r5, r5, #16
 800c952:	d1f3      	bne.n	800c93c <silk_CNG+0x840>
 800c954:	f8d7 d010 	ldr.w	sp, [r7, #16]
}
 800c958:	377c      	adds	r7, #124	; 0x7c
 800c95a:	46bd      	mov	sp, r7
 800c95c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            CNG_sig_Q14[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( CNG_sig_Q14[ MAX_LPC_ORDER + i ], silk_LSHIFT_SAT32( LPC_pred_Q10, 4 ) );
 800c960:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800c964:	e757      	b.n	800c816 <silk_CNG+0x71a>
        return (opus_int32) ((x << m) | (x >> (32 - m)));
 800c966:	bfb8      	it	lt
 800c968:	3020      	addlt	r0, #32
        return (opus_int32) ((x << (32 - r)) | (x >> r));
 800c96a:	41c3      	rors	r3, r0
 800c96c:	e472      	b.n	800c254 <silk_CNG+0x158>
 800c96e:	f103 4c00 	add.w	ip, r3, #2147483648	; 0x80000000
 800c972:	f1ac 0c10 	sub.w	ip, ip, #16
 800c976:	f1bc 0f00 	cmp.w	ip, #0
 800c97a:	f8df c094 	ldr.w	ip, [pc, #148]	; 800ca10 <silk_CNG+0x914>
 800c97e:	f6bf af45 	bge.w	800c80c <silk_CNG+0x710>
 800c982:	ea53 020c 	orrs.w	r2, r3, ip
 800c986:	f53f af45 	bmi.w	800c814 <silk_CNG+0x718>
 800c98a:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 800c98e:	e742      	b.n	800c816 <silk_CNG+0x71a>
            frame[ i ] = (opus_int16)silk_ADD_SAT16( frame[ i ], silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( CNG_sig_Q14[ MAX_LPC_ORDER + i ], gain_Q10 ), 8 ) ) );
 800c990:	f647 7eff 	movw	lr, #32767	; 0x7fff
 800c994:	e7c4      	b.n	800c920 <silk_CNG+0x824>
 800c996:	f647 7cff 	movw	ip, #32767	; 0x7fff
 800c99a:	e767      	b.n	800c86c <silk_CNG+0x770>
 800c99c:	f8df c074 	ldr.w	ip, [pc, #116]	; 800ca14 <silk_CNG+0x918>
 800c9a0:	e764      	b.n	800c86c <silk_CNG+0x770>
            CNG_sig_Q14[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( CNG_sig_Q14[ MAX_LPC_ORDER + i ], silk_LSHIFT_SAT32( LPC_pred_Q10, 4 ) );
 800c9a2:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800c9a6:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800c9aa:	f57f af2f 	bpl.w	800c80c <silk_CNG+0x710>
 800c9ae:	e7e8      	b.n	800c982 <silk_CNG+0x886>
            frame[ i ] = (opus_int16)silk_ADD_SAT16( frame[ i ], silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( CNG_sig_Q14[ MAX_LPC_ORDER + i ], gain_Q10 ), 8 ) ) );
 800c9b0:	f647 7cff 	movw	ip, #32767	; 0x7fff
 800c9b4:	44f4      	add	ip, lr
 800c9b6:	f51c 4f00 	cmn.w	ip, #32768	; 0x8000
 800c9ba:	da88      	bge.n	800c8ce <silk_CNG+0x7d2>
 800c9bc:	f8df e054 	ldr.w	lr, [pc, #84]	; 800ca14 <silk_CNG+0x918>
 800c9c0:	e7ae      	b.n	800c920 <silk_CNG+0x824>
 800c9c2:	f8df c050 	ldr.w	ip, [pc, #80]	; 800ca14 <silk_CNG+0x918>
 800c9c6:	e77e      	b.n	800c8c6 <silk_CNG+0x7ca>
 800c9c8:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800c9cc:	e7a5      	b.n	800c91a <silk_CNG+0x81e>
 800c9ce:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800c9d2:	e7a2      	b.n	800c91a <silk_CNG+0x81e>
        silk_NLSF2A( A_Q12, psCNG->CNG_smth_NLSF_Q15, psDec->LPC_order, psDec->arch );
 800c9d4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800c9d6:	f107 0058 	add.w	r0, r7, #88	; 0x58
 800c9da:	f000 fba9 	bl	800d130 <silk_NLSF2A>
        silk_memcpy( CNG_sig_Q14, psCNG->CNG_synth_state, MAX_LPC_ORDER * sizeof( opus_int32 ) );
 800c9de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c9e0:	6b7e      	ldr	r6, [r7, #52]	; 0x34
 800c9e2:	461c      	mov	r4, r3
 800c9e4:	f103 0c40 	add.w	ip, r3, #64	; 0x40
 800c9e8:	4635      	mov	r5, r6
 800c9ea:	6820      	ldr	r0, [r4, #0]
 800c9ec:	6861      	ldr	r1, [r4, #4]
 800c9ee:	68a2      	ldr	r2, [r4, #8]
 800c9f0:	68e3      	ldr	r3, [r4, #12]
 800c9f2:	3410      	adds	r4, #16
 800c9f4:	4564      	cmp	r4, ip
 800c9f6:	f106 0610 	add.w	r6, r6, #16
 800c9fa:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800c9fc:	d1f4      	bne.n	800c9e8 <silk_CNG+0x8ec>
 800c9fe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ca00:	3b40      	subs	r3, #64	; 0x40
 800ca02:	60fb      	str	r3, [r7, #12]
 800ca04:	e793      	b.n	800c92e <silk_CNG+0x832>
 800ca06:	bf00      	nop
 800ca08:	0bb38435 	.word	0x0bb38435
 800ca0c:	3619636b 	.word	0x3619636b
 800ca10:	7ffffff0 	.word	0x7ffffff0
 800ca14:	ffff8000 	.word	0xffff8000

0800ca18 <silk_LPC_analysis_filter>:
    const opus_int16            *B,                 /* I    MA prediction coefficients, Q12 [order]                     */
    const opus_int32            len,                /* I    Signal length                                               */
    const opus_int32            d,                  /* I    Filter order                                                */
    int                         arch                /* I    Run-time architecture                                       */
)
{
 800ca18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ca1c:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    for ( j = 0; j < d; j++ ) {
        out[ j ] = 0;
    }
#else
    (void)arch;
    for( ix = d; ix < len; ix++ ) {
 800ca20:	4599      	cmp	r9, r3
 800ca22:	da5b      	bge.n	800cadc <silk_LPC_analysis_filter+0xc4>
 800ca24:	f06f 0b03 	mvn.w	fp, #3
 800ca28:	f109 4800 	add.w	r8, r9, #2147483648	; 0x80000000
 800ca2c:	f108 38ff 	add.w	r8, r8, #4294967295
 800ca30:	ea4f 0848 	mov.w	r8, r8, lsl #1
 800ca34:	f1a9 0407 	sub.w	r4, r9, #7
 800ca38:	eb01 0c08 	add.w	ip, r1, r8
 800ca3c:	0864      	lsrs	r4, r4, #1
 800ca3e:	3902      	subs	r1, #2
 800ca40:	4480      	add	r8, r0
 800ca42:	eb01 0a43 	add.w	sl, r1, r3, lsl #1
 800ca46:	ebab 0b84 	sub.w	fp, fp, r4, lsl #2
        in_ptr = &in[ ix - 1 ];

        out32_Q12 = silk_SMULBB( in_ptr[  0 ], B[ 0 ] );
 800ca4a:	8811      	ldrh	r1, [r2, #0]
 800ca4c:	f8bc 4000 	ldrh.w	r4, [ip]
        /* Allowing wrap around so that two wraps can cancel each other. The rare
           cases where the result wraps around can only be triggered by invalid streams*/
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -1 ], B[ 1 ] );
 800ca50:	8855      	ldrh	r5, [r2, #2]
        out32_Q12 = silk_SMULBB( in_ptr[  0 ], B[ 0 ] );
 800ca52:	fb14 f401 	smulbb	r4, r4, r1
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -1 ], B[ 1 ] );
 800ca56:	f83c 3c02 	ldrh.w	r3, [ip, #-2]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -2 ], B[ 2 ] );
 800ca5a:	f83c 1c04 	ldrh.w	r1, [ip, #-4]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -1 ], B[ 1 ] );
 800ca5e:	fb13 4305 	smlabb	r3, r3, r5, r4
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -2 ], B[ 2 ] );
 800ca62:	8894      	ldrh	r4, [r2, #4]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -3 ], B[ 3 ] );
 800ca64:	f83c 5c06 	ldrh.w	r5, [ip, #-6]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -2 ], B[ 2 ] );
 800ca68:	fb11 3104 	smlabb	r1, r1, r4, r3
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -3 ], B[ 3 ] );
 800ca6c:	88d4      	ldrh	r4, [r2, #6]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -4 ], B[ 4 ] );
 800ca6e:	f83c 3c08 	ldrh.w	r3, [ip, #-8]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -3 ], B[ 3 ] );
 800ca72:	fb15 1104 	smlabb	r1, r5, r4, r1
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -4 ], B[ 4 ] );
 800ca76:	8914      	ldrh	r4, [r2, #8]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -5 ], B[ 5 ] );
 800ca78:	f83c 5c0a 	ldrh.w	r5, [ip, #-10]
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -4 ], B[ 4 ] );
 800ca7c:	fb13 1304 	smlabb	r3, r3, r4, r1
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -5 ], B[ 5 ] );
 800ca80:	8951      	ldrh	r1, [r2, #10]
        for( j = 6; j < d; j += 2 ) {
 800ca82:	f1b9 0f06 	cmp.w	r9, #6
        out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -5 ], B[ 5 ] );
 800ca86:	fb15 3501 	smlabb	r5, r5, r1, r3
        for( j = 6; j < d; j += 2 ) {
 800ca8a:	dd15      	ble.n	800cab8 <silk_LPC_analysis_filter+0xa0>
 800ca8c:	4616      	mov	r6, r2
 800ca8e:	4664      	mov	r4, ip
 800ca90:	eb0b 070c 	add.w	r7, fp, ip
            out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -j     ], B[ j     ] );
            out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -j - 1 ], B[ j + 1 ] );
 800ca94:	f834 1c0e 	ldrh.w	r1, [r4, #-14]
 800ca98:	f8b6 e00e 	ldrh.w	lr, [r6, #14]
 800ca9c:	f834 3c0c 	ldrh.w	r3, [r4, #-12]
 800caa0:	fb11 f10e 	smulbb	r1, r1, lr
 800caa4:	f8b6 e00c 	ldrh.w	lr, [r6, #12]
 800caa8:	3c04      	subs	r4, #4
 800caaa:	fb13 130e 	smlabb	r3, r3, lr, r1
        for( j = 6; j < d; j += 2 ) {
 800caae:	42a7      	cmp	r7, r4
 800cab0:	f106 0604 	add.w	r6, r6, #4
            out32_Q12 = silk_SMLABB_ovflw( out32_Q12, in_ptr[ -j - 1 ], B[ j + 1 ] );
 800cab4:	441d      	add	r5, r3
        for( j = 6; j < d; j += 2 ) {
 800cab6:	d1ed      	bne.n	800ca94 <silk_LPC_analysis_filter+0x7c>
        }

        /* Subtract prediction */
        out32_Q12 = silk_SUB32_ovflw( silk_LSHIFT( (opus_int32)in_ptr[ 1 ], 12 ), out32_Q12 );
 800cab8:	f93c 3f02 	ldrsh.w	r3, [ip, #2]!
 800cabc:	ebc5 3303 	rsb	r3, r5, r3, lsl #12

        /* Scale to Q0 */
        out32 = silk_RSHIFT_ROUND( out32_Q12, 12 );
 800cac0:	12db      	asrs	r3, r3, #11
 800cac2:	3301      	adds	r3, #1
 800cac4:	105b      	asrs	r3, r3, #1

        /* Saturate output */
        out[ ix ] = (opus_int16)silk_SAT16( out32 );
 800cac6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800caca:	da0e      	bge.n	800caea <silk_LPC_analysis_filter+0xd2>
 800cacc:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 800cad0:	db0e      	blt.n	800caf0 <silk_LPC_analysis_filter+0xd8>
 800cad2:	b21b      	sxth	r3, r3
    for( ix = d; ix < len; ix++ ) {
 800cad4:	45e2      	cmp	sl, ip
        out[ ix ] = (opus_int16)silk_SAT16( out32 );
 800cad6:	f828 3f02 	strh.w	r3, [r8, #2]!
    for( ix = d; ix < len; ix++ ) {
 800cada:	d1b6      	bne.n	800ca4a <silk_LPC_analysis_filter+0x32>
    }

    /* Set first d output samples to zero */
    silk_memset( out, 0, d * sizeof( opus_int16 ) );
 800cadc:	ea4f 0249 	mov.w	r2, r9, lsl #1
 800cae0:	2100      	movs	r1, #0
#endif
}
 800cae2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    silk_memset( out, 0, d * sizeof( opus_int16 ) );
 800cae6:	f007 bb1f 	b.w	8014128 <memset>
        out[ ix ] = (opus_int16)silk_SAT16( out32 );
 800caea:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800caee:	e7f1      	b.n	800cad4 <silk_LPC_analysis_filter+0xbc>
 800caf0:	4b00      	ldr	r3, [pc, #0]	; (800caf4 <silk_LPC_analysis_filter+0xdc>)
 800caf2:	e7ef      	b.n	800cad4 <silk_LPC_analysis_filter+0xbc>
 800caf4:	ffff8000 	.word	0xffff8000

0800caf8 <silk_LPC_fit>:
    opus_int32                    *a_QIN,             /* I/O  Input signal                                                */
    const opus_int              QOUT,               /* I    Input Q domain                                              */
    const opus_int              QIN,                /* I    Input Q domain                                              */
    const opus_int              d                   /* I    Filter order                                                */
)
{
 800caf8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cafc:	4607      	mov	r7, r0
 800cafe:	460d      	mov	r5, r1
            if( absval > maxabs ) {
                maxabs = absval;
                idx    = k;
            }
        }
        maxabs = silk_RSHIFT_ROUND( maxabs, QIN - QOUT );
 800cb00:	f04f 0b0a 	mov.w	fp, #10
    opus_int    i, k, idx = 0;
 800cb04:	2600      	movs	r6, #0
        maxabs = silk_RSHIFT_ROUND( maxabs, QIN - QOUT );
 800cb06:	eba3 0802 	sub.w	r8, r3, r2
{
 800cb0a:	9c0a      	ldr	r4, [sp, #40]	; 0x28

        if( maxabs > silk_int16_MAX ) {
            /* Reduce magnitude of prediction coefficients */
            maxabs = silk_min( maxabs, 163838 );  /* ( silk_int32_MAX >> 14 ) + silk_int16_MAX = 163838 */
 800cb0c:	f8df 9164 	ldr.w	r9, [pc, #356]	; 800cc74 <silk_LPC_fit+0x17c>
        maxabs = silk_RSHIFT_ROUND( maxabs, QIN - QOUT );
 800cb10:	f108 3aff 	add.w	sl, r8, #4294967295
        for( k = 0; k < d; k++ ) {
 800cb14:	2c00      	cmp	r4, #0
        maxabs = 0;
 800cb16:	f04f 0300 	mov.w	r3, #0
        for( k = 0; k < d; k++ ) {
 800cb1a:	dd0f      	ble.n	800cb3c <silk_LPC_fit+0x44>
 800cb1c:	4619      	mov	r1, r3
 800cb1e:	1f28      	subs	r0, r5, #4
            absval = silk_abs( a_QIN[k] );
 800cb20:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800cb24:	2a00      	cmp	r2, #0
 800cb26:	bfb8      	it	lt
 800cb28:	4252      	neglt	r2, r2
            if( absval > maxabs ) {
 800cb2a:	4293      	cmp	r3, r2
 800cb2c:	bfb8      	it	lt
 800cb2e:	460e      	movlt	r6, r1
        for( k = 0; k < d; k++ ) {
 800cb30:	f101 0101 	add.w	r1, r1, #1
            if( absval > maxabs ) {
 800cb34:	bfb8      	it	lt
 800cb36:	4613      	movlt	r3, r2
        for( k = 0; k < d; k++ ) {
 800cb38:	428c      	cmp	r4, r1
 800cb3a:	d1f1      	bne.n	800cb20 <silk_LPC_fit+0x28>
        maxabs = silk_RSHIFT_ROUND( maxabs, QIN - QOUT );
 800cb3c:	f1b8 0f01 	cmp.w	r8, #1
 800cb40:	d04a      	beq.n	800cbd8 <silk_LPC_fit+0xe0>
 800cb42:	fa43 f30a 	asr.w	r3, r3, sl
 800cb46:	3301      	adds	r3, #1
 800cb48:	105b      	asrs	r3, r3, #1
        if( maxabs > silk_int16_MAX ) {
 800cb4a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800cb4e:	db4a      	blt.n	800cbe6 <silk_LPC_fit+0xee>
            maxabs = silk_min( maxabs, 163838 );  /* ( silk_int32_MAX >> 14 ) + silk_int16_MAX = 163838 */
 800cb50:	454b      	cmp	r3, r9
 800cb52:	bfa8      	it	ge
 800cb54:	464b      	movge	r3, r9
            chirp_Q16 = SILK_FIX_CONST( 0.999, 16 ) - silk_DIV32( silk_LSHIFT( maxabs - silk_int16_MAX, 14 ),
 800cb56:	fb06 3203 	mla	r2, r6, r3, r3
 800cb5a:	f5a3 43ff 	sub.w	r3, r3, #32640	; 0x7f80
 800cb5e:	3b7f      	subs	r3, #127	; 0x7f
 800cb60:	039b      	lsls	r3, r3, #14
 800cb62:	1092      	asrs	r2, r2, #2
 800cb64:	fb93 f2f2 	sdiv	r2, r3, r2
                                        silk_RSHIFT32( silk_MUL( maxabs, idx + 1), 2 ) );
            silk_bwexpander_32( a_QIN, d, chirp_Q16 );
 800cb68:	f5c2 427f 	rsb	r2, r2, #65280	; 0xff00
 800cb6c:	32be      	adds	r2, #190	; 0xbe
 800cb6e:	4621      	mov	r1, r4
 800cb70:	4628      	mov	r0, r5
 800cb72:	f001 ffbb 	bl	800eaec <silk_bwexpander_32>
    for( i = 0; i < 10; i++ ) {
 800cb76:	f1bb 0b01 	subs.w	fp, fp, #1
 800cb7a:	d1cb      	bne.n	800cb14 <silk_LPC_fit+0x1c>
        }
    }

    if( i == 10 ) {
        /* Reached the last iteration, clip the coefficients */
        for( k = 0; k < d; k++ ) {
 800cb7c:	2c00      	cmp	r4, #0
 800cb7e:	dd29      	ble.n	800cbd4 <silk_LPC_fit+0xdc>
 800cb80:	f1b8 0f01 	cmp.w	r8, #1
 800cb84:	f1a5 0504 	sub.w	r5, r5, #4
 800cb88:	d052      	beq.n	800cc30 <silk_LPC_fit+0x138>
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
 800cb8a:	4839      	ldr	r0, [pc, #228]	; (800cc70 <silk_LPC_fit+0x178>)
 800cb8c:	eb05 0484 	add.w	r4, r5, r4, lsl #2
 800cb90:	3f02      	subs	r7, #2
 800cb92:	f108 32ff 	add.w	r2, r8, #4294967295
 800cb96:	e00b      	b.n	800cbb0 <silk_LPC_fit+0xb8>
 800cb98:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 800cb9c:	db45      	blt.n	800cc2a <silk_LPC_fit+0x132>
 800cb9e:	4619      	mov	r1, r3
 800cba0:	b21b      	sxth	r3, r3
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
 800cba2:	fa01 f108 	lsl.w	r1, r1, r8
        for( k = 0; k < d; k++ ) {
 800cba6:	42ac      	cmp	r4, r5
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
 800cba8:	f827 3f02 	strh.w	r3, [r7, #2]!
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
 800cbac:	6029      	str	r1, [r5, #0]
        for( k = 0; k < d; k++ ) {
 800cbae:	d011      	beq.n	800cbd4 <silk_LPC_fit+0xdc>
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
 800cbb0:	f855 3f04 	ldr.w	r3, [r5, #4]!
 800cbb4:	4113      	asrs	r3, r2
 800cbb6:	3301      	adds	r3, #1
 800cbb8:	105b      	asrs	r3, r3, #1
 800cbba:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800cbbe:	dbeb      	blt.n	800cb98 <silk_LPC_fit+0xa0>
 800cbc0:	f647 71ff 	movw	r1, #32767	; 0x7fff
 800cbc4:	460b      	mov	r3, r1
        for( k = 0; k < d; k++ ) {
 800cbc6:	42ac      	cmp	r4, r5
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
 800cbc8:	fa01 f108 	lsl.w	r1, r1, r8
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
 800cbcc:	f827 3f02 	strh.w	r3, [r7, #2]!
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
 800cbd0:	6029      	str	r1, [r5, #0]
        for( k = 0; k < d; k++ ) {
 800cbd2:	d1ed      	bne.n	800cbb0 <silk_LPC_fit+0xb8>
    } else {
        for( k = 0; k < d; k++ ) {
            a_QOUT[ k ] = (opus_int16)silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT );
        }
    }
}
 800cbd4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        maxabs = silk_RSHIFT_ROUND( maxabs, QIN - QOUT );
 800cbd8:	f003 0201 	and.w	r2, r3, #1
 800cbdc:	eb02 0363 	add.w	r3, r2, r3, asr #1
        if( maxabs > silk_int16_MAX ) {
 800cbe0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800cbe4:	dab4      	bge.n	800cb50 <silk_LPC_fit+0x58>
        for( k = 0; k < d; k++ ) {
 800cbe6:	2c00      	cmp	r4, #0
 800cbe8:	ddf4      	ble.n	800cbd4 <silk_LPC_fit+0xdc>
 800cbea:	3d04      	subs	r5, #4
 800cbec:	f1b8 0f01 	cmp.w	r8, #1
 800cbf0:	eb05 0484 	add.w	r4, r5, r4, lsl #2
 800cbf4:	f1a7 0702 	sub.w	r7, r7, #2
 800cbf8:	d00c      	beq.n	800cc14 <silk_LPC_fit+0x11c>
 800cbfa:	f108 32ff 	add.w	r2, r8, #4294967295
            a_QOUT[ k ] = (opus_int16)silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT );
 800cbfe:	f855 3f04 	ldr.w	r3, [r5, #4]!
 800cc02:	4113      	asrs	r3, r2
 800cc04:	3301      	adds	r3, #1
 800cc06:	105b      	asrs	r3, r3, #1
        for( k = 0; k < d; k++ ) {
 800cc08:	42a5      	cmp	r5, r4
            a_QOUT[ k ] = (opus_int16)silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT );
 800cc0a:	f827 3f02 	strh.w	r3, [r7, #2]!
        for( k = 0; k < d; k++ ) {
 800cc0e:	d1f6      	bne.n	800cbfe <silk_LPC_fit+0x106>
}
 800cc10:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cc14:	f855 2f04 	ldr.w	r2, [r5, #4]!
            a_QOUT[ k ] = (opus_int16)silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT );
 800cc18:	f002 0301 	and.w	r3, r2, #1
 800cc1c:	eb03 0362 	add.w	r3, r3, r2, asr #1
        for( k = 0; k < d; k++ ) {
 800cc20:	42a5      	cmp	r5, r4
            a_QOUT[ k ] = (opus_int16)silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT );
 800cc22:	f827 3f02 	strh.w	r3, [r7, #2]!
        for( k = 0; k < d; k++ ) {
 800cc26:	d1f5      	bne.n	800cc14 <silk_LPC_fit+0x11c>
 800cc28:	e7d4      	b.n	800cbd4 <silk_LPC_fit+0xdc>
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
 800cc2a:	4601      	mov	r1, r0
 800cc2c:	4603      	mov	r3, r0
 800cc2e:	e7b8      	b.n	800cba2 <silk_LPC_fit+0xaa>
 800cc30:	490f      	ldr	r1, [pc, #60]	; (800cc70 <silk_LPC_fit+0x178>)
 800cc32:	eb05 0484 	add.w	r4, r5, r4, lsl #2
 800cc36:	3f02      	subs	r7, #2
 800cc38:	e00a      	b.n	800cc50 <silk_LPC_fit+0x158>
 800cc3a:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 800cc3e:	b21b      	sxth	r3, r3
 800cc40:	db13      	blt.n	800cc6a <silk_LPC_fit+0x172>
 800cc42:	461a      	mov	r2, r3
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
 800cc44:	0052      	lsls	r2, r2, #1
        for( k = 0; k < d; k++ ) {
 800cc46:	42a5      	cmp	r5, r4
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
 800cc48:	f827 3f02 	strh.w	r3, [r7, #2]!
            a_QIN[ k ] = silk_LSHIFT( (opus_int32)a_QOUT[ k ], QIN - QOUT );
 800cc4c:	602a      	str	r2, [r5, #0]
        for( k = 0; k < d; k++ ) {
 800cc4e:	d0c1      	beq.n	800cbd4 <silk_LPC_fit+0xdc>
 800cc50:	f855 2f04 	ldr.w	r2, [r5, #4]!
            a_QOUT[ k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( a_QIN[ k ], QIN - QOUT ) );
 800cc54:	f002 0301 	and.w	r3, r2, #1
 800cc58:	eb03 0362 	add.w	r3, r3, r2, asr #1
 800cc5c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800cc60:	dbeb      	blt.n	800cc3a <silk_LPC_fit+0x142>
 800cc62:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800cc66:	4613      	mov	r3, r2
 800cc68:	e7ec      	b.n	800cc44 <silk_LPC_fit+0x14c>
 800cc6a:	460a      	mov	r2, r1
 800cc6c:	460b      	mov	r3, r1
 800cc6e:	e7e9      	b.n	800cc44 <silk_LPC_fit+0x14c>
 800cc70:	ffff8000 	.word	0xffff8000
 800cc74:	00027ffe 	.word	0x00027ffe

0800cc78 <silk_LPC_inverse_pred_gain_c>:
/* For input in Q12 domain */
opus_int32 silk_LPC_inverse_pred_gain_c(            /* O   Returns inverse prediction gain in energy domain, Q30        */
    const opus_int16            *A_Q12,             /* I   Prediction coefficients, Q12 [order]                         */
    const opus_int              order               /* I   Prediction order                                             */
)
{
 800cc78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    opus_int   k;
    opus_int32 Atmp_QA[ SILK_MAX_ORDER_LPC ];
    opus_int32 DC_resp = 0;

    /* Increase Q domain of the AR coefficients */
    for( k = 0; k < order; k++ ) {
 800cc7c:	2900      	cmp	r1, #0
{
 800cc7e:	b0b3      	sub	sp, #204	; 0xcc
    for( k = 0; k < order; k++ ) {
 800cc80:	dd13      	ble.n	800ccaa <silk_LPC_inverse_pred_gain_c+0x32>
    opus_int32 DC_resp = 0;
 800cc82:	2200      	movs	r2, #0
 800cc84:	3802      	subs	r0, #2
 800cc86:	eb00 0641 	add.w	r6, r0, r1, lsl #1
 800cc8a:	ac1a      	add	r4, sp, #104	; 0x68
        DC_resp += (opus_int32)A_Q12[ k ];
 800cc8c:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
        Atmp_QA[ k ] = silk_LSHIFT32( (opus_int32)A_Q12[ k ], QA - 12 );
 800cc90:	031d      	lsls	r5, r3, #12
    for( k = 0; k < order; k++ ) {
 800cc92:	4286      	cmp	r6, r0
        DC_resp += (opus_int32)A_Q12[ k ];
 800cc94:	441a      	add	r2, r3
        Atmp_QA[ k ] = silk_LSHIFT32( (opus_int32)A_Q12[ k ], QA - 12 );
 800cc96:	f844 5b04 	str.w	r5, [r4], #4
    for( k = 0; k < order; k++ ) {
 800cc9a:	d1f7      	bne.n	800cc8c <silk_LPC_inverse_pred_gain_c+0x14>
    }
    /* If the DC is unstable, we don't even need to do the full calculations */
    if( DC_resp >= 4096 ) {
 800cc9c:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 800cca0:	db03      	blt.n	800ccaa <silk_LPC_inverse_pred_gain_c+0x32>
        return 0;
 800cca2:	2000      	movs	r0, #0
        return 0;
    }
    return LPC_inverse_pred_gain_QA_c( Atmp_QA, order );
}
 800cca4:	b033      	add	sp, #204	; 0xcc
 800cca6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for( k = order - 1; k > 0; k-- ) {
 800ccaa:	1e48      	subs	r0, r1, #1
 800ccac:	ab32      	add	r3, sp, #200	; 0xc8
 800ccae:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800ccb2:	f853 6c60 	ldr.w	r6, [r3, #-96]
 800ccb6:	4bcd      	ldr	r3, [pc, #820]	; (800cfec <silk_LPC_inverse_pred_gain_c+0x374>)
 800ccb8:	2800      	cmp	r0, #0
 800ccba:	eb06 0203 	add.w	r2, r6, r3
 800ccbe:	f340 821b 	ble.w	800d0f8 <silk_LPC_inverse_pred_gain_c+0x480>
        if( ( A_QA[ k ] > A_LIMIT ) || ( A_QA[ k ] < -A_LIMIT ) ) {
 800ccc2:	48cb      	ldr	r0, [pc, #812]	; (800cff0 <silk_LPC_inverse_pred_gain_c+0x378>)
 800ccc4:	4282      	cmp	r2, r0
 800ccc6:	d8ec      	bhi.n	800cca2 <silk_LPC_inverse_pred_gain_c+0x2a>
        rc_Q31 = -silk_LSHIFT( A_QA[ k ], 31 - QA );
 800ccc8:	01f6      	lsls	r6, r6, #7
 800ccca:	4276      	negs	r6, r6
        rc_mult1_Q30 = silk_SUB32( SILK_FIX_CONST( 1, 30 ), silk_SMMUL( rc_Q31, rc_Q31 ) );
 800cccc:	fb86 4506 	smull	r4, r5, r6, r6
 800ccd0:	f1c5 4280 	rsb	r2, r5, #1073741824	; 0x40000000
        invGain_Q30 = silk_LSHIFT( silk_SMMUL( invGain_Q30, rc_mult1_Q30 ), 2 );
 800ccd4:	f022 0403 	bic.w	r4, r2, #3
 800ccd8:	9416      	str	r4, [sp, #88]	; 0x58
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
 800ccda:	4fc6      	ldr	r7, [pc, #792]	; (800cff4 <silk_LPC_inverse_pred_gain_c+0x37c>)
        rc_mult1_Q30 = silk_SUB32( SILK_FIX_CONST( 1, 30 ), silk_SMMUL( rc_Q31, rc_Q31 ) );
 800ccdc:	4634      	mov	r4, r6
 800ccde:	17f5      	asrs	r5, r6, #31
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
 800cce0:	9e16      	ldr	r6, [sp, #88]	; 0x58
 800cce2:	42be      	cmp	r6, r7
 800cce4:	dddd      	ble.n	800cca2 <silk_LPC_inverse_pred_gain_c+0x2a>
 800cce6:	910e      	str	r1, [sp, #56]	; 0x38
 800cce8:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 800ccec:	3901      	subs	r1, #1
        if( ( A_QA[ k ] > A_LIMIT ) || ( A_QA[ k ] < -A_LIMIT ) ) {
 800ccee:	e9cd 3017 	strd	r3, r0, [sp, #92]	; 0x5c
 800ccf2:	ab1a      	add	r3, sp, #104	; 0x68
 800ccf4:	eb03 0381 	add.w	r3, r3, r1, lsl #2
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
 800ccf8:	9719      	str	r7, [sp, #100]	; 0x64
 800ccfa:	930f      	str	r3, [sp, #60]	; 0x3c
 800ccfc:	2a00      	cmp	r2, #0
 800ccfe:	f000 81b1 	beq.w	800d064 <silk_LPC_inverse_pred_gain_c+0x3ec>
        mult2Q = 32 - silk_CLZ32( silk_abs( rc_mult1_Q30 ) );
 800cd02:	ea82 7ce2 	eor.w	ip, r2, r2, asr #31
 800cd06:	ebac 7ce2 	sub.w	ip, ip, r2, asr #31
 800cd0a:	fabc fc8c 	clz	ip, ip
 800cd0e:	2000      	movs	r0, #0
 800cd10:	f1cc 0320 	rsb	r3, ip, #32
 800cd14:	9309      	str	r3, [sp, #36]	; 0x24
        rc_mult2 = silk_INVERSE32_varQ( rc_mult1_Q30, mult2Q + 30 );
 800cd16:	f10c 33ff 	add.w	r3, ip, #4294967295
    /* Compute number of bits head room and normalize input */
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                */

    /* Inverse of b32, with 14 bits of precision */
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
 800cd1a:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                */
 800cd1e:	fa02 f303 	lsl.w	r3, r2, r3
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
 800cd22:	141a      	asrs	r2, r3, #16
 800cd24:	fb91 f2f2 	sdiv	r2, r1, r2
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800cd28:	0416      	lsls	r6, r2, #16
  __asm__(
 800cd2a:	fb83 7106 	smull	r7, r1, r3, r6

    /* First approximation */
    result = silk_LSHIFT(b32_inv, 16);                                          /* Q: 61 - b_headrm            */

    /* Compute residual by subtracting product of denominator and first approximation from one */
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
 800cd2e:	f1c1 5100 	rsb	r1, r1, #536870912	; 0x20000000
 800cd32:	00c9      	lsls	r1, r1, #3
static OPUS_INLINE opus_int32 silk_SMLAWW_armv4(opus_int32 a, opus_int32 b,
 opus_int32 c)
{
  unsigned rd_lo;
  int rd_hi;
  __asm__(
 800cd34:	fb81 6302 	smull	r6, r3, r1, r2
    "#silk_SMLAWW\n\t"
    "smull %0, %1, %2, %3\n\t"
    : "=&r"(rd_lo), "=&r"(rd_hi)
    : "%r"(b), "r"(c)
  );
  return a+SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800cd38:	041b      	lsls	r3, r3, #16
 800cd3a:	eb03 4202 	add.w	r2, r3, r2, lsl #16
    /* Refinement */
    result = silk_SMLAWW(result, err_Q32, b32_inv);                             /* Q: 61 - b_headrm            */

    /* Convert to Qres domain */
    lshift = 61 - b_headrm - Qres;
    if( lshift <= 0 ) {
 800cd3e:	2800      	cmp	r0, #0
 800cd40:	eb02 4216 	add.w	r2, r2, r6, lsr #16
 800cd44:	f340 8199 	ble.w	800d07a <silk_LPC_inverse_pred_gain_c+0x402>
        return silk_LSHIFT_SAT32(result, -lshift);
    } else {
        if( lshift < 32){
 800cd48:	2820      	cmp	r0, #32
            return silk_RSHIFT(result, lshift);
        }else{
            /* Avoid undefined result */
            return 0;
 800cd4a:	bf0c      	ite	eq
 800cd4c:	2300      	moveq	r3, #0
            return silk_RSHIFT(result, lshift);
 800cd4e:	fa42 f300 	asrne.w	r3, r2, r0
            return 0;
 800cd52:	930d      	str	r3, [sp, #52]	; 0x34
        for( n = 0; n < (k + 1) >> 1; n++ ) {
 800cd54:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800cd56:	105b      	asrs	r3, r3, #1
 800cd58:	2b00      	cmp	r3, #0
 800cd5a:	f340 819d 	ble.w	800d098 <silk_LPC_inverse_pred_gain_c+0x420>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
 800cd5e:	980d      	ldr	r0, [sp, #52]	; 0x34
 800cd60:	f1cc 0c1f 	rsb	ip, ip, #31
 800cd64:	4606      	mov	r6, r0
 800cd66:	17c7      	asrs	r7, r0, #31
 800cd68:	e9cd 6704 	strd	r6, r7, [sp, #16]
 800cd6c:	4246      	negs	r6, r0
 800cd6e:	ea4f 71c6 	mov.w	r1, r6, lsl #31
 800cd72:	910a      	str	r1, [sp, #40]	; 0x28
 800cd74:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 800cd78:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 800cd7c:	07fa      	lsls	r2, r7, #31
 800cd7e:	ea42 0256 	orr.w	r2, r2, r6, lsr #1
 800cd82:	920b      	str	r2, [sp, #44]	; 0x2c
 800cd84:	fb80 1201 	smull	r1, r2, r0, r1
 800cd88:	460e      	mov	r6, r1
 800cd8a:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 800cd8e:	1049      	asrs	r1, r1, #1
 800cd90:	ea4f 0030 	mov.w	r0, r0, rrx
 800cd94:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
 800cd98:	4631      	mov	r1, r6
 800cd9a:	4617      	mov	r7, r2
 800cd9c:	1052      	asrs	r2, r2, #1
 800cd9e:	ea4f 0131 	mov.w	r1, r1, rrx
 800cda2:	e9cd 1214 	strd	r1, r2, [sp, #80]	; 0x50
 800cda6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800cda8:	f1cc 0b20 	rsb	fp, ip, #32
 800cdac:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
 800cdb0:	e9cd 6712 	strd	r6, r7, [sp, #72]	; 0x48
 800cdb4:	f10d 0e68 	add.w	lr, sp, #104	; 0x68
 800cdb8:	930c      	str	r3, [sp, #48]	; 0x30
 800cdba:	4617      	mov	r7, r2
 800cdbc:	f8cd b020 	str.w	fp, [sp, #32]
 800cdc0:	e9cd 8900 	strd	r8, r9, [sp]
 800cdc4:	e09f      	b.n	800cf06 <silk_LPC_inverse_pred_gain_c+0x28e>
 800cdc6:	2b00      	cmp	r3, #0
 800cdc8:	f2c0 8116 	blt.w	800cff8 <silk_LPC_inverse_pred_gain_c+0x380>
 800cdcc:	f108 4000 	add.w	r0, r8, #2147483648	; 0x80000000
 800cdd0:	4210      	tst	r0, r2
 800cdd2:	f100 8125 	bmi.w	800d020 <silk_LPC_inverse_pred_gain_c+0x3a8>
 800cdd6:	469a      	mov	sl, r3
 800cdd8:	ea4f 7be3 	mov.w	fp, r3, asr #31
 800cddc:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 800cde0:	fb0a f309 	mul.w	r3, sl, r9
 800cde4:	fbaa 0108 	umull	r0, r1, sl, r8
 800cde8:	fb08 330b 	mla	r3, r8, fp, r3
 800cdec:	4419      	add	r1, r3
 800cdee:	fa20 f30c 	lsr.w	r3, r0, ip
 800cdf2:	9300      	str	r3, [sp, #0]
 800cdf4:	9b08      	ldr	r3, [sp, #32]
 800cdf6:	f1bc 0920 	subs.w	r9, ip, #32
 800cdfa:	fa01 f803 	lsl.w	r8, r1, r3
 800cdfe:	9b00      	ldr	r3, [sp, #0]
 800ce00:	ea43 0308 	orr.w	r3, r3, r8
 800ce04:	9300      	str	r3, [sp, #0]
 800ce06:	d404      	bmi.n	800ce12 <silk_LPC_inverse_pred_gain_c+0x19a>
 800ce08:	fa41 f909 	asr.w	r9, r1, r9
 800ce0c:	ea43 0309 	orr.w	r3, r3, r9
 800ce10:	9300      	str	r3, [sp, #0]
 800ce12:	fa41 f30c 	asr.w	r3, r1, ip
 800ce16:	9301      	str	r3, [sp, #4]
 800ce18:	e9dd 8900 	ldrd	r8, r9, [sp]
 800ce1c:	f118 0801 	adds.w	r8, r8, #1
 800ce20:	f149 0900 	adc.w	r9, r9, #0
 800ce24:	ea5f 0969 	movs.w	r9, r9, asr #1
 800ce28:	ea4f 0838 	mov.w	r8, r8, rrx
 800ce2c:	4640      	mov	r0, r8
 800ce2e:	4649      	mov	r1, r9
 800ce30:	e9cd 0106 	strd	r0, r1, [sp, #24]
            if( tmp64 > silk_int32_MAX || tmp64 < silk_int32_MIN ) {
 800ce34:	f118 4000 	adds.w	r0, r8, #2147483648	; 0x80000000
 800ce38:	f149 0100 	adc.w	r1, r9, #0
 800ce3c:	f04f 0900 	mov.w	r9, #0
 800ce40:	f04f 38ff 	mov.w	r8, #4294967295
 800ce44:	4589      	cmp	r9, r1
 800ce46:	bf08      	it	eq
 800ce48:	4580      	cmpeq	r8, r0
 800ce4a:	f4ff af2a 	bcc.w	800cca2 <silk_LPC_inverse_pred_gain_c+0x2a>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
 800ce4e:	fb02 f905 	mul.w	r9, r2, r5
 800ce52:	17d1      	asrs	r1, r2, #31
 800ce54:	fb04 9901 	mla	r9, r4, r1, r9
 800ce58:	fba2 2304 	umull	r2, r3, r2, r4
 800ce5c:	444b      	add	r3, r9
 800ce5e:	ea4f 7a92 	mov.w	sl, r2, lsr #30
 800ce62:	ea4a 0a83 	orr.w	sl, sl, r3, lsl #2
 800ce66:	f11a 0001 	adds.w	r0, sl, #1
 800ce6a:	ea4f 7ba3 	mov.w	fp, r3, asr #30
 800ce6e:	f14b 0100 	adc.w	r1, fp, #0
 800ce72:	1049      	asrs	r1, r1, #1
 800ce74:	ea4f 0030 	mov.w	r0, r0, rrx
            A_QA[ n ] = ( opus_int32 )tmp64;
 800ce78:	9b06      	ldr	r3, [sp, #24]
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
 800ce7a:	1a32      	subs	r2, r6, r0
            A_QA[ n ] = ( opus_int32 )tmp64;
 800ce7c:	f8ce 3000 	str.w	r3, [lr]
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
 800ce80:	f100 80c5 	bmi.w	800d00e <silk_LPC_inverse_pred_gain_c+0x396>
 800ce84:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800ce88:	4230      	tst	r0, r6
 800ce8a:	f100 80ce 	bmi.w	800d02a <silk_LPC_inverse_pred_gain_c+0x3b2>
 800ce8e:	17d3      	asrs	r3, r2, #31
 800ce90:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 800ce94:	4649      	mov	r1, r9
 800ce96:	fb02 f101 	mul.w	r1, r2, r1
 800ce9a:	fb08 1103 	mla	r1, r8, r3, r1
 800ce9e:	fba2 2308 	umull	r2, r3, r2, r8
 800cea2:	440b      	add	r3, r1
 800cea4:	fa22 f10c 	lsr.w	r1, r2, ip
 800cea8:	9102      	str	r1, [sp, #8]
 800ceaa:	9908      	ldr	r1, [sp, #32]
 800ceac:	9e02      	ldr	r6, [sp, #8]
 800ceae:	fa03 f001 	lsl.w	r0, r3, r1
 800ceb2:	4306      	orrs	r6, r0
 800ceb4:	f1bc 0120 	subs.w	r1, ip, #32
 800ceb8:	9602      	str	r6, [sp, #8]
 800ceba:	d404      	bmi.n	800cec6 <silk_LPC_inverse_pred_gain_c+0x24e>
 800cebc:	4630      	mov	r0, r6
 800cebe:	fa43 f101 	asr.w	r1, r3, r1
 800cec2:	4308      	orrs	r0, r1
 800cec4:	9002      	str	r0, [sp, #8]
 800cec6:	fa43 f30c 	asr.w	r3, r3, ip
 800ceca:	9303      	str	r3, [sp, #12]
 800cecc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800ced0:	3201      	adds	r2, #1
 800ced2:	f143 0300 	adc.w	r3, r3, #0
 800ced6:	ea5f 0963 	movs.w	r9, r3, asr #1
 800ceda:	ea4f 0832 	mov.w	r8, r2, rrx
            if( tmp64 > silk_int32_MAX || tmp64 < silk_int32_MIN ) {
 800cede:	2300      	movs	r3, #0
 800cee0:	f04f 32ff 	mov.w	r2, #4294967295
 800cee4:	f118 4000 	adds.w	r0, r8, #2147483648	; 0x80000000
 800cee8:	f149 0100 	adc.w	r1, r9, #0
 800ceec:	428b      	cmp	r3, r1
 800ceee:	bf08      	it	eq
 800cef0:	4282      	cmpeq	r2, r0
 800cef2:	f4ff aed6 	bcc.w	800cca2 <silk_LPC_inverse_pred_gain_c+0x2a>
        for( n = 0; n < (k + 1) >> 1; n++ ) {
 800cef6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
            A_QA[ k - n - 1 ] = ( opus_int32 )tmp64;
 800cef8:	f8c7 8000 	str.w	r8, [r7]
        for( n = 0; n < (k + 1) >> 1; n++ ) {
 800cefc:	429f      	cmp	r7, r3
 800cefe:	f10e 0e04 	add.w	lr, lr, #4
 800cf02:	f000 80c7 	beq.w	800d094 <silk_LPC_inverse_pred_gain_c+0x41c>
            tmp2 = A_QA[ k - n - 1 ];
 800cf06:	f857 6d04 	ldr.w	r6, [r7, #-4]!
 800cf0a:	fb06 f805 	mul.w	r8, r6, r5
 800cf0e:	17f1      	asrs	r1, r6, #31
 800cf10:	fb04 8801 	mla	r8, r4, r1, r8
 800cf14:	fba6 0104 	umull	r0, r1, r6, r4
 800cf18:	4441      	add	r1, r8
 800cf1a:	ea4f 7990 	mov.w	r9, r0, lsr #30
 800cf1e:	ea49 0981 	orr.w	r9, r9, r1, lsl #2
 800cf22:	f119 0201 	adds.w	r2, r9, #1
 800cf26:	ea4f 7aa1 	mov.w	sl, r1, asr #30
 800cf2a:	f14a 0300 	adc.w	r3, sl, #0
 800cf2e:	ea5f 0963 	movs.w	r9, r3, asr #1
 800cf32:	ea4f 0832 	mov.w	r8, r2, rrx
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
 800cf36:	9909      	ldr	r1, [sp, #36]	; 0x24
            tmp1 = A_QA[ n ];
 800cf38:	f8de 2000 	ldr.w	r2, [lr]
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
 800cf3c:	2901      	cmp	r1, #1
 800cf3e:	eba2 0308 	sub.w	r3, r2, r8
 800cf42:	f47f af40 	bne.w	800cdc6 <silk_LPC_inverse_pred_gain_c+0x14e>
 800cf46:	2b00      	cmp	r3, #0
 800cf48:	db74      	blt.n	800d034 <silk_LPC_inverse_pred_gain_c+0x3bc>
 800cf4a:	f108 4000 	add.w	r0, r8, #2147483648	; 0x80000000
 800cf4e:	4210      	tst	r0, r2
 800cf50:	f100 8083 	bmi.w	800d05a <silk_LPC_inverse_pred_gain_c+0x3e2>
 800cf54:	990d      	ldr	r1, [sp, #52]	; 0x34
 800cf56:	fb83 ab01 	smull	sl, fp, r3, r1
 800cf5a:	ea5f 096b 	movs.w	r9, fp, asr #1
 800cf5e:	ea4f 083a 	mov.w	r8, sl, rrx
 800cf62:	2100      	movs	r1, #0
 800cf64:	f00a 0001 	and.w	r0, sl, #1
 800cf68:	eb10 0a08 	adds.w	sl, r0, r8
 800cf6c:	eb41 0b09 	adc.w	fp, r1, r9
 800cf70:	4650      	mov	r0, sl
 800cf72:	4659      	mov	r1, fp
            if( tmp64 > silk_int32_MAX || tmp64 < silk_int32_MIN ) {
 800cf74:	f04f 0900 	mov.w	r9, #0
 800cf78:	f04f 38ff 	mov.w	r8, #4294967295
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
 800cf7c:	e9cd 0106 	strd	r0, r1, [sp, #24]
            if( tmp64 > silk_int32_MAX || tmp64 < silk_int32_MIN ) {
 800cf80:	f11a 4000 	adds.w	r0, sl, #2147483648	; 0x80000000
 800cf84:	f14b 0100 	adc.w	r1, fp, #0
 800cf88:	4589      	cmp	r9, r1
 800cf8a:	bf08      	it	eq
 800cf8c:	4580      	cmpeq	r8, r0
 800cf8e:	f4ff ae88 	bcc.w	800cca2 <silk_LPC_inverse_pred_gain_c+0x2a>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
 800cf92:	fb02 f805 	mul.w	r8, r2, r5
 800cf96:	17d1      	asrs	r1, r2, #31
 800cf98:	fb04 8801 	mla	r8, r4, r1, r8
 800cf9c:	fba2 2304 	umull	r2, r3, r2, r4
 800cfa0:	4443      	add	r3, r8
 800cfa2:	ea4f 7992 	mov.w	r9, r2, lsr #30
 800cfa6:	ea49 0983 	orr.w	r9, r9, r3, lsl #2
 800cfaa:	f119 0001 	adds.w	r0, r9, #1
 800cfae:	ea4f 7aa3 	mov.w	sl, r3, asr #30
 800cfb2:	f14a 0100 	adc.w	r1, sl, #0
 800cfb6:	1049      	asrs	r1, r1, #1
 800cfb8:	ea4f 0030 	mov.w	r0, r0, rrx
            A_QA[ n ] = ( opus_int32 )tmp64;
 800cfbc:	9b06      	ldr	r3, [sp, #24]
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
 800cfbe:	1a32      	subs	r2, r6, r0
            A_QA[ n ] = ( opus_int32 )tmp64;
 800cfc0:	f8ce 3000 	str.w	r3, [lr]
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
 800cfc4:	d440      	bmi.n	800d048 <silk_LPC_inverse_pred_gain_c+0x3d0>
 800cfc6:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800cfca:	4230      	tst	r0, r6
 800cfcc:	d450      	bmi.n	800d070 <silk_LPC_inverse_pred_gain_c+0x3f8>
 800cfce:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800cfd0:	fb82 8903 	smull	r8, r9, r2, r3
 800cfd4:	ea5f 0169 	movs.w	r1, r9, asr #1
 800cfd8:	ea4f 0038 	mov.w	r0, r8, rrx
 800cfdc:	2300      	movs	r3, #0
 800cfde:	f008 0201 	and.w	r2, r8, #1
 800cfe2:	eb12 0800 	adds.w	r8, r2, r0
 800cfe6:	eb43 0901 	adc.w	r9, r3, r1
 800cfea:	e778      	b.n	800cede <silk_LPC_inverse_pred_gain_c+0x266>
 800cfec:	00ffef9e 	.word	0x00ffef9e
 800cff0:	01ffdf3c 	.word	0x01ffdf3c
 800cff4:	0001a36d 	.word	0x0001a36d
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
 800cff8:	f102 4100 	add.w	r1, r2, #2147483648	; 0x80000000
 800cffc:	ea11 0f08 	tst.w	r1, r8
 800d000:	f57f aee9 	bpl.w	800cdd6 <silk_LPC_inverse_pred_gain_c+0x15e>
 800d004:	f06f 4a00 	mvn.w	sl, #2147483648	; 0x80000000
 800d008:	f04f 0b00 	mov.w	fp, #0
 800d00c:	e6e6      	b.n	800cddc <silk_LPC_inverse_pred_gain_c+0x164>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
 800d00e:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
 800d012:	4206      	tst	r6, r0
 800d014:	f57f af3b 	bpl.w	800ce8e <silk_LPC_inverse_pred_gain_c+0x216>
 800d018:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 800d01c:	2300      	movs	r3, #0
 800d01e:	e737      	b.n	800ce90 <silk_LPC_inverse_pred_gain_c+0x218>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
 800d020:	f04f 4a00 	mov.w	sl, #2147483648	; 0x80000000
 800d024:	f04f 3bff 	mov.w	fp, #4294967295
 800d028:	e6d8      	b.n	800cddc <silk_LPC_inverse_pred_gain_c+0x164>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
 800d02a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800d02e:	f04f 33ff 	mov.w	r3, #4294967295
 800d032:	e72d      	b.n	800ce90 <silk_LPC_inverse_pred_gain_c+0x218>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
 800d034:	f102 4100 	add.w	r1, r2, #2147483648	; 0x80000000
 800d038:	ea11 0f08 	tst.w	r1, r8
 800d03c:	d58a      	bpl.n	800cf54 <silk_LPC_inverse_pred_gain_c+0x2dc>
 800d03e:	e9dd ab12 	ldrd	sl, fp, [sp, #72]	; 0x48
 800d042:	e9dd 8914 	ldrd	r8, r9, [sp, #80]	; 0x50
 800d046:	e78c      	b.n	800cf62 <silk_LPC_inverse_pred_gain_c+0x2ea>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
 800d048:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
 800d04c:	4206      	tst	r6, r0
 800d04e:	d5be      	bpl.n	800cfce <silk_LPC_inverse_pred_gain_c+0x356>
 800d050:	e9dd 8912 	ldrd	r8, r9, [sp, #72]	; 0x48
 800d054:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
 800d058:	e7c0      	b.n	800cfdc <silk_LPC_inverse_pred_gain_c+0x364>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp1,
 800d05a:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 800d05e:	e9dd 8910 	ldrd	r8, r9, [sp, #64]	; 0x40
 800d062:	e77e      	b.n	800cf62 <silk_LPC_inverse_pred_gain_c+0x2ea>
 800d064:	4610      	mov	r0, r2
        mult2Q = 32 - silk_CLZ32( silk_abs( rc_mult1_Q30 ) );
 800d066:	9209      	str	r2, [sp, #36]	; 0x24
 800d068:	231f      	movs	r3, #31
 800d06a:	f04f 0c20 	mov.w	ip, #32
 800d06e:	e654      	b.n	800cd1a <silk_LPC_inverse_pred_gain_c+0xa2>
            tmp64 = silk_RSHIFT_ROUND64( silk_SMULL( silk_SUB_SAT32(tmp2,
 800d070:	e9dd 890a 	ldrd	r8, r9, [sp, #40]	; 0x28
 800d074:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 800d078:	e7b0      	b.n	800cfdc <silk_LPC_inverse_pred_gain_c+0x364>
        return silk_LSHIFT_SAT32(result, -lshift);
 800d07a:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800d07e:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 800d082:	4240      	negs	r0, r0
 800d084:	4103      	asrs	r3, r0
 800d086:	4101      	asrs	r1, r0
 800d088:	428b      	cmp	r3, r1
 800d08a:	dd26      	ble.n	800d0da <silk_LPC_inverse_pred_gain_c+0x462>
 800d08c:	429a      	cmp	r2, r3
 800d08e:	dd2f      	ble.n	800d0f0 <silk_LPC_inverse_pred_gain_c+0x478>
 800d090:	461a      	mov	r2, r3
 800d092:	e027      	b.n	800d0e4 <silk_LPC_inverse_pred_gain_c+0x46c>
 800d094:	e9dd 8900 	ldrd	r8, r9, [sp]
 800d098:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800d09a:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 800d09e:	930f      	str	r3, [sp, #60]	; 0x3c
 800d0a0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800d0a2:	18e2      	adds	r2, r4, r3
    for( k = order - 1; k > 0; k-- ) {
 800d0a4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d0a6:	2b02      	cmp	r3, #2
 800d0a8:	d029      	beq.n	800d0fe <silk_LPC_inverse_pred_gain_c+0x486>
        if( ( A_QA[ k ] > A_LIMIT ) || ( A_QA[ k ] < -A_LIMIT ) ) {
 800d0aa:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800d0ac:	429a      	cmp	r2, r3
 800d0ae:	f63f adf8 	bhi.w	800cca2 <silk_LPC_inverse_pred_gain_c+0x2a>
        rc_Q31 = -silk_LSHIFT( A_QA[ k ], 31 - QA );
 800d0b2:	01e4      	lsls	r4, r4, #7
 800d0b4:	4264      	negs	r4, r4
        rc_mult1_Q30 = silk_SUB32( SILK_FIX_CONST( 1, 30 ), silk_SMMUL( rc_Q31, rc_Q31 ) );
 800d0b6:	fb84 2304 	smull	r2, r3, r4, r4
 800d0ba:	f1c3 4280 	rsb	r2, r3, #1073741824	; 0x40000000
        invGain_Q30 = silk_LSHIFT( silk_SMMUL( invGain_Q30, rc_mult1_Q30 ), 2 );
 800d0be:	9b16      	ldr	r3, [sp, #88]	; 0x58
        rc_mult1_Q30 = silk_SUB32( SILK_FIX_CONST( 1, 30 ), silk_SMMUL( rc_Q31, rc_Q31 ) );
 800d0c0:	17e5      	asrs	r5, r4, #31
        invGain_Q30 = silk_LSHIFT( silk_SMMUL( invGain_Q30, rc_mult1_Q30 ), 2 );
 800d0c2:	fb83 0102 	smull	r0, r1, r3, r2
 800d0c6:	008b      	lsls	r3, r1, #2
 800d0c8:	990e      	ldr	r1, [sp, #56]	; 0x38
 800d0ca:	9316      	str	r3, [sp, #88]	; 0x58
 800d0cc:	3901      	subs	r1, #1
 800d0ce:	910e      	str	r1, [sp, #56]	; 0x38
        if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
 800d0d0:	9919      	ldr	r1, [sp, #100]	; 0x64
 800d0d2:	428b      	cmp	r3, r1
 800d0d4:	f73f ae12 	bgt.w	800ccfc <silk_LPC_inverse_pred_gain_c+0x84>
 800d0d8:	e5e3      	b.n	800cca2 <silk_LPC_inverse_pred_gain_c+0x2a>
 800d0da:	428a      	cmp	r2, r1
 800d0dc:	dc06      	bgt.n	800d0ec <silk_LPC_inverse_pred_gain_c+0x474>
 800d0de:	429a      	cmp	r2, r3
 800d0e0:	bfb8      	it	lt
 800d0e2:	461a      	movlt	r2, r3
 800d0e4:	fa02 f300 	lsl.w	r3, r2, r0
 800d0e8:	930d      	str	r3, [sp, #52]	; 0x34
 800d0ea:	e633      	b.n	800cd54 <silk_LPC_inverse_pred_gain_c+0xdc>
 800d0ec:	460a      	mov	r2, r1
 800d0ee:	e7f9      	b.n	800d0e4 <silk_LPC_inverse_pred_gain_c+0x46c>
 800d0f0:	428a      	cmp	r2, r1
 800d0f2:	bfb8      	it	lt
 800d0f4:	460a      	movlt	r2, r1
 800d0f6:	e7f5      	b.n	800d0e4 <silk_LPC_inverse_pred_gain_c+0x46c>
    invGain_Q30 = SILK_FIX_CONST( 1, 30 );
 800d0f8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800d0fc:	9316      	str	r3, [sp, #88]	; 0x58
    if( ( A_QA[ k ] > A_LIMIT ) || ( A_QA[ k ] < -A_LIMIT ) ) {
 800d0fe:	4b0a      	ldr	r3, [pc, #40]	; (800d128 <silk_LPC_inverse_pred_gain_c+0x4b0>)
 800d100:	429a      	cmp	r2, r3
 800d102:	f63f adce 	bhi.w	800cca2 <silk_LPC_inverse_pred_gain_c+0x2a>
    rc_Q31 = -silk_LSHIFT( A_QA[ 0 ], 31 - QA );
 800d106:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
 800d108:	4c08      	ldr	r4, [pc, #32]	; (800d12c <silk_LPC_inverse_pred_gain_c+0x4b4>)
    rc_Q31 = -silk_LSHIFT( A_QA[ 0 ], 31 - QA );
 800d10a:	01da      	lsls	r2, r3, #7
 800d10c:	4252      	negs	r2, r2
    rc_mult1_Q30 = silk_SUB32( SILK_FIX_CONST( 1, 30 ), silk_SMMUL( rc_Q31, rc_Q31 ) );
 800d10e:	fb82 2302 	smull	r2, r3, r2, r2
 800d112:	f1c3 4080 	rsb	r0, r3, #1073741824	; 0x40000000
    invGain_Q30 = silk_LSHIFT( silk_SMMUL( invGain_Q30, rc_mult1_Q30 ), 2 );
 800d116:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800d118:	fb80 0103 	smull	r0, r1, r0, r3
 800d11c:	0088      	lsls	r0, r1, #2
    if( invGain_Q30 < SILK_FIX_CONST( 1.0f / MAX_PREDICTION_POWER_GAIN, 30 ) ) {
 800d11e:	42a0      	cmp	r0, r4
 800d120:	f73f adc0 	bgt.w	800cca4 <silk_LPC_inverse_pred_gain_c+0x2c>
 800d124:	e5bd      	b.n	800cca2 <silk_LPC_inverse_pred_gain_c+0x2a>
 800d126:	bf00      	nop
 800d128:	01ffdf3c 	.word	0x01ffdf3c
 800d12c:	0001a36d 	.word	0x0001a36d

0800d130 <silk_NLSF2A>:
    opus_int16                  *a_Q12,             /* O    monic whitening filter coefficients in Q12,  [ d ]          */
    const opus_int16            *NLSF,              /* I    normalized line spectral frequencies in Q15, [ d ]          */
    const opus_int              d,                  /* I    filter order (should be even)                               */
    int                         arch                /* I    Run-time architecture                                       */
)
{
 800d130:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    silk_assert( LSF_COS_TAB_SZ_FIX == 128 );
    celt_assert( d==10 || d==16 );

    /* convert LSFs to 2*cos(LSF), using piecewise linear curve from table */
    ordering = d == 16 ? ordering16 : ordering10;
 800d134:	2a10      	cmp	r2, #16
{
 800d136:	b0d9      	sub	sp, #356	; 0x164
 800d138:	920a      	str	r2, [sp, #40]	; 0x28
 800d13a:	900d      	str	r0, [sp, #52]	; 0x34
    ordering = d == 16 ? ordering16 : ordering10;
 800d13c:	f000 83a5 	beq.w	800d88a <silk_NLSF2A+0x75a>
    for( k = 0; k < d; k++ ) {
 800d140:	2a00      	cmp	r2, #0
 800d142:	dd22      	ble.n	800d18a <silk_NLSF2A+0x5a>
 800d144:	4614      	mov	r4, r2
    ordering = d == 16 ? ordering16 : ordering10;
 800d146:	4eb4      	ldr	r6, [pc, #720]	; (800d418 <silk_NLSF2A+0x2e8>)
 800d148:	2500      	movs	r5, #0
 800d14a:	4fb4      	ldr	r7, [pc, #720]	; (800d41c <silk_NLSF2A+0x2ec>)
 800d14c:	3902      	subs	r1, #2
 800d14e:	3e01      	subs	r6, #1
        silk_assert( NLSF[k] >= 0 );

        /* f_int on a scale 0-127 (rounded down) */
        f_int = silk_RSHIFT( NLSF[k], 15 - 7 );
 800d150:	f931 cf02 	ldrsh.w	ip, [r1, #2]!
        /* Read start and end value from table */
        cos_val = silk_LSFCosTab_FIX_Q12[ f_int ];                /* Q12 */
        delta   = silk_LSFCosTab_FIX_Q12[ f_int + 1 ] - cos_val;  /* Q12, with a range of 0..200 */

        /* Linear interpolation */
        cos_LSF_QA[ordering[k]] = silk_RSHIFT_ROUND( silk_LSHIFT( cos_val, 8 ) + silk_MUL( delta, f_frac ), 20 - QA ); /* QA */
 800d154:	f816 0f01 	ldrb.w	r0, [r6, #1]!
        f_int = silk_RSHIFT( NLSF[k], 15 - 7 );
 800d158:	ea4f 2e2c 	mov.w	lr, ip, asr #8
        delta   = silk_LSFCosTab_FIX_Q12[ f_int + 1 ] - cos_val;  /* Q12, with a range of 0..200 */
 800d15c:	f10e 0301 	add.w	r3, lr, #1
        cos_val = silk_LSFCosTab_FIX_Q12[ f_int ];                /* Q12 */
 800d160:	f937 201e 	ldrsh.w	r2, [r7, lr, lsl #1]
        delta   = silk_LSFCosTab_FIX_Q12[ f_int + 1 ] - cos_val;  /* Q12, with a range of 0..200 */
 800d164:	f937 3013 	ldrsh.w	r3, [r7, r3, lsl #1]
        f_frac = NLSF[k] - silk_LSHIFT( f_int, 15 - 7 );
 800d168:	ebac 2c0e 	sub.w	ip, ip, lr, lsl #8
        delta   = silk_LSFCosTab_FIX_Q12[ f_int + 1 ] - cos_val;  /* Q12, with a range of 0..200 */
 800d16c:	1a9b      	subs	r3, r3, r2
        cos_LSF_QA[ordering[k]] = silk_RSHIFT_ROUND( silk_LSHIFT( cos_val, 8 ) + silk_MUL( delta, f_frac ), 20 - QA ); /* QA */
 800d16e:	0212      	lsls	r2, r2, #8
 800d170:	fb0c 2303 	mla	r3, ip, r3, r2
 800d174:	10db      	asrs	r3, r3, #3
 800d176:	3301      	adds	r3, #1
    for( k = 0; k < d; k++ ) {
 800d178:	3501      	adds	r5, #1
        cos_LSF_QA[ordering[k]] = silk_RSHIFT_ROUND( silk_LSHIFT( cos_val, 8 ) + silk_MUL( delta, f_frac ), 20 - QA ); /* QA */
 800d17a:	aa58      	add	r2, sp, #352	; 0x160
 800d17c:	105b      	asrs	r3, r3, #1
 800d17e:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    for( k = 0; k < d; k++ ) {
 800d182:	42ac      	cmp	r4, r5
        cos_LSF_QA[ordering[k]] = silk_RSHIFT_ROUND( silk_LSHIFT( cos_val, 8 ) + silk_MUL( delta, f_frac ), 20 - QA ); /* QA */
 800d184:	f840 3cc0 	str.w	r3, [r0, #-192]
    for( k = 0; k < d; k++ ) {
 800d188:	dce2      	bgt.n	800d150 <silk_NLSF2A+0x20>
 800d18a:	e9dd 3128 	ldrd	r3, r1, [sp, #160]	; 0xa0
    out[0] = silk_LSHIFT( 1, QA );
 800d18e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    }

    dd = silk_RSHIFT( d, 1 );
 800d192:	980a      	ldr	r0, [sp, #40]	; 0x28
    out[1] = -cLSF[0];
 800d194:	425b      	negs	r3, r3
    dd = silk_RSHIFT( d, 1 );
 800d196:	1040      	asrs	r0, r0, #1
    out[0] = silk_LSHIFT( 1, QA );
 800d198:	f10d 0a38 	add.w	sl, sp, #56	; 0x38
 800d19c:	e9ca 2300 	strd	r2, r3, [sl]
    for( k = 1; k < dd; k++ ) {
 800d1a0:	2801      	cmp	r0, #1
 800d1a2:	f1c1 0300 	rsb	r3, r1, #0
    dd = silk_RSHIFT( d, 1 );
 800d1a6:	9009      	str	r0, [sp, #36]	; 0x24
 800d1a8:	930b      	str	r3, [sp, #44]	; 0x2c
    for( k = 1; k < dd; k++ ) {
 800d1aa:	f340 8374 	ble.w	800d896 <silk_NLSF2A+0x766>
 800d1ae:	2301      	movs	r3, #1
 800d1b0:	f10d 0b3c 	add.w	fp, sp, #60	; 0x3c
 800d1b4:	f8cd b01c 	str.w	fp, [sp, #28]
 800d1b8:	469b      	mov	fp, r3
        ftmp = cLSF[2*k];            /* QA*/
 800d1ba:	ab28      	add	r3, sp, #160	; 0xa0
 800d1bc:	f853 803b 	ldr.w	r8, [r3, fp, lsl #3]
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
 800d1c0:	9d07      	ldr	r5, [sp, #28]
 800d1c2:	e955 e901 	ldrd	lr, r9, [r5, #-4]
 800d1c6:	fb88 0109 	smull	r0, r1, r8, r9
 800d1ca:	0bc6      	lsrs	r6, r0, #15
 800d1cc:	ea46 4641 	orr.w	r6, r6, r1, lsl #17
 800d1d0:	1c72      	adds	r2, r6, #1
 800d1d2:	ea4f 37e1 	mov.w	r7, r1, asr #15
 800d1d6:	f147 0300 	adc.w	r3, r7, #0
 800d1da:	105b      	asrs	r3, r3, #1
 800d1dc:	ea4f 0232 	mov.w	r2, r2, rrx
        for( n = k; n > 1; n-- ) {
 800d1e0:	f1bb 0f01 	cmp.w	fp, #1
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
 800d1e4:	ebc2 024e 	rsb	r2, r2, lr, lsl #1
 800d1e8:	606a      	str	r2, [r5, #4]
        for( n = k; n > 1; n-- ) {
 800d1ea:	d066      	beq.n	800d2ba <silk_NLSF2A+0x18a>
 800d1ec:	f1bb 0f03 	cmp.w	fp, #3
 800d1f0:	465c      	mov	r4, fp
 800d1f2:	dd43      	ble.n	800d27c <silk_NLSF2A+0x14c>
 800d1f4:	464f      	mov	r7, r9
 800d1f6:	f1ab 0304 	sub.w	r3, fp, #4
 800d1fa:	f023 0301 	bic.w	r3, r3, #1
 800d1fe:	f1ab 0202 	sub.w	r2, fp, #2
 800d202:	1ad3      	subs	r3, r2, r3
 800d204:	e9cd 8305 	strd	r8, r3, [sp, #20]
 800d208:	f8cd b020 	str.w	fp, [sp, #32]
            out[n] += out[n-2] - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[n-1] ), QA );
 800d20c:	9905      	ldr	r1, [sp, #20]
 800d20e:	f855 6c08 	ldr.w	r6, [r5, #-8]
 800d212:	fb81 230e 	smull	r2, r3, r1, lr
 800d216:	fb81 8906 	smull	r8, r9, r1, r6
 800d21a:	0bd0      	lsrs	r0, r2, #15
 800d21c:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
 800d220:	13db      	asrs	r3, r3, #15
 800d222:	9303      	str	r3, [sp, #12]
 800d224:	9002      	str	r0, [sp, #8]
 800d226:	ea4f 3bd8 	mov.w	fp, r8, lsr #15
 800d22a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800d22e:	ea4b 4b49 	orr.w	fp, fp, r9, lsl #17
 800d232:	3001      	adds	r0, #1
 800d234:	f141 0100 	adc.w	r1, r1, #0
 800d238:	ea4f 3ce9 	mov.w	ip, r9, asr #15
 800d23c:	f11b 0201 	adds.w	r2, fp, #1
 800d240:	f14c 0300 	adc.w	r3, ip, #0
 800d244:	1049      	asrs	r1, r1, #1
 800d246:	ea4f 0030 	mov.w	r0, r0, rrx
 800d24a:	105b      	asrs	r3, r3, #1
 800d24c:	ea4f 0232 	mov.w	r2, r2, rrx
 800d250:	1a30      	subs	r0, r6, r0
 800d252:	4407      	add	r7, r0
 800d254:	f84a 7024 	str.w	r7, [sl, r4, lsl #2]
 800d258:	f855 1c0c 	ldr.w	r1, [r5, #-12]
 800d25c:	9b06      	ldr	r3, [sp, #24]
 800d25e:	3c02      	subs	r4, #2
 800d260:	1a8a      	subs	r2, r1, r2
 800d262:	4472      	add	r2, lr
 800d264:	429c      	cmp	r4, r3
 800d266:	f845 2c04 	str.w	r2, [r5, #-4]
 800d26a:	4637      	mov	r7, r6
 800d26c:	468e      	mov	lr, r1
 800d26e:	f1a5 0508 	sub.w	r5, r5, #8
 800d272:	d1cb      	bne.n	800d20c <silk_NLSF2A+0xdc>
 800d274:	f8dd 8014 	ldr.w	r8, [sp, #20]
 800d278:	f8dd b020 	ldr.w	fp, [sp, #32]
 800d27c:	00a4      	lsls	r4, r4, #2
 800d27e:	1f25      	subs	r5, r4, #4
 800d280:	4455      	add	r5, sl
 800d282:	4454      	add	r4, sl
 800d284:	f855 6904 	ldr.w	r6, [r5], #-4
 800d288:	6821      	ldr	r1, [r4, #0]
 800d28a:	fb88 6706 	smull	r6, r7, r8, r6
 800d28e:	0bf3      	lsrs	r3, r6, #15
 800d290:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
 800d294:	9302      	str	r3, [sp, #8]
 800d296:	13fb      	asrs	r3, r7, #15
 800d298:	9303      	str	r3, [sp, #12]
 800d29a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800d29e:	3201      	adds	r2, #1
 800d2a0:	f143 0300 	adc.w	r3, r3, #0
 800d2a4:	105f      	asrs	r7, r3, #1
 800d2a6:	ea4f 0632 	mov.w	r6, r2, rrx
 800d2aa:	682b      	ldr	r3, [r5, #0]
        for( n = k; n > 1; n-- ) {
 800d2ac:	4555      	cmp	r5, sl
            out[n] += out[n-2] - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[n-1] ), QA );
 800d2ae:	eba3 0206 	sub.w	r2, r3, r6
 800d2b2:	4411      	add	r1, r2
 800d2b4:	f844 1904 	str.w	r1, [r4], #-4
        for( n = k; n > 1; n-- ) {
 800d2b8:	d1e4      	bne.n	800d284 <silk_NLSF2A+0x154>
        out[1] -= ftmp;
 800d2ba:	f8da 3004 	ldr.w	r3, [sl, #4]
 800d2be:	9a07      	ldr	r2, [sp, #28]
 800d2c0:	eba3 0308 	sub.w	r3, r3, r8
 800d2c4:	f8ca 3004 	str.w	r3, [sl, #4]
    for( k = 1; k < dd; k++ ) {
 800d2c8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d2ca:	f10b 0b01 	add.w	fp, fp, #1
 800d2ce:	3204      	adds	r2, #4
 800d2d0:	455b      	cmp	r3, fp
 800d2d2:	9207      	str	r2, [sp, #28]
 800d2d4:	f47f af71 	bne.w	800d1ba <silk_NLSF2A+0x8a>
    out[0] = silk_LSHIFT( 1, QA );
 800d2d8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800d2dc:	931b      	str	r3, [sp, #108]	; 0x6c
    out[1] = -cLSF[0];
 800d2de:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800d2e0:	aa58      	add	r2, sp, #352	; 0x160
 800d2e2:	f842 3df0 	str.w	r3, [r2, #-240]!
    for( k = 1; k < dd; k++ ) {
 800d2e6:	2301      	movs	r3, #1
 800d2e8:	a928      	add	r1, sp, #160	; 0xa0
 800d2ea:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
 800d2ee:	9107      	str	r1, [sp, #28]
    out[1] = -cLSF[0];
 800d2f0:	9208      	str	r2, [sp, #32]
    for( k = 1; k < dd; k++ ) {
 800d2f2:	9306      	str	r3, [sp, #24]
 800d2f4:	f10d 0b6c 	add.w	fp, sp, #108	; 0x6c
        ftmp = cLSF[2*k];            /* QA*/
 800d2f8:	9b07      	ldr	r3, [sp, #28]
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
 800d2fa:	9d08      	ldr	r5, [sp, #32]
        ftmp = cLSF[2*k];            /* QA*/
 800d2fc:	f8d3 800c 	ldr.w	r8, [r3, #12]
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
 800d300:	e955 e901 	ldrd	lr, r9, [r5, #-4]
 800d304:	fb88 0109 	smull	r0, r1, r8, r9
 800d308:	0bc6      	lsrs	r6, r0, #15
 800d30a:	ea46 4641 	orr.w	r6, r6, r1, lsl #17
 800d30e:	1c72      	adds	r2, r6, #1
 800d310:	ea4f 37e1 	mov.w	r7, r1, asr #15
 800d314:	f147 0300 	adc.w	r3, r7, #0
 800d318:	105b      	asrs	r3, r3, #1
 800d31a:	ea4f 0232 	mov.w	r2, r2, rrx
        for( n = k; n > 1; n-- ) {
 800d31e:	9b06      	ldr	r3, [sp, #24]
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
 800d320:	ebc2 024e 	rsb	r2, r2, lr, lsl #1
        for( n = k; n > 1; n-- ) {
 800d324:	2b01      	cmp	r3, #1
        out[k+1] = silk_LSHIFT( out[k-1], 1 ) - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[k] ), QA );
 800d326:	606a      	str	r2, [r5, #4]
        for( n = k; n > 1; n-- ) {
 800d328:	d064      	beq.n	800d3f4 <silk_NLSF2A+0x2c4>
 800d32a:	2b03      	cmp	r3, #3
 800d32c:	461a      	mov	r2, r3
 800d32e:	f340 82aa 	ble.w	800d886 <silk_NLSF2A+0x756>
 800d332:	46c4      	mov	ip, r8
 800d334:	461c      	mov	r4, r3
 800d336:	3b04      	subs	r3, #4
 800d338:	f023 0301 	bic.w	r3, r3, #1
 800d33c:	3a02      	subs	r2, #2
 800d33e:	1ad3      	subs	r3, r2, r3
 800d340:	9305      	str	r3, [sp, #20]
 800d342:	f8cd 9008 	str.w	r9, [sp, #8]
 800d346:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
            out[n] += out[n-2] - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[n-1] ), QA );
 800d34a:	fb8c 230e 	smull	r2, r3, ip, lr
 800d34e:	0bd1      	lsrs	r1, r2, #15
 800d350:	ea41 4143 	orr.w	r1, r1, r3, lsl #17
 800d354:	460f      	mov	r7, r1
 800d356:	f855 6c08 	ldr.w	r6, [r5, #-8]
 800d35a:	3701      	adds	r7, #1
 800d35c:	fb8c 0106 	smull	r0, r1, ip, r6
 800d360:	ea4f 39d0 	mov.w	r9, r0, lsr #15
 800d364:	ea4f 33e3 	mov.w	r3, r3, asr #15
 800d368:	ea49 4941 	orr.w	r9, r9, r1, lsl #17
 800d36c:	f143 0800 	adc.w	r8, r3, #0
 800d370:	ea4f 3ae1 	mov.w	sl, r1, asr #15
 800d374:	f119 0201 	adds.w	r2, r9, #1
 800d378:	f14a 0300 	adc.w	r3, sl, #0
 800d37c:	ea5f 0168 	movs.w	r1, r8, asr #1
 800d380:	ea4f 0037 	mov.w	r0, r7, rrx
 800d384:	105b      	asrs	r3, r3, #1
 800d386:	ea4f 0232 	mov.w	r2, r2, rrx
 800d38a:	9902      	ldr	r1, [sp, #8]
 800d38c:	1a30      	subs	r0, r6, r0
 800d38e:	4408      	add	r0, r1
 800d390:	f84b 0024 	str.w	r0, [fp, r4, lsl #2]
 800d394:	f855 1c0c 	ldr.w	r1, [r5, #-12]
 800d398:	9b05      	ldr	r3, [sp, #20]
 800d39a:	3c02      	subs	r4, #2
 800d39c:	1a8a      	subs	r2, r1, r2
 800d39e:	4472      	add	r2, lr
 800d3a0:	429c      	cmp	r4, r3
 800d3a2:	f845 2c04 	str.w	r2, [r5, #-4]
 800d3a6:	9602      	str	r6, [sp, #8]
 800d3a8:	468e      	mov	lr, r1
 800d3aa:	f1a5 0508 	sub.w	r5, r5, #8
 800d3ae:	d1cc      	bne.n	800d34a <silk_NLSF2A+0x21a>
 800d3b0:	46e0      	mov	r8, ip
 800d3b2:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
 800d3b6:	00a4      	lsls	r4, r4, #2
 800d3b8:	1f25      	subs	r5, r4, #4
 800d3ba:	445d      	add	r5, fp
 800d3bc:	445c      	add	r4, fp
 800d3be:	f855 6904 	ldr.w	r6, [r5], #-4
 800d3c2:	6821      	ldr	r1, [r4, #0]
 800d3c4:	fb88 6706 	smull	r6, r7, r8, r6
 800d3c8:	0bf3      	lsrs	r3, r6, #15
 800d3ca:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
 800d3ce:	9302      	str	r3, [sp, #8]
 800d3d0:	13fb      	asrs	r3, r7, #15
 800d3d2:	9303      	str	r3, [sp, #12]
 800d3d4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800d3d8:	3201      	adds	r2, #1
 800d3da:	f143 0300 	adc.w	r3, r3, #0
 800d3de:	105f      	asrs	r7, r3, #1
 800d3e0:	ea4f 0632 	mov.w	r6, r2, rrx
 800d3e4:	682b      	ldr	r3, [r5, #0]
        for( n = k; n > 1; n-- ) {
 800d3e6:	455d      	cmp	r5, fp
            out[n] += out[n-2] - (opus_int32)silk_RSHIFT_ROUND64( silk_SMULL( ftmp, out[n-1] ), QA );
 800d3e8:	eba3 0206 	sub.w	r2, r3, r6
 800d3ec:	4411      	add	r1, r2
 800d3ee:	f844 1904 	str.w	r1, [r4], #-4
        for( n = k; n > 1; n-- ) {
 800d3f2:	d1e4      	bne.n	800d3be <silk_NLSF2A+0x28e>
        out[1] -= ftmp;
 800d3f4:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800d3f6:	9907      	ldr	r1, [sp, #28]
    for( k = 1; k < dd; k++ ) {
 800d3f8:	9a06      	ldr	r2, [sp, #24]
        out[1] -= ftmp;
 800d3fa:	eba3 0308 	sub.w	r3, r3, r8
 800d3fe:	3108      	adds	r1, #8
 800d400:	9107      	str	r1, [sp, #28]
 800d402:	931c      	str	r3, [sp, #112]	; 0x70
 800d404:	9908      	ldr	r1, [sp, #32]
    for( k = 1; k < dd; k++ ) {
 800d406:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d408:	3201      	adds	r2, #1
 800d40a:	3104      	adds	r1, #4
 800d40c:	429a      	cmp	r2, r3
 800d40e:	9206      	str	r2, [sp, #24]
 800d410:	9108      	str	r1, [sp, #32]
 800d412:	f47f af71 	bne.w	800d2f8 <silk_NLSF2A+0x1c8>
 800d416:	e003      	b.n	800d420 <silk_NLSF2A+0x2f0>
 800d418:	08016864 	.word	0x08016864
 800d41c:	08016ad8 	.word	0x08016ad8
 800d420:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d422:	2b02      	cmp	r3, #2
 800d424:	f103 34ff 	add.w	r4, r3, #4294967295
 800d428:	f340 8241 	ble.w	800d8ae <silk_NLSF2A+0x77e>
    silk_NLSF2A_find_poly( Q, &cos_LSF_QA[ 1 ], dd );

    /* convert even and odd polynomials to opus_int32 Q12 filter coefs */
    for( k = 0; k < dd; k++ ) {
        Ptmp = P[ k+1 ] + P[ k ];
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d42c:	e9dd 731b 	ldrd	r7, r3, [sp, #108]	; 0x6c
        Ptmp = P[ k+1 ] + P[ k ];
 800d430:	e9da 2000 	ldrd	r2, r0, [sl]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d434:	1bdf      	subs	r7, r3, r7
        Ptmp = P[ k+1 ] + P[ k ];
 800d436:	4402      	add	r2, r0

        /* the Ptmp and Qtmp values at this stage need to fit in int32 */
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d438:	427e      	negs	r6, r7
 800d43a:	1ab6      	subs	r6, r6, r2
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d43c:	991d      	ldr	r1, [sp, #116]	; 0x74
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d43e:	1aba      	subs	r2, r7, r2
 800d440:	9f0a      	ldr	r7, [sp, #40]	; 0x28
        Ptmp = P[ k+1 ] + P[ k ];
 800d442:	f8da 5008 	ldr.w	r5, [sl, #8]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d446:	f50d 7cb0 	add.w	ip, sp, #352	; 0x160
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d44a:	9640      	str	r6, [sp, #256]	; 0x100
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d44c:	1acb      	subs	r3, r1, r3
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d44e:	eb0c 0687 	add.w	r6, ip, r7, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
 800d452:	4428      	add	r0, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d454:	f846 2c64 	str.w	r2, [r6, #-100]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d458:	425a      	negs	r2, r3
 800d45a:	1a12      	subs	r2, r2, r0
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d45c:	1a1b      	subs	r3, r3, r0
 800d45e:	2c03      	cmp	r4, #3
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d460:	9241      	str	r2, [sp, #260]	; 0x104
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d462:	f846 3c68 	str.w	r3, [r6, #-104]
 800d466:	f340 821c 	ble.w	800d8a2 <silk_NLSF2A+0x772>
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d46a:	e9dd 261e 	ldrd	r2, r6, [sp, #120]	; 0x78
        Ptmp = P[ k+1 ] + P[ k ];
 800d46e:	f8da 000c 	ldr.w	r0, [sl, #12]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d472:	1a51      	subs	r1, r2, r1
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d474:	f1c1 0c00 	rsb	ip, r1, #0
        Ptmp = P[ k+1 ] + P[ k ];
 800d478:	182b      	adds	r3, r5, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d47a:	ebac 0503 	sub.w	r5, ip, r3
 800d47e:	9542      	str	r5, [sp, #264]	; 0x108
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d480:	9d0a      	ldr	r5, [sp, #40]	; 0x28
        Ptmp = P[ k+1 ] + P[ k ];
 800d482:	f8da 7010 	ldr.w	r7, [sl, #16]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d486:	f50d 7cb0 	add.w	ip, sp, #352	; 0x160
 800d48a:	1acb      	subs	r3, r1, r3
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d48c:	1ab2      	subs	r2, r6, r2
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d48e:	eb0c 0185 	add.w	r1, ip, r5, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
 800d492:	4438      	add	r0, r7
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d494:	f841 3c6c 	str.w	r3, [r1, #-108]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d498:	4253      	negs	r3, r2
 800d49a:	1a1b      	subs	r3, r3, r0
 800d49c:	2c05      	cmp	r4, #5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d49e:	eba2 0000 	sub.w	r0, r2, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d4a2:	9343      	str	r3, [sp, #268]	; 0x10c
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d4a4:	f841 0c70 	str.w	r0, [r1, #-112]
 800d4a8:	f340 81fe 	ble.w	800d8a8 <silk_NLSF2A+0x778>
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d4ac:	e9dd 3120 	ldrd	r3, r1, [sp, #128]	; 0x80
        Ptmp = P[ k+1 ] + P[ k ];
 800d4b0:	f8da 0014 	ldr.w	r0, [sl, #20]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d4b4:	1b9e      	subs	r6, r3, r6
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d4b6:	f1c6 0c00 	rsb	ip, r6, #0
        Ptmp = P[ k+1 ] + P[ k ];
 800d4ba:	183a      	adds	r2, r7, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d4bc:	ebac 0702 	sub.w	r7, ip, r2
 800d4c0:	9744      	str	r7, [sp, #272]	; 0x110
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d4c2:	9f0a      	ldr	r7, [sp, #40]	; 0x28
        Ptmp = P[ k+1 ] + P[ k ];
 800d4c4:	f8da 5018 	ldr.w	r5, [sl, #24]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d4c8:	f50d 7cb0 	add.w	ip, sp, #352	; 0x160
 800d4cc:	1ab2      	subs	r2, r6, r2
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d4ce:	1acb      	subs	r3, r1, r3
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d4d0:	eb0c 0687 	add.w	r6, ip, r7, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
 800d4d4:	4428      	add	r0, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d4d6:	f846 2c74 	str.w	r2, [r6, #-116]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d4da:	425a      	negs	r2, r3
 800d4dc:	1a12      	subs	r2, r2, r0
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d4de:	1a1b      	subs	r3, r3, r0
 800d4e0:	2c07      	cmp	r4, #7
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d4e2:	9245      	str	r2, [sp, #276]	; 0x114
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d4e4:	f846 3c78 	str.w	r3, [r6, #-120]
 800d4e8:	f340 81d2 	ble.w	800d890 <silk_NLSF2A+0x760>
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d4ec:	e9dd 3022 	ldrd	r3, r0, [sp, #136]	; 0x88
        Ptmp = P[ k+1 ] + P[ k ];
 800d4f0:	f8da c01c 	ldr.w	ip, [sl, #28]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d4f4:	1a59      	subs	r1, r3, r1
        Ptmp = P[ k+1 ] + P[ k ];
 800d4f6:	eb05 020c 	add.w	r2, r5, ip
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d4fa:	424f      	negs	r7, r1
 800d4fc:	1abf      	subs	r7, r7, r2
        Ptmp = P[ k+1 ] + P[ k ];
 800d4fe:	f8da 6020 	ldr.w	r6, [sl, #32]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d502:	9746      	str	r7, [sp, #280]	; 0x118
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d504:	9f0a      	ldr	r7, [sp, #40]	; 0x28
        Ptmp = P[ k+1 ] + P[ k ];
 800d506:	eb0c 0506 	add.w	r5, ip, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d50a:	f50d 7cb0 	add.w	ip, sp, #352	; 0x160
 800d50e:	1a8a      	subs	r2, r1, r2
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d510:	1ac3      	subs	r3, r0, r3
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d512:	eb0c 0187 	add.w	r1, ip, r7, lsl #2
 800d516:	f841 2c7c 	str.w	r2, [r1, #-124]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d51a:	425a      	negs	r2, r3
 800d51c:	1b52      	subs	r2, r2, r5
 800d51e:	9247      	str	r2, [sp, #284]	; 0x11c
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d520:	1b5b      	subs	r3, r3, r5
 800d522:	eb0c 0287 	add.w	r2, ip, r7, lsl #2
 800d526:	2c09      	cmp	r4, #9
 800d528:	f842 3c80 	str.w	r3, [r2, #-128]
 800d52c:	f340 81c2 	ble.w	800d8b4 <silk_NLSF2A+0x784>
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d530:	e9dd 3524 	ldrd	r3, r5, [sp, #144]	; 0x90
        Ptmp = P[ k+1 ] + P[ k ];
 800d534:	f8da 1024 	ldr.w	r1, [sl, #36]	; 0x24
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d538:	1a18      	subs	r0, r3, r0
        Ptmp = P[ k+1 ] + P[ k ];
 800d53a:	1872      	adds	r2, r6, r1
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d53c:	f1c0 0c00 	rsb	ip, r0, #0
 800d540:	ebac 0602 	sub.w	r6, ip, r2
 800d544:	9648      	str	r6, [sp, #288]	; 0x120
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d546:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 800d548:	f50d 7cb0 	add.w	ip, sp, #352	; 0x160
        Ptmp = P[ k+1 ] + P[ k ];
 800d54c:	f8da 7028 	ldr.w	r7, [sl, #40]	; 0x28
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d550:	1aeb      	subs	r3, r5, r3
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d552:	1a80      	subs	r0, r0, r2
 800d554:	eb0c 0286 	add.w	r2, ip, r6, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
 800d558:	4439      	add	r1, r7
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d55a:	f842 0c84 	str.w	r0, [r2, #-132]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d55e:	425a      	negs	r2, r3
 800d560:	1a52      	subs	r2, r2, r1
 800d562:	9249      	str	r2, [sp, #292]	; 0x124
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d564:	1a5b      	subs	r3, r3, r1
 800d566:	eb0c 0286 	add.w	r2, ip, r6, lsl #2
 800d56a:	2c0b      	cmp	r4, #11
 800d56c:	f842 3c88 	str.w	r3, [r2, #-136]
 800d570:	f340 81a3 	ble.w	800d8ba <silk_NLSF2A+0x78a>
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d574:	e9dd 2326 	ldrd	r2, r3, [sp, #152]	; 0x98
        Ptmp = P[ k+1 ] + P[ k ];
 800d578:	e9da 010b 	ldrd	r0, r1, [sl, #44]	; 0x2c
 800d57c:	f04f 090c 	mov.w	r9, #12
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d580:	1a9b      	subs	r3, r3, r2
 800d582:	1b55      	subs	r5, r2, r5
        Ptmp = P[ k+1 ] + P[ k ];
 800d584:	4401      	add	r1, r0
 800d586:	19c2      	adds	r2, r0, r7
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d588:	426c      	negs	r4, r5
 800d58a:	4258      	negs	r0, r3
 800d58c:	1aa4      	subs	r4, r4, r2
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d58e:	1aad      	subs	r5, r5, r2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d590:	1a40      	subs	r0, r0, r1
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d592:	eb0c 0286 	add.w	r2, ip, r6, lsl #2
 800d596:	1a59      	subs	r1, r3, r1
 800d598:	eb0c 0386 	add.w	r3, ip, r6, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d59c:	944a      	str	r4, [sp, #296]	; 0x128
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d59e:	f843 5c8c 	str.w	r5, [r3, #-140]
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d5a2:	904b      	str	r0, [sp, #300]	; 0x12c
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d5a4:	f842 1c90 	str.w	r1, [r2, #-144]
        Ptmp = P[ k+1 ] + P[ k ];
 800d5a8:	f109 0201 	add.w	r2, r9, #1
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d5ac:	ab58      	add	r3, sp, #352	; 0x160
 800d5ae:	eb03 0c89 	add.w	ip, r3, r9, lsl #2
 800d5b2:	eb03 0e82 	add.w	lr, r3, r2, lsl #2
 800d5b6:	f85e 4cf4 	ldr.w	r4, [lr, #-244]
 800d5ba:	f85c 0cf4 	ldr.w	r0, [ip, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d5be:	f85a 6022 	ldr.w	r6, [sl, r2, lsl #2]
 800d5c2:	f85a 1029 	ldr.w	r1, [sl, r9, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d5c6:	1a20      	subs	r0, r4, r0
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d5c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        Ptmp = P[ k+1 ] + P[ k ];
 800d5ca:	4431      	add	r1, r6
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d5cc:	4247      	negs	r7, r0
 800d5ce:	1a7f      	subs	r7, r7, r1
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d5d0:	1a40      	subs	r0, r0, r1
 800d5d2:	eba3 0509 	sub.w	r5, r3, r9
 800d5d6:	a958      	add	r1, sp, #352	; 0x160
 800d5d8:	eb01 0585 	add.w	r5, r1, r5, lsl #2
    for( k = 0; k < dd; k++ ) {
 800d5dc:	9909      	ldr	r1, [sp, #36]	; 0x24
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d5de:	f84c 7c60 	str.w	r7, [ip, #-96]
    for( k = 0; k < dd; k++ ) {
 800d5e2:	4291      	cmp	r1, r2
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d5e4:	f845 0c64 	str.w	r0, [r5, #-100]
    for( k = 0; k < dd; k++ ) {
 800d5e8:	f340 8114 	ble.w	800d814 <silk_NLSF2A+0x6e4>
        Ptmp = P[ k+1 ] + P[ k ];
 800d5ec:	f109 0102 	add.w	r1, r9, #2
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d5f0:	a858      	add	r0, sp, #352	; 0x160
 800d5f2:	eb00 0781 	add.w	r7, r0, r1, lsl #2
 800d5f6:	f857 0cf4 	ldr.w	r0, [r7, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d5fa:	f85a 5021 	ldr.w	r5, [sl, r1, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d5fe:	1b04      	subs	r4, r0, r4
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d600:	f1c4 0c00 	rsb	ip, r4, #0
        Ptmp = P[ k+1 ] + P[ k ];
 800d604:	442e      	add	r6, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d606:	1a9a      	subs	r2, r3, r2
 800d608:	f50d 78b0 	add.w	r8, sp, #352	; 0x160
 800d60c:	eb08 0282 	add.w	r2, r8, r2, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d610:	ebac 0c06 	sub.w	ip, ip, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d614:	1ba4      	subs	r4, r4, r6
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d616:	f84e cc60 	str.w	ip, [lr, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d61a:	f842 4c64 	str.w	r4, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
 800d61e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d620:	428a      	cmp	r2, r1
 800d622:	f340 80f7 	ble.w	800d814 <silk_NLSF2A+0x6e4>
        Ptmp = P[ k+1 ] + P[ k ];
 800d626:	f109 0203 	add.w	r2, r9, #3
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d62a:	eb08 0c82 	add.w	ip, r8, r2, lsl #2
 800d62e:	f85c 4cf4 	ldr.w	r4, [ip, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d632:	f85a 6022 	ldr.w	r6, [sl, r2, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d636:	1a20      	subs	r0, r4, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d638:	f1c0 0e00 	rsb	lr, r0, #0
        Ptmp = P[ k+1 ] + P[ k ];
 800d63c:	4435      	add	r5, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d63e:	1a59      	subs	r1, r3, r1
 800d640:	1b40      	subs	r0, r0, r5
 800d642:	eb08 0181 	add.w	r1, r8, r1, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d646:	ebae 0e05 	sub.w	lr, lr, r5
 800d64a:	f847 ec60 	str.w	lr, [r7, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d64e:	f841 0c64 	str.w	r0, [r1, #-100]
    for( k = 0; k < dd; k++ ) {
 800d652:	9809      	ldr	r0, [sp, #36]	; 0x24
 800d654:	4290      	cmp	r0, r2
 800d656:	f340 80dd 	ble.w	800d814 <silk_NLSF2A+0x6e4>
        Ptmp = P[ k+1 ] + P[ k ];
 800d65a:	f109 0104 	add.w	r1, r9, #4
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d65e:	eb08 0781 	add.w	r7, r8, r1, lsl #2
 800d662:	f857 0cf4 	ldr.w	r0, [r7, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d666:	f85a 5021 	ldr.w	r5, [sl, r1, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d66a:	1b04      	subs	r4, r0, r4
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d66c:	f1c4 0e00 	rsb	lr, r4, #0
        Ptmp = P[ k+1 ] + P[ k ];
 800d670:	442e      	add	r6, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d672:	1a9a      	subs	r2, r3, r2
 800d674:	1ba4      	subs	r4, r4, r6
 800d676:	eb08 0282 	add.w	r2, r8, r2, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d67a:	ebae 0e06 	sub.w	lr, lr, r6
 800d67e:	f84c ec60 	str.w	lr, [ip, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d682:	f842 4c64 	str.w	r4, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
 800d686:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800d688:	428c      	cmp	r4, r1
 800d68a:	f340 80c3 	ble.w	800d814 <silk_NLSF2A+0x6e4>
        Ptmp = P[ k+1 ] + P[ k ];
 800d68e:	f109 0205 	add.w	r2, r9, #5
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d692:	eb08 0c82 	add.w	ip, r8, r2, lsl #2
 800d696:	f85c 4cf4 	ldr.w	r4, [ip, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d69a:	f85a 6022 	ldr.w	r6, [sl, r2, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d69e:	1a20      	subs	r0, r4, r0
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d6a0:	f1c0 0e00 	rsb	lr, r0, #0
        Ptmp = P[ k+1 ] + P[ k ];
 800d6a4:	4435      	add	r5, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d6a6:	1a59      	subs	r1, r3, r1
 800d6a8:	eb08 0181 	add.w	r1, r8, r1, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d6ac:	ebae 0e05 	sub.w	lr, lr, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d6b0:	1b40      	subs	r0, r0, r5
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d6b2:	f847 ec60 	str.w	lr, [r7, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d6b6:	f841 0c64 	str.w	r0, [r1, #-100]
    for( k = 0; k < dd; k++ ) {
 800d6ba:	9909      	ldr	r1, [sp, #36]	; 0x24
 800d6bc:	4291      	cmp	r1, r2
 800d6be:	f340 80a9 	ble.w	800d814 <silk_NLSF2A+0x6e4>
        Ptmp = P[ k+1 ] + P[ k ];
 800d6c2:	f109 0106 	add.w	r1, r9, #6
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d6c6:	eb08 0e81 	add.w	lr, r8, r1, lsl #2
 800d6ca:	f85e 5cf4 	ldr.w	r5, [lr, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d6ce:	f85a 7021 	ldr.w	r7, [sl, r1, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d6d2:	1b2c      	subs	r4, r5, r4
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d6d4:	4260      	negs	r0, r4
        Ptmp = P[ k+1 ] + P[ k ];
 800d6d6:	443e      	add	r6, r7
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d6d8:	1a9a      	subs	r2, r3, r2
 800d6da:	eb08 0282 	add.w	r2, r8, r2, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d6de:	1b80      	subs	r0, r0, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d6e0:	1ba4      	subs	r4, r4, r6
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d6e2:	f84c 0c60 	str.w	r0, [ip, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d6e6:	f842 4c64 	str.w	r4, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
 800d6ea:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d6ec:	428a      	cmp	r2, r1
 800d6ee:	f340 8091 	ble.w	800d814 <silk_NLSF2A+0x6e4>
        Ptmp = P[ k+1 ] + P[ k ];
 800d6f2:	f109 0007 	add.w	r0, r9, #7
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d6f6:	eb08 0c80 	add.w	ip, r8, r0, lsl #2
 800d6fa:	f85c 4cf4 	ldr.w	r4, [ip, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d6fe:	f85a 6020 	ldr.w	r6, [sl, r0, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d702:	1b65      	subs	r5, r4, r5
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d704:	426a      	negs	r2, r5
        Ptmp = P[ k+1 ] + P[ k ];
 800d706:	4437      	add	r7, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d708:	1a59      	subs	r1, r3, r1
 800d70a:	eb08 0181 	add.w	r1, r8, r1, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d70e:	1bd2      	subs	r2, r2, r7
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d710:	1bed      	subs	r5, r5, r7
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d712:	f84e 2c60 	str.w	r2, [lr, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d716:	f841 5c64 	str.w	r5, [r1, #-100]
    for( k = 0; k < dd; k++ ) {
 800d71a:	9909      	ldr	r1, [sp, #36]	; 0x24
 800d71c:	4281      	cmp	r1, r0
 800d71e:	dd79      	ble.n	800d814 <silk_NLSF2A+0x6e4>
        Ptmp = P[ k+1 ] + P[ k ];
 800d720:	f109 0208 	add.w	r2, r9, #8
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d724:	eb08 0782 	add.w	r7, r8, r2, lsl #2
 800d728:	f857 1cf4 	ldr.w	r1, [r7, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d72c:	f85a 5022 	ldr.w	r5, [sl, r2, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d730:	1b0c      	subs	r4, r1, r4
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d732:	f1c4 0e00 	rsb	lr, r4, #0
        Ptmp = P[ k+1 ] + P[ k ];
 800d736:	442e      	add	r6, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d738:	1a18      	subs	r0, r3, r0
 800d73a:	1ba4      	subs	r4, r4, r6
 800d73c:	eb08 0080 	add.w	r0, r8, r0, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d740:	ebae 0e06 	sub.w	lr, lr, r6
 800d744:	f84c ec60 	str.w	lr, [ip, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d748:	f840 4c64 	str.w	r4, [r0, #-100]
    for( k = 0; k < dd; k++ ) {
 800d74c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800d74e:	4294      	cmp	r4, r2
 800d750:	dd60      	ble.n	800d814 <silk_NLSF2A+0x6e4>
        Ptmp = P[ k+1 ] + P[ k ];
 800d752:	f109 0009 	add.w	r0, r9, #9
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d756:	eb08 0c80 	add.w	ip, r8, r0, lsl #2
 800d75a:	f85c 4cf4 	ldr.w	r4, [ip, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d75e:	f85a 6020 	ldr.w	r6, [sl, r0, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d762:	1a61      	subs	r1, r4, r1
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d764:	f1c1 0e00 	rsb	lr, r1, #0
        Ptmp = P[ k+1 ] + P[ k ];
 800d768:	4435      	add	r5, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d76a:	1a9a      	subs	r2, r3, r2
 800d76c:	eb08 0282 	add.w	r2, r8, r2, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d770:	ebae 0e05 	sub.w	lr, lr, r5
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d774:	1b49      	subs	r1, r1, r5
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d776:	f847 ec60 	str.w	lr, [r7, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d77a:	f842 1c64 	str.w	r1, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
 800d77e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d780:	4282      	cmp	r2, r0
 800d782:	dd47      	ble.n	800d814 <silk_NLSF2A+0x6e4>
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d784:	4641      	mov	r1, r8
        Ptmp = P[ k+1 ] + P[ k ];
 800d786:	f109 020a 	add.w	r2, r9, #10
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d78a:	ea4f 0e82 	mov.w	lr, r2, lsl #2
 800d78e:	4471      	add	r1, lr
 800d790:	f851 5cf4 	ldr.w	r5, [r1, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d794:	f85a 7022 	ldr.w	r7, [sl, r2, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d798:	1b2c      	subs	r4, r5, r4
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d79a:	4261      	negs	r1, r4
        Ptmp = P[ k+1 ] + P[ k ];
 800d79c:	443e      	add	r6, r7
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d79e:	1a18      	subs	r0, r3, r0
 800d7a0:	eb08 0080 	add.w	r0, r8, r0, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d7a4:	1b89      	subs	r1, r1, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d7a6:	1ba4      	subs	r4, r4, r6
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d7a8:	f84c 1c60 	str.w	r1, [ip, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d7ac:	f840 4c64 	str.w	r4, [r0, #-100]
    for( k = 0; k < dd; k++ ) {
 800d7b0:	9809      	ldr	r0, [sp, #36]	; 0x24
 800d7b2:	4290      	cmp	r0, r2
 800d7b4:	dd2e      	ble.n	800d814 <silk_NLSF2A+0x6e4>
        Ptmp = P[ k+1 ] + P[ k ];
 800d7b6:	f109 010b 	add.w	r1, r9, #11
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d7ba:	eb08 0081 	add.w	r0, r8, r1, lsl #2
 800d7be:	f850 6cf4 	ldr.w	r6, [r0, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d7c2:	f85a 4021 	ldr.w	r4, [sl, r1, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d7c6:	1b75      	subs	r5, r6, r5
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d7c8:	f1c5 0c00 	rsb	ip, r5, #0
        Ptmp = P[ k+1 ] + P[ k ];
 800d7cc:	4427      	add	r7, r4
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d7ce:	1a9a      	subs	r2, r3, r2
 800d7d0:	eb08 0282 	add.w	r2, r8, r2, lsl #2
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d7d4:	44c6      	add	lr, r8
 800d7d6:	ebac 0c07 	sub.w	ip, ip, r7
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d7da:	1bed      	subs	r5, r5, r7
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d7dc:	f84e cc60 	str.w	ip, [lr, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d7e0:	f842 5c64 	str.w	r5, [r2, #-100]
    for( k = 0; k < dd; k++ ) {
 800d7e4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d7e6:	428a      	cmp	r2, r1
 800d7e8:	dd14      	ble.n	800d814 <silk_NLSF2A+0x6e4>
        Ptmp = P[ k+1 ] + P[ k ];
 800d7ea:	f109 030c 	add.w	r3, r9, #12
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d7ee:	eb08 0283 	add.w	r2, r8, r3, lsl #2
        Ptmp = P[ k+1 ] + P[ k ];
 800d7f2:	f85a 3023 	ldr.w	r3, [sl, r3, lsl #2]
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d7f6:	f852 2cf4 	ldr.w	r2, [r2, #-244]
        Ptmp = P[ k+1 ] + P[ k ];
 800d7fa:	441c      	add	r4, r3
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d7fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        Qtmp = Q[ k+1 ] - Q[ k ];
 800d7fe:	1b92      	subs	r2, r2, r6
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d800:	1a5b      	subs	r3, r3, r1
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d802:	4251      	negs	r1, r2
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d804:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 800d808:	1b12      	subs	r2, r2, r4
        a32_QA1[ k ]     = -Qtmp - Ptmp;        /* QA+1 */
 800d80a:	1b0c      	subs	r4, r1, r4
 800d80c:	f840 4c60 	str.w	r4, [r0, #-96]
        a32_QA1[ d-k-1 ] =  Qtmp - Ptmp;        /* QA+1 */
 800d810:	f843 2c64 	str.w	r2, [r3, #-100]
    }

    /* Convert int32 coefficients to Q12 int16 coefs */
    silk_LPC_fit( a_Q12, a32_QA1, 12, QA + 1, d );
 800d814:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800d816:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 800d81a:	9400      	str	r4, [sp, #0]
 800d81c:	a940      	add	r1, sp, #256	; 0x100
 800d81e:	2311      	movs	r3, #17
 800d820:	4648      	mov	r0, r9
 800d822:	220c      	movs	r2, #12
 800d824:	f7ff f968 	bl	800caf8 <silk_LPC_fit>
 800d828:	4623      	mov	r3, r4
 800d82a:	4698      	mov	r8, r3
 800d82c:	f1a9 0602 	sub.w	r6, r9, #2

    for( i = 0; silk_LPC_inverse_pred_gain( a_Q12, d, arch ) == 0 && i < MAX_LPC_STABILIZE_ITERATIONS; i++ ) {
 800d830:	4641      	mov	r1, r8
 800d832:	4648      	mov	r0, r9
 800d834:	eb06 0744 	add.w	r7, r6, r4, lsl #1
        /* Prediction coefficients are (too close to) unstable; apply bandwidth expansion   */
        /* on the unscaled coefficients, convert to Q12 and measure again                   */
        silk_bwexpander_32( a32_QA1, d, 65536 - silk_LSHIFT( 2, i ) );
 800d838:	2502      	movs	r5, #2
    for( i = 0; silk_LPC_inverse_pred_gain( a_Q12, d, arch ) == 0 && i < MAX_LPC_STABILIZE_ITERATIONS; i++ ) {
 800d83a:	2400      	movs	r4, #0
 800d83c:	f7ff fa1c 	bl	800cc78 <silk_LPC_inverse_pred_gain_c>
 800d840:	b9f0      	cbnz	r0, 800d880 <silk_NLSF2A+0x750>
 800d842:	2c10      	cmp	r4, #16
 800d844:	d01c      	beq.n	800d880 <silk_NLSF2A+0x750>
        silk_bwexpander_32( a32_QA1, d, 65536 - silk_LSHIFT( 2, i ) );
 800d846:	fa05 f204 	lsl.w	r2, r5, r4
 800d84a:	f5c2 3280 	rsb	r2, r2, #65536	; 0x10000
 800d84e:	4641      	mov	r1, r8
 800d850:	a840      	add	r0, sp, #256	; 0x100
 800d852:	f001 f94b 	bl	800eaec <silk_bwexpander_32>
        for( k = 0; k < d; k++ ) {
 800d856:	f1b8 0f00 	cmp.w	r8, #0
 800d85a:	dd0a      	ble.n	800d872 <silk_NLSF2A+0x742>
 800d85c:	4632      	mov	r2, r6
 800d85e:	a940      	add	r1, sp, #256	; 0x100
            a_Q12[ k ] = (opus_int16)silk_RSHIFT_ROUND( a32_QA1[ k ], QA + 1 - 12 );            /* QA+1 -> Q12 */
 800d860:	f851 3b04 	ldr.w	r3, [r1], #4
 800d864:	111b      	asrs	r3, r3, #4
 800d866:	3301      	adds	r3, #1
 800d868:	105b      	asrs	r3, r3, #1
 800d86a:	f822 3f02 	strh.w	r3, [r2, #2]!
        for( k = 0; k < d; k++ ) {
 800d86e:	42ba      	cmp	r2, r7
 800d870:	d1f6      	bne.n	800d860 <silk_NLSF2A+0x730>
    for( i = 0; silk_LPC_inverse_pred_gain( a_Q12, d, arch ) == 0 && i < MAX_LPC_STABILIZE_ITERATIONS; i++ ) {
 800d872:	4641      	mov	r1, r8
 800d874:	4648      	mov	r0, r9
 800d876:	3401      	adds	r4, #1
 800d878:	f7ff f9fe 	bl	800cc78 <silk_LPC_inverse_pred_gain_c>
 800d87c:	2800      	cmp	r0, #0
 800d87e:	d0e0      	beq.n	800d842 <silk_NLSF2A+0x712>
        }
    }
}
 800d880:	b059      	add	sp, #356	; 0x164
 800d882:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d886:	461c      	mov	r4, r3
 800d888:	e595      	b.n	800d3b6 <silk_NLSF2A+0x286>
    ordering = d == 16 ? ordering16 : ordering10;
 800d88a:	4e0d      	ldr	r6, [pc, #52]	; (800d8c0 <silk_NLSF2A+0x790>)
 800d88c:	4614      	mov	r4, r2
 800d88e:	e45b      	b.n	800d148 <silk_NLSF2A+0x18>
        Ptmp = P[ k+1 ] + P[ k ];
 800d890:	f04f 0906 	mov.w	r9, #6
 800d894:	e688      	b.n	800d5a8 <silk_NLSF2A+0x478>
    out[1] = -cLSF[0];
 800d896:	e9cd 231b 	strd	r2, r3, [sp, #108]	; 0x6c
    for( k = 0; k < dd; k++ ) {
 800d89a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d89c:	2b00      	cmp	r3, #0
 800d89e:	ddb9      	ble.n	800d814 <silk_NLSF2A+0x6e4>
 800d8a0:	e5be      	b.n	800d420 <silk_NLSF2A+0x2f0>
        Ptmp = P[ k+1 ] + P[ k ];
 800d8a2:	f04f 0902 	mov.w	r9, #2
 800d8a6:	e67f      	b.n	800d5a8 <silk_NLSF2A+0x478>
 800d8a8:	f04f 0904 	mov.w	r9, #4
 800d8ac:	e67c      	b.n	800d5a8 <silk_NLSF2A+0x478>
        for( n = k; n > 1; n-- ) {
 800d8ae:	f04f 0900 	mov.w	r9, #0
 800d8b2:	e679      	b.n	800d5a8 <silk_NLSF2A+0x478>
        Ptmp = P[ k+1 ] + P[ k ];
 800d8b4:	f04f 0908 	mov.w	r9, #8
 800d8b8:	e676      	b.n	800d5a8 <silk_NLSF2A+0x478>
 800d8ba:	f04f 090a 	mov.w	r9, #10
 800d8be:	e673      	b.n	800d5a8 <silk_NLSF2A+0x478>
 800d8c0:	08016870 	.word	0x08016870

0800d8c4 <silk_NLSF_decode>:
void silk_NLSF_decode(
          opus_int16            *pNLSF_Q15,                     /* O    Quantized NLSF vector [ LPC_ORDER ]         */
          opus_int8             *NLSFIndices,                   /* I    Codebook path vector [ LPC_ORDER + 1 ]      */
    const silk_NLSF_CB_struct   *psNLSF_CB                      /* I    Codebook object                             */
)
{
 800d8c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d8c8:	b095      	sub	sp, #84	; 0x54
    opus_int32       NLSF_Q15_tmp;
    const opus_uint8 *pCB_element;
    const opus_int16 *pCB_Wght_Q9;

    /* Unpack entropy table indices and predictor for current CB1 index */
    silk_NLSF_unpack( ec_ix, pred_Q8, psNLSF_CB, NLSFIndices[ 0 ] );
 800d8ca:	466e      	mov	r6, sp
{
 800d8cc:	4614      	mov	r4, r2
    silk_NLSF_unpack( ec_ix, pred_Q8, psNLSF_CB, NLSFIndices[ 0 ] );
 800d8ce:	f991 3000 	ldrsb.w	r3, [r1]
{
 800d8d2:	460f      	mov	r7, r1
 800d8d4:	4605      	mov	r5, r0
    silk_NLSF_unpack( ec_ix, pred_Q8, psNLSF_CB, NLSFIndices[ 0 ] );
 800d8d6:	4631      	mov	r1, r6
 800d8d8:	a804      	add	r0, sp, #16
 800d8da:	f000 f98d 	bl	800dbf8 <silk_NLSF_unpack>

    /* Predictive residual dequantizer */
    silk_NLSF_residual_dequant( res_Q10, &NLSFIndices[ 1 ], pred_Q8, psNLSF_CB->quantStepSize_Q16, psNLSF_CB->order );
 800d8de:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
 800d8e2:	f9b4 c004 	ldrsh.w	ip, [r4, #4]
    for( i = order-1; i >= 0; i-- ) {
 800d8e6:	f1b9 0f00 	cmp.w	r9, #0
 800d8ea:	464a      	mov	r2, r9
 800d8ec:	dd21      	ble.n	800d932 <silk_NLSF_decode+0x6e>
 800d8ee:	ab0c      	add	r3, sp, #48	; 0x30
    out_Q10 = 0;
 800d8f0:	2100      	movs	r1, #0
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800d8f2:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 800d8f6:	eb03 0e49 	add.w	lr, r3, r9, lsl #1
 800d8fa:	eb06 0009 	add.w	r0, r6, r9
 800d8fe:	eb07 0809 	add.w	r8, r7, r9
 800d902:	e007      	b.n	800d914 <silk_NLSF_decode+0x50>
            out_Q10 = silk_SUB16( out_Q10, SILK_FIX_CONST( NLSF_QUANT_LEVEL_ADJ, 10 ) );
 800d904:	3b66      	subs	r3, #102	; 0x66
  __asm__(
 800d906:	fb83 ba0c 	smull	fp, sl, r3, ip
    for( i = order-1; i >= 0; i-- ) {
 800d90a:	4286      	cmp	r6, r0
        out_Q10  = silk_SMLAWB( pred_Q10, (opus_int32)out_Q10, quant_step_size_Q16 );
 800d90c:	4451      	add	r1, sl
        x_Q10[ i ] = out_Q10;
 800d90e:	f82e 1d02 	strh.w	r1, [lr, #-2]!
    for( i = order-1; i >= 0; i-- ) {
 800d912:	d00e      	beq.n	800d932 <silk_NLSF_decode+0x6e>
 800d914:	3801      	subs	r0, #1
        pred_Q10 = silk_RSHIFT( silk_SMULBB( out_Q10, (opus_int16)pred_coef_Q8[ i ] ), 8 );
 800d916:	f890 a000 	ldrb.w	sl, [r0]
        out_Q10  = silk_LSHIFT( indices[ i ], 10 );
 800d91a:	f918 3901 	ldrsb.w	r3, [r8], #-1
        pred_Q10 = silk_RSHIFT( silk_SMULBB( out_Q10, (opus_int16)pred_coef_Q8[ i ] ), 8 );
 800d91e:	fb1a f101 	smulbb	r1, sl, r1
        out_Q10  = silk_LSHIFT( indices[ i ], 10 );
 800d922:	029b      	lsls	r3, r3, #10
        if( out_Q10 > 0 ) {
 800d924:	2b00      	cmp	r3, #0
        pred_Q10 = silk_RSHIFT( silk_SMULBB( out_Q10, (opus_int16)pred_coef_Q8[ i ] ), 8 );
 800d926:	ea4f 2121 	mov.w	r1, r1, asr #8
        if( out_Q10 > 0 ) {
 800d92a:	dceb      	bgt.n	800d904 <silk_NLSF_decode+0x40>
            out_Q10 = silk_ADD16( out_Q10, SILK_FIX_CONST( NLSF_QUANT_LEVEL_ADJ, 10 ) );
 800d92c:	bf18      	it	ne
 800d92e:	3366      	addne	r3, #102	; 0x66
 800d930:	e7e9      	b.n	800d906 <silk_NLSF_decode+0x42>

    /* Apply inverse square-rooted weights to first stage and add to output */
    pCB_element = &psNLSF_CB->CB1_NLSF_Q8[ NLSFIndices[ 0 ] * psNLSF_CB->order ];
 800d932:	f997 6000 	ldrsb.w	r6, [r7]
    pCB_Wght_Q9 = &psNLSF_CB->CB1_Wght_Q9[ NLSFIndices[ 0 ] * psNLSF_CB->order ];
    for( i = 0; i < psNLSF_CB->order; i++ ) {
 800d936:	f1b9 0f00 	cmp.w	r9, #0
    pCB_element = &psNLSF_CB->CB1_NLSF_Q8[ NLSFIndices[ 0 ] * psNLSF_CB->order ];
 800d93a:	fb16 f309 	smulbb	r3, r6, r9
 800d93e:	68a7      	ldr	r7, [r4, #8]
    pCB_Wght_Q9 = &psNLSF_CB->CB1_Wght_Q9[ NLSFIndices[ 0 ] * psNLSF_CB->order ];
 800d940:	68e0      	ldr	r0, [r4, #12]
 800d942:	ea4f 0343 	mov.w	r3, r3, lsl #1
    for( i = 0; i < psNLSF_CB->order; i++ ) {
 800d946:	dd2a      	ble.n	800d99e <silk_NLSF_decode+0xda>
 800d948:	fb09 7906 	mla	r9, r9, r6, r7
 800d94c:	3b02      	subs	r3, #2
 800d94e:	2100      	movs	r1, #0
 800d950:	f109 39ff 	add.w	r9, r9, #4294967295
 800d954:	4418      	add	r0, r3
 800d956:	af0c      	add	r7, sp, #48	; 0x30
 800d958:	1eae      	subs	r6, r5, #2
 800d95a:	e009      	b.n	800d970 <silk_NLSF_decode+0xac>
        NLSF_Q15_tmp = silk_ADD_LSHIFT32( silk_DIV32_16( silk_LSHIFT( (opus_int32)res_Q10[ i ], 14 ), pCB_Wght_Q9[ i ] ), (opus_int16)pCB_element[ i ], 7 );
        pNLSF_Q15[ i ] = (opus_int16)silk_LIMIT( NLSF_Q15_tmp, 0, 32767 );
 800d95c:	2b00      	cmp	r3, #0
 800d95e:	db25      	blt.n	800d9ac <silk_NLSF_decode+0xe8>
 800d960:	b21b      	sxth	r3, r3
 800d962:	f826 3f02 	strh.w	r3, [r6, #2]!
    for( i = 0; i < psNLSF_CB->order; i++ ) {
 800d966:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 800d96a:	3101      	adds	r1, #1
 800d96c:	428a      	cmp	r2, r1
 800d96e:	dd16      	ble.n	800d99e <silk_NLSF_decode+0xda>
        NLSF_Q15_tmp = silk_ADD_LSHIFT32( silk_DIV32_16( silk_LSHIFT( (opus_int32)res_Q10[ i ], 14 ), pCB_Wght_Q9[ i ] ), (opus_int16)pCB_element[ i ], 7 );
 800d970:	f937 3b02 	ldrsh.w	r3, [r7], #2
 800d974:	f930 2f02 	ldrsh.w	r2, [r0, #2]!
 800d978:	039b      	lsls	r3, r3, #14
 800d97a:	fb93 f3f2 	sdiv	r3, r3, r2
 800d97e:	f819 2f01 	ldrb.w	r2, [r9, #1]!
 800d982:	eb03 13c2 	add.w	r3, r3, r2, lsl #7
        pNLSF_Q15[ i ] = (opus_int16)silk_LIMIT( NLSF_Q15_tmp, 0, 32767 );
 800d986:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800d98a:	dbe7      	blt.n	800d95c <silk_NLSF_decode+0x98>
 800d98c:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800d990:	f826 3f02 	strh.w	r3, [r6, #2]!
    for( i = 0; i < psNLSF_CB->order; i++ ) {
 800d994:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 800d998:	3101      	adds	r1, #1
 800d99a:	428a      	cmp	r2, r1
 800d99c:	dce8      	bgt.n	800d970 <silk_NLSF_decode+0xac>
    }

    /* NLSF stabilization */
    silk_NLSF_stabilize( pNLSF_Q15, psNLSF_CB->deltaMin_Q15, psNLSF_CB->order );
 800d99e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800d9a0:	4628      	mov	r0, r5
 800d9a2:	f000 f805 	bl	800d9b0 <silk_NLSF_stabilize>
}
 800d9a6:	b015      	add	sp, #84	; 0x54
 800d9a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        pNLSF_Q15[ i ] = (opus_int16)silk_LIMIT( NLSF_Q15_tmp, 0, 32767 );
 800d9ac:	2300      	movs	r3, #0
 800d9ae:	e7d8      	b.n	800d962 <silk_NLSF_decode+0x9e>

0800d9b0 <silk_NLSF_stabilize>:
                min_diff_Q15 = diff_Q15;
                I = i;
            }
        }
        /* Last element */
        diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15[L-1] + NDeltaMin_Q15[L] );
 800d9b0:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
{
 800d9b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15[L-1] + NDeltaMin_Q15[L] );
 800d9b8:	18d3      	adds	r3, r2, r3
{
 800d9ba:	b087      	sub	sp, #28
        diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15[L-1] + NDeltaMin_Q15[L] );
 800d9bc:	9305      	str	r3, [sp, #20]
 800d9be:	005b      	lsls	r3, r3, #1
{
 800d9c0:	4694      	mov	ip, r2
        diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15[L-1] + NDeltaMin_Q15[L] );
 800d9c2:	1c9a      	adds	r2, r3, #2
 800d9c4:	4614      	mov	r4, r2
 800d9c6:	f04f 0814 	mov.w	r8, #20
 800d9ca:	9204      	str	r2, [sp, #16]
 800d9cc:	1d1a      	adds	r2, r3, #4
 800d9ce:	18c3      	adds	r3, r0, r3
 800d9d0:	190c      	adds	r4, r1, r4
 800d9d2:	188a      	adds	r2, r1, r2
 800d9d4:	9300      	str	r3, [sp, #0]
 800d9d6:	1c8b      	adds	r3, r1, #2
 800d9d8:	9401      	str	r4, [sp, #4]
 800d9da:	9202      	str	r2, [sp, #8]
 800d9dc:	f10c 3eff 	add.w	lr, ip, #4294967295
 800d9e0:	9303      	str	r3, [sp, #12]
        min_diff_Q15 = NLSF_Q15[0] - NDeltaMin_Q15[0];
 800d9e2:	f9b0 4000 	ldrsh.w	r4, [r0]
 800d9e6:	f9b1 9000 	ldrsh.w	r9, [r1]
        for( i = 1; i <= L-1; i++ ) {
 800d9ea:	f1bc 0f01 	cmp.w	ip, #1
        min_diff_Q15 = NLSF_Q15[0] - NDeltaMin_Q15[0];
 800d9ee:	eba4 0309 	sub.w	r3, r4, r9
        for( i = 1; i <= L-1; i++ ) {
 800d9f2:	f340 80e8 	ble.w	800dbc6 <silk_NLSF_stabilize+0x216>
 800d9f6:	f1bc 0f03 	cmp.w	ip, #3
 800d9fa:	f340 80f0 	ble.w	800dbde <silk_NLSF_stabilize+0x22e>
 800d9fe:	f04f 0a02 	mov.w	sl, #2
        I = 0;
 800da02:	2700      	movs	r7, #0
        for( i = 1; i <= L-1; i++ ) {
 800da04:	2601      	movs	r6, #1
            diff_Q15 = NLSF_Q15[i] - ( NLSF_Q15[i-1] + NDeltaMin_Q15[i] );
 800da06:	f931 2016 	ldrsh.w	r2, [r1, r6, lsl #1]
 800da0a:	f930 b016 	ldrsh.w	fp, [r0, r6, lsl #1]
 800da0e:	4422      	add	r2, r4
 800da10:	ebab 0202 	sub.w	r2, fp, r2
            if( diff_Q15 < min_diff_Q15 ) {
 800da14:	429a      	cmp	r2, r3
 800da16:	bfa8      	it	ge
 800da18:	461a      	movge	r2, r3
 800da1a:	4635      	mov	r5, r6
 800da1c:	bfa8      	it	ge
 800da1e:	463e      	movge	r6, r7
            diff_Q15 = NLSF_Q15[i] - ( NLSF_Q15[i-1] + NDeltaMin_Q15[i] );
 800da20:	f931 301a 	ldrsh.w	r3, [r1, sl, lsl #1]
 800da24:	f930 401a 	ldrsh.w	r4, [r0, sl, lsl #1]
 800da28:	445b      	add	r3, fp
 800da2a:	1ae3      	subs	r3, r4, r3
            if( diff_Q15 < min_diff_Q15 ) {
 800da2c:	4293      	cmp	r3, r2
        for( i = 1; i <= L-1; i++ ) {
 800da2e:	4657      	mov	r7, sl
 800da30:	f10a 0a02 	add.w	sl, sl, #2
            if( diff_Q15 < min_diff_Q15 ) {
 800da34:	bfa4      	itt	ge
 800da36:	4637      	movge	r7, r6
 800da38:	4613      	movge	r3, r2
 800da3a:	45d6      	cmp	lr, sl
 800da3c:	f105 0602 	add.w	r6, r5, #2
 800da40:	dce1      	bgt.n	800da06 <silk_NLSF_stabilize+0x56>
 800da42:	f106 4b00 	add.w	fp, r6, #2147483648	; 0x80000000
 800da46:	f10b 3bff 	add.w	fp, fp, #4294967295
 800da4a:	ea4f 0b4b 	mov.w	fp, fp, lsl #1
 800da4e:	eb00 0a0b 	add.w	sl, r0, fp
 800da52:	448b      	add	fp, r1
            diff_Q15 = NLSF_Q15[i] - ( NLSF_Q15[i-1] + NDeltaMin_Q15[i] );
 800da54:	f93a 2f02 	ldrsh.w	r2, [sl, #2]!
 800da58:	f93b 5f02 	ldrsh.w	r5, [fp, #2]!
 800da5c:	f93a 4c02 	ldrsh.w	r4, [sl, #-2]
 800da60:	442c      	add	r4, r5
 800da62:	1b12      	subs	r2, r2, r4
            if( diff_Q15 < min_diff_Q15 ) {
 800da64:	4293      	cmp	r3, r2
 800da66:	bfc8      	it	gt
 800da68:	4637      	movgt	r7, r6
        for( i = 1; i <= L-1; i++ ) {
 800da6a:	f106 0601 	add.w	r6, r6, #1
            if( diff_Q15 < min_diff_Q15 ) {
 800da6e:	bfc8      	it	gt
 800da70:	4613      	movgt	r3, r2
        for( i = 1; i <= L-1; i++ ) {
 800da72:	45b4      	cmp	ip, r6
 800da74:	dcee      	bgt.n	800da54 <silk_NLSF_stabilize+0xa4>
        diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15[L-1] + NDeltaMin_Q15[L] );
 800da76:	9a01      	ldr	r2, [sp, #4]
 800da78:	f9b2 4000 	ldrsh.w	r4, [r2]
 800da7c:	9a00      	ldr	r2, [sp, #0]
 800da7e:	f9b2 2000 	ldrsh.w	r2, [r2]
 800da82:	4422      	add	r2, r4
 800da84:	f5c2 4200 	rsb	r2, r2, #32768	; 0x8000
        if( diff_Q15 < min_diff_Q15 ) {
 800da88:	429a      	cmp	r2, r3
 800da8a:	bfac      	ite	ge
 800da8c:	461a      	movge	r2, r3
 800da8e:	4667      	movlt	r7, ip
        }

        /***************************************************/
        /* Now check if the smallest distance non-negative */
        /***************************************************/
        if( min_diff_Q15 >= 0 ) {
 800da90:	2a00      	cmp	r2, #0
 800da92:	da56      	bge.n	800db42 <silk_NLSF_stabilize+0x192>
            return;
        }

        if( I == 0 ) {
 800da94:	2f00      	cmp	r7, #0
 800da96:	d157      	bne.n	800db48 <silk_NLSF_stabilize+0x198>
            /* Move away from lower limit */
            NLSF_Q15[0] = NDeltaMin_Q15[0];
 800da98:	f8a0 9000 	strh.w	r9, [r0]
    for( loops = 0; loops < MAX_LOOPS; loops++ ) {
 800da9c:	f1b8 0801 	subs.w	r8, r8, #1
 800daa0:	d19f      	bne.n	800d9e2 <silk_NLSF_stabilize+0x32>
 800daa2:	4604      	mov	r4, r0
 800daa4:	460d      	mov	r5, r1
    if( loops == MAX_LOOPS )
    {
        /* Insertion sort (fast for already almost sorted arrays):   */
        /* Best case:  O(n)   for an already sorted array            */
        /* Worst case: O(n^2) for an inversely sorted array          */
        silk_insertion_sort_increasing_all_values_int16( &NLSF_Q15[0], L );
 800daa6:	4661      	mov	r1, ip
 800daa8:	4666      	mov	r6, ip
 800daaa:	f004 f8e3 	bl	8011c74 <silk_insertion_sort_increasing_all_values_int16>

        /* First NLSF should be no less than NDeltaMin[0] */
        NLSF_Q15[0] = silk_max_int( NLSF_Q15[0], NDeltaMin_Q15[0] );
 800daae:	f9b4 2000 	ldrsh.w	r2, [r4]
 800dab2:	f9b5 3000 	ldrsh.w	r3, [r5]
 800dab6:	4293      	cmp	r3, r2
 800dab8:	bfb8      	it	lt
 800daba:	4613      	movlt	r3, r2

        /* Keep delta_min distance between the NLSFs */
        for( i = 1; i < L; i++ )
 800dabc:	2e01      	cmp	r6, #1
        NLSF_Q15[0] = silk_max_int( NLSF_Q15[0], NDeltaMin_Q15[0] );
 800dabe:	8023      	strh	r3, [r4, #0]
        for( i = 1; i < L; i++ )
 800dac0:	dd22      	ble.n	800db08 <silk_NLSF_stabilize+0x158>
 800dac2:	9804      	ldr	r0, [sp, #16]
 800dac4:	4622      	mov	r2, r4
 800dac6:	1827      	adds	r7, r4, r0
 800dac8:	4629      	mov	r1, r5
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
 800daca:	f8df c128 	ldr.w	ip, [pc, #296]	; 800dbf4 <silk_NLSF_stabilize+0x244>
 800dace:	3f02      	subs	r7, #2
 800dad0:	e00a      	b.n	800dae8 <silk_NLSF_stabilize+0x138>
 800dad2:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 800dad6:	f2c0 8085 	blt.w	800dbe4 <silk_NLSF_stabilize+0x234>
 800dada:	b21b      	sxth	r3, r3
 800dadc:	4573      	cmp	r3, lr
 800dade:	bfb8      	it	lt
 800dae0:	4673      	movlt	r3, lr
        for( i = 1; i < L; i++ )
 800dae2:	4297      	cmp	r7, r2
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
 800dae4:	8013      	strh	r3, [r2, #0]
        for( i = 1; i < L; i++ )
 800dae6:	d00f      	beq.n	800db08 <silk_NLSF_stabilize+0x158>
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
 800dae8:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
 800daec:	f932 ef02 	ldrsh.w	lr, [r2, #2]!
 800daf0:	4403      	add	r3, r0
 800daf2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800daf6:	dbec      	blt.n	800dad2 <silk_NLSF_stabilize+0x122>
 800daf8:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800dafc:	4573      	cmp	r3, lr
 800dafe:	bfb8      	it	lt
 800db00:	4673      	movlt	r3, lr
        for( i = 1; i < L; i++ )
 800db02:	4297      	cmp	r7, r2
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
 800db04:	8013      	strh	r3, [r2, #0]
        for( i = 1; i < L; i++ )
 800db06:	d1ef      	bne.n	800dae8 <silk_NLSF_stabilize+0x138>

        /* Last NLSF should be no higher than 1 - NDeltaMin[L] */
        NLSF_Q15[L-1] = silk_min_int( NLSF_Q15[L-1], (1<<15) - NDeltaMin_Q15[L] );
 800db08:	9b04      	ldr	r3, [sp, #16]
 800db0a:	9905      	ldr	r1, [sp, #20]
 800db0c:	5eeb      	ldrsh	r3, [r5, r3]
 800db0e:	f934 2011 	ldrsh.w	r2, [r4, r1, lsl #1]
 800db12:	f5c3 4300 	rsb	r3, r3, #32768	; 0x8000
#define SILK_FIX_CONST( C, Q )              ((opus_int32)((C) * ((opus_int64)1 << (Q)) + 0.5))

/* silk_min() versions with typecast in the function call */
static OPUS_INLINE opus_int silk_min_int(opus_int a, opus_int b)
{
    return (((a) < (b)) ? (a) : (b));
 800db16:	4293      	cmp	r3, r2
 800db18:	bfa8      	it	ge
 800db1a:	4613      	movge	r3, r2

        /* Keep NDeltaMin distance between the NLSFs */
        for( i = L-2; i >= 0; i-- )
 800db1c:	2e01      	cmp	r6, #1
        NLSF_Q15[L-1] = silk_min_int( NLSF_Q15[L-1], (1<<15) - NDeltaMin_Q15[L] );
 800db1e:	f824 3011 	strh.w	r3, [r4, r1, lsl #1]
        for( i = L-2; i >= 0; i-- )
 800db22:	dd0e      	ble.n	800db42 <silk_NLSF_stabilize+0x192>
 800db24:	e9dd 0500 	ldrd	r0, r5, [sp]
 800db28:	b21b      	sxth	r3, r3
            NLSF_Q15[i] = silk_min_int( NLSF_Q15[i], NLSF_Q15[i+1] - NDeltaMin_Q15[i+1] );
 800db2a:	f935 1d02 	ldrsh.w	r1, [r5, #-2]!
 800db2e:	f930 2d02 	ldrsh.w	r2, [r0, #-2]!
 800db32:	1a5b      	subs	r3, r3, r1
 800db34:	4293      	cmp	r3, r2
 800db36:	bfa8      	it	ge
 800db38:	4613      	movge	r3, r2
        for( i = L-2; i >= 0; i-- )
 800db3a:	42a0      	cmp	r0, r4
            NLSF_Q15[i] = silk_min_int( NLSF_Q15[i], NLSF_Q15[i+1] - NDeltaMin_Q15[i+1] );
 800db3c:	b21b      	sxth	r3, r3
 800db3e:	8003      	strh	r3, [r0, #0]
        for( i = L-2; i >= 0; i-- )
 800db40:	d1f3      	bne.n	800db2a <silk_NLSF_stabilize+0x17a>
    }
}
 800db42:	b007      	add	sp, #28
 800db44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        } else if( I == L) {
 800db48:	4567      	cmp	r7, ip
 800db4a:	d037      	beq.n	800dbbc <silk_NLSF_stabilize+0x20c>
            for( k = 0; k < I; k++ ) {
 800db4c:	2f00      	cmp	r7, #0
            min_center_Q15 = 0;
 800db4e:	f04f 0200 	mov.w	r2, #0
            for( k = 0; k < I; k++ ) {
 800db52:	dd4c      	ble.n	800dbee <silk_NLSF_stabilize+0x23e>
 800db54:	1e8b      	subs	r3, r1, #2
 800db56:	007d      	lsls	r5, r7, #1
 800db58:	195e      	adds	r6, r3, r5
                min_center_Q15 += NDeltaMin_Q15[k];
 800db5a:	f933 4f02 	ldrsh.w	r4, [r3, #2]!
            for( k = 0; k < I; k++ ) {
 800db5e:	429e      	cmp	r6, r3
                min_center_Q15 += NDeltaMin_Q15[k];
 800db60:	4422      	add	r2, r4
            for( k = 0; k < I; k++ ) {
 800db62:	d1fa      	bne.n	800db5a <silk_NLSF_stabilize+0x1aa>
            min_center_Q15 += silk_RSHIFT( NDeltaMin_Q15[I], 1 );
 800db64:	5f4e      	ldrsh	r6, [r1, r5]
            for( k = L; k > I; k-- ) {
 800db66:	4567      	cmp	r7, ip
            min_center_Q15 += silk_RSHIFT( NDeltaMin_Q15[I], 1 );
 800db68:	ea4f 0666 	mov.w	r6, r6, asr #1
 800db6c:	eb01 0905 	add.w	r9, r1, r5
 800db70:	4432      	add	r2, r6
            for( k = L; k > I; k-- ) {
 800db72:	da39      	bge.n	800dbe8 <silk_NLSF_stabilize+0x238>
            max_center_Q15 = 1 << 15;
 800db74:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 800db78:	9f03      	ldr	r7, [sp, #12]
            for( k = L; k > I; k-- ) {
 800db7a:	9b02      	ldr	r3, [sp, #8]
 800db7c:	eb07 0a05 	add.w	sl, r7, r5
                max_center_Q15 -= NDeltaMin_Q15[k];
 800db80:	f933 7d02 	ldrsh.w	r7, [r3, #-2]!
            for( k = L; k > I; k-- ) {
 800db84:	459a      	cmp	sl, r3
                max_center_Q15 -= NDeltaMin_Q15[k];
 800db86:	eba4 0407 	sub.w	r4, r4, r7
            for( k = L; k > I; k-- ) {
 800db8a:	d1f9      	bne.n	800db80 <silk_NLSF_stabilize+0x1d0>
 800db8c:	1eaf      	subs	r7, r5, #2
 800db8e:	5f43      	ldrsh	r3, [r0, r5]
 800db90:	f930 a007 	ldrsh.w	sl, [r0, r7]
            max_center_Q15 -= silk_RSHIFT( NDeltaMin_Q15[I], 1 );
 800db94:	1ba4      	subs	r4, r4, r6
 800db96:	4453      	add	r3, sl
 800db98:	f003 0b01 	and.w	fp, r3, #1
            center_freq_Q15 = (opus_int16)silk_LIMIT_32( silk_RSHIFT_ROUND( (opus_int32)NLSF_Q15[I-1] + (opus_int32)NLSF_Q15[I], 1 ),
 800db9c:	42a2      	cmp	r2, r4
 800db9e:	4405      	add	r5, r0
 800dba0:	eb0b 0363 	add.w	r3, fp, r3, asr #1
 800dba4:	dd11      	ble.n	800dbca <silk_NLSF_stabilize+0x21a>
 800dba6:	429a      	cmp	r2, r3
 800dba8:	da15      	bge.n	800dbd6 <silk_NLSF_stabilize+0x226>
 800dbaa:	b213      	sxth	r3, r2
            NLSF_Q15[I-1] = center_freq_Q15 - silk_RSHIFT( NDeltaMin_Q15[I], 1 );
 800dbac:	1b9e      	subs	r6, r3, r6
 800dbae:	b2b6      	uxth	r6, r6
 800dbb0:	53c6      	strh	r6, [r0, r7]
            NLSF_Q15[I] = NLSF_Q15[I-1] + NDeltaMin_Q15[I];
 800dbb2:	f8b9 3000 	ldrh.w	r3, [r9]
 800dbb6:	441e      	add	r6, r3
 800dbb8:	802e      	strh	r6, [r5, #0]
 800dbba:	e76f      	b.n	800da9c <silk_NLSF_stabilize+0xec>
            NLSF_Q15[L-1] = ( 1 << 15 ) - NDeltaMin_Q15[L];
 800dbbc:	9b00      	ldr	r3, [sp, #0]
 800dbbe:	f5c4 4400 	rsb	r4, r4, #32768	; 0x8000
 800dbc2:	801c      	strh	r4, [r3, #0]
 800dbc4:	e76a      	b.n	800da9c <silk_NLSF_stabilize+0xec>
        I = 0;
 800dbc6:	2700      	movs	r7, #0
 800dbc8:	e755      	b.n	800da76 <silk_NLSF_stabilize+0xc6>
            center_freq_Q15 = (opus_int16)silk_LIMIT_32( silk_RSHIFT_ROUND( (opus_int32)NLSF_Q15[I-1] + (opus_int32)NLSF_Q15[I], 1 ),
 800dbca:	429c      	cmp	r4, r3
 800dbcc:	db05      	blt.n	800dbda <silk_NLSF_stabilize+0x22a>
 800dbce:	429a      	cmp	r2, r3
 800dbd0:	dceb      	bgt.n	800dbaa <silk_NLSF_stabilize+0x1fa>
 800dbd2:	b21b      	sxth	r3, r3
 800dbd4:	e7ea      	b.n	800dbac <silk_NLSF_stabilize+0x1fc>
 800dbd6:	429c      	cmp	r4, r3
 800dbd8:	ddfb      	ble.n	800dbd2 <silk_NLSF_stabilize+0x222>
 800dbda:	b223      	sxth	r3, r4
 800dbdc:	e7e6      	b.n	800dbac <silk_NLSF_stabilize+0x1fc>
        for( i = 1; i <= L-1; i++ ) {
 800dbde:	2700      	movs	r7, #0
 800dbe0:	2601      	movs	r6, #1
 800dbe2:	e72e      	b.n	800da42 <silk_NLSF_stabilize+0x92>
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
 800dbe4:	4663      	mov	r3, ip
 800dbe6:	e779      	b.n	800dadc <silk_NLSF_stabilize+0x12c>
            max_center_Q15 = 1 << 15;
 800dbe8:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 800dbec:	e7ce      	b.n	800db8c <silk_NLSF_stabilize+0x1dc>
 800dbee:	007d      	lsls	r5, r7, #1
 800dbf0:	e7b8      	b.n	800db64 <silk_NLSF_stabilize+0x1b4>
 800dbf2:	bf00      	nop
 800dbf4:	ffff8000 	.word	0xffff8000

0800dbf8 <silk_NLSF_unpack>:
          opus_int16            ec_ix[],                        /* O    Indices to entropy tables [ LPC_ORDER ]     */
          opus_uint8            pred_Q8[],                      /* O    LSF predictor [ LPC_ORDER ]                 */
    const silk_NLSF_CB_struct   *psNLSF_CB,                     /* I    Codebook object                             */
    const opus_int              CB1_index                       /* I    Index of vector in first LSF codebook       */
)
{
 800dbf8:	b5f0      	push	{r4, r5, r6, r7, lr}
    opus_int   i;
    opus_uint8 entry;
    const opus_uint8 *ec_sel_ptr;

    ec_sel_ptr = &psNLSF_CB->ec_sel[ CB1_index * psNLSF_CB->order / 2 ];
 800dbfa:	f9b2 5002 	ldrsh.w	r5, [r2, #2]
 800dbfe:	6994      	ldr	r4, [r2, #24]
 800dc00:	fb03 f305 	mul.w	r3, r3, r5
    for( i = 0; i < psNLSF_CB->order; i += 2 ) {
 800dc04:	2d00      	cmp	r5, #0
    ec_sel_ptr = &psNLSF_CB->ec_sel[ CB1_index * psNLSF_CB->order / 2 ];
 800dc06:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 800dc0a:	eb04 0c63 	add.w	ip, r4, r3, asr #1
    for( i = 0; i < psNLSF_CB->order; i += 2 ) {
 800dc0e:	dd2b      	ble.n	800dc68 <silk_NLSF_unpack+0x70>
 800dc10:	4607      	mov	r7, r0
 800dc12:	2400      	movs	r4, #0
        entry = *ec_sel_ptr++;
 800dc14:	f81c 3b01 	ldrb.w	r3, [ip], #1
        ec_ix  [ i     ] = silk_SMULBB( silk_RSHIFT( entry, 1 ) & 7, 2 * NLSF_QUANT_MAX_AMPLITUDE + 1 );
        pred_Q8[ i     ] = psNLSF_CB->pred_Q8[ i + ( entry & 1 ) * ( psNLSF_CB->order - 1 ) ];
 800dc18:	f8d2 e014 	ldr.w	lr, [r2, #20]
        ec_ix  [ i     ] = silk_SMULBB( silk_RSHIFT( entry, 1 ) & 7, 2 * NLSF_QUANT_MAX_AMPLITUDE + 1 );
 800dc1c:	f3c3 0642 	ubfx	r6, r3, #1, #3
 800dc20:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
 800dc24:	f820 6014 	strh.w	r6, [r0, r4, lsl #1]
        pred_Q8[ i     ] = psNLSF_CB->pred_Q8[ i + ( entry & 1 ) * ( psNLSF_CB->order - 1 ) ];
 800dc28:	f9b2 5002 	ldrsh.w	r5, [r2, #2]
 800dc2c:	f003 0601 	and.w	r6, r3, #1
 800dc30:	3d01      	subs	r5, #1
 800dc32:	fb06 e505 	mla	r5, r6, r5, lr
        ec_ix  [ i + 1 ] = silk_SMULBB( silk_RSHIFT( entry, 5 ) & 7, 2 * NLSF_QUANT_MAX_AMPLITUDE + 1 );
 800dc36:	095e      	lsrs	r6, r3, #5
        pred_Q8[ i     ] = psNLSF_CB->pred_Q8[ i + ( entry & 1 ) * ( psNLSF_CB->order - 1 ) ];
 800dc38:	5d2d      	ldrb	r5, [r5, r4]
        ec_ix  [ i + 1 ] = silk_SMULBB( silk_RSHIFT( entry, 5 ) & 7, 2 * NLSF_QUANT_MAX_AMPLITUDE + 1 );
 800dc3a:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
        pred_Q8[ i     ] = psNLSF_CB->pred_Q8[ i + ( entry & 1 ) * ( psNLSF_CB->order - 1 ) ];
 800dc3e:	550d      	strb	r5, [r1, r4]
        ec_ix  [ i + 1 ] = silk_SMULBB( silk_RSHIFT( entry, 5 ) & 7, 2 * NLSF_QUANT_MAX_AMPLITUDE + 1 );
 800dc40:	807e      	strh	r6, [r7, #2]
        pred_Q8[ i + 1 ] = psNLSF_CB->pred_Q8[ i + ( silk_RSHIFT( entry, 4 ) & 1 ) * ( psNLSF_CB->order - 1 ) + 1 ];
 800dc42:	f9b2 6002 	ldrsh.w	r6, [r2, #2]
 800dc46:	6955      	ldr	r5, [r2, #20]
 800dc48:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800dc4c:	4425      	add	r5, r4
 800dc4e:	3e01      	subs	r6, #1
 800dc50:	fb06 5303 	mla	r3, r6, r3, r5
 800dc54:	785d      	ldrb	r5, [r3, #1]
 800dc56:	190b      	adds	r3, r1, r4
 800dc58:	705d      	strb	r5, [r3, #1]
    for( i = 0; i < psNLSF_CB->order; i += 2 ) {
 800dc5a:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
 800dc5e:	3402      	adds	r4, #2
 800dc60:	42a3      	cmp	r3, r4
 800dc62:	f107 0704 	add.w	r7, r7, #4
 800dc66:	dcd5      	bgt.n	800dc14 <silk_NLSF_unpack+0x1c>
    }
}
 800dc68:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800dc6a:	bf00      	nop

0800dc6c <silk_PLC_Reset>:


void silk_PLC_Reset(
    silk_decoder_state                  *psDec              /* I/O Decoder state        */
)
{
 800dc6c:	b4f0      	push	{r4, r5, r6, r7}
    psDec->sPLC.pitchL_Q8 = silk_LSHIFT( psDec->frame_length, 8 - 1 );
    psDec->sPLC.prevGain_Q16[ 0 ] = SILK_FIX_CONST( 1, 16 );
 800dc6e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    psDec->sPLC.pitchL_Q8 = silk_LSHIFT( psDec->frame_length, 8 - 1 );
 800dc72:	f241 074c 	movw	r7, #4172	; 0x104c
    psDec->sPLC.prevGain_Q16[ 0 ] = SILK_FIX_CONST( 1, 16 );
 800dc76:	f241 0c94 	movw	ip, #4244	; 0x1094
    psDec->sPLC.prevGain_Q16[ 1 ] = SILK_FIX_CONST( 1, 16 );
 800dc7a:	f241 0698 	movw	r6, #4248	; 0x1098
    psDec->sPLC.subfr_length = 20;
 800dc7e:	f241 04a4 	movw	r4, #4260	; 0x10a4
 800dc82:	2514      	movs	r5, #20
    psDec->sPLC.nb_subfr = 2;
 800dc84:	2102      	movs	r1, #2
    psDec->sPLC.pitchL_Q8 = silk_LSHIFT( psDec->frame_length, 8 - 1 );
 800dc86:	f8d0 3918 	ldr.w	r3, [r0, #2328]	; 0x918
    psDec->sPLC.prevGain_Q16[ 0 ] = SILK_FIX_CONST( 1, 16 );
 800dc8a:	f840 200c 	str.w	r2, [r0, ip]
    psDec->sPLC.pitchL_Q8 = silk_LSHIFT( psDec->frame_length, 8 - 1 );
 800dc8e:	01db      	lsls	r3, r3, #7
 800dc90:	51c3      	str	r3, [r0, r7]
    psDec->sPLC.nb_subfr = 2;
 800dc92:	f500 5385 	add.w	r3, r0, #4256	; 0x10a0
    psDec->sPLC.prevGain_Q16[ 1 ] = SILK_FIX_CONST( 1, 16 );
 800dc96:	5182      	str	r2, [r0, r6]
    psDec->sPLC.subfr_length = 20;
 800dc98:	5105      	str	r5, [r0, r4]
    psDec->sPLC.nb_subfr = 2;
 800dc9a:	6019      	str	r1, [r3, #0]
}
 800dc9c:	bcf0      	pop	{r4, r5, r6, r7}
 800dc9e:	4770      	bx	lr

0800dca0 <silk_PLC>:
    silk_decoder_control                *psDecCtrl,         /* I/O Decoder control      */
    opus_int16                          frame[],            /* I/O  signal              */
    opus_int                            lost,               /* I Loss flag              */
    int                                 arch                /* I Run-time architecture  */
)
{
 800dca0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dca4:	b0b3      	sub	sp, #204	; 0xcc
 800dca6:	4680      	mov	r8, r0
    /* PLC control function */
    if( psDec->fs_kHz != psDec->sPLC.fs_kHz ) {
 800dca8:	f241 059c 	movw	r5, #4252	; 0x109c
 800dcac:	f8d0 090c 	ldr.w	r0, [r0, #2316]	; 0x90c
 800dcb0:	f858 4005 	ldr.w	r4, [r8, r5]
{
 800dcb4:	af02      	add	r7, sp, #8
    if( psDec->fs_kHz != psDec->sPLC.fs_kHz ) {
 800dcb6:	42a0      	cmp	r0, r4
{
 800dcb8:	6239      	str	r1, [r7, #32]
 800dcba:	61ba      	str	r2, [r7, #24]
    if( psDec->fs_kHz != psDec->sPLC.fs_kHz ) {
 800dcbc:	d01c      	beq.n	800dcf8 <silk_PLC+0x58>
    psDec->sPLC.prevGain_Q16[ 0 ] = SILK_FIX_CONST( 1, 16 );
 800dcbe:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    psDec->sPLC.pitchL_Q8 = silk_LSHIFT( psDec->frame_length, 8 - 1 );
 800dcc2:	f241 0a4c 	movw	sl, #4172	; 0x104c
    psDec->sPLC.prevGain_Q16[ 0 ] = SILK_FIX_CONST( 1, 16 );
 800dcc6:	f241 0994 	movw	r9, #4244	; 0x1094
    psDec->sPLC.prevGain_Q16[ 1 ] = SILK_FIX_CONST( 1, 16 );
 800dcca:	f241 0e98 	movw	lr, #4248	; 0x1098
    psDec->sPLC.subfr_length = 20;
 800dcce:	f241 06a4 	movw	r6, #4260	; 0x10a4
 800dcd2:	f04f 0c14 	mov.w	ip, #20
    psDec->sPLC.nb_subfr = 2;
 800dcd6:	2402      	movs	r4, #2
    psDec->sPLC.pitchL_Q8 = silk_LSHIFT( psDec->frame_length, 8 - 1 );
 800dcd8:	f8d8 2918 	ldr.w	r2, [r8, #2328]	; 0x918
    psDec->sPLC.prevGain_Q16[ 0 ] = SILK_FIX_CONST( 1, 16 );
 800dcdc:	f848 1009 	str.w	r1, [r8, r9]
    psDec->sPLC.pitchL_Q8 = silk_LSHIFT( psDec->frame_length, 8 - 1 );
 800dce0:	01d2      	lsls	r2, r2, #7
 800dce2:	f848 200a 	str.w	r2, [r8, sl]
    psDec->sPLC.nb_subfr = 2;
 800dce6:	f508 5285 	add.w	r2, r8, #4256	; 0x10a0
    psDec->sPLC.prevGain_Q16[ 1 ] = SILK_FIX_CONST( 1, 16 );
 800dcea:	f848 100e 	str.w	r1, [r8, lr]
    psDec->sPLC.subfr_length = 20;
 800dcee:	f848 c006 	str.w	ip, [r8, r6]
    psDec->sPLC.nb_subfr = 2;
 800dcf2:	6014      	str	r4, [r2, #0]
        silk_PLC_Reset( psDec );
        psDec->sPLC.fs_kHz = psDec->fs_kHz;
 800dcf4:	f848 0005 	str.w	r0, [r8, r5]
 800dcf8:	f241 014c 	movw	r1, #4172	; 0x104c
 800dcfc:	eb08 0601 	add.w	r6, r8, r1
 800dd00:	1d32      	adds	r2, r6, #4
 800dd02:	65be      	str	r6, [r7, #88]	; 0x58
 800dd04:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
 800dd08:	f106 0b0e 	add.w	fp, r6, #14
 800dd0c:	f8d8 591c 	ldr.w	r5, [r8, #2332]	; 0x91c
 800dd10:	f8d8 4914 	ldr.w	r4, [r8, #2324]	; 0x914
    }

    if( lost ) {
 800dd14:	2b00      	cmp	r3, #0
 800dd16:	f040 810b 	bne.w	800df30 <silk_PLC+0x290>
    silk_PLC_struct *psPLC;

    psPLC = &psDec->sPLC;

    /* Update parameters used in case of packet loss */
    psDec->prevSignalType = psDec->indices.signalType;
 800dd1a:	f241 0c44 	movw	ip, #4164	; 0x1044
 800dd1e:	f998 6acd 	ldrsb.w	r6, [r8, #2765]	; 0xacd
    LTP_Gain_Q14 = 0;
    if( psDec->indices.signalType == TYPE_VOICED ) {
 800dd22:	2e02      	cmp	r6, #2
    psDec->prevSignalType = psDec->indices.signalType;
 800dd24:	f848 600c 	str.w	r6, [r8, ip]
    if( psDec->indices.signalType == TYPE_VOICED ) {
 800dd28:	f040 80db 	bne.w	800dee2 <silk_PLC+0x242>
 800dd2c:	6a3e      	ldr	r6, [r7, #32]
        /* Find the parameters for the last subframe which contains a pitch pulse */
        for( j = 0; j * psDec->subfr_length < psDecCtrl->pitchL[ psDec->nb_subfr - 1 ]; j++ ) {
 800dd2e:	f104 3aff 	add.w	sl, r4, #4294967295
 800dd32:	eb06 0984 	add.w	r9, r6, r4, lsl #2
 800dd36:	f859 ec04 	ldr.w	lr, [r9, #-4]
 800dd3a:	f1be 0f00 	cmp.w	lr, #0
 800dd3e:	f340 85fc 	ble.w	800e93a <silk_PLC+0xc9a>
            if( j == psDec->nb_subfr ) {
 800dd42:	2c00      	cmp	r4, #0
 800dd44:	f000 85f9 	beq.w	800e93a <silk_PLC+0xc9a>
                break;
            }
            temp_LTP_Gain_Q14 = 0;
            for( i = 0; i < LTP_ORDER; i++ ) {
                temp_LTP_Gain_Q14 += psDecCtrl->LTPCoef_Q14[ ( psDec->nb_subfr - 1 - j ) * LTP_ORDER  + i ];
 800dd48:	eb0a 008a 	add.w	r0, sl, sl, lsl #2
 800dd4c:	eb06 0040 	add.w	r0, r6, r0, lsl #1
 800dd50:	f9b0 6062 	ldrsh.w	r6, [r0, #98]	; 0x62
 800dd54:	f9b0 c060 	ldrsh.w	ip, [r0, #96]	; 0x60
 800dd58:	f9b0 2064 	ldrsh.w	r2, [r0, #100]	; 0x64
 800dd5c:	44b4      	add	ip, r6
 800dd5e:	f9b0 6066 	ldrsh.w	r6, [r0, #102]	; 0x66
 800dd62:	4494      	add	ip, r2
 800dd64:	f9b0 0068 	ldrsh.w	r0, [r0, #104]	; 0x68
 800dd68:	44b4      	add	ip, r6
 800dd6a:	4460      	add	r0, ip
            }
            if( temp_LTP_Gain_Q14 > LTP_Gain_Q14 ) {
 800dd6c:	2800      	cmp	r0, #0
 800dd6e:	f300 84d1 	bgt.w	800e714 <silk_PLC+0xa74>
        for( j = 0; j * psDec->subfr_length < psDecCtrl->pitchL[ psDec->nb_subfr - 1 ]; j++ ) {
 800dd72:	45ae      	cmp	lr, r5
 800dd74:	f340 855c 	ble.w	800e830 <silk_PLC+0xb90>
            if( j == psDec->nb_subfr ) {
 800dd78:	2c01      	cmp	r4, #1
 800dd7a:	d072      	beq.n	800de62 <silk_PLC+0x1c2>
                temp_LTP_Gain_Q14 += psDecCtrl->LTPCoef_Q14[ ( psDec->nb_subfr - 1 - j ) * LTP_ORDER  + i ];
 800dd7c:	1ea6      	subs	r6, r4, #2
 800dd7e:	6a3a      	ldr	r2, [r7, #32]
 800dd80:	eb06 0186 	add.w	r1, r6, r6, lsl #2
 800dd84:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 800dd88:	f9b1 a062 	ldrsh.w	sl, [r1, #98]	; 0x62
 800dd8c:	f9b1 0060 	ldrsh.w	r0, [r1, #96]	; 0x60
 800dd90:	f9b1 c064 	ldrsh.w	ip, [r1, #100]	; 0x64
 800dd94:	4450      	add	r0, sl
 800dd96:	f9b1 a066 	ldrsh.w	sl, [r1, #102]	; 0x66
 800dd9a:	4460      	add	r0, ip
 800dd9c:	f9b1 1068 	ldrsh.w	r1, [r1, #104]	; 0x68
 800dda0:	4450      	add	r0, sl
 800dda2:	4401      	add	r1, r0
            if( temp_LTP_Gain_Q14 > LTP_Gain_Q14 ) {
 800dda4:	4299      	cmp	r1, r3
 800dda6:	dd22      	ble.n	800ddee <silk_PLC+0x14e>
                LTP_Gain_Q14 = temp_LTP_Gain_Q14;
                silk_memcpy( psPLC->LTPCoef_Q14,
 800dda8:	f04f 0c05 	mov.w	ip, #5
 800ddac:	f04f 0e30 	mov.w	lr, #48	; 0x30
                    &psDecCtrl->LTPCoef_Q14[ silk_SMULBB( psDec->nb_subfr - 1 - j, LTP_ORDER ) ],
                    LTP_ORDER * sizeof( opus_int16 ) );

                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800ddb0:	f241 0a4c 	movw	sl, #4172	; 0x104c
 800ddb4:	460b      	mov	r3, r1
                silk_memcpy( psPLC->LTPCoef_Q14,
 800ddb6:	fb16 e10c 	smlabb	r1, r6, ip, lr
 800ddba:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 800ddbe:	f8d1 e000 	ldr.w	lr, [r1]
 800ddc2:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800ddc4:	f8d1 c004 	ldr.w	ip, [r1, #4]
 800ddc8:	f8c0 e004 	str.w	lr, [r0, #4]
 800ddcc:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 800ddd0:	f8c7 2080 	str.w	r2, [r7, #128]	; 0x80
 800ddd4:	f8c0 c004 	str.w	ip, [r0, #4]
 800ddd8:	8909      	ldrh	r1, [r1, #8]
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800ddda:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
                silk_memcpy( psPLC->LTPCoef_Q14,
 800ddde:	8101      	strh	r1, [r0, #8]
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800dde0:	f852 1026 	ldr.w	r1, [r2, r6, lsl #2]
 800dde4:	f859 ec04 	ldr.w	lr, [r9, #-4]
 800dde8:	0209      	lsls	r1, r1, #8
 800ddea:	f848 100a 	str.w	r1, [r8, sl]
        for( j = 0; j * psDec->subfr_length < psDecCtrl->pitchL[ psDec->nb_subfr - 1 ]; j++ ) {
 800ddee:	006e      	lsls	r6, r5, #1
 800ddf0:	4576      	cmp	r6, lr
 800ddf2:	da36      	bge.n	800de62 <silk_PLC+0x1c2>
            if( j == psDec->nb_subfr ) {
 800ddf4:	2c02      	cmp	r4, #2
 800ddf6:	d034      	beq.n	800de62 <silk_PLC+0x1c2>
 800ddf8:	6a3a      	ldr	r2, [r7, #32]
                temp_LTP_Gain_Q14 += psDecCtrl->LTPCoef_Q14[ ( psDec->nb_subfr - 1 - j ) * LTP_ORDER  + i ];
 800ddfa:	f1a4 0c03 	sub.w	ip, r4, #3
 800ddfe:	eb0c 018c 	add.w	r1, ip, ip, lsl #2
 800de02:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 800de06:	f9b1 a062 	ldrsh.w	sl, [r1, #98]	; 0x62
 800de0a:	f9b1 0060 	ldrsh.w	r0, [r1, #96]	; 0x60
 800de0e:	f9b1 2064 	ldrsh.w	r2, [r1, #100]	; 0x64
 800de12:	4450      	add	r0, sl
 800de14:	f9b1 a066 	ldrsh.w	sl, [r1, #102]	; 0x66
 800de18:	4410      	add	r0, r2
 800de1a:	f9b1 1068 	ldrsh.w	r1, [r1, #104]	; 0x68
 800de1e:	4450      	add	r0, sl
 800de20:	4401      	add	r1, r0
            if( temp_LTP_Gain_Q14 > LTP_Gain_Q14 ) {
 800de22:	4299      	cmp	r1, r3
 800de24:	f300 853f 	bgt.w	800e8a6 <silk_PLC+0xc06>
        for( j = 0; j * psDec->subfr_length < psDecCtrl->pitchL[ psDec->nb_subfr - 1 ]; j++ ) {
 800de28:	442e      	add	r6, r5
 800de2a:	4576      	cmp	r6, lr
 800de2c:	da19      	bge.n	800de62 <silk_PLC+0x1c2>
            if( j == psDec->nb_subfr ) {
 800de2e:	2c03      	cmp	r4, #3
 800de30:	d017      	beq.n	800de62 <silk_PLC+0x1c2>
                temp_LTP_Gain_Q14 += psDecCtrl->LTPCoef_Q14[ ( psDec->nb_subfr - 1 - j ) * LTP_ORDER  + i ];
 800de32:	1f26      	subs	r6, r4, #4
 800de34:	6a3a      	ldr	r2, [r7, #32]
 800de36:	eb06 0186 	add.w	r1, r6, r6, lsl #2
 800de3a:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 800de3e:	f9b1 0062 	ldrsh.w	r0, [r1, #98]	; 0x62
 800de42:	f9b1 e060 	ldrsh.w	lr, [r1, #96]	; 0x60
 800de46:	f9b1 c064 	ldrsh.w	ip, [r1, #100]	; 0x64
 800de4a:	4486      	add	lr, r0
 800de4c:	f9b1 0066 	ldrsh.w	r0, [r1, #102]	; 0x66
 800de50:	44f4      	add	ip, lr
 800de52:	f9b1 e068 	ldrsh.w	lr, [r1, #104]	; 0x68
 800de56:	eb00 010c 	add.w	r1, r0, ip
 800de5a:	4471      	add	r1, lr
            if( temp_LTP_Gain_Q14 > LTP_Gain_Q14 ) {
 800de5c:	428b      	cmp	r3, r1
 800de5e:	f2c0 8548 	blt.w	800e8f2 <silk_PLC+0xc52>

        silk_memset( psPLC->LTPCoef_Q14, 0, LTP_ORDER * sizeof( opus_int16 ) );
        psPLC->LTPCoef_Q14[ LTP_ORDER / 2 ] = LTP_Gain_Q14;

        /* Limit LT coefs */
        if( LTP_Gain_Q14 < V_PITCH_GAIN_START_MIN_Q14 ) {
 800de62:	f642 4ccc 	movw	ip, #11468	; 0x2ccc
        silk_memset( psPLC->LTPCoef_Q14, 0, LTP_ORDER * sizeof( opus_int16 ) );
 800de66:	2100      	movs	r1, #0
 800de68:	6dbe      	ldr	r6, [r7, #88]	; 0x58
 800de6a:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
        if( LTP_Gain_Q14 < V_PITCH_GAIN_START_MIN_Q14 ) {
 800de6e:	4563      	cmp	r3, ip
        silk_memset( psPLC->LTPCoef_Q14, 0, LTP_ORDER * sizeof( opus_int16 ) );
 800de70:	6071      	str	r1, [r6, #4]
 800de72:	6051      	str	r1, [r2, #4]
 800de74:	8111      	strh	r1, [r2, #8]
        psPLC->LTPCoef_Q14[ LTP_ORDER / 2 ] = LTP_Gain_Q14;
 800de76:	8133      	strh	r3, [r6, #8]
        if( LTP_Gain_Q14 < V_PITCH_GAIN_START_MIN_Q14 ) {
 800de78:	f340 84e1 	ble.w	800e83e <silk_PLC+0xb9e>
            tmp = silk_LSHIFT( V_PITCH_GAIN_START_MIN_Q14, 10 );
            scale_Q10 = silk_DIV32( tmp, silk_max( LTP_Gain_Q14, 1 ) );
            for( i = 0; i < LTP_ORDER; i++ ) {
                psPLC->LTPCoef_Q14[ i ] = silk_RSHIFT( silk_SMULBB( psPLC->LTPCoef_Q14[ i ], scale_Q10 ), 10 );
            }
        } else if( LTP_Gain_Q14 > V_PITCH_GAIN_START_MAX_Q14 ) {
 800de7c:	f643 42cd 	movw	r2, #15565	; 0x3ccd
 800de80:	4293      	cmp	r3, r2
 800de82:	dd3a      	ble.n	800defa <silk_PLC+0x25a>
 800de84:	4631      	mov	r1, r6
            opus_int   scale_Q14;
            opus_int32 tmp;

            tmp = silk_LSHIFT( V_PITCH_GAIN_START_MAX_Q14, 14 );
            scale_Q14 = silk_DIV32( tmp, silk_max( LTP_Gain_Q14, 1 ) );
 800de86:	4a50      	ldr	r2, [pc, #320]	; (800dfc8 <silk_PLC+0x328>)
            for( i = 0; i < LTP_ORDER; i++ ) {
                psPLC->LTPCoef_Q14[ i ] = silk_RSHIFT( silk_SMULBB( psPLC->LTPCoef_Q14[ i ], scale_Q14 ), 14 );
 800de88:	f241 0e52 	movw	lr, #4178	; 0x1052
            scale_Q14 = silk_DIV32( tmp, silk_max( LTP_Gain_Q14, 1 ) );
 800de8c:	fb92 f3f3 	sdiv	r3, r2, r3
                psPLC->LTPCoef_Q14[ i ] = silk_RSHIFT( silk_SMULBB( psPLC->LTPCoef_Q14[ i ], scale_Q14 ), 14 );
 800de90:	f241 0954 	movw	r9, #4180	; 0x1054
 800de94:	f241 0c56 	movw	ip, #4182	; 0x1056
 800de98:	f241 0658 	movw	r6, #4184	; 0x1058
 800de9c:	f9b1 2004 	ldrsh.w	r2, [r1, #4]
 800dea0:	fb03 f202 	mul.w	r2, r3, r2
 800dea4:	1392      	asrs	r2, r2, #14
 800dea6:	808a      	strh	r2, [r1, #4]
 800dea8:	f938 000e 	ldrsh.w	r0, [r8, lr]
 800deac:	f938 1009 	ldrsh.w	r1, [r8, r9]
 800deb0:	fb03 f000 	mul.w	r0, r3, r0
 800deb4:	1380      	asrs	r0, r0, #14
 800deb6:	f938 200c 	ldrsh.w	r2, [r8, ip]
 800deba:	f828 000e 	strh.w	r0, [r8, lr]
 800debe:	f938 0006 	ldrsh.w	r0, [r8, r6]
 800dec2:	fb03 f101 	mul.w	r1, r3, r1
 800dec6:	fb03 f202 	mul.w	r2, r3, r2
 800deca:	fb03 f300 	mul.w	r3, r3, r0
 800dece:	1389      	asrs	r1, r1, #14
 800ded0:	1392      	asrs	r2, r2, #14
 800ded2:	139b      	asrs	r3, r3, #14
 800ded4:	f828 1009 	strh.w	r1, [r8, r9]
 800ded8:	f828 200c 	strh.w	r2, [r8, ip]
 800dedc:	f828 3006 	strh.w	r3, [r8, r6]
 800dee0:	e00b      	b.n	800defa <silk_PLC+0x25a>
            }
        }
    } else {
        psPLC->pitchL_Q8 = silk_LSHIFT( silk_SMULBB( psDec->fs_kHz, 18 ), 8 );
 800dee2:	b200      	sxth	r0, r0
        silk_memset( psPLC->LTPCoef_Q14, 0, LTP_ORDER * sizeof( opus_int16 ));
 800dee4:	6dba      	ldr	r2, [r7, #88]	; 0x58
        psPLC->pitchL_Q8 = silk_LSHIFT( silk_SMULBB( psDec->fs_kHz, 18 ), 8 );
 800dee6:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
 800deea:	0240      	lsls	r0, r0, #9
 800deec:	f848 0001 	str.w	r0, [r8, r1]
        silk_memset( psPLC->LTPCoef_Q14, 0, LTP_ORDER * sizeof( opus_int16 ));
 800def0:	6053      	str	r3, [r2, #4]
 800def2:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800def6:	6053      	str	r3, [r2, #4]
 800def8:	8113      	strh	r3, [r2, #8]
    }

    /* Save LPC coeficients */
    silk_memcpy( psPLC->prevLPC_Q12, psDecCtrl->PredCoef_Q12[ 1 ], psDec->LPC_order * sizeof( opus_int16 ) );
 800defa:	6a3e      	ldr	r6, [r7, #32]
 800defc:	f8d8 2924 	ldr.w	r2, [r8, #2340]	; 0x924
 800df00:	f106 0140 	add.w	r1, r6, #64	; 0x40
 800df04:	4658      	mov	r0, fp
 800df06:	0052      	lsls	r2, r2, #1
 800df08:	f006 f8ea 	bl	80140e0 <memcpy>
    psPLC->prevLTP_scale_Q14 = psDecCtrl->LTP_scale_Q14;
 800df0c:	f8d6 2088 	ldr.w	r2, [r6, #136]	; 0x88
 800df10:	6db9      	ldr	r1, [r7, #88]	; 0x58

    /* Save last two gains */
    silk_memcpy( psPLC->prevGain_Q16, &psDecCtrl->Gains_Q16[ psDec->nb_subfr - 2 ], 2 * sizeof( opus_int32 ) );
 800df12:	1ca3      	adds	r3, r4, #2
    psPLC->prevLTP_scale_Q14 = psDecCtrl->LTP_scale_Q14;
 800df14:	f8a1 2044 	strh.w	r2, [r1, #68]	; 0x44
    silk_memcpy( psPLC->prevGain_Q16, &psDecCtrl->Gains_Q16[ psDec->nb_subfr - 2 ], 2 * sizeof( opus_int32 ) );
 800df18:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800df1c:	681a      	ldr	r2, [r3, #0]
 800df1e:	685b      	ldr	r3, [r3, #4]
}
 800df20:	37c4      	adds	r7, #196	; 0xc4
    silk_memcpy( psPLC->prevGain_Q16, &psDecCtrl->Gains_Q16[ psDec->nb_subfr - 2 ], 2 * sizeof( opus_int32 ) );
 800df22:	648a      	str	r2, [r1, #72]	; 0x48
 800df24:	64cb      	str	r3, [r1, #76]	; 0x4c

    psPLC->subfr_length = psDec->subfr_length;
 800df26:	658d      	str	r5, [r1, #88]	; 0x58
    psPLC->nb_subfr = psDec->nb_subfr;
 800df28:	654c      	str	r4, [r1, #84]	; 0x54
}
 800df2a:	46bd      	mov	sp, r7
 800df2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    VARDECL( opus_int32, sLTP_Q14 );
    silk_PLC_struct *psPLC = &psDec->sPLC;
    opus_int32 prevGain_Q10[2];
    SAVE_STACK;

    ALLOC( sLTP_Q14, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800df30:	f8d8 3920 	ldr.w	r3, [r8, #2336]	; 0x920
 800df34:	f8d8 2918 	ldr.w	r2, [r8, #2328]	; 0x918
#ifdef SMALL_FOOTPRINT
    /* Ugly hack that breaks aliasing rules to save stack: put sLTP at the very end of sLTP_Q14. */
    sLTP = ((opus_int16*)&sLTP_Q14[psDec->ltp_mem_length + psDec->frame_length])-psDec->ltp_mem_length;
#else
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800df38:	0058      	lsls	r0, r3, #1
    ALLOC( sLTP_Q14, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800df3a:	4413      	add	r3, r2
 800df3c:	009b      	lsls	r3, r3, #2
 800df3e:	330a      	adds	r3, #10
 800df40:	f023 0307 	bic.w	r3, r3, #7
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800df44:	3008      	adds	r0, #8
#endif

    prevGain_Q10[0] = silk_RSHIFT( psPLC->prevGain_Q16[ 0 ], 6);
 800df46:	6cb2      	ldr	r2, [r6, #72]	; 0x48
    prevGain_Q10[1] = silk_RSHIFT( psPLC->prevGain_Q16[ 1 ], 6);
 800df48:	6cf1      	ldr	r1, [r6, #76]	; 0x4c
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800df4a:	f020 0007 	bic.w	r0, r0, #7
{
 800df4e:	f8c7 d000 	str.w	sp, [r7]
    ALLOC( sLTP_Q14, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800df52:	ebad 0d03 	sub.w	sp, sp, r3
 800df56:	ae02      	add	r6, sp, #8

    if( psDec->first_frame_after_reset ) {
 800df58:	f8d8 3948 	ldr.w	r3, [r8, #2376]	; 0x948
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800df5c:	ebad 0d00 	sub.w	sp, sp, r0
    prevGain_Q10[1] = silk_RSHIFT( psPLC->prevGain_Q16[ 1 ], 6);
 800df60:	1189      	asrs	r1, r1, #6
    prevGain_Q10[0] = silk_RSHIFT( psPLC->prevGain_Q16[ 0 ], 6);
 800df62:	1192      	asrs	r2, r2, #6
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800df64:	a802      	add	r0, sp, #8
    ALLOC( sLTP_Q14, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800df66:	643e      	str	r6, [r7, #64]	; 0x40
    prevGain_Q10[1] = silk_RSHIFT( psPLC->prevGain_Q16[ 1 ], 6);
 800df68:	60f9      	str	r1, [r7, #12]
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800df6a:	f8c7 0080 	str.w	r0, [r7, #128]	; 0x80
    prevGain_Q10[1] = silk_RSHIFT( psPLC->prevGain_Q16[ 1 ], 6);
 800df6e:	e9c7 2126 	strd	r2, r1, [r7, #152]	; 0x98
    if( psDec->first_frame_after_reset ) {
 800df72:	2b00      	cmp	r3, #0
 800df74:	f040 8455 	bne.w	800e822 <silk_PLC+0xb82>
 800df78:	f06f 4e40 	mvn.w	lr, #3221225472	; 0xc0000000
 800df7c:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
    ALLOC( exc_buf, 2*subfr_length, opus_int16 );
 800df80:	00ab      	lsls	r3, r5, #2
 800df82:	3c02      	subs	r4, #2
 800df84:	fb05 e404 	mla	r4, r5, r4, lr
 800df88:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800df8c:	3308      	adds	r3, #8
 800df8e:	f023 0307 	bic.w	r3, r3, #7
{
 800df92:	f8c7 d07c 	str.w	sp, [r7, #124]	; 0x7c
    ALLOC( exc_buf, 2*subfr_length, opus_int16 );
 800df96:	ebad 0d03 	sub.w	sp, sp, r3
       silk_memset( psPLC->prevLPC_Q12, 0, sizeof( psPLC->prevLPC_Q12 ) );
    }

    silk_PLC_energy(&energy1, &shift1, &energy2, &shift2, psDec->exc_Q14, prevGain_Q10, psDec->subfr_length, psDec->nb_subfr);
 800df9a:	f108 0e04 	add.w	lr, r8, #4
    ALLOC( exc_buf, 2*subfr_length, opus_int16 );
 800df9e:	ab02      	add	r3, sp, #8
        for( i = 0; i < subfr_length; i++ ) {
 800dfa0:	2d00      	cmp	r5, #0
    ALLOC( exc_buf, 2*subfr_length, opus_int16 );
 800dfa2:	67bb      	str	r3, [r7, #120]	; 0x78
 800dfa4:	eb0e 0e84 	add.w	lr, lr, r4, lsl #2
 800dfa8:	f10d 0c06 	add.w	ip, sp, #6
 800dfac:	ea4f 0945 	mov.w	r9, r5, lsl #1
    for( k = 0; k < 2; k++ ) {
 800dfb0:	f04f 0a00 	mov.w	sl, #0
        for( i = 0; i < subfr_length; i++ ) {
 800dfb4:	dd38      	ble.n	800e028 <silk_PLC+0x388>
            exc_buf_ptr[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT(
 800dfb6:	f107 0398 	add.w	r3, r7, #152	; 0x98
 800dfba:	4664      	mov	r4, ip
 800dfbc:	4676      	mov	r6, lr
 800dfbe:	f853 002a 	ldr.w	r0, [r3, sl, lsl #2]
 800dfc2:	44cc      	add	ip, r9
 800dfc4:	e016      	b.n	800dff4 <silk_PLC+0x354>
 800dfc6:	bf00      	nop
 800dfc8:	0f334000 	.word	0x0f334000
  __asm__(
 800dfcc:	fb82 3100 	smull	r3, r1, r2, r0
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800dfd0:	0c1b      	lsrs	r3, r3, #16
 800dfd2:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 800dfd6:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
 800dfda:	f2c0 821f 	blt.w	800e41c <silk_PLC+0x77c>
  __asm__(
 800dfde:	fb82 3100 	smull	r3, r1, r2, r0
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800dfe2:	0c1b      	lsrs	r3, r3, #16
 800dfe4:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 800dfe8:	f343 230f 	sbfx	r3, r3, #8, #16
 800dfec:	f824 3f02 	strh.w	r3, [r4, #2]!
        for( i = 0; i < subfr_length; i++ ) {
 800dff0:	45a4      	cmp	ip, r4
 800dff2:	d00f      	beq.n	800e014 <silk_PLC+0x374>
            exc_buf_ptr[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT(
 800dff4:	f856 2f04 	ldr.w	r2, [r6, #4]!
  __asm__(
 800dff8:	fb82 3100 	smull	r3, r1, r2, r0
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800dffc:	0c1b      	lsrs	r3, r3, #16
 800dffe:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 800e002:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800e006:	dbe1      	blt.n	800dfcc <silk_PLC+0x32c>
 800e008:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800e00c:	f824 3f02 	strh.w	r3, [r4, #2]!
        for( i = 0; i < subfr_length; i++ ) {
 800e010:	45a4      	cmp	ip, r4
 800e012:	d1ef      	bne.n	800dff4 <silk_PLC+0x354>
 800e014:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800e018:	449e      	add	lr, r3
    for( k = 0; k < 2; k++ ) {
 800e01a:	f1ba 0f00 	cmp.w	sl, #0
 800e01e:	d10a      	bne.n	800e036 <silk_PLC+0x396>
        for( i = 0; i < subfr_length; i++ ) {
 800e020:	2d00      	cmp	r5, #0
    for( k = 0; k < 2; k++ ) {
 800e022:	f04f 0a01 	mov.w	sl, #1
        for( i = 0; i < subfr_length; i++ ) {
 800e026:	dcc6      	bgt.n	800dfb6 <silk_PLC+0x316>
 800e028:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800e02c:	44cc      	add	ip, r9
 800e02e:	449e      	add	lr, r3
    for( k = 0; k < 2; k++ ) {
 800e030:	f1ba 0f00 	cmp.w	sl, #0
 800e034:	d0f4      	beq.n	800e020 <silk_PLC+0x380>
    silk_sum_sqr_shift( energy1, shift1, exc_buf,                  subfr_length );
 800e036:	6fbc      	ldr	r4, [r7, #120]	; 0x78
 800e038:	462b      	mov	r3, r5
 800e03a:	4622      	mov	r2, r4
 800e03c:	f107 0188 	add.w	r1, r7, #136	; 0x88
 800e040:	f107 0090 	add.w	r0, r7, #144	; 0x90
 800e044:	f003 ff9e 	bl	8011f84 <silk_sum_sqr_shift>
    silk_sum_sqr_shift( energy2, shift2, &exc_buf[ subfr_length ], subfr_length );
 800e048:	4622      	mov	r2, r4
 800e04a:	462b      	mov	r3, r5
 800e04c:	444a      	add	r2, r9
 800e04e:	f107 018c 	add.w	r1, r7, #140	; 0x8c
 800e052:	f107 0094 	add.w	r0, r7, #148	; 0x94
 800e056:	f003 ff95 	bl	8011f84 <silk_sum_sqr_shift>

    if( silk_RSHIFT( energy1, shift2 ) < silk_RSHIFT( energy2, shift1 ) ) {
 800e05a:	e9d7 0223 	ldrd	r0, r2, [r7, #140]	; 0x8c
 800e05e:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 800e062:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800e066:	4102      	asrs	r2, r0
 800e068:	410b      	asrs	r3, r1
 800e06a:	429a      	cmp	r2, r3
        /* First sub-frame has lowest energy */
        rand_ptr = &psDec->exc_Q14[ silk_max_int( 0, ( psPLC->nb_subfr - 1 ) * psPLC->subfr_length - RAND_BUF_SIZE ) ];
 800e06c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    /* Set up Gain to random noise component */
    B_Q14          = psPLC->LTPCoef_Q14;
    rand_scale_Q14 = psPLC->randScale_Q14;

    /* Set up attenuation gains */
    harm_Gain_Q15 = HARM_ATT_Q15[ silk_min_int( NB_ATT - 1, psDec->lossCnt ) ];
 800e06e:	49c0      	ldr	r1, [pc, #768]	; (800e370 <silk_PLC+0x6d0>)
        rand_ptr = &psDec->exc_Q14[ silk_max_int( 0, ( psPLC->nb_subfr - 1 ) * psPLC->subfr_length - RAND_BUF_SIZE ) ];
 800e070:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800e072:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e074:	bfb8      	it	lt
 800e076:	f102 32ff 	addlt.w	r2, r2, #4294967295
        rand_ptr = &psDec->exc_Q14[ silk_max_int( 0, psPLC->nb_subfr * psPLC->subfr_length - RAND_BUF_SIZE ) ];
 800e07a:	fb03 f302 	mul.w	r3, r3, r2
 800e07e:	3b80      	subs	r3, #128	; 0x80
}

/* silk_min() versions with typecast in the function call */
static OPUS_INLINE opus_int silk_max_int(opus_int a, opus_int b)
{
    return (((a) > (b)) ? (a) : (b));
 800e080:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800e084:	3301      	adds	r3, #1
 800e086:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 800e08a:	677b      	str	r3, [r7, #116]	; 0x74
    harm_Gain_Q15 = HARM_ATT_Q15[ silk_min_int( NB_ATT - 1, psDec->lossCnt ) ];
 800e08c:	f508 5382 	add.w	r3, r8, #4160	; 0x1040
 800e090:	617b      	str	r3, [r7, #20]
    return (((a) < (b)) ? (a) : (b));
 800e092:	681b      	ldr	r3, [r3, #0]
    if( psDec->prevSignalType == TYPE_VOICED ) {
 800e094:	f241 0244 	movw	r2, #4164	; 0x1044
 800e098:	2b01      	cmp	r3, #1
 800e09a:	bfa8      	it	ge
 800e09c:	2301      	movge	r3, #1
 800e09e:	f858 2002 	ldr.w	r2, [r8, r2]
    harm_Gain_Q15 = HARM_ATT_Q15[ silk_min_int( NB_ATT - 1, psDec->lossCnt ) ];
 800e0a2:	f931 1013 	ldrsh.w	r1, [r1, r3, lsl #1]
    if( psDec->prevSignalType == TYPE_VOICED ) {
 800e0a6:	2a02      	cmp	r2, #2
    harm_Gain_Q15 = HARM_ATT_Q15[ silk_min_int( NB_ATT - 1, psDec->lossCnt ) ];
 800e0a8:	63f9      	str	r1, [r7, #60]	; 0x3c
    rand_scale_Q14 = psPLC->randScale_Q14;
 800e0aa:	6db9      	ldr	r1, [r7, #88]	; 0x58
        rand_Gain_Q15 = PLC_RAND_ATTENUATE_V_Q15[  silk_min_int( NB_ATT - 1, psDec->lossCnt ) ];
 800e0ac:	bf0c      	ite	eq
 800e0ae:	4ab1      	ldreq	r2, [pc, #708]	; (800e374 <silk_PLC+0x6d4>)
    } else {
        rand_Gain_Q15 = PLC_RAND_ATTENUATE_UV_Q15[ silk_min_int( NB_ATT - 1, psDec->lossCnt ) ];
 800e0b0:	4ab1      	ldrne	r2, [pc, #708]	; (800e378 <silk_PLC+0x6d8>)
    rand_scale_Q14 = psPLC->randScale_Q14;
 800e0b2:	f9b1 1038 	ldrsh.w	r1, [r1, #56]	; 0x38
        rand_Gain_Q15 = PLC_RAND_ATTENUATE_UV_Q15[ silk_min_int( NB_ATT - 1, psDec->lossCnt ) ];
 800e0b6:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 800e0ba:	f8d7 d07c 	ldr.w	sp, [r7, #124]	; 0x7c
    rand_scale_Q14 = psPLC->randScale_Q14;
 800e0be:	6579      	str	r1, [r7, #84]	; 0x54
    }

    /* LPC concealment. Apply BWE to previous LPC */
    silk_bwexpander( psPLC->prevLPC_Q12, psDec->LPC_order, SILK_FIX_CONST( BWE_COEF, 16 ) );
 800e0c0:	f64f 5271 	movw	r2, #64881	; 0xfd71
 800e0c4:	f8d8 1924 	ldr.w	r1, [r8, #2340]	; 0x924
 800e0c8:	4658      	mov	r0, fp
        rand_Gain_Q15 = PLC_RAND_ATTENUATE_UV_Q15[ silk_min_int( NB_ATT - 1, psDec->lossCnt ) ];
 800e0ca:	61fb      	str	r3, [r7, #28]
    silk_bwexpander( psPLC->prevLPC_Q12, psDec->LPC_order, SILK_FIX_CONST( BWE_COEF, 16 ) );
 800e0cc:	f000 fce6 	bl	800ea9c <silk_bwexpander>

    /* Preload LPC coeficients to array on stack. Gives small performance gain */
    silk_memcpy( A_Q12, psPLC->prevLPC_Q12, psDec->LPC_order * sizeof( opus_int16 ) );
 800e0d0:	f8d8 4924 	ldr.w	r4, [r8, #2340]	; 0x924
 800e0d4:	f107 00a0 	add.w	r0, r7, #160	; 0xa0
 800e0d8:	0062      	lsls	r2, r4, #1
 800e0da:	4659      	mov	r1, fp
 800e0dc:	f006 f800 	bl	80140e0 <memcpy>

    /* First Lost frame */
    if( psDec->lossCnt == 0 ) {
 800e0e0:	697b      	ldr	r3, [r7, #20]
 800e0e2:	681b      	ldr	r3, [r3, #0]
 800e0e4:	bb73      	cbnz	r3, 800e144 <silk_PLC+0x4a4>
        rand_scale_Q14 = 1 << 14;

        /* Reduce random noise Gain for voiced frames */
        if( psDec->prevSignalType == TYPE_VOICED ) {
 800e0e6:	f241 0344 	movw	r3, #4164	; 0x1044
 800e0ea:	f858 3003 	ldr.w	r3, [r8, r3]
 800e0ee:	2b02      	cmp	r3, #2
 800e0f0:	f040 82f5 	bne.w	800e6de <silk_PLC+0xa3e>
            for( i = 0; i < LTP_ORDER; i++ ) {
                rand_scale_Q14 -= B_Q14[ i ];
 800e0f4:	f241 0350 	movw	r3, #4176	; 0x1050
 800e0f8:	f241 0652 	movw	r6, #4178	; 0x1052
 800e0fc:	f241 0554 	movw	r5, #4180	; 0x1054
 800e100:	f241 0056 	movw	r0, #4182	; 0x1056
 800e104:	f241 0158 	movw	r1, #4184	; 0x1058
}
static OPUS_INLINE opus_int16 silk_max_16(opus_int16 a, opus_int16 b)
{
    return (((a) > (b)) ? (a) : (b));
 800e108:	f640 42cd 	movw	r2, #3277	; 0xccd
 800e10c:	f838 3003 	ldrh.w	r3, [r8, r3]
 800e110:	f838 6006 	ldrh.w	r6, [r8, r6]
 800e114:	f5c3 4380 	rsb	r3, r3, #16384	; 0x4000
 800e118:	f838 5005 	ldrh.w	r5, [r8, r5]
 800e11c:	1b9b      	subs	r3, r3, r6
 800e11e:	f838 0000 	ldrh.w	r0, [r8, r0]
 800e122:	1b5b      	subs	r3, r3, r5
 800e124:	f838 1001 	ldrh.w	r1, [r8, r1]
 800e128:	1a1b      	subs	r3, r3, r0
 800e12a:	1a5b      	subs	r3, r3, r1
 800e12c:	b21b      	sxth	r3, r3
 800e12e:	4293      	cmp	r3, r2
 800e130:	bfb8      	it	lt
 800e132:	4613      	movlt	r3, r2
            }
            rand_scale_Q14 = silk_max_16( 3277, rand_scale_Q14 ); /* 0.2 */
            rand_scale_Q14 = (opus_int16)silk_RSHIFT( silk_SMULBB( rand_scale_Q14, psPLC->prevLTP_scale_Q14 ), 14 );
 800e134:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800e136:	f8b2 2044 	ldrh.w	r2, [r2, #68]	; 0x44
 800e13a:	fb12 f303 	smulbb	r3, r2, r3
 800e13e:	f343 338f 	sbfx	r3, r3, #14, #16
 800e142:	657b      	str	r3, [r7, #84]	; 0x54

            rand_Gain_Q15 = silk_RSHIFT( silk_SMULWB( down_scale_Q30, rand_Gain_Q15 ), 14 );
        }
    }

    rand_seed    = psPLC->rand_seed;
 800e144:	f241 034c 	movw	r3, #4172	; 0x104c
    lag          = silk_RSHIFT_ROUND( psPLC->pitchL_Q8, 8 );
 800e148:	f858 3003 	ldr.w	r3, [r8, r3]
    sLTP_buf_idx = psDec->ltp_mem_length;
 800e14c:	f8d8 2920 	ldr.w	r2, [r8, #2336]	; 0x920
    lag          = silk_RSHIFT_ROUND( psPLC->pitchL_Q8, 8 );
 800e150:	11db      	asrs	r3, r3, #7
 800e152:	3301      	adds	r3, #1
 800e154:	ea4f 0b63 	mov.w	fp, r3, asr #1

    /* Rewhiten LTP state */
    idx = psDec->ltp_mem_length - lag - psDec->LPC_order - LTP_ORDER / 2;
 800e158:	4613      	mov	r3, r2
 800e15a:	eba2 090b 	sub.w	r9, r2, fp
 800e15e:	eba9 0504 	sub.w	r5, r9, r4
    celt_assert( idx > 0 );
    silk_LPC_analysis_filter( &sLTP[ idx ], &psDec->outBuf[ idx ], A_Q12, psDec->ltp_mem_length - idx, psDec->LPC_order, arch );
 800e162:	f8d7 6080 	ldr.w	r6, [r7, #128]	; 0x80
    idx = psDec->ltp_mem_length - lag - psDec->LPC_order - LTP_ORDER / 2;
 800e166:	f1a5 0a02 	sub.w	sl, r5, #2
 800e16a:	ea4f 004a 	mov.w	r0, sl, lsl #1
    silk_LPC_analysis_filter( &sLTP[ idx ], &psDec->outBuf[ idx ], A_Q12, psDec->ltp_mem_length - idx, psDec->LPC_order, arch );
 800e16e:	f200 5144 	addw	r1, r0, #1348	; 0x544
 800e172:	f8d7 50e8 	ldr.w	r5, [r7, #232]	; 0xe8
 800e176:	4430      	add	r0, r6
    rand_seed    = psPLC->rand_seed;
 800e178:	6dbe      	ldr	r6, [r7, #88]	; 0x58
    sLTP_buf_idx = psDec->ltp_mem_length;
 800e17a:	673a      	str	r2, [r7, #112]	; 0x70
    silk_LPC_analysis_filter( &sLTP[ idx ], &psDec->outBuf[ idx ], A_Q12, psDec->ltp_mem_length - idx, psDec->LPC_order, arch );
 800e17c:	eba3 030a 	sub.w	r3, r3, sl
    rand_seed    = psPLC->rand_seed;
 800e180:	6b76      	ldr	r6, [r6, #52]	; 0x34
    silk_LPC_analysis_filter( &sLTP[ idx ], &psDec->outBuf[ idx ], A_Q12, psDec->ltp_mem_length - idx, psDec->LPC_order, arch );
 800e182:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 800e186:	4441      	add	r1, r8
 800e188:	e9cd 4500 	strd	r4, r5, [sp]
 800e18c:	f7fe fc44 	bl	800ca18 <silk_LPC_analysis_filter>
    /* Scale LTP state */
    inv_gain_Q30 = silk_INVERSE32_varQ( psPLC->prevGain_Q16[ 1 ], 46 );
 800e190:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e192:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800e194:	2b00      	cmp	r3, #0
 800e196:	f000 829b 	beq.w	800e6d0 <silk_PLC+0xa30>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
 800e19a:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 800e19e:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 800e1a2:	fab2 f282 	clz	r2, r2
 800e1a6:	3a01      	subs	r2, #1
 800e1a8:	f1c2 010f 	rsb	r1, r2, #15
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
 800e1ac:	f06f 4060 	mvn.w	r0, #3758096384	; 0xe0000000
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                */
 800e1b0:	4093      	lsls	r3, r2
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
 800e1b2:	141a      	asrs	r2, r3, #16
 800e1b4:	fb90 f0f2 	sdiv	r0, r0, r2
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800e1b8:	0404      	lsls	r4, r0, #16
  __asm__(
 800e1ba:	fb83 c204 	smull	ip, r2, r3, r4
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
 800e1be:	f1c2 5300 	rsb	r3, r2, #536870912	; 0x20000000
 800e1c2:	00db      	lsls	r3, r3, #3
  __asm__(
 800e1c4:	fb83 2400 	smull	r2, r4, r3, r0
  return a+SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800e1c8:	0423      	lsls	r3, r4, #16
 800e1ca:	eb03 4300 	add.w	r3, r3, r0, lsl #16
    if( lshift <= 0 ) {
 800e1ce:	2900      	cmp	r1, #0
 800e1d0:	eb03 4312 	add.w	r3, r3, r2, lsr #16
 800e1d4:	f340 8317 	ble.w	800e806 <silk_PLC+0xb66>
            return silk_RSHIFT(result, lshift);
 800e1d8:	fa43 f201 	asr.w	r2, r3, r1
    inv_gain_Q30 = silk_min( inv_gain_Q30, silk_int32_MAX >> 1 );
 800e1dc:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
    for( i = idx + psDec->LPC_order; i < psDec->ltp_mem_length; i++ ) {
 800e1e0:	f8d8 0924 	ldr.w	r0, [r8, #2340]	; 0x924
 800e1e4:	f8d8 1920 	ldr.w	r1, [r8, #2336]	; 0x920
    inv_gain_Q30 = silk_min( inv_gain_Q30, silk_int32_MAX >> 1 );
 800e1e8:	429a      	cmp	r2, r3
    for( i = idx + psDec->LPC_order; i < psDec->ltp_mem_length; i++ ) {
 800e1ea:	eb0a 0500 	add.w	r5, sl, r0
    inv_gain_Q30 = silk_min( inv_gain_Q30, silk_int32_MAX >> 1 );
 800e1ee:	bfa8      	it	ge
 800e1f0:	461a      	movge	r2, r3
    for( i = idx + psDec->LPC_order; i < psDec->ltp_mem_length; i++ ) {
 800e1f2:	428d      	cmp	r5, r1
 800e1f4:	60b8      	str	r0, [r7, #8]
 800e1f6:	6139      	str	r1, [r7, #16]
 800e1f8:	460b      	mov	r3, r1
 800e1fa:	da14      	bge.n	800e226 <silk_PLC+0x586>
 800e1fc:	469c      	mov	ip, r3
 800e1fe:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 800e202:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800e204:	eb01 0145 	add.w	r1, r1, r5, lsl #1
 800e208:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 800e20c:	3902      	subs	r1, #2
 800e20e:	3804      	subs	r0, #4
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800e210:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
 800e214:	3501      	adds	r5, #1
 800e216:	4565      	cmp	r5, ip
 800e218:	ea4f 4303 	mov.w	r3, r3, lsl #16
  __asm__(
 800e21c:	fb82 e403 	smull	lr, r4, r2, r3
        sLTP_Q14[ i ] = silk_SMULWB( inv_gain_Q30, sLTP[ i ] );
 800e220:	f840 4f04 	str.w	r4, [r0, #4]!
    for( i = idx + psDec->LPC_order; i < psDec->ltp_mem_length; i++ ) {
 800e224:	d1f4      	bne.n	800e210 <silk_PLC+0x570>
    }

    /***************************/
    /* LTP synthesis filtering */
    /***************************/
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800e226:	f8d8 3914 	ldr.w	r3, [r8, #2324]	; 0x914
 800e22a:	2b00      	cmp	r3, #0
 800e22c:	63bb      	str	r3, [r7, #56]	; 0x38
 800e22e:	f340 80ff 	ble.w	800e430 <silk_PLC+0x790>
 800e232:	f241 0c50 	movw	ip, #4176	; 0x1050
 800e236:	f241 0552 	movw	r5, #4178	; 0x1052
 800e23a:	f241 0454 	movw	r4, #4180	; 0x1054
 800e23e:	f241 0056 	movw	r0, #4182	; 0x1056
 800e242:	f241 0158 	movw	r1, #4184	; 0x1058
 800e246:	f241 0e4c 	movw	lr, #4172	; 0x104c
 800e24a:	f938 200c 	ldrsh.w	r2, [r8, ip]
 800e24e:	2300      	movs	r3, #0
 800e250:	66fa      	str	r2, [r7, #108]	; 0x6c
 800e252:	f938 2005 	ldrsh.w	r2, [r8, r5]
 800e256:	64fb      	str	r3, [r7, #76]	; 0x4c
 800e258:	66ba      	str	r2, [r7, #104]	; 0x68
 800e25a:	f938 2004 	ldrsh.w	r2, [r8, r4]
 800e25e:	f9b8 390c 	ldrsh.w	r3, [r8, #2316]	; 0x90c
 800e262:	667a      	str	r2, [r7, #100]	; 0x64
 800e264:	f938 2000 	ldrsh.w	r2, [r8, r0]
 800e268:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800e26c:	663a      	str	r2, [r7, #96]	; 0x60
 800e26e:	f938 2001 	ldrsh.w	r2, [r8, r1]
 800e272:	46b2      	mov	sl, r6
 800e274:	65fa      	str	r2, [r7, #92]	; 0x5c
 800e276:	f858 200e 	ldr.w	r2, [r8, lr]
        /* Set up pointer */
        pred_lag_ptr = &sLTP_Q14[ sLTP_buf_idx - lag + LTP_ORDER / 2 ];
        for( i = 0; i < psDec->subfr_length; i++ ) {
 800e27a:	f8d8 591c 	ldr.w	r5, [r8, #2332]	; 0x91c
 800e27e:	653a      	str	r2, [r7, #80]	; 0x50
 800e280:	f508 5282 	add.w	r2, r8, #4160	; 0x1040
 800e284:	4611      	mov	r1, r2
 800e286:	f998 2acd 	ldrsb.w	r2, [r8, #2765]	; 0xacd
 800e28a:	f8c7 8004 	str.w	r8, [r7, #4]
 800e28e:	637a      	str	r2, [r7, #52]	; 0x34
 800e290:	025a      	lsls	r2, r3, #9
 800e292:	460b      	mov	r3, r1
 800e294:	633a      	str	r2, [r7, #48]	; 0x30
 800e296:	460a      	mov	r2, r1
 800e298:	3318      	adds	r3, #24
 800e29a:	647b      	str	r3, [r7, #68]	; 0x44
 800e29c:	464b      	mov	r3, r9
 800e29e:	3210      	adds	r2, #16
 800e2a0:	64ba      	str	r2, [r7, #72]	; 0x48
 800e2a2:	f101 0212 	add.w	r2, r1, #18
 800e2a6:	62fa      	str	r2, [r7, #44]	; 0x2c
 800e2a8:	f101 0214 	add.w	r2, r1, #20
 800e2ac:	62ba      	str	r2, [r7, #40]	; 0x28
 800e2ae:	f101 0216 	add.w	r2, r1, #22
 800e2b2:	627a      	str	r2, [r7, #36]	; 0x24
        pred_lag_ptr = &sLTP_Q14[ sLTP_buf_idx - lag + LTP_ORDER / 2 ];
 800e2b4:	3302      	adds	r3, #2
        for( i = 0; i < psDec->subfr_length; i++ ) {
 800e2b6:	2d00      	cmp	r5, #0
 800e2b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800e2bc:	dd62      	ble.n	800e384 <silk_PLC+0x6e4>
 800e2be:	2200      	movs	r2, #0
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800e2c0:	4656      	mov	r6, sl
 800e2c2:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800e2c4:	6f3c      	ldr	r4, [r7, #112]	; 0x70
 800e2c6:	3b04      	subs	r3, #4
 800e2c8:	eb01 0084 	add.w	r0, r1, r4, lsl #2
 800e2cc:	440b      	add	r3, r1
 800e2ce:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 800e2d0:	3804      	subs	r0, #4
 800e2d2:	0409      	lsls	r1, r1, #16
 800e2d4:	f8c7 1080 	str.w	r1, [r7, #128]	; 0x80
 800e2d8:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 800e2da:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84
 800e2de:	0409      	lsls	r1, r1, #16
 800e2e0:	67f9      	str	r1, [r7, #124]	; 0x7c
 800e2e2:	6e79      	ldr	r1, [r7, #100]	; 0x64
 800e2e4:	ea4f 4801 	mov.w	r8, r1, lsl #16
 800e2e8:	6e39      	ldr	r1, [r7, #96]	; 0x60
 800e2ea:	ea4f 4e01 	mov.w	lr, r1, lsl #16
 800e2ee:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800e2f0:	ea4f 4c01 	mov.w	ip, r1, lsl #16
 800e2f4:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800e2f6:	040c      	lsls	r4, r1, #16
 800e2f8:	67bc      	str	r4, [r7, #120]	; 0x78
            LTP_pred_Q12 = silk_SMLAWB( LTP_pred_Q12, pred_lag_ptr[ -3 ], B_Q14[ 3 ] );
            LTP_pred_Q12 = silk_SMLAWB( LTP_pred_Q12, pred_lag_ptr[ -4 ], B_Q14[ 4 ] );
            pred_lag_ptr++;

            /* Generate LPC excitation */
            rand_seed = silk_RAND( rand_seed );
 800e2fa:	4820      	ldr	r0, [pc, #128]	; (800e37c <silk_PLC+0x6dc>)
 800e2fc:	4c20      	ldr	r4, [pc, #128]	; (800e380 <silk_PLC+0x6e0>)
  __asm__(
 800e2fe:	f853 1f04 	ldr.w	r1, [r3, #4]!
 800e302:	fb00 4606 	mla	r6, r0, r6, r4
 800e306:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
 800e30a:	fb81 a900 	smull	sl, r9, r1, r0
            LTP_pred_Q12 = silk_SMLAWB( LTP_pred_Q12, pred_lag_ptr[  0 ], B_Q14[ 0 ] );
 800e30e:	f109 0a02 	add.w	sl, r9, #2
 800e312:	f853 1c04 	ldr.w	r1, [r3, #-4]
 800e316:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 800e318:	fb81 b900 	smull	fp, r9, r1, r0
            LTP_pred_Q12 = silk_SMLAWB( LTP_pred_Q12, pred_lag_ptr[ -1 ], B_Q14[ 1 ] );
 800e31c:	44d1      	add	r9, sl
 800e31e:	f853 1c08 	ldr.w	r1, [r3, #-8]
 800e322:	fb81 ba08 	smull	fp, sl, r1, r8
            LTP_pred_Q12 = silk_SMLAWB( LTP_pred_Q12, pred_lag_ptr[ -2 ], B_Q14[ 2 ] );
 800e326:	44d1      	add	r9, sl
 800e328:	f853 1c0c 	ldr.w	r1, [r3, #-12]
 800e32c:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800e32e:	fb81 ba0e 	smull	fp, sl, r1, lr
            LTP_pred_Q12 = silk_SMLAWB( LTP_pred_Q12, pred_lag_ptr[ -3 ], B_Q14[ 3 ] );
 800e332:	44ca      	add	sl, r9
 800e334:	f853 1c10 	ldr.w	r1, [r3, #-16]
 800e338:	fb81 b90c 	smull	fp, r9, r1, ip
            LTP_pred_Q12 = silk_SMLAWB( LTP_pred_Q12, pred_lag_ptr[ -4 ], B_Q14[ 4 ] );
 800e33c:	eb0a 0109 	add.w	r1, sl, r9
            idx = silk_RSHIFT( rand_seed, 25 ) & RAND_BUF_MASK;
 800e340:	ea4f 6956 	mov.w	r9, r6, lsr #25
 800e344:	f850 9029 	ldr.w	r9, [r0, r9, lsl #2]
 800e348:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 800e34a:	fb89 ba00 	smull	fp, sl, r9, r0
            sLTP_Q14[ sLTP_buf_idx ] = silk_LSHIFT32( silk_SMLAWB( LTP_pred_Q12, rand_ptr[ idx ], rand_scale_Q14 ), 2 );
 800e34e:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 800e352:	4451      	add	r1, sl
        for( i = 0; i < psDec->subfr_length; i++ ) {
 800e354:	3201      	adds	r2, #1
            sLTP_Q14[ sLTP_buf_idx ] = silk_LSHIFT32( silk_SMLAWB( LTP_pred_Q12, rand_ptr[ idx ], rand_scale_Q14 ), 2 );
 800e356:	0089      	lsls	r1, r1, #2
 800e358:	f840 1f04 	str.w	r1, [r0, #4]!
        for( i = 0; i < psDec->subfr_length; i++ ) {
 800e35c:	42aa      	cmp	r2, r5
            sLTP_Q14[ sLTP_buf_idx ] = silk_LSHIFT32( silk_SMLAWB( LTP_pred_Q12, rand_ptr[ idx ], rand_scale_Q14 ), 2 );
 800e35e:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84
        for( i = 0; i < psDec->subfr_length; i++ ) {
 800e362:	d1ca      	bne.n	800e2fa <silk_PLC+0x65a>
 800e364:	46b2      	mov	sl, r6
 800e366:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e368:	442b      	add	r3, r5
 800e36a:	673b      	str	r3, [r7, #112]	; 0x70
 800e36c:	e00a      	b.n	800e384 <silk_PLC+0x6e4>
 800e36e:	bf00      	nop
 800e370:	08016880 	.word	0x08016880
 800e374:	08016888 	.word	0x08016888
 800e378:	08016884 	.word	0x08016884
 800e37c:	0bb38435 	.word	0x0bb38435
 800e380:	3619636b 	.word	0x3619636b
            sLTP_buf_idx++;
        }

        /* Gradually reduce LTP gain */
        for( j = 0; j < LTP_ORDER; j++ ) {
            B_Q14[ j ] = silk_RSHIFT( silk_SMULBB( harm_Gain_Q15, B_Q14[ j ] ), 15 );
 800e384:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e386:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
 800e388:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800e38a:	fb03 f606 	mul.w	r6, r3, r6
 800e38e:	fb03 f000 	mul.w	r0, r3, r0
 800e392:	6ebc      	ldr	r4, [r7, #104]	; 0x68
 800e394:	6e79      	ldr	r1, [r7, #100]	; 0x64
 800e396:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800e398:	fb03 f404 	mul.w	r4, r3, r4
 800e39c:	fb03 f101 	mul.w	r1, r3, r1
 800e3a0:	fb03 f202 	mul.w	r2, r3, r2
 800e3a4:	f346 33cf 	sbfx	r3, r6, #15, #16
 800e3a8:	6cbe      	ldr	r6, [r7, #72]	; 0x48
 800e3aa:	f340 30cf 	sbfx	r0, r0, #15, #16
 800e3ae:	8030      	strh	r0, [r6, #0]
 800e3b0:	66f8      	str	r0, [r7, #108]	; 0x6c
 800e3b2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800e3b4:	f344 34cf 	sbfx	r4, r4, #15, #16
 800e3b8:	8004      	strh	r4, [r0, #0]
 800e3ba:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800e3bc:	f341 31cf 	sbfx	r1, r1, #15, #16
 800e3c0:	8001      	strh	r1, [r0, #0]
 800e3c2:	6679      	str	r1, [r7, #100]	; 0x64
 800e3c4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800e3c6:	f342 32cf 	sbfx	r2, r2, #15, #16
 800e3ca:	800a      	strh	r2, [r1, #0]
 800e3cc:	663a      	str	r2, [r7, #96]	; 0x60
 800e3ce:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800e3d0:	65fb      	str	r3, [r7, #92]	; 0x5c
 800e3d2:	8013      	strh	r3, [r2, #0]
        }
        if ( psDec->indices.signalType != TYPE_NO_VOICE_ACTIVITY ) {
 800e3d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
            B_Q14[ j ] = silk_RSHIFT( silk_SMULBB( harm_Gain_Q15, B_Q14[ j ] ), 15 );
 800e3d6:	66bc      	str	r4, [r7, #104]	; 0x68
        if ( psDec->indices.signalType != TYPE_NO_VOICE_ACTIVITY ) {
 800e3d8:	b133      	cbz	r3, 800e3e8 <silk_PLC+0x748>
            /* Gradually reduce excitation gain */
            rand_scale_Q14 = silk_RSHIFT( silk_SMULBB( rand_scale_Q14, rand_Gain_Q15 ), 15 );
 800e3da:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800e3dc:	69fb      	ldr	r3, [r7, #28]
 800e3de:	fb13 f302 	smulbb	r3, r3, r2
 800e3e2:	f343 33cf 	sbfx	r3, r3, #15, #16
 800e3e6:	657b      	str	r3, [r7, #84]	; 0x54
 800e3e8:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800e3ea:	480d      	ldr	r0, [pc, #52]	; (800e420 <silk_PLC+0x780>)
 800e3ec:	fb81 2300 	smull	r2, r3, r1, r0
        }

        /* Slowly increase pitch lag */
        psPLC->pitchL_Q8 = silk_SMLAWB( psPLC->pitchL_Q8, psPLC->pitchL_Q8, PITCH_DRIFT_FAC_Q16 );
 800e3f0:	440b      	add	r3, r1
    return (((a) < (b)) ? (a) : (b));
 800e3f2:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800e3f4:	461a      	mov	r2, r3
 800e3f6:	428b      	cmp	r3, r1
 800e3f8:	bfa8      	it	ge
 800e3fa:	460a      	movge	r2, r1
        psPLC->pitchL_Q8 = silk_min_32( psPLC->pitchL_Q8, silk_LSHIFT( silk_SMULBB( MAX_PITCH_LAG_MS, psDec->fs_kHz ), 8 ) );
 800e3fc:	6db8      	ldr	r0, [r7, #88]	; 0x58
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800e3fe:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
        lag = silk_RSHIFT_ROUND( psPLC->pitchL_Q8, 8 );
 800e400:	11d3      	asrs	r3, r2, #7
 800e402:	653a      	str	r2, [r7, #80]	; 0x50
        psPLC->pitchL_Q8 = silk_min_32( psPLC->pitchL_Q8, silk_LSHIFT( silk_SMULBB( MAX_PITCH_LAG_MS, psDec->fs_kHz ), 8 ) );
 800e404:	6002      	str	r2, [r0, #0]
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800e406:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e408:	3101      	adds	r1, #1
        lag = silk_RSHIFT_ROUND( psPLC->pitchL_Q8, 8 );
 800e40a:	3301      	adds	r3, #1
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800e40c:	4291      	cmp	r1, r2
 800e40e:	64f9      	str	r1, [r7, #76]	; 0x4c
        lag = silk_RSHIFT_ROUND( psPLC->pitchL_Q8, 8 );
 800e410:	ea4f 0363 	mov.w	r3, r3, asr #1
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800e414:	d008      	beq.n	800e428 <silk_PLC+0x788>
 800e416:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 800e418:	1ad3      	subs	r3, r2, r3
 800e41a:	e74b      	b.n	800e2b4 <silk_PLC+0x614>
            exc_buf_ptr[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT(
 800e41c:	4b01      	ldr	r3, [pc, #4]	; (800e424 <silk_PLC+0x784>)
 800e41e:	e5e5      	b.n	800dfec <silk_PLC+0x34c>
 800e420:	028f0000 	.word	0x028f0000
 800e424:	ffff8000 	.word	0xffff8000
 800e428:	469b      	mov	fp, r3
 800e42a:	4656      	mov	r6, sl
 800e42c:	f8d7 8004 	ldr.w	r8, [r7, #4]
    }

    /***************************/
    /* LPC synthesis filtering */
    /***************************/
    sLPC_Q14_ptr = &sLTP_Q14[ psDec->ltp_mem_length - MAX_LPC_ORDER ];
 800e430:	693b      	ldr	r3, [r7, #16]
 800e432:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e434:	3b10      	subs	r3, #16
 800e436:	eb02 0383 	add.w	r3, r2, r3, lsl #2

    /* Copy LPC state */
    silk_memcpy( sLPC_Q14_ptr, psDec->sLPC_Q14_buf, MAX_LPC_ORDER * sizeof( opus_int32 ) );
 800e43a:	469e      	mov	lr, r3
 800e43c:	f208 5404 	addw	r4, r8, #1284	; 0x504
    sLPC_Q14_ptr = &sLTP_Q14[ psDec->ltp_mem_length - MAX_LPC_ORDER ];
 800e440:	647b      	str	r3, [r7, #68]	; 0x44
    silk_memcpy( sLPC_Q14_ptr, psDec->sLPC_Q14_buf, MAX_LPC_ORDER * sizeof( opus_int32 ) );
 800e442:	63fc      	str	r4, [r7, #60]	; 0x3c
 800e444:	f208 5c44 	addw	ip, r8, #1348	; 0x544
 800e448:	4675      	mov	r5, lr
 800e44a:	6820      	ldr	r0, [r4, #0]
 800e44c:	6861      	ldr	r1, [r4, #4]
 800e44e:	68a2      	ldr	r2, [r4, #8]
 800e450:	68e3      	ldr	r3, [r4, #12]
 800e452:	3410      	adds	r4, #16
 800e454:	4564      	cmp	r4, ip
 800e456:	f10e 0e10 	add.w	lr, lr, #16
 800e45a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800e45c:	d1f4      	bne.n	800e448 <silk_PLC+0x7a8>

    celt_assert( psDec->LPC_order >= 10 ); /* check that unrolling works */
    for( i = 0; i < psDec->frame_length; i++ ) {
 800e45e:	f8d8 a918 	ldr.w	sl, [r8, #2328]	; 0x918
 800e462:	f1ba 0f00 	cmp.w	sl, #0
 800e466:	f340 8274 	ble.w	800e952 <silk_PLC+0xcb2>
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800e46a:	f9b7 30a8 	ldrsh.w	r3, [r7, #168]	; 0xa8
 800e46e:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800e472:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800e476:	f9b7 30b2 	ldrsh.w	r3, [r7, #178]	; 0xb2
 800e47a:	f8c7 a040 	str.w	sl, [r7, #64]	; 0x40
 800e47e:	673b      	str	r3, [r7, #112]	; 0x70
 800e480:	f9b7 30b4 	ldrsh.w	r3, [r7, #180]	; 0xb4
 800e484:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800e486:	66bb      	str	r3, [r7, #104]	; 0x68
 800e488:	f9b7 30b6 	ldrsh.w	r3, [r7, #182]	; 0xb6
 800e48c:	f9b7 50aa 	ldrsh.w	r5, [r7, #170]	; 0xaa
 800e490:	663b      	str	r3, [r7, #96]	; 0x60
 800e492:	f9b7 30b8 	ldrsh.w	r3, [r7, #184]	; 0xb8
 800e496:	f9b7 40ac 	ldrsh.w	r4, [r7, #172]	; 0xac
 800e49a:	65fb      	str	r3, [r7, #92]	; 0x5c
 800e49c:	f9b7 30ba 	ldrsh.w	r3, [r7, #186]	; 0xba
 800e4a0:	63ba      	str	r2, [r7, #56]	; 0x38
 800e4a2:	653b      	str	r3, [r7, #80]	; 0x50
 800e4a4:	f9b7 30bc 	ldrsh.w	r3, [r7, #188]	; 0xbc
 800e4a8:	f9b7 10b0 	ldrsh.w	r1, [r7, #176]	; 0xb0
 800e4ac:	64fb      	str	r3, [r7, #76]	; 0x4c
 800e4ae:	f9b7 30be 	ldrsh.w	r3, [r7, #190]	; 0xbe
 800e4b2:	f9b7 90a0 	ldrsh.w	r9, [r7, #160]	; 0xa0
 800e4b6:	64bb      	str	r3, [r7, #72]	; 0x48
 800e4b8:	69bb      	ldr	r3, [r7, #24]
 800e4ba:	f9b7 80a2 	ldrsh.w	r8, [r7, #162]	; 0xa2
 800e4be:	f1a3 0a02 	sub.w	sl, r3, #2
 800e4c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e4c4:	f9b7 e0a4 	ldrsh.w	lr, [r7, #164]	; 0xa4
 800e4c8:	18d3      	adds	r3, r2, r3
 800e4ca:	66fb      	str	r3, [r7, #108]	; 0x6c
 800e4cc:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800e4d0:	f9b7 c0a6 	ldrsh.w	ip, [r7, #166]	; 0xa6
 800e4d4:	041a      	lsls	r2, r3, #16
 800e4d6:	f8c7 2080 	str.w	r2, [r7, #128]	; 0x80
 800e4da:	042a      	lsls	r2, r5, #16
 800e4dc:	f9b7 00ae 	ldrsh.w	r0, [r7, #174]	; 0xae
 800e4e0:	67fa      	str	r2, [r7, #124]	; 0x7c
 800e4e2:	0422      	lsls	r2, r4, #16
 800e4e4:	67ba      	str	r2, [r7, #120]	; 0x78
 800e4e6:	040a      	lsls	r2, r1, #16
 800e4e8:	677a      	str	r2, [r7, #116]	; 0x74
 800e4ea:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 800e4ec:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e4ee:	0412      	lsls	r2, r2, #16
 800e4f0:	673a      	str	r2, [r7, #112]	; 0x70
 800e4f2:	041a      	lsls	r2, r3, #16
 800e4f4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e4f6:	667a      	str	r2, [r7, #100]	; 0x64
 800e4f8:	041a      	lsls	r2, r3, #16
 800e4fa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800e4fc:	663a      	str	r2, [r7, #96]	; 0x60
 800e4fe:	041a      	lsls	r2, r3, #16
 800e500:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e502:	65fa      	str	r2, [r7, #92]	; 0x5c
 800e504:	041a      	lsls	r2, r3, #16
 800e506:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e508:	653a      	str	r2, [r7, #80]	; 0x50
 800e50a:	041a      	lsls	r2, r3, #16
 800e50c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
        /* partly unrolled */
        /* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
        LPC_pred_Q10 = silk_RSHIFT( psDec->LPC_order, 1 );
 800e50e:	68bc      	ldr	r4, [r7, #8]
 800e510:	041b      	lsls	r3, r3, #16
 800e512:	0400      	lsls	r0, r0, #16
 800e514:	64bb      	str	r3, [r7, #72]	; 0x48
 800e516:	68f9      	ldr	r1, [r7, #12]
 800e518:	1063      	asrs	r3, r4, #1
 800e51a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800e51e:	ea4f 4909 	mov.w	r9, r9, lsl #16
 800e522:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e524:	ea4f 4808 	mov.w	r8, r8, lsl #16
 800e528:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 800e52c:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 800e530:	64fa      	str	r2, [r7, #76]	; 0x4c
 800e532:	f8c7 b034 	str.w	fp, [r7, #52]	; 0x34
 800e536:	66b8      	str	r0, [r7, #104]	; 0x68
 800e538:	63be      	str	r6, [r7, #56]	; 0x38
  __asm__(
 800e53a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800e53c:	fb82 6509 	smull	r6, r5, r2, r9
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  1 ], A_Q12[ 0 ] );
 800e540:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  6 ], A_Q12[ 5 ] );
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  7 ], A_Q12[ 6 ] );
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  8 ], A_Q12[ 7 ] );
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  9 ], A_Q12[ 8 ] );
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i - 10 ], A_Q12[ 9 ] );
        for( j = 10; j < psDec->LPC_order; j++ ) {
 800e544:	2c0a      	cmp	r4, #10
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  1 ], A_Q12[ 0 ] );
 800e546:	4415      	add	r5, r2
 800e548:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800e54a:	fb82 b608 	smull	fp, r6, r2, r8
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  2 ], A_Q12[ 1 ] );
 800e54e:	4435      	add	r5, r6
 800e550:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800e552:	fb82 b60e 	smull	fp, r6, r2, lr
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  3 ], A_Q12[ 2 ] );
 800e556:	442e      	add	r6, r5
 800e558:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800e55a:	fb82 b50c 	smull	fp, r5, r2, ip
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  4 ], A_Q12[ 3 ] );
 800e55e:	442e      	add	r6, r5
 800e560:	f8d7 5080 	ldr.w	r5, [r7, #128]	; 0x80
 800e564:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800e566:	4628      	mov	r0, r5
 800e568:	fb82 b500 	smull	fp, r5, r2, r0
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  5 ], A_Q12[ 4 ] );
 800e56c:	4435      	add	r5, r6
 800e56e:	6ffe      	ldr	r6, [r7, #124]	; 0x7c
 800e570:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e572:	4630      	mov	r0, r6
 800e574:	fb82 b600 	smull	fp, r6, r2, r0
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  6 ], A_Q12[ 5 ] );
 800e578:	4435      	add	r5, r6
 800e57a:	6fbe      	ldr	r6, [r7, #120]	; 0x78
 800e57c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800e57e:	4630      	mov	r0, r6
 800e580:	fb82 b600 	smull	fp, r6, r2, r0
 800e584:	6eba      	ldr	r2, [r7, #104]	; 0x68
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  7 ], A_Q12[ 6 ] );
 800e586:	442e      	add	r6, r5
 800e588:	4610      	mov	r0, r2
 800e58a:	6a1d      	ldr	r5, [r3, #32]
 800e58c:	fb85 b200 	smull	fp, r2, r5, r0
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  8 ], A_Q12[ 7 ] );
 800e590:	4416      	add	r6, r2
 800e592:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800e594:	69dd      	ldr	r5, [r3, #28]
 800e596:	4610      	mov	r0, r2
 800e598:	fb85 b200 	smull	fp, r2, r5, r0
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i -  9 ], A_Q12[ 8 ] );
 800e59c:	4432      	add	r2, r6
 800e59e:	6f3e      	ldr	r6, [r7, #112]	; 0x70
 800e5a0:	699d      	ldr	r5, [r3, #24]
 800e5a2:	4630      	mov	r0, r6
 800e5a4:	fb85 b600 	smull	fp, r6, r5, r0
        LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i - 10 ], A_Q12[ 9 ] );
 800e5a8:	4432      	add	r2, r6
        for( j = 10; j < psDec->LPC_order; j++ ) {
 800e5aa:	dd2d      	ble.n	800e608 <silk_PLC+0x968>
 800e5ac:	6e7e      	ldr	r6, [r7, #100]	; 0x64
 800e5ae:	2c0b      	cmp	r4, #11
 800e5b0:	695d      	ldr	r5, [r3, #20]
 800e5b2:	4630      	mov	r0, r6
 800e5b4:	fb85 b600 	smull	fp, r6, r5, r0
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i - j - 1 ], A_Q12[ j ] );
 800e5b8:	4432      	add	r2, r6
        for( j = 10; j < psDec->LPC_order; j++ ) {
 800e5ba:	d025      	beq.n	800e608 <silk_PLC+0x968>
 800e5bc:	6e3e      	ldr	r6, [r7, #96]	; 0x60
 800e5be:	2c0c      	cmp	r4, #12
 800e5c0:	691d      	ldr	r5, [r3, #16]
 800e5c2:	4630      	mov	r0, r6
 800e5c4:	fb85 b600 	smull	fp, r6, r5, r0
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i - j - 1 ], A_Q12[ j ] );
 800e5c8:	4432      	add	r2, r6
        for( j = 10; j < psDec->LPC_order; j++ ) {
 800e5ca:	d01d      	beq.n	800e608 <silk_PLC+0x968>
 800e5cc:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
 800e5ce:	2c0d      	cmp	r4, #13
 800e5d0:	68dd      	ldr	r5, [r3, #12]
 800e5d2:	4630      	mov	r0, r6
 800e5d4:	fb85 b600 	smull	fp, r6, r5, r0
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i - j - 1 ], A_Q12[ j ] );
 800e5d8:	4432      	add	r2, r6
        for( j = 10; j < psDec->LPC_order; j++ ) {
 800e5da:	d015      	beq.n	800e608 <silk_PLC+0x968>
 800e5dc:	6d3e      	ldr	r6, [r7, #80]	; 0x50
 800e5de:	2c0e      	cmp	r4, #14
 800e5e0:	689d      	ldr	r5, [r3, #8]
 800e5e2:	4630      	mov	r0, r6
 800e5e4:	fb85 b600 	smull	fp, r6, r5, r0
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i - j - 1 ], A_Q12[ j ] );
 800e5e8:	4432      	add	r2, r6
        for( j = 10; j < psDec->LPC_order; j++ ) {
 800e5ea:	d00d      	beq.n	800e608 <silk_PLC+0x968>
 800e5ec:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
 800e5ee:	2c0f      	cmp	r4, #15
 800e5f0:	685d      	ldr	r5, [r3, #4]
 800e5f2:	4630      	mov	r0, r6
 800e5f4:	fb85 b600 	smull	fp, r6, r5, r0
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i - j - 1 ], A_Q12[ j ] );
 800e5f8:	4432      	add	r2, r6
        for( j = 10; j < psDec->LPC_order; j++ ) {
 800e5fa:	d005      	beq.n	800e608 <silk_PLC+0x968>
 800e5fc:	6cbe      	ldr	r6, [r7, #72]	; 0x48
 800e5fe:	681d      	ldr	r5, [r3, #0]
 800e600:	4630      	mov	r0, r6
 800e602:	fb85 b600 	smull	fp, r6, r5, r0
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14_ptr[ MAX_LPC_ORDER + i - j - 1 ], A_Q12[ j ] );
 800e606:	4432      	add	r2, r6
        }

        /* Add prediction to LPC excitation */
        sLPC_Q14_ptr[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( sLPC_Q14_ptr[ MAX_LPC_ORDER + i ],
 800e608:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 800e60c:	6c1d      	ldr	r5, [r3, #64]	; 0x40
 800e60e:	f280 80e5 	bge.w	800e7dc <silk_PLC+0xb3c>
 800e612:	f1b2 4f78 	cmp.w	r2, #4160749568	; 0xf8000000
 800e616:	f2c0 80ef 	blt.w	800e7f8 <silk_PLC+0xb58>
 800e61a:	0112      	lsls	r2, r2, #4
 800e61c:	42d5      	cmn	r5, r2
 800e61e:	f100 80e4 	bmi.w	800e7ea <silk_PLC+0xb4a>
 800e622:	4215      	tst	r5, r2
 800e624:	d458      	bmi.n	800e6d8 <silk_PLC+0xa38>
 800e626:	442a      	add	r2, r5
  __asm__(
 800e628:	fb82 5601 	smull	r5, r6, r2, r1
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800e62c:	0c2d      	lsrs	r5, r5, #16
 800e62e:	eb05 4506 	add.w	r5, r5, r6, lsl #16
                                            silk_LSHIFT_SAT32( LPC_pred_Q10, 4 ));

        /* Scale with Gain */
        frame[ i ] = (opus_int16)silk_SAT16( silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( sLPC_Q14_ptr[ MAX_LPC_ORDER + i ], prevGain_Q10[ 1 ] ), 8 ) ) );
 800e632:	11ed      	asrs	r5, r5, #7
 800e634:	3501      	adds	r5, #1
 800e636:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
        sLPC_Q14_ptr[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( sLPC_Q14_ptr[ MAX_LPC_ORDER + i ],
 800e63a:	641a      	str	r2, [r3, #64]	; 0x40
        frame[ i ] = (opus_int16)silk_SAT16( silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( sLPC_Q14_ptr[ MAX_LPC_ORDER + i ], prevGain_Q10[ 1 ] ), 8 ) ) );
 800e63c:	f280 808f 	bge.w	800e75e <silk_PLC+0xabe>
  __asm__(
 800e640:	fb82 5601 	smull	r5, r6, r2, r1
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800e644:	0c2d      	lsrs	r5, r5, #16
 800e646:	eb05 4506 	add.w	r5, r5, r6, lsl #16
 800e64a:	11ed      	asrs	r5, r5, #7
 800e64c:	3501      	adds	r5, #1
 800e64e:	f515 3f80 	cmn.w	r5, #65536	; 0x10000
 800e652:	f2c0 8084 	blt.w	800e75e <silk_PLC+0xabe>
  __asm__(
 800e656:	fb82 5601 	smull	r5, r6, r2, r1
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800e65a:	0c2d      	lsrs	r5, r5, #16
 800e65c:	eb05 4506 	add.w	r5, r5, r6, lsl #16
 800e660:	11ed      	asrs	r5, r5, #7
 800e662:	3501      	adds	r5, #1
 800e664:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 800e668:	db79      	blt.n	800e75e <silk_PLC+0xabe>
 800e66a:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800e66e:	f82a 2f02 	strh.w	r2, [sl, #2]!
    for( i = 0; i < psDec->frame_length; i++ ) {
 800e672:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800e674:	3304      	adds	r3, #4
 800e676:	429a      	cmp	r2, r3
 800e678:	f47f af5f 	bne.w	800e53a <silk_PLC+0x89a>
 800e67c:	e9d7 b60d 	ldrd	fp, r6, [r7, #52]	; 0x34
 800e680:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    }

    /* Save LPC state */
    silk_memcpy( psDec->sLPC_Q14_buf, &sLPC_Q14_ptr[ psDec->frame_length ], MAX_LPC_ORDER * sizeof( opus_int32 ) );
 800e682:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e684:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
 800e686:	4413      	add	r3, r2
 800e688:	469a      	mov	sl, r3
 800e68a:	f103 0c40 	add.w	ip, r3, #64	; 0x40
 800e68e:	4654      	mov	r4, sl
 800e690:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800e692:	4564      	cmp	r4, ip
 800e694:	6028      	str	r0, [r5, #0]
 800e696:	6069      	str	r1, [r5, #4]
 800e698:	60aa      	str	r2, [r5, #8]
 800e69a:	60eb      	str	r3, [r5, #12]
 800e69c:	f10a 0a10 	add.w	sl, sl, #16
 800e6a0:	f105 0510 	add.w	r5, r5, #16
 800e6a4:	d1f3      	bne.n	800e68e <silk_PLC+0x9ee>

    /**************************************/
    /* Update states                      */
    /**************************************/
    psPLC->rand_seed     = rand_seed;
 800e6a6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    psPLC->randScale_Q14 = rand_scale_Q14;
 800e6a8:	6d7a      	ldr	r2, [r7, #84]	; 0x54
    psPLC->rand_seed     = rand_seed;
 800e6aa:	635e      	str	r6, [r3, #52]	; 0x34
    psPLC->randScale_Q14 = rand_scale_Q14;
 800e6ac:	871a      	strh	r2, [r3, #56]	; 0x38
    for( i = 0; i < MAX_NB_SUBFR; i++ ) {
        psDecCtrl->pitchL[ i ] = lag;
 800e6ae:	6a3b      	ldr	r3, [r7, #32]
 800e6b0:	e9c3 bb00 	strd	fp, fp, [r3]
 800e6b4:	f8c3 b008 	str.w	fp, [r3, #8]
 800e6b8:	f8c3 b00c 	str.w	fp, [r3, #12]
        psDec->lossCnt++;
 800e6bc:	697a      	ldr	r2, [r7, #20]
 800e6be:	f8d7 d000 	ldr.w	sp, [r7]
 800e6c2:	6813      	ldr	r3, [r2, #0]
}
 800e6c4:	37c4      	adds	r7, #196	; 0xc4
        psDec->lossCnt++;
 800e6c6:	3301      	adds	r3, #1
 800e6c8:	6013      	str	r3, [r2, #0]
}
 800e6ca:	46bd      	mov	sp, r7
 800e6cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e6d0:	f06f 010f 	mvn.w	r1, #15
 800e6d4:	221f      	movs	r2, #31
 800e6d6:	e569      	b.n	800e1ac <silk_PLC+0x50c>
        sLPC_Q14_ptr[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( sLPC_Q14_ptr[ MAX_LPC_ORDER + i ],
 800e6d8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800e6dc:	e7a4      	b.n	800e628 <silk_PLC+0x988>
            invGain_Q30 = silk_LPC_inverse_pred_gain( psPLC->prevLPC_Q12, psDec->LPC_order, arch );
 800e6de:	4621      	mov	r1, r4
 800e6e0:	4658      	mov	r0, fp
 800e6e2:	f7fe fac9 	bl	800cc78 <silk_LPC_inverse_pred_gain_c>
 800e6e6:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
 800e6ea:	bfa8      	it	ge
 800e6ec:	f04f 6000 	movge.w	r0, #134217728	; 0x8000000
        rand_scale_Q14 = 1 << 14;
 800e6f0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
}
static OPUS_INLINE opus_int32 silk_max_32(opus_int32 a, opus_int32 b)
{
    return (((a) > (b)) ? (a) : (b));
 800e6f4:	f5b0 0f80 	cmp.w	r0, #4194304	; 0x400000
 800e6f8:	bfb8      	it	lt
 800e6fa:	f44f 0080 	movlt.w	r0, #4194304	; 0x400000
 800e6fe:	657b      	str	r3, [r7, #84]	; 0x54
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800e700:	69fb      	ldr	r3, [r7, #28]
            down_scale_Q30 = silk_LSHIFT( down_scale_Q30, LOG2_INV_LPC_GAIN_HIGH_THRES );
 800e702:	00c0      	lsls	r0, r0, #3
 800e704:	041b      	lsls	r3, r3, #16
  __asm__(
 800e706:	fb80 1203 	smull	r1, r2, r0, r3
            rand_Gain_Q15 = silk_RSHIFT( silk_SMULWB( down_scale_Q30, rand_Gain_Q15 ), 14 );
 800e70a:	1393      	asrs	r3, r2, #14
 800e70c:	f8d8 4924 	ldr.w	r4, [r8, #2340]	; 0x924
 800e710:	61fb      	str	r3, [r7, #28]
 800e712:	e517      	b.n	800e144 <silk_PLC+0x4a4>
                silk_memcpy( psPLC->LTPCoef_Q14,
 800e714:	2630      	movs	r6, #48	; 0x30
 800e716:	2305      	movs	r3, #5
 800e718:	fb1a 6303 	smlabb	r3, sl, r3, r6
 800e71c:	6a3a      	ldr	r2, [r7, #32]
 800e71e:	6dbe      	ldr	r6, [r7, #88]	; 0x58
 800e720:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800e724:	f8d3 c000 	ldr.w	ip, [r3]
 800e728:	f8d3 e004 	ldr.w	lr, [r3, #4]
 800e72c:	f8c6 c004 	str.w	ip, [r6, #4]
 800e730:	f8d7 6084 	ldr.w	r6, [r7, #132]	; 0x84
 800e734:	f8c7 2080 	str.w	r2, [r7, #128]	; 0x80
 800e738:	f8c6 e004 	str.w	lr, [r6, #4]
 800e73c:	891b      	ldrh	r3, [r3, #8]
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800e73e:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
                silk_memcpy( psPLC->LTPCoef_Q14,
 800e742:	8133      	strh	r3, [r6, #8]
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800e744:	f852 302a 	ldr.w	r3, [r2, sl, lsl #2]
 800e748:	f859 ec04 	ldr.w	lr, [r9, #-4]
 800e74c:	021b      	lsls	r3, r3, #8
        for( j = 0; j * psDec->subfr_length < psDecCtrl->pitchL[ psDec->nb_subfr - 1 ]; j++ ) {
 800e74e:	45ae      	cmp	lr, r5
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800e750:	f848 3001 	str.w	r3, [r8, r1]
                temp_LTP_Gain_Q14 += psDecCtrl->LTPCoef_Q14[ ( psDec->nb_subfr - 1 - j ) * LTP_ORDER  + i ];
 800e754:	4603      	mov	r3, r0
        for( j = 0; j * psDec->subfr_length < psDecCtrl->pitchL[ psDec->nb_subfr - 1 ]; j++ ) {
 800e756:	f73f ab0f 	bgt.w	800dd78 <silk_PLC+0xd8>
 800e75a:	f7ff bb82 	b.w	800de62 <silk_PLC+0x1c2>
  __asm__(
 800e75e:	fb82 5601 	smull	r5, r6, r2, r1
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800e762:	0c2d      	lsrs	r5, r5, #16
 800e764:	eb05 4506 	add.w	r5, r5, r6, lsl #16
        frame[ i ] = (opus_int16)silk_SAT16( silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( sLPC_Q14_ptr[ MAX_LPC_ORDER + i ], prevGain_Q10[ 1 ] ), 8 ) ) );
 800e768:	11ed      	asrs	r5, r5, #7
 800e76a:	3501      	adds	r5, #1
 800e76c:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 800e770:	da15      	bge.n	800e79e <silk_PLC+0xafe>
  __asm__(
 800e772:	fb82 5601 	smull	r5, r6, r2, r1
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800e776:	0c2d      	lsrs	r5, r5, #16
 800e778:	eb05 4506 	add.w	r5, r5, r6, lsl #16
 800e77c:	11ed      	asrs	r5, r5, #7
 800e77e:	3501      	adds	r5, #1
 800e780:	f515 3f80 	cmn.w	r5, #65536	; 0x10000
 800e784:	db0b      	blt.n	800e79e <silk_PLC+0xafe>
  __asm__(
 800e786:	fb82 5601 	smull	r5, r6, r2, r1
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800e78a:	0c2d      	lsrs	r5, r5, #16
 800e78c:	eb05 4506 	add.w	r5, r5, r6, lsl #16
 800e790:	11ed      	asrs	r5, r5, #7
 800e792:	3501      	adds	r5, #1
 800e794:	f515 3f80 	cmn.w	r5, #65536	; 0x10000
 800e798:	da01      	bge.n	800e79e <silk_PLC+0xafe>
 800e79a:	4a70      	ldr	r2, [pc, #448]	; (800e95c <silk_PLC+0xcbc>)
 800e79c:	e767      	b.n	800e66e <silk_PLC+0x9ce>
  __asm__(
 800e79e:	fb82 5601 	smull	r5, r6, r2, r1
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800e7a2:	0c2d      	lsrs	r5, r5, #16
 800e7a4:	eb05 4506 	add.w	r5, r5, r6, lsl #16
 800e7a8:	11ed      	asrs	r5, r5, #7
 800e7aa:	3501      	adds	r5, #1
 800e7ac:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 800e7b0:	f6bf af5b 	bge.w	800e66a <silk_PLC+0x9ca>
  __asm__(
 800e7b4:	fb82 5601 	smull	r5, r6, r2, r1
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800e7b8:	0c2d      	lsrs	r5, r5, #16
 800e7ba:	eb05 4506 	add.w	r5, r5, r6, lsl #16
 800e7be:	11ed      	asrs	r5, r5, #7
 800e7c0:	3501      	adds	r5, #1
 800e7c2:	f515 3f80 	cmn.w	r5, #65536	; 0x10000
 800e7c6:	dbe8      	blt.n	800e79a <silk_PLC+0xafa>
  __asm__(
 800e7c8:	fb82 5601 	smull	r5, r6, r2, r1
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800e7cc:	0c2d      	lsrs	r5, r5, #16
 800e7ce:	eb05 4206 	add.w	r2, r5, r6, lsl #16
 800e7d2:	11d2      	asrs	r2, r2, #7
 800e7d4:	3201      	adds	r2, #1
 800e7d6:	f342 024f 	sbfx	r2, r2, #1, #16
 800e7da:	e748      	b.n	800e66e <silk_PLC+0x9ce>
        sLPC_Q14_ptr[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( sLPC_Q14_ptr[ MAX_LPC_ORDER + i ],
 800e7dc:	f105 4200 	add.w	r2, r5, #2147483648	; 0x80000000
 800e7e0:	3a10      	subs	r2, #16
 800e7e2:	2a00      	cmp	r2, #0
 800e7e4:	4a5e      	ldr	r2, [pc, #376]	; (800e960 <silk_PLC+0xcc0>)
 800e7e6:	f6bf af1c 	bge.w	800e622 <silk_PLC+0x982>
 800e7ea:	ea55 0002 	orrs.w	r0, r5, r2
 800e7ee:	f53f af1a 	bmi.w	800e626 <silk_PLC+0x986>
 800e7f2:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 800e7f6:	e717      	b.n	800e628 <silk_PLC+0x988>
 800e7f8:	f1b5 4f00 	cmp.w	r5, #2147483648	; 0x80000000
 800e7fc:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800e800:	f57f af0f 	bpl.w	800e622 <silk_PLC+0x982>
 800e804:	e7f1      	b.n	800e7ea <silk_PLC+0xb4a>
        return silk_LSHIFT_SAT32(result, -lshift);
 800e806:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 800e80a:	4249      	negs	r1, r1
 800e80c:	410a      	asrs	r2, r1
 800e80e:	4293      	cmp	r3, r2
 800e810:	dc05      	bgt.n	800e81e <silk_PLC+0xb7e>
 800e812:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800e816:	410a      	asrs	r2, r1
 800e818:	429a      	cmp	r2, r3
 800e81a:	bfb8      	it	lt
 800e81c:	461a      	movlt	r2, r3
 800e81e:	408a      	lsls	r2, r1
 800e820:	e4dc      	b.n	800e1dc <silk_PLC+0x53c>
       silk_memset( psPLC->prevLPC_Q12, 0, sizeof( psPLC->prevLPC_Q12 ) );
 800e822:	2220      	movs	r2, #32
 800e824:	2100      	movs	r1, #0
 800e826:	4658      	mov	r0, fp
 800e828:	f005 fc7e 	bl	8014128 <memset>
 800e82c:	f7ff bba4 	b.w	800df78 <silk_PLC+0x2d8>
        silk_memset( psPLC->LTPCoef_Q14, 0, LTP_ORDER * sizeof( opus_int16 ) );
 800e830:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800e832:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 800e836:	6053      	str	r3, [r2, #4]
 800e838:	604b      	str	r3, [r1, #4]
 800e83a:	810b      	strh	r3, [r1, #8]
        psPLC->LTPCoef_Q14[ LTP_ORDER / 2 ] = LTP_Gain_Q14;
 800e83c:	8113      	strh	r3, [r2, #8]
 800e83e:	2b01      	cmp	r3, #1
 800e840:	bfb8      	it	lt
 800e842:	2301      	movlt	r3, #1
 800e844:	4a47      	ldr	r2, [pc, #284]	; (800e964 <silk_PLC+0xcc4>)
 800e846:	6db9      	ldr	r1, [r7, #88]	; 0x58
 800e848:	fb92 f3f3 	sdiv	r3, r2, r3
 800e84c:	b21b      	sxth	r3, r3
                psPLC->LTPCoef_Q14[ i ] = silk_RSHIFT( silk_SMULBB( psPLC->LTPCoef_Q14[ i ], scale_Q10 ), 10 );
 800e84e:	f241 0952 	movw	r9, #4178	; 0x1052
 800e852:	f241 0e54 	movw	lr, #4180	; 0x1054
 800e856:	f241 0c56 	movw	ip, #4182	; 0x1056
 800e85a:	f241 0658 	movw	r6, #4184	; 0x1058
 800e85e:	f9b1 2004 	ldrsh.w	r2, [r1, #4]
 800e862:	fb03 f202 	mul.w	r2, r3, r2
 800e866:	1292      	asrs	r2, r2, #10
 800e868:	808a      	strh	r2, [r1, #4]
 800e86a:	f938 0009 	ldrsh.w	r0, [r8, r9]
 800e86e:	f938 100e 	ldrsh.w	r1, [r8, lr]
 800e872:	fb03 f000 	mul.w	r0, r3, r0
 800e876:	1280      	asrs	r0, r0, #10
 800e878:	f938 200c 	ldrsh.w	r2, [r8, ip]
 800e87c:	f828 0009 	strh.w	r0, [r8, r9]
 800e880:	f938 0006 	ldrsh.w	r0, [r8, r6]
 800e884:	fb03 f101 	mul.w	r1, r3, r1
 800e888:	fb03 f202 	mul.w	r2, r3, r2
 800e88c:	fb03 f300 	mul.w	r3, r3, r0
 800e890:	1289      	asrs	r1, r1, #10
 800e892:	1292      	asrs	r2, r2, #10
 800e894:	129b      	asrs	r3, r3, #10
 800e896:	f828 100e 	strh.w	r1, [r8, lr]
 800e89a:	f828 200c 	strh.w	r2, [r8, ip]
 800e89e:	f828 3006 	strh.w	r3, [r8, r6]
 800e8a2:	f7ff bb2a 	b.w	800defa <silk_PLC+0x25a>
                silk_memcpy( psPLC->LTPCoef_Q14,
 800e8a6:	f04f 0e05 	mov.w	lr, #5
 800e8aa:	f04f 0a30 	mov.w	sl, #48	; 0x30
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800e8ae:	460b      	mov	r3, r1
                silk_memcpy( psPLC->LTPCoef_Q14,
 800e8b0:	fb1c a10e 	smlabb	r1, ip, lr, sl
 800e8b4:	6a3a      	ldr	r2, [r7, #32]
 800e8b6:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800e8b8:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 800e8bc:	f8d1 a000 	ldr.w	sl, [r1]
 800e8c0:	f8d1 e004 	ldr.w	lr, [r1, #4]
 800e8c4:	f8c0 a004 	str.w	sl, [r0, #4]
 800e8c8:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 800e8cc:	f8c7 2080 	str.w	r2, [r7, #128]	; 0x80
 800e8d0:	f8c0 e004 	str.w	lr, [r0, #4]
 800e8d4:	8909      	ldrh	r1, [r1, #8]
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800e8d6:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
                silk_memcpy( psPLC->LTPCoef_Q14,
 800e8da:	8101      	strh	r1, [r0, #8]
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800e8dc:	f852 102c 	ldr.w	r1, [r2, ip, lsl #2]
 800e8e0:	f241 024c 	movw	r2, #4172	; 0x104c
 800e8e4:	0209      	lsls	r1, r1, #8
 800e8e6:	f859 ec04 	ldr.w	lr, [r9, #-4]
 800e8ea:	f848 1002 	str.w	r1, [r8, r2]
 800e8ee:	f7ff ba9b 	b.w	800de28 <silk_PLC+0x188>
                silk_memcpy( psPLC->LTPCoef_Q14,
 800e8f2:	f04f 0c30 	mov.w	ip, #48	; 0x30
 800e8f6:	2305      	movs	r3, #5
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800e8f8:	f241 094c 	movw	r9, #4172	; 0x104c
                silk_memcpy( psPLC->LTPCoef_Q14,
 800e8fc:	fb16 c303 	smlabb	r3, r6, r3, ip
 800e900:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800e904:	f8d3 e000 	ldr.w	lr, [r3]
 800e908:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800e90a:	f8d3 c004 	ldr.w	ip, [r3, #4]
 800e90e:	f8c0 e004 	str.w	lr, [r0, #4]
 800e912:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 800e916:	f8c7 2080 	str.w	r2, [r7, #128]	; 0x80
 800e91a:	f8c0 c004 	str.w	ip, [r0, #4]
 800e91e:	f8b3 c008 	ldrh.w	ip, [r3, #8]
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800e922:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
                silk_memcpy( psPLC->LTPCoef_Q14,
 800e926:	f8a0 c008 	strh.w	ip, [r0, #8]
                psPLC->pitchL_Q8 = silk_LSHIFT( psDecCtrl->pitchL[ psDec->nb_subfr - 1 - j ], 8 );
 800e92a:	460b      	mov	r3, r1
 800e92c:	f852 1026 	ldr.w	r1, [r2, r6, lsl #2]
 800e930:	0209      	lsls	r1, r1, #8
 800e932:	f848 1009 	str.w	r1, [r8, r9]
 800e936:	f7ff ba94 	b.w	800de62 <silk_PLC+0x1c2>
        silk_memset( psPLC->LTPCoef_Q14, 0, LTP_ORDER * sizeof( opus_int16 ) );
 800e93a:	2100      	movs	r1, #0
 800e93c:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800e93e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800e942:	6051      	str	r1, [r2, #4]
 800e944:	6059      	str	r1, [r3, #4]
 800e946:	8119      	strh	r1, [r3, #8]
        psPLC->LTPCoef_Q14[ LTP_ORDER / 2 ] = LTP_Gain_Q14;
 800e948:	8111      	strh	r1, [r2, #8]
 800e94a:	f44f 5350 	mov.w	r3, #13312	; 0x3400
 800e94e:	4611      	mov	r1, r2
 800e950:	e77d      	b.n	800e84e <silk_PLC+0xbae>
 800e952:	ea4f 038a 	mov.w	r3, sl, lsl #2
 800e956:	643b      	str	r3, [r7, #64]	; 0x40
 800e958:	461a      	mov	r2, r3
 800e95a:	e692      	b.n	800e682 <silk_PLC+0x9e2>
 800e95c:	ffff8000 	.word	0xffff8000
 800e960:	7ffffff0 	.word	0x7ffffff0
 800e964:	00b33400 	.word	0x00b33400

0800e968 <silk_PLC_glue_frames>:
void silk_PLC_glue_frames(
    silk_decoder_state                  *psDec,             /* I/O decoder state        */
    opus_int16                          frame[],            /* I/O signal               */
    opus_int                            length              /* I length of signal       */
)
{
 800e968:	b5f0      	push	{r4, r5, r6, r7, lr}
    opus_int   i, energy_shift;
    opus_int32 energy;
    silk_PLC_struct *psPLC;
    psPLC = &psDec->sPLC;

    if( psDec->lossCnt ) {
 800e96a:	f500 5382 	add.w	r3, r0, #4160	; 0x1040
 800e96e:	681d      	ldr	r5, [r3, #0]
{
 800e970:	b083      	sub	sp, #12
 800e972:	460e      	mov	r6, r1
 800e974:	4617      	mov	r7, r2
    if( psDec->lossCnt ) {
 800e976:	2d00      	cmp	r5, #0
 800e978:	d173      	bne.n	800ea62 <silk_PLC_glue_frames+0xfa>
        /* Calculate energy in concealed residual */
        silk_sum_sqr_shift( &psPLC->conc_energy, &psPLC->conc_energy_shift, frame, length );

        psPLC->last_frame_lost = 1;
    } else {
        if( psDec->sPLC.last_frame_lost ) {
 800e97a:	f241 037c 	movw	r3, #4220	; 0x107c
 800e97e:	58c3      	ldr	r3, [r0, r3]
 800e980:	4604      	mov	r4, r0
 800e982:	b933      	cbnz	r3, 800e992 <silk_PLC_glue_frames+0x2a>
 800e984:	f500 5482 	add.w	r4, r0, #4160	; 0x1040
 800e988:	340c      	adds	r4, #12
                        break;
                    }
                }
            }
        }
        psPLC->last_frame_lost = 0;
 800e98a:	2300      	movs	r3, #0
 800e98c:	6323      	str	r3, [r4, #48]	; 0x30
    }
}
 800e98e:	b003      	add	sp, #12
 800e990:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( energy_shift > psPLC->conc_energy_shift ) {
 800e992:	f504 5482 	add.w	r4, r4, #4160	; 0x1040
            silk_sum_sqr_shift( &energy, &energy_shift, frame, length );
 800e996:	4613      	mov	r3, r2
 800e998:	a801      	add	r0, sp, #4
 800e99a:	460a      	mov	r2, r1
            if( energy_shift > psPLC->conc_energy_shift ) {
 800e99c:	340c      	adds	r4, #12
            silk_sum_sqr_shift( &energy, &energy_shift, frame, length );
 800e99e:	4669      	mov	r1, sp
 800e9a0:	f003 faf0 	bl	8011f84 <silk_sum_sqr_shift>
            if( energy_shift > psPLC->conc_energy_shift ) {
 800e9a4:	6c20      	ldr	r0, [r4, #64]	; 0x40
 800e9a6:	9900      	ldr	r1, [sp, #0]
                psPLC->conc_energy = silk_RSHIFT( psPLC->conc_energy, energy_shift - psPLC->conc_energy_shift );
 800e9a8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
            if( energy_shift > psPLC->conc_energy_shift ) {
 800e9aa:	4288      	cmp	r0, r1
 800e9ac:	db66      	blt.n	800ea7c <silk_PLC_glue_frames+0x114>
 800e9ae:	9b01      	ldr	r3, [sp, #4]
                energy = silk_RSHIFT( energy, psPLC->conc_energy_shift - energy_shift );
 800e9b0:	bfc4      	itt	gt
 800e9b2:	1a41      	subgt	r1, r0, r1
 800e9b4:	410b      	asrgt	r3, r1
            if( energy > psPLC->conc_energy ) {
 800e9b6:	429a      	cmp	r2, r3
 800e9b8:	dae7      	bge.n	800e98a <silk_PLC_glue_frames+0x22>
 800e9ba:	2a00      	cmp	r2, #0
 800e9bc:	d063      	beq.n	800ea86 <silk_PLC_glue_frames+0x11e>
 800e9be:	fab2 f182 	clz	r1, r2
                LZ = LZ - 1;
 800e9c2:	3901      	subs	r1, #1
                energy = silk_RSHIFT( energy, silk_max_32( 24 - LZ, 0 ) );
 800e9c4:	f1c1 0018 	rsb	r0, r1, #24
 800e9c8:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 800e9cc:	4103      	asrs	r3, r0
                frac_Q24 = silk_DIV32( psPLC->conc_energy, silk_max( energy, 1 ) );
 800e9ce:	2b01      	cmp	r3, #1
 800e9d0:	bfb8      	it	lt
 800e9d2:	2301      	movlt	r3, #1
                psPLC->conc_energy = silk_LSHIFT( psPLC->conc_energy, LZ );
 800e9d4:	408a      	lsls	r2, r1
                frac_Q24 = silk_DIV32( psPLC->conc_energy, silk_max( energy, 1 ) );
 800e9d6:	fb92 f3f3 	sdiv	r3, r2, r3
    if( x <= 0 ) {
 800e9da:	2b00      	cmp	r3, #0
                psPLC->conc_energy = silk_LSHIFT( psPLC->conc_energy, LZ );
 800e9dc:	63e2      	str	r2, [r4, #60]	; 0x3c
 800e9de:	dd5a      	ble.n	800ea96 <silk_PLC_glue_frames+0x12e>
 800e9e0:	fab3 f283 	clz	r2, r3
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
 800e9e4:	f1c2 0118 	rsb	r1, r2, #24
    if( rot == 0 ) {
 800e9e8:	2900      	cmp	r1, #0
 800e9ea:	d150      	bne.n	800ea8e <silk_PLC_glue_frames+0x126>
        y = 32768;
 800e9ec:	f012 0f01 	tst.w	r2, #1
 800e9f0:	f24b 4586 	movw	r5, #46214	; 0xb486
 800e9f4:	bf18      	it	ne
 800e9f6:	f44f 4500 	movne.w	r5, #32768	; 0x8000
    * frac_Q7 = silk_ROR32(in, 24 - lzeros) & 0x7f;
 800e9fa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
 800e9fe:	eb03 01c3 	add.w	r1, r3, r3, lsl #3
    y >>= silk_RSHIFT(lz, 1);
 800ea02:	1052      	asrs	r2, r2, #1
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
 800ea04:	ebc3 03c1 	rsb	r3, r3, r1, lsl #3
    y >>= silk_RSHIFT(lz, 1);
 800ea08:	4115      	asrs	r5, r2
    y = silk_SMLAWB(y, y, silk_SMULBB(213, frac_Q7));
 800ea0a:	ebc3 0383 	rsb	r3, r3, r3, lsl #2
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800ea0e:	041b      	lsls	r3, r3, #16
  __asm__(
 800ea10:	fb85 1203 	smull	r1, r2, r5, r3
 800ea14:	4415      	add	r5, r2
 800ea16:	012d      	lsls	r5, r5, #4
 800ea18:	f5c5 3280 	rsb	r2, r5, #65536	; 0x10000
                slope_Q16 = silk_DIV32_16( ( (opus_int32)1 << 16 ) - gain_Q16, length );
 800ea1c:	fb92 f2f7 	sdiv	r2, r2, r7
                for( i = 0; i < length; i++ ) {
 800ea20:	2f00      	cmp	r7, #0
                slope_Q16 = silk_LSHIFT( slope_Q16, 2 );
 800ea22:	ea4f 0282 	mov.w	r2, r2, lsl #2
                for( i = 0; i < length; i++ ) {
 800ea26:	ddb0      	ble.n	800e98a <silk_PLC_glue_frames+0x22>
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800ea28:	f9b6 3000 	ldrsh.w	r3, [r6]
                    gain_Q16 += slope_Q16;
 800ea2c:	1950      	adds	r0, r2, r5
                    if( gain_Q16 > (opus_int32)1 << 16 ) {
 800ea2e:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 800ea32:	ea4f 4303 	mov.w	r3, r3, lsl #16
  __asm__(
 800ea36:	fb85 c103 	smull	ip, r1, r5, r3
                    frame[ i ] = silk_SMULWB( gain_Q16, frame[ i ] );
 800ea3a:	8031      	strh	r1, [r6, #0]
                    if( gain_Q16 > (opus_int32)1 << 16 ) {
 800ea3c:	dca5      	bgt.n	800e98a <silk_PLC_glue_frames+0x22>
 800ea3e:	eb06 0747 	add.w	r7, r6, r7, lsl #1
 800ea42:	4631      	mov	r1, r6
 800ea44:	3f02      	subs	r7, #2
 800ea46:	e009      	b.n	800ea5c <silk_PLC_glue_frames+0xf4>
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800ea48:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
 800ea4c:	041b      	lsls	r3, r3, #16
  __asm__(
 800ea4e:	fb80 6503 	smull	r6, r5, r0, r3
                    gain_Q16 += slope_Q16;
 800ea52:	4410      	add	r0, r2
                    if( gain_Q16 > (opus_int32)1 << 16 ) {
 800ea54:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
                    frame[ i ] = silk_SMULWB( gain_Q16, frame[ i ] );
 800ea58:	800d      	strh	r5, [r1, #0]
                    if( gain_Q16 > (opus_int32)1 << 16 ) {
 800ea5a:	dc96      	bgt.n	800e98a <silk_PLC_glue_frames+0x22>
                for( i = 0; i < length; i++ ) {
 800ea5c:	42b9      	cmp	r1, r7
 800ea5e:	d1f3      	bne.n	800ea48 <silk_PLC_glue_frames+0xe0>
 800ea60:	e793      	b.n	800e98a <silk_PLC_glue_frames+0x22>
        silk_sum_sqr_shift( &psPLC->conc_energy, &psPLC->conc_energy_shift, frame, length );
 800ea62:	461c      	mov	r4, r3
 800ea64:	4613      	mov	r3, r2
 800ea66:	f104 0048 	add.w	r0, r4, #72	; 0x48
 800ea6a:	460a      	mov	r2, r1
 800ea6c:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 800ea70:	f003 fa88 	bl	8011f84 <silk_sum_sqr_shift>
        psPLC->last_frame_lost = 1;
 800ea74:	2301      	movs	r3, #1
 800ea76:	63e3      	str	r3, [r4, #60]	; 0x3c
}
 800ea78:	b003      	add	sp, #12
 800ea7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
                psPLC->conc_energy = silk_RSHIFT( psPLC->conc_energy, energy_shift - psPLC->conc_energy_shift );
 800ea7c:	1a09      	subs	r1, r1, r0
 800ea7e:	410a      	asrs	r2, r1
 800ea80:	63e2      	str	r2, [r4, #60]	; 0x3c
 800ea82:	9b01      	ldr	r3, [sp, #4]
 800ea84:	e797      	b.n	800e9b6 <silk_PLC_glue_frames+0x4e>
                psPLC->conc_energy = silk_LSHIFT( psPLC->conc_energy, LZ );
 800ea86:	63e2      	str	r2, [r4, #60]	; 0x3c
 800ea88:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800ea8c:	e7c6      	b.n	800ea1c <silk_PLC_glue_frames+0xb4>
        return (opus_int32) ((x << m) | (x >> (32 - m)));
 800ea8e:	bfb8      	it	lt
 800ea90:	3120      	addlt	r1, #32
        return (opus_int32) ((x << (32 - r)) | (x >> r));
 800ea92:	41cb      	rors	r3, r1
 800ea94:	e7aa      	b.n	800e9ec <silk_PLC_glue_frames+0x84>
    if( x <= 0 ) {
 800ea96:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800ea9a:	e7bf      	b.n	800ea1c <silk_PLC_glue_frames+0xb4>

0800ea9c <silk_bwexpander>:
    opus_int   i;
    opus_int32 chirp_minus_one_Q16 = chirp_Q16 - 65536;

    /* NB: Dont use silk_SMULWB, instead of silk_RSHIFT_ROUND( silk_MUL(), 16 ), below.  */
    /* Bias in silk_SMULWB can lead to unstable filters                                */
    for( i = 0; i < d - 1; i++ ) {
 800ea9c:	2901      	cmp	r1, #1
{
 800ea9e:	b4f0      	push	{r4, r5, r6, r7}
    for( i = 0; i < d - 1; i++ ) {
 800eaa0:	dd15      	ble.n	800eace <silk_bwexpander+0x32>
 800eaa2:	1f06      	subs	r6, r0, #4
 800eaa4:	f5a2 3780 	sub.w	r7, r2, #65536	; 0x10000
 800eaa8:	eb06 0641 	add.w	r6, r6, r1, lsl #1
 800eaac:	1e85      	subs	r5, r0, #2
        ar[ i ]    = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ i ]             ), 16 );
 800eaae:	f935 3f02 	ldrsh.w	r3, [r5, #2]!
        chirp_Q16 +=             silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
 800eab2:	fb02 f407 	mul.w	r4, r2, r7
        ar[ i ]    = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ i ]             ), 16 );
 800eab6:	fb02 f303 	mul.w	r3, r2, r3
 800eaba:	13db      	asrs	r3, r3, #15
 800eabc:	3301      	adds	r3, #1
        chirp_Q16 +=             silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
 800eabe:	13e4      	asrs	r4, r4, #15
        ar[ i ]    = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ i ]             ), 16 );
 800eac0:	105b      	asrs	r3, r3, #1
        chirp_Q16 +=             silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
 800eac2:	3401      	adds	r4, #1
    for( i = 0; i < d - 1; i++ ) {
 800eac4:	42ae      	cmp	r6, r5
        ar[ i ]    = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ i ]             ), 16 );
 800eac6:	802b      	strh	r3, [r5, #0]
        chirp_Q16 +=             silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
 800eac8:	eb02 0264 	add.w	r2, r2, r4, asr #1
    for( i = 0; i < d - 1; i++ ) {
 800eacc:	d1ef      	bne.n	800eaae <silk_bwexpander+0x12>
    }
    ar[ d - 1 ] = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ d - 1 ] ), 16 );
}
 800eace:	bcf0      	pop	{r4, r5, r6, r7}
    ar[ d - 1 ] = (opus_int16)silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, ar[ d - 1 ] ), 16 );
 800ead0:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
 800ead4:	3901      	subs	r1, #1
 800ead6:	f930 3011 	ldrsh.w	r3, [r0, r1, lsl #1]
 800eada:	fb02 f303 	mul.w	r3, r2, r3
 800eade:	13db      	asrs	r3, r3, #15
 800eae0:	3301      	adds	r3, #1
 800eae2:	105b      	asrs	r3, r3, #1
 800eae4:	f820 3011 	strh.w	r3, [r0, r1, lsl #1]
}
 800eae8:	4770      	bx	lr
 800eaea:	bf00      	nop

0800eaec <silk_bwexpander_32>:
)
{
    opus_int   i;
    opus_int32 chirp_minus_one_Q16 = chirp_Q16 - 65536;

    for( i = 0; i < d - 1; i++ ) {
 800eaec:	2901      	cmp	r1, #1
{
 800eaee:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = 0; i < d - 1; i++ ) {
 800eaf0:	dd16      	ble.n	800eb20 <silk_bwexpander_32+0x34>
 800eaf2:	f1a0 0c08 	sub.w	ip, r0, #8
 800eaf6:	f5a2 3e80 	sub.w	lr, r2, #65536	; 0x10000
 800eafa:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
 800eafe:	1f05      	subs	r5, r0, #4
        ar[ i ]    = silk_SMULWW( chirp_Q16, ar[ i ] );
        chirp_Q16 += silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
 800eb00:	fb02 f30e 	mul.w	r3, r2, lr
  __asm__(
 800eb04:	f855 6f04 	ldr.w	r6, [r5, #4]!
 800eb08:	13db      	asrs	r3, r3, #15
 800eb0a:	fb82 4706 	smull	r4, r7, r2, r6
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800eb0e:	0c24      	lsrs	r4, r4, #16
 800eb10:	eb04 4407 	add.w	r4, r4, r7, lsl #16
 800eb14:	3301      	adds	r3, #1
    for( i = 0; i < d - 1; i++ ) {
 800eb16:	45ac      	cmp	ip, r5
        ar[ i ]    = silk_SMULWW( chirp_Q16, ar[ i ] );
 800eb18:	602c      	str	r4, [r5, #0]
        chirp_Q16 += silk_RSHIFT_ROUND( silk_MUL( chirp_Q16, chirp_minus_one_Q16 ), 16 );
 800eb1a:	eb02 0263 	add.w	r2, r2, r3, asr #1
    for( i = 0; i < d - 1; i++ ) {
 800eb1e:	d1ef      	bne.n	800eb00 <silk_bwexpander_32+0x14>
    }
    ar[ d - 1 ] = silk_SMULWW( chirp_Q16, ar[ d - 1 ] );
 800eb20:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 800eb24:	3901      	subs	r1, #1
  __asm__(
 800eb26:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
 800eb2a:	fb82 3504 	smull	r3, r5, r2, r4
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800eb2e:	0c1b      	lsrs	r3, r3, #16
 800eb30:	eb03 4305 	add.w	r3, r3, r5, lsl #16
 800eb34:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
 800eb38:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800eb3a:	bf00      	nop

0800eb3c <silk_decode_signs>:
    opus_int                    length,                             /* I    length of input                             */
    const opus_int              signalType,                         /* I    Signal type                                 */
    const opus_int              quantOffsetType,                    /* I    Quantization offset type                    */
    const opus_int              sum_pulses[ MAX_NB_SHELL_BLOCKS ]   /* I    Sum of absolute pulses per block            */
)
{
 800eb3c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    opus_int         i, j, p;
    opus_uint8       icdf[ 2 ];
    opus_int16       *q_ptr;
    const opus_uint8 *icdf_ptr;

    icdf[ 1 ] = 0;
 800eb40:	2600      	movs	r6, #0
{
 800eb42:	b082      	sub	sp, #8
    q_ptr = pulses;
    i = silk_SMULBB( 7, silk_ADD_LSHIFT( quantOffsetType, signalType, 1 ) );
    icdf_ptr = &silk_sign_iCDF[ i ];
    length = silk_RSHIFT( length + SHELL_CODEC_FRAME_LENGTH/2, LOG2_SHELL_CODEC_FRAME_LENGTH );
 800eb44:	f102 0708 	add.w	r7, r2, #8
{
 800eb48:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    length = silk_RSHIFT( length + SHELL_CODEC_FRAME_LENGTH/2, LOG2_SHELL_CODEC_FRAME_LENGTH );
 800eb4a:	113f      	asrs	r7, r7, #4
    for( i = 0; i < length; i++ ) {
 800eb4c:	42b7      	cmp	r7, r6
    i = silk_SMULBB( 7, silk_ADD_LSHIFT( quantOffsetType, signalType, 1 ) );
 800eb4e:	eb04 0343 	add.w	r3, r4, r3, lsl #1
    icdf[ 1 ] = 0;
 800eb52:	f88d 6005 	strb.w	r6, [sp, #5]
    for( i = 0; i < length; i++ ) {
 800eb56:	f340 8132 	ble.w	800edbe <silk_decode_signs+0x282>
 800eb5a:	4605      	mov	r5, r0
        p = sum_pulses[ i ];
        if( p > 0 ) {
            icdf[ 0 ] = icdf_ptr[ silk_min( p & 0x1F, 6 ) ];
 800eb5c:	f04f 0a07 	mov.w	sl, #7
 800eb60:	fa0f f883 	sxth.w	r8, r3
 800eb64:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800eb66:	f8df 925c 	ldr.w	r9, [pc, #604]	; 800edc4 <silk_decode_signs+0x288>
 800eb6a:	1f1e      	subs	r6, r3, #4
 800eb6c:	f101 0420 	add.w	r4, r1, #32
 800eb70:	eb06 0787 	add.w	r7, r6, r7, lsl #2
        p = sum_pulses[ i ];
 800eb74:	f856 3f04 	ldr.w	r3, [r6, #4]!
        if( p > 0 ) {
 800eb78:	2b00      	cmp	r3, #0
 800eb7a:	f340 811b 	ble.w	800edb4 <silk_decode_signs+0x278>
            icdf[ 0 ] = icdf_ptr[ silk_min( p & 0x1F, 6 ) ];
 800eb7e:	f003 031f 	and.w	r3, r3, #31
 800eb82:	2b05      	cmp	r3, #5
 800eb84:	bfc8      	it	gt
 800eb86:	2306      	movgt	r3, #6
 800eb88:	fb18 330a 	smlabb	r3, r8, sl, r3
            for( j = 0; j < SHELL_CODEC_FRAME_LENGTH; j++ ) {
                if( q_ptr[ j ] > 0 ) {
 800eb8c:	f934 2c20 	ldrsh.w	r2, [r4, #-32]
            icdf[ 0 ] = icdf_ptr[ silk_min( p & 0x1F, 6 ) ];
 800eb90:	f813 3009 	ldrb.w	r3, [r3, r9]
                if( q_ptr[ j ] > 0 ) {
 800eb94:	2a00      	cmp	r2, #0
            icdf[ 0 ] = icdf_ptr[ silk_min( p & 0x1F, 6 ) ];
 800eb96:	f88d 3004 	strb.w	r3, [sp, #4]
                if( q_ptr[ j ] > 0 ) {
 800eb9a:	dd0c      	ble.n	800ebb6 <silk_decode_signs+0x7a>
                    if( ec_dec_icdf( psRangeDec, icdf, 8 ) == 0 ) {
                        q_ptr[ j ] = -q_ptr[ j ];
                    }
#else
                    /* implementation with shift, subtraction, multiplication */
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800eb9c:	2208      	movs	r2, #8
 800eb9e:	a901      	add	r1, sp, #4
 800eba0:	4628      	mov	r0, r5
 800eba2:	f7f9 fcf3 	bl	800858c <ec_dec_icdf>
 800eba6:	f834 3c20 	ldrh.w	r3, [r4, #-32]
 800ebaa:	0040      	lsls	r0, r0, #1
 800ebac:	3801      	subs	r0, #1
 800ebae:	fb13 f300 	smulbb	r3, r3, r0
 800ebb2:	f824 3c20 	strh.w	r3, [r4, #-32]
                if( q_ptr[ j ] > 0 ) {
 800ebb6:	f934 3c1e 	ldrsh.w	r3, [r4, #-30]
 800ebba:	2b00      	cmp	r3, #0
 800ebbc:	dd0c      	ble.n	800ebd8 <silk_decode_signs+0x9c>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ebbe:	2208      	movs	r2, #8
 800ebc0:	a901      	add	r1, sp, #4
 800ebc2:	4628      	mov	r0, r5
 800ebc4:	f7f9 fce2 	bl	800858c <ec_dec_icdf>
 800ebc8:	f834 3c1e 	ldrh.w	r3, [r4, #-30]
 800ebcc:	0040      	lsls	r0, r0, #1
 800ebce:	3801      	subs	r0, #1
 800ebd0:	fb13 f300 	smulbb	r3, r3, r0
 800ebd4:	f824 3c1e 	strh.w	r3, [r4, #-30]
                if( q_ptr[ j ] > 0 ) {
 800ebd8:	f934 3c1c 	ldrsh.w	r3, [r4, #-28]
 800ebdc:	2b00      	cmp	r3, #0
 800ebde:	dd0c      	ble.n	800ebfa <silk_decode_signs+0xbe>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ebe0:	2208      	movs	r2, #8
 800ebe2:	a901      	add	r1, sp, #4
 800ebe4:	4628      	mov	r0, r5
 800ebe6:	f7f9 fcd1 	bl	800858c <ec_dec_icdf>
 800ebea:	f834 3c1c 	ldrh.w	r3, [r4, #-28]
 800ebee:	0040      	lsls	r0, r0, #1
 800ebf0:	3801      	subs	r0, #1
 800ebf2:	fb13 f300 	smulbb	r3, r3, r0
 800ebf6:	f824 3c1c 	strh.w	r3, [r4, #-28]
                if( q_ptr[ j ] > 0 ) {
 800ebfa:	f934 3c1a 	ldrsh.w	r3, [r4, #-26]
 800ebfe:	2b00      	cmp	r3, #0
 800ec00:	dd0c      	ble.n	800ec1c <silk_decode_signs+0xe0>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ec02:	2208      	movs	r2, #8
 800ec04:	a901      	add	r1, sp, #4
 800ec06:	4628      	mov	r0, r5
 800ec08:	f7f9 fcc0 	bl	800858c <ec_dec_icdf>
 800ec0c:	f834 3c1a 	ldrh.w	r3, [r4, #-26]
 800ec10:	0040      	lsls	r0, r0, #1
 800ec12:	3801      	subs	r0, #1
 800ec14:	fb13 f300 	smulbb	r3, r3, r0
 800ec18:	f824 3c1a 	strh.w	r3, [r4, #-26]
                if( q_ptr[ j ] > 0 ) {
 800ec1c:	f934 3c18 	ldrsh.w	r3, [r4, #-24]
 800ec20:	2b00      	cmp	r3, #0
 800ec22:	dd0c      	ble.n	800ec3e <silk_decode_signs+0x102>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ec24:	2208      	movs	r2, #8
 800ec26:	a901      	add	r1, sp, #4
 800ec28:	4628      	mov	r0, r5
 800ec2a:	f7f9 fcaf 	bl	800858c <ec_dec_icdf>
 800ec2e:	f834 3c18 	ldrh.w	r3, [r4, #-24]
 800ec32:	0040      	lsls	r0, r0, #1
 800ec34:	3801      	subs	r0, #1
 800ec36:	fb13 f300 	smulbb	r3, r3, r0
 800ec3a:	f824 3c18 	strh.w	r3, [r4, #-24]
                if( q_ptr[ j ] > 0 ) {
 800ec3e:	f934 3c16 	ldrsh.w	r3, [r4, #-22]
 800ec42:	2b00      	cmp	r3, #0
 800ec44:	dd0c      	ble.n	800ec60 <silk_decode_signs+0x124>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ec46:	2208      	movs	r2, #8
 800ec48:	a901      	add	r1, sp, #4
 800ec4a:	4628      	mov	r0, r5
 800ec4c:	f7f9 fc9e 	bl	800858c <ec_dec_icdf>
 800ec50:	f834 3c16 	ldrh.w	r3, [r4, #-22]
 800ec54:	0040      	lsls	r0, r0, #1
 800ec56:	3801      	subs	r0, #1
 800ec58:	fb13 f300 	smulbb	r3, r3, r0
 800ec5c:	f824 3c16 	strh.w	r3, [r4, #-22]
                if( q_ptr[ j ] > 0 ) {
 800ec60:	f934 3c14 	ldrsh.w	r3, [r4, #-20]
 800ec64:	2b00      	cmp	r3, #0
 800ec66:	dd0c      	ble.n	800ec82 <silk_decode_signs+0x146>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ec68:	2208      	movs	r2, #8
 800ec6a:	a901      	add	r1, sp, #4
 800ec6c:	4628      	mov	r0, r5
 800ec6e:	f7f9 fc8d 	bl	800858c <ec_dec_icdf>
 800ec72:	f834 3c14 	ldrh.w	r3, [r4, #-20]
 800ec76:	0040      	lsls	r0, r0, #1
 800ec78:	3801      	subs	r0, #1
 800ec7a:	fb13 f300 	smulbb	r3, r3, r0
 800ec7e:	f824 3c14 	strh.w	r3, [r4, #-20]
                if( q_ptr[ j ] > 0 ) {
 800ec82:	f934 3c12 	ldrsh.w	r3, [r4, #-18]
 800ec86:	2b00      	cmp	r3, #0
 800ec88:	dd0c      	ble.n	800eca4 <silk_decode_signs+0x168>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ec8a:	2208      	movs	r2, #8
 800ec8c:	a901      	add	r1, sp, #4
 800ec8e:	4628      	mov	r0, r5
 800ec90:	f7f9 fc7c 	bl	800858c <ec_dec_icdf>
 800ec94:	f834 3c12 	ldrh.w	r3, [r4, #-18]
 800ec98:	0040      	lsls	r0, r0, #1
 800ec9a:	3801      	subs	r0, #1
 800ec9c:	fb13 f300 	smulbb	r3, r3, r0
 800eca0:	f824 3c12 	strh.w	r3, [r4, #-18]
                if( q_ptr[ j ] > 0 ) {
 800eca4:	f934 3c10 	ldrsh.w	r3, [r4, #-16]
 800eca8:	2b00      	cmp	r3, #0
 800ecaa:	dd0c      	ble.n	800ecc6 <silk_decode_signs+0x18a>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ecac:	2208      	movs	r2, #8
 800ecae:	a901      	add	r1, sp, #4
 800ecb0:	4628      	mov	r0, r5
 800ecb2:	f7f9 fc6b 	bl	800858c <ec_dec_icdf>
 800ecb6:	f834 3c10 	ldrh.w	r3, [r4, #-16]
 800ecba:	0040      	lsls	r0, r0, #1
 800ecbc:	3801      	subs	r0, #1
 800ecbe:	fb13 f300 	smulbb	r3, r3, r0
 800ecc2:	f824 3c10 	strh.w	r3, [r4, #-16]
                if( q_ptr[ j ] > 0 ) {
 800ecc6:	f934 3c0e 	ldrsh.w	r3, [r4, #-14]
 800ecca:	2b00      	cmp	r3, #0
 800eccc:	dd0c      	ble.n	800ece8 <silk_decode_signs+0x1ac>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ecce:	2208      	movs	r2, #8
 800ecd0:	a901      	add	r1, sp, #4
 800ecd2:	4628      	mov	r0, r5
 800ecd4:	f7f9 fc5a 	bl	800858c <ec_dec_icdf>
 800ecd8:	f834 3c0e 	ldrh.w	r3, [r4, #-14]
 800ecdc:	0040      	lsls	r0, r0, #1
 800ecde:	3801      	subs	r0, #1
 800ece0:	fb13 f300 	smulbb	r3, r3, r0
 800ece4:	f824 3c0e 	strh.w	r3, [r4, #-14]
                if( q_ptr[ j ] > 0 ) {
 800ece8:	f934 3c0c 	ldrsh.w	r3, [r4, #-12]
 800ecec:	2b00      	cmp	r3, #0
 800ecee:	dd0c      	ble.n	800ed0a <silk_decode_signs+0x1ce>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ecf0:	2208      	movs	r2, #8
 800ecf2:	a901      	add	r1, sp, #4
 800ecf4:	4628      	mov	r0, r5
 800ecf6:	f7f9 fc49 	bl	800858c <ec_dec_icdf>
 800ecfa:	f834 3c0c 	ldrh.w	r3, [r4, #-12]
 800ecfe:	0040      	lsls	r0, r0, #1
 800ed00:	3801      	subs	r0, #1
 800ed02:	fb13 f300 	smulbb	r3, r3, r0
 800ed06:	f824 3c0c 	strh.w	r3, [r4, #-12]
                if( q_ptr[ j ] > 0 ) {
 800ed0a:	f934 3c0a 	ldrsh.w	r3, [r4, #-10]
 800ed0e:	2b00      	cmp	r3, #0
 800ed10:	dd0c      	ble.n	800ed2c <silk_decode_signs+0x1f0>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ed12:	2208      	movs	r2, #8
 800ed14:	a901      	add	r1, sp, #4
 800ed16:	4628      	mov	r0, r5
 800ed18:	f7f9 fc38 	bl	800858c <ec_dec_icdf>
 800ed1c:	f834 3c0a 	ldrh.w	r3, [r4, #-10]
 800ed20:	0040      	lsls	r0, r0, #1
 800ed22:	3801      	subs	r0, #1
 800ed24:	fb13 f300 	smulbb	r3, r3, r0
 800ed28:	f824 3c0a 	strh.w	r3, [r4, #-10]
                if( q_ptr[ j ] > 0 ) {
 800ed2c:	f934 3c08 	ldrsh.w	r3, [r4, #-8]
 800ed30:	2b00      	cmp	r3, #0
 800ed32:	dd0c      	ble.n	800ed4e <silk_decode_signs+0x212>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ed34:	2208      	movs	r2, #8
 800ed36:	a901      	add	r1, sp, #4
 800ed38:	4628      	mov	r0, r5
 800ed3a:	f7f9 fc27 	bl	800858c <ec_dec_icdf>
 800ed3e:	f834 3c08 	ldrh.w	r3, [r4, #-8]
 800ed42:	0040      	lsls	r0, r0, #1
 800ed44:	3801      	subs	r0, #1
 800ed46:	fb13 f300 	smulbb	r3, r3, r0
 800ed4a:	f824 3c08 	strh.w	r3, [r4, #-8]
                if( q_ptr[ j ] > 0 ) {
 800ed4e:	f934 3c06 	ldrsh.w	r3, [r4, #-6]
 800ed52:	2b00      	cmp	r3, #0
 800ed54:	dd0c      	ble.n	800ed70 <silk_decode_signs+0x234>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ed56:	2208      	movs	r2, #8
 800ed58:	a901      	add	r1, sp, #4
 800ed5a:	4628      	mov	r0, r5
 800ed5c:	f7f9 fc16 	bl	800858c <ec_dec_icdf>
 800ed60:	f834 3c06 	ldrh.w	r3, [r4, #-6]
 800ed64:	0040      	lsls	r0, r0, #1
 800ed66:	3801      	subs	r0, #1
 800ed68:	fb13 f300 	smulbb	r3, r3, r0
 800ed6c:	f824 3c06 	strh.w	r3, [r4, #-6]
                if( q_ptr[ j ] > 0 ) {
 800ed70:	f934 3c04 	ldrsh.w	r3, [r4, #-4]
 800ed74:	2b00      	cmp	r3, #0
 800ed76:	dd0c      	ble.n	800ed92 <silk_decode_signs+0x256>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ed78:	2208      	movs	r2, #8
 800ed7a:	a901      	add	r1, sp, #4
 800ed7c:	4628      	mov	r0, r5
 800ed7e:	f7f9 fc05 	bl	800858c <ec_dec_icdf>
 800ed82:	f834 3c04 	ldrh.w	r3, [r4, #-4]
 800ed86:	0040      	lsls	r0, r0, #1
 800ed88:	3801      	subs	r0, #1
 800ed8a:	fb13 f300 	smulbb	r3, r3, r0
 800ed8e:	f824 3c04 	strh.w	r3, [r4, #-4]
                if( q_ptr[ j ] > 0 ) {
 800ed92:	f934 3c02 	ldrsh.w	r3, [r4, #-2]
 800ed96:	2b00      	cmp	r3, #0
 800ed98:	dd0c      	ble.n	800edb4 <silk_decode_signs+0x278>
                    q_ptr[ j ] *= silk_dec_map( ec_dec_icdf( psRangeDec, icdf, 8 ) );
 800ed9a:	2208      	movs	r2, #8
 800ed9c:	a901      	add	r1, sp, #4
 800ed9e:	4628      	mov	r0, r5
 800eda0:	f7f9 fbf4 	bl	800858c <ec_dec_icdf>
 800eda4:	f834 3c02 	ldrh.w	r3, [r4, #-2]
 800eda8:	0040      	lsls	r0, r0, #1
 800edaa:	3801      	subs	r0, #1
 800edac:	fb13 f300 	smulbb	r3, r3, r0
 800edb0:	f824 3c02 	strh.w	r3, [r4, #-2]
    for( i = 0; i < length; i++ ) {
 800edb4:	42be      	cmp	r6, r7
 800edb6:	f104 0420 	add.w	r4, r4, #32
 800edba:	f47f aedb 	bne.w	800eb74 <silk_decode_signs+0x38>
                }
            }
        }
        q_ptr += SHELL_CODEC_FRAME_LENGTH;
    }
}
 800edbe:	b002      	add	sp, #8
 800edc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800edc4:	08017fa4 	.word	0x08017fa4

0800edc8 <silk_InitDecoder>:

/* Reset decoder state */
opus_int silk_InitDecoder(                              /* O    Returns error code                              */
    void                            *decState           /* I/O  State                                           */
)
{
 800edc8:	b538      	push	{r3, r4, r5, lr}
 800edca:	4604      	mov	r4, r0
    opus_int n, ret = SILK_NO_ERROR;
    silk_decoder_state *channel_state = ((silk_decoder *)decState)->channel_state;

    for( n = 0; n < DECODER_NUM_CHANNELS; n++ ) {
        ret  = silk_init_decoder( &channel_state[ n ] );
 800edcc:	f001 ff84 	bl	8010cd8 <silk_init_decoder>
 800edd0:	f504 5085 	add.w	r0, r4, #4256	; 0x10a0
 800edd4:	3008      	adds	r0, #8
 800edd6:	f001 ff7f 	bl	8010cd8 <silk_init_decoder>
    }
    silk_memset(&((silk_decoder *)decState)->sStereo, 0, sizeof(((silk_decoder *)decState)->sStereo));
 800edda:	f242 1150 	movw	r1, #8528	; 0x2150
 800edde:	2300      	movs	r3, #0
    /* Not strictly needed, but it's cleaner that way */
    ((silk_decoder *)decState)->prev_decode_only_middle = 0;
 800ede0:	f242 1564 	movw	r5, #8548	; 0x2164
    silk_memset(&((silk_decoder *)decState)->sStereo, 0, sizeof(((silk_decoder *)decState)->sStereo));
 800ede4:	1862      	adds	r2, r4, r1
 800ede6:	5063      	str	r3, [r4, r1]
 800ede8:	6053      	str	r3, [r2, #4]
 800edea:	6093      	str	r3, [r2, #8]
    ((silk_decoder *)decState)->prev_decode_only_middle = 0;
 800edec:	5163      	str	r3, [r4, r5]

    return ret;
}
 800edee:	bd38      	pop	{r3, r4, r5, pc}

0800edf0 <silk_Decode>:
    ec_dec                          *psRangeDec,        /* I/O  Compressor data structure                       */
    opus_int16                      *samplesOut,        /* O    Decoded output speech vector                    */
    opus_int32                      *nSamplesOut,       /* O    Number of samples decoded                       */
    int                             arch                /* I    Run-time architecture                           */
)
{
 800edf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800edf4:	f5ad 7d35 	sub.w	sp, sp, #724	; 0x2d4
 800edf8:	460c      	mov	r4, r1
    opus_int   i, n, decode_only_middle = 0, ret = SILK_NO_ERROR;
 800edfa:	2100      	movs	r1, #0
{
 800edfc:	af04      	add	r7, sp, #16
 800edfe:	623a      	str	r2, [r7, #32]
 800ee00:	4606      	mov	r6, r0
 800ee02:	6862      	ldr	r2, [r4, #4]
    opus_int   i, n, decode_only_middle = 0, ret = SILK_NO_ERROR;
 800ee04:	62b9      	str	r1, [r7, #40]	; 0x28
    opus_int32 nSamplesOutDec, LBRR_symbol;
    opus_int16 *samplesOut1_tmp[ 2 ];
    VARDECL( opus_int16, samplesOut1_tmp_storage1 );
    VARDECL( opus_int16, samplesOut1_tmp_storage2 );
    VARDECL( opus_int16, samplesOut2_tmp );
    opus_int32 MS_pred_Q13[ 2 ] = { 0 };
 800ee06:	e9c7 110e 	strd	r1, r1, [r7, #56]	; 0x38
    celt_assert( decControl->nChannelsInternal == 1 || decControl->nChannelsInternal == 2 );

    /**********************************/
    /* Test if first frame in payload */
    /**********************************/
    if( newPacketFlag ) {
 800ee0a:	b163      	cbz	r3, 800ee26 <silk_Decode+0x36>
        for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800ee0c:	428a      	cmp	r2, r1
 800ee0e:	dd0a      	ble.n	800ee26 <silk_Decode+0x36>
 800ee10:	f241 00a8 	movw	r0, #4264	; 0x10a8
 800ee14:	4633      	mov	r3, r6
 800ee16:	4605      	mov	r5, r0
 800ee18:	fb00 6002 	mla	r0, r0, r2, r6
            channel_state[ n ].nFramesDecoded = 0;  /* Used to count frames in packet */
 800ee1c:	f8c3 1954 	str.w	r1, [r3, #2388]	; 0x954
 800ee20:	442b      	add	r3, r5
        for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800ee22:	4298      	cmp	r0, r3
 800ee24:	d1fa      	bne.n	800ee1c <silk_Decode+0x2c>
        }
    }

    /* If Mono -> Stereo transition in bitstream: init state of second channel */
    if( decControl->nChannelsInternal > psDec->nChannelsInternal ) {
 800ee26:	f242 1360 	movw	r3, #8544	; 0x2160
 800ee2a:	58f3      	ldr	r3, [r6, r3]
 800ee2c:	4293      	cmp	r3, r2
 800ee2e:	f2c0 8114 	blt.w	800f05a <silk_Decode+0x26a>
    opus_int   i, n, decode_only_middle = 0, ret = SILK_NO_ERROR;
 800ee32:	2300      	movs	r3, #0
 800ee34:	627b      	str	r3, [r7, #36]	; 0x24
 800ee36:	f8d6 3954 	ldr.w	r3, [r6, #2388]	; 0x954
        ret += silk_init_decoder( &channel_state[ 1 ] );
    }

    stereo_to_mono = decControl->nChannelsInternal == 1 && psDec->nChannelsInternal == 2 &&
 800ee3a:	2a01      	cmp	r2, #1
 800ee3c:	613b      	str	r3, [r7, #16]
 800ee3e:	f000 80fd 	beq.w	800f03c <silk_Decode+0x24c>
                     ( decControl->internalSampleRate == 1000*channel_state[ 0 ].fs_kHz );

    if( channel_state[ 0 ].nFramesDecoded == 0 ) {
 800ee42:	bb9b      	cbnz	r3, 800eeac <silk_Decode+0xbc>
        for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800ee44:	2a00      	cmp	r2, #0
 800ee46:	dd33      	ble.n	800eeb0 <silk_Decode+0xc0>
 800ee48:	46b0      	mov	r8, r6
    stereo_to_mono = decControl->nChannelsInternal == 1 && psDec->nChannelsInternal == 2 &&
 800ee4a:	f04f 0b00 	mov.w	fp, #0
            } else if( decControl->payloadSize_ms == 40 ) {
                channel_state[ n ].nFramesPerPacket = 2;
                channel_state[ n ].nb_subfr = 4;
            } else if( decControl->payloadSize_ms == 60 ) {
                channel_state[ n ].nFramesPerPacket = 3;
                channel_state[ n ].nb_subfr = 4;
 800ee4e:	f04f 0a04 	mov.w	sl, #4
                channel_state[ n ].nFramesPerPacket = 2;
 800ee52:	f04f 0902 	mov.w	r9, #2
 800ee56:	6a7d      	ldr	r5, [r7, #36]	; 0x24
            if( decControl->payloadSize_ms == 0 ) {
 800ee58:	6923      	ldr	r3, [r4, #16]
 800ee5a:	2b00      	cmp	r3, #0
 800ee5c:	f000 80dd 	beq.w	800f01a <silk_Decode+0x22a>
            } else if( decControl->payloadSize_ms == 10 ) {
 800ee60:	2b0a      	cmp	r3, #10
 800ee62:	f000 80da 	beq.w	800f01a <silk_Decode+0x22a>
            } else if( decControl->payloadSize_ms == 20 ) {
 800ee66:	2b14      	cmp	r3, #20
 800ee68:	f000 80dd 	beq.w	800f026 <silk_Decode+0x236>
            } else if( decControl->payloadSize_ms == 40 ) {
 800ee6c:	2b28      	cmp	r3, #40	; 0x28
 800ee6e:	f000 80e0 	beq.w	800f032 <silk_Decode+0x242>
            } else if( decControl->payloadSize_ms == 60 ) {
 800ee72:	2b3c      	cmp	r3, #60	; 0x3c
 800ee74:	f040 841b 	bne.w	800f6ae <silk_Decode+0x8be>
                channel_state[ n ].nFramesPerPacket = 3;
 800ee78:	2303      	movs	r3, #3
                channel_state[ n ].nb_subfr = 4;
 800ee7a:	f8c8 a914 	str.w	sl, [r8, #2324]	; 0x914
                channel_state[ n ].nFramesPerPacket = 3;
 800ee7e:	f8c8 3958 	str.w	r3, [r8, #2392]	; 0x958
            } else {
                celt_assert( 0 );
                RESTORE_STACK;
                return SILK_DEC_INVALID_FRAME_SIZE;
            }
            fs_kHz_dec = ( decControl->internalSampleRate >> 10 ) + 1;
 800ee82:	68e1      	ldr	r1, [r4, #12]
 800ee84:	1289      	asrs	r1, r1, #10
            if( fs_kHz_dec != 8 && fs_kHz_dec != 12 && fs_kHz_dec != 16 ) {
 800ee86:	f021 0308 	bic.w	r3, r1, #8
 800ee8a:	2b07      	cmp	r3, #7
            fs_kHz_dec = ( decControl->internalSampleRate >> 10 ) + 1;
 800ee8c:	f101 0101 	add.w	r1, r1, #1
            if( fs_kHz_dec != 8 && fs_kHz_dec != 12 && fs_kHz_dec != 16 ) {
 800ee90:	f000 809d 	beq.w	800efce <silk_Decode+0x1de>
 800ee94:	290c      	cmp	r1, #12
 800ee96:	f000 809a 	beq.w	800efce <silk_Decode+0x1de>
                celt_assert( 0 );
                RESTORE_STACK;
                return SILK_DEC_INVALID_SAMPLING_FREQUENCY;
 800ee9a:	f06f 03c7 	mvn.w	r3, #199	; 0xc7
 800ee9e:	4618      	mov	r0, r3
 800eea0:	627b      	str	r3, [r7, #36]	; 0x24
    } else {
       psDec->prev_decode_only_middle = decode_only_middle;
    }
    RESTORE_STACK;
    return ret;
}
 800eea2:	f507 7731 	add.w	r7, r7, #708	; 0x2c4
 800eea6:	46bd      	mov	sp, r7
 800eea8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800eeac:	2300      	movs	r3, #0
 800eeae:	613b      	str	r3, [r7, #16]
    if( decControl->nChannelsAPI == 2 && decControl->nChannelsInternal == 2 && ( psDec->nChannelsAPI == 1 || psDec->nChannelsInternal == 1 ) ) {
 800eeb0:	6825      	ldr	r5, [r4, #0]
 800eeb2:	2d02      	cmp	r5, #2
 800eeb4:	4629      	mov	r1, r5
 800eeb6:	f000 809f 	beq.w	800eff8 <silk_Decode+0x208>
    psDec->nChannelsAPI      = decControl->nChannelsAPI;
 800eeba:	f242 185c 	movw	r8, #8540	; 0x215c
    if( decControl->API_sampleRate > (opus_int32)MAX_API_FS_KHZ * 1000 || decControl->API_sampleRate < 8000 ) {
 800eebe:	f649 4e40 	movw	lr, #40000	; 0x9c40
    psDec->nChannelsInternal = decControl->nChannelsInternal;
 800eec2:	f242 1c60 	movw	ip, #8544	; 0x2160
    if( decControl->API_sampleRate > (opus_int32)MAX_API_FS_KHZ * 1000 || decControl->API_sampleRate < 8000 ) {
 800eec6:	68a0      	ldr	r0, [r4, #8]
    psDec->nChannelsAPI      = decControl->nChannelsAPI;
 800eec8:	f846 1008 	str.w	r1, [r6, r8]
    if( decControl->API_sampleRate > (opus_int32)MAX_API_FS_KHZ * 1000 || decControl->API_sampleRate < 8000 ) {
 800eecc:	f5a0 58fa 	sub.w	r8, r0, #8000	; 0x1f40
 800eed0:	45f0      	cmp	r8, lr
    psDec->nChannelsInternal = decControl->nChannelsInternal;
 800eed2:	f846 200c 	str.w	r2, [r6, ip]
    if( decControl->API_sampleRate > (opus_int32)MAX_API_FS_KHZ * 1000 || decControl->API_sampleRate < 8000 ) {
 800eed6:	4684      	mov	ip, r0
 800eed8:	d8df      	bhi.n	800ee9a <silk_Decode+0xaa>
    if( lostFlag != FLAG_PACKET_LOST && channel_state[ 0 ].nFramesDecoded == 0 ) {
 800eeda:	6a3b      	ldr	r3, [r7, #32]
 800eedc:	2b01      	cmp	r3, #1
 800eede:	f000 80c4 	beq.w	800f06a <silk_Decode+0x27a>
 800eee2:	f8d6 9954 	ldr.w	r9, [r6, #2388]	; 0x954
 800eee6:	f1b9 0f00 	cmp.w	r9, #0
 800eeea:	f040 82cf 	bne.w	800f48c <silk_Decode+0x69c>
        for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800eeee:	2a00      	cmp	r2, #0
 800eef0:	f340 8272 	ble.w	800f3d8 <silk_Decode+0x5e8>
 800eef4:	f606 1b64 	addw	fp, r6, #2404	; 0x964
 800eef8:	465d      	mov	r5, fp
 800eefa:	46cb      	mov	fp, r9
 800eefc:	f8d7 a2e8 	ldr.w	sl, [r7, #744]	; 0x2e8
 800ef00:	61fe      	str	r6, [r7, #28]
            for( i = 0; i < channel_state[ n ].nFramesPerPacket; i++ ) {
 800ef02:	f855 2c0c 	ldr.w	r2, [r5, #-12]
 800ef06:	2a00      	cmp	r2, #0
 800ef08:	dd0e      	ble.n	800ef28 <silk_Decode+0x138>
 800ef0a:	462e      	mov	r6, r5
 800ef0c:	f04f 0800 	mov.w	r8, #0
                channel_state[ n ].VAD_flags[ i ] = ec_dec_bit_logp(psRangeDec, 1);
 800ef10:	2101      	movs	r1, #1
 800ef12:	4650      	mov	r0, sl
 800ef14:	f7f9 fae8 	bl	80084e8 <ec_dec_bit_logp>
 800ef18:	f846 0b04 	str.w	r0, [r6], #4
            for( i = 0; i < channel_state[ n ].nFramesPerPacket; i++ ) {
 800ef1c:	f855 3c0c 	ldr.w	r3, [r5, #-12]
 800ef20:	f108 0801 	add.w	r8, r8, #1
 800ef24:	4543      	cmp	r3, r8
 800ef26:	dcf3      	bgt.n	800ef10 <silk_Decode+0x120>
            channel_state[ n ].LBRR_flag = ec_dec_bit_logp(psRangeDec, 1);
 800ef28:	2101      	movs	r1, #1
 800ef2a:	4650      	mov	r0, sl
 800ef2c:	f7f9 fadc 	bl	80084e8 <ec_dec_bit_logp>
 800ef30:	60e8      	str	r0, [r5, #12]
        for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800ef32:	6862      	ldr	r2, [r4, #4]
 800ef34:	f10b 0b01 	add.w	fp, fp, #1
 800ef38:	f505 5585 	add.w	r5, r5, #4256	; 0x10a0
 800ef3c:	455a      	cmp	r2, fp
 800ef3e:	f105 0508 	add.w	r5, r5, #8
 800ef42:	dcde      	bgt.n	800ef02 <silk_Decode+0x112>
        for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800ef44:	2a00      	cmp	r2, #0
 800ef46:	69fe      	ldr	r6, [r7, #28]
 800ef48:	f340 8246 	ble.w	800f3d8 <silk_Decode+0x5e8>
            silk_memset( channel_state[ n ].LBRR_flags, 0, sizeof( channel_state[ n ].LBRR_flags ) );
 800ef4c:	f04f 0b00 	mov.w	fp, #0
                    LBRR_symbol = ec_dec_icdf( psRangeDec, silk_LBRR_flags_iCDF_ptr[ channel_state[ n ].nFramesPerPacket - 2 ], 8 ) + 1;
 800ef50:	f8df a738 	ldr.w	sl, [pc, #1848]	; 800f68c <silk_Decode+0x89c>
 800ef54:	f606 1874 	addw	r8, r6, #2420	; 0x974
 800ef58:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 800ef5a:	e00b      	b.n	800ef74 <silk_Decode+0x184>
                    channel_state[ n ].LBRR_flags[ 0 ] = 1;
 800ef5c:	f8c8 3000 	str.w	r3, [r8]
        for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800ef60:	6862      	ldr	r2, [r4, #4]
 800ef62:	f109 0901 	add.w	r9, r9, #1
 800ef66:	f508 5885 	add.w	r8, r8, #4256	; 0x10a0
 800ef6a:	454a      	cmp	r2, r9
 800ef6c:	f108 0808 	add.w	r8, r8, #8
 800ef70:	f340 8231 	ble.w	800f3d6 <silk_Decode+0x5e6>
            if( channel_state[ n ].LBRR_flag ) {
 800ef74:	f858 3c04 	ldr.w	r3, [r8, #-4]
            silk_memset( channel_state[ n ].LBRR_flags, 0, sizeof( channel_state[ n ].LBRR_flags ) );
 800ef78:	f8c8 b000 	str.w	fp, [r8]
 800ef7c:	f8c8 b004 	str.w	fp, [r8, #4]
 800ef80:	f8c8 b008 	str.w	fp, [r8, #8]
            if( channel_state[ n ].LBRR_flag ) {
 800ef84:	2b00      	cmp	r3, #0
 800ef86:	d0eb      	beq.n	800ef60 <silk_Decode+0x170>
                if( channel_state[ n ].nFramesPerPacket == 1 ) {
 800ef88:	f858 3c1c 	ldr.w	r3, [r8, #-28]
 800ef8c:	2b01      	cmp	r3, #1
 800ef8e:	d0e5      	beq.n	800ef5c <silk_Decode+0x16c>
                    LBRR_symbol = ec_dec_icdf( psRangeDec, silk_LBRR_flags_iCDF_ptr[ channel_state[ n ].nFramesPerPacket - 2 ], 8 ) + 1;
 800ef90:	3b02      	subs	r3, #2
 800ef92:	f85a 1023 	ldr.w	r1, [sl, r3, lsl #2]
 800ef96:	2208      	movs	r2, #8
 800ef98:	f8d7 02e8 	ldr.w	r0, [r7, #744]	; 0x2e8
 800ef9c:	f7f9 faf6 	bl	800858c <ec_dec_icdf>
                    for( i = 0; i < channel_state[ n ].nFramesPerPacket; i++ ) {
 800efa0:	f858 3c1c 	ldr.w	r3, [r8, #-28]
                    LBRR_symbol = ec_dec_icdf( psRangeDec, silk_LBRR_flags_iCDF_ptr[ channel_state[ n ].nFramesPerPacket - 2 ], 8 ) + 1;
 800efa4:	3001      	adds	r0, #1
                    for( i = 0; i < channel_state[ n ].nFramesPerPacket; i++ ) {
 800efa6:	2b00      	cmp	r3, #0
                        channel_state[ n ].LBRR_flags[ i ] = silk_RSHIFT( LBRR_symbol, i ) & 1;
 800efa8:	f000 0201 	and.w	r2, r0, #1
 800efac:	f3c0 0140 	ubfx	r1, r0, #1, #1
                    for( i = 0; i < channel_state[ n ].nFramesPerPacket; i++ ) {
 800efb0:	ddd6      	ble.n	800ef60 <silk_Decode+0x170>
 800efb2:	2b01      	cmp	r3, #1
                        channel_state[ n ].LBRR_flags[ i ] = silk_RSHIFT( LBRR_symbol, i ) & 1;
 800efb4:	f8c8 2000 	str.w	r2, [r8]
                    for( i = 0; i < channel_state[ n ].nFramesPerPacket; i++ ) {
 800efb8:	d0d2      	beq.n	800ef60 <silk_Decode+0x170>
 800efba:	2b02      	cmp	r3, #2
                        channel_state[ n ].LBRR_flags[ i ] = silk_RSHIFT( LBRR_symbol, i ) & 1;
 800efbc:	bf18      	it	ne
 800efbe:	f3c0 0080 	ubfxne	r0, r0, #2, #1
 800efc2:	f8c8 1004 	str.w	r1, [r8, #4]
 800efc6:	bf18      	it	ne
 800efc8:	f8c8 0008 	strne.w	r0, [r8, #8]
 800efcc:	e7c8      	b.n	800ef60 <silk_Decode+0x170>
            ret += silk_decoder_set_fs( &channel_state[ n ], fs_kHz_dec, decControl->API_sampleRate );
 800efce:	68a2      	ldr	r2, [r4, #8]
 800efd0:	4640      	mov	r0, r8
 800efd2:	f001 fd49 	bl	8010a68 <silk_decoder_set_fs>
        for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800efd6:	6862      	ldr	r2, [r4, #4]
 800efd8:	f10b 0b01 	add.w	fp, fp, #1
 800efdc:	f508 5885 	add.w	r8, r8, #4256	; 0x10a0
 800efe0:	455a      	cmp	r2, fp
            ret += silk_decoder_set_fs( &channel_state[ n ], fs_kHz_dec, decControl->API_sampleRate );
 800efe2:	4405      	add	r5, r0
 800efe4:	f108 0808 	add.w	r8, r8, #8
        for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800efe8:	f73f af36 	bgt.w	800ee58 <silk_Decode+0x68>
 800efec:	627d      	str	r5, [r7, #36]	; 0x24
    if( decControl->nChannelsAPI == 2 && decControl->nChannelsInternal == 2 && ( psDec->nChannelsAPI == 1 || psDec->nChannelsInternal == 1 ) ) {
 800efee:	6825      	ldr	r5, [r4, #0]
 800eff0:	2d02      	cmp	r5, #2
 800eff2:	4629      	mov	r1, r5
 800eff4:	f47f af61 	bne.w	800eeba <silk_Decode+0xca>
 800eff8:	2a02      	cmp	r2, #2
 800effa:	f47f af5e 	bne.w	800eeba <silk_Decode+0xca>
 800effe:	f242 115c 	movw	r1, #8540	; 0x215c
 800f002:	5871      	ldr	r1, [r6, r1]
 800f004:	2901      	cmp	r1, #1
 800f006:	f000 832b 	beq.w	800f660 <silk_Decode+0x870>
 800f00a:	f242 1160 	movw	r1, #8544	; 0x2160
 800f00e:	5871      	ldr	r1, [r6, r1]
 800f010:	2901      	cmp	r1, #1
 800f012:	f000 8325 	beq.w	800f660 <silk_Decode+0x870>
 800f016:	4611      	mov	r1, r2
 800f018:	e74f      	b.n	800eeba <silk_Decode+0xca>
                channel_state[ n ].nFramesPerPacket = 1;
 800f01a:	2301      	movs	r3, #1
                channel_state[ n ].nb_subfr = 2;
 800f01c:	f8c8 9914 	str.w	r9, [r8, #2324]	; 0x914
                channel_state[ n ].nFramesPerPacket = 1;
 800f020:	f8c8 3958 	str.w	r3, [r8, #2392]	; 0x958
 800f024:	e72d      	b.n	800ee82 <silk_Decode+0x92>
                channel_state[ n ].nFramesPerPacket = 1;
 800f026:	2301      	movs	r3, #1
                channel_state[ n ].nb_subfr = 4;
 800f028:	f8c8 a914 	str.w	sl, [r8, #2324]	; 0x914
                channel_state[ n ].nFramesPerPacket = 1;
 800f02c:	f8c8 3958 	str.w	r3, [r8, #2392]	; 0x958
 800f030:	e727      	b.n	800ee82 <silk_Decode+0x92>
                channel_state[ n ].nFramesPerPacket = 2;
 800f032:	f8c8 9958 	str.w	r9, [r8, #2392]	; 0x958
                channel_state[ n ].nb_subfr = 4;
 800f036:	f8c8 a914 	str.w	sl, [r8, #2324]	; 0x914
 800f03a:	e722      	b.n	800ee82 <silk_Decode+0x92>
    stereo_to_mono = decControl->nChannelsInternal == 1 && psDec->nChannelsInternal == 2 &&
 800f03c:	f242 1360 	movw	r3, #8544	; 0x2160
 800f040:	58f3      	ldr	r3, [r6, r3]
 800f042:	2b02      	cmp	r3, #2
 800f044:	f000 82f6 	beq.w	800f634 <silk_Decode+0x844>
    if( channel_state[ 0 ].nFramesDecoded == 0 ) {
 800f048:	693b      	ldr	r3, [r7, #16]
 800f04a:	2b00      	cmp	r3, #0
 800f04c:	f43f aefc 	beq.w	800ee48 <silk_Decode+0x58>
    if( decControl->nChannelsAPI == 2 && decControl->nChannelsInternal == 2 && ( psDec->nChannelsAPI == 1 || psDec->nChannelsInternal == 1 ) ) {
 800f050:	2300      	movs	r3, #0
 800f052:	6825      	ldr	r5, [r4, #0]
 800f054:	613b      	str	r3, [r7, #16]
 800f056:	4629      	mov	r1, r5
 800f058:	e72f      	b.n	800eeba <silk_Decode+0xca>
        ret += silk_init_decoder( &channel_state[ 1 ] );
 800f05a:	f506 5085 	add.w	r0, r6, #4256	; 0x10a0
 800f05e:	3008      	adds	r0, #8
 800f060:	f001 fe3a 	bl	8010cd8 <silk_init_decoder>
 800f064:	6862      	ldr	r2, [r4, #4]
 800f066:	6278      	str	r0, [r7, #36]	; 0x24
 800f068:	e6e5      	b.n	800ee36 <silk_Decode+0x46>
    if( decControl->nChannelsInternal == 2 ) {
 800f06a:	2a02      	cmp	r2, #2
 800f06c:	f000 821c 	beq.w	800f4a8 <silk_Decode+0x6b8>
 800f070:	4684      	mov	ip, r0
 800f072:	4629      	mov	r1, r5
    delay_stack_alloc = decControl->internalSampleRate*decControl->nChannelsInternal
 800f074:	68e0      	ldr	r0, [r4, #12]
          < decControl->API_sampleRate*decControl->nChannelsAPI;
 800f076:	fb01 f10c 	mul.w	r1, r1, ip
    delay_stack_alloc = decControl->internalSampleRate*decControl->nChannelsInternal
 800f07a:	fb00 f002 	mul.w	r0, r0, r2
    ALLOC( samplesOut1_tmp_storage1, delay_stack_alloc ? ALLOC_NONE
 800f07e:	4603      	mov	r3, r0
          < decControl->API_sampleRate*decControl->nChannelsAPI;
 800f080:	60f9      	str	r1, [r7, #12]
    delay_stack_alloc = decControl->internalSampleRate*decControl->nChannelsInternal
 800f082:	60b8      	str	r0, [r7, #8]
 800f084:	f8d6 1918 	ldr.w	r1, [r6, #2328]	; 0x918
    ALLOC( samplesOut1_tmp_storage1, delay_stack_alloc ? ALLOC_NONE
 800f088:	68f8      	ldr	r0, [r7, #12]
 800f08a:	3102      	adds	r1, #2
 800f08c:	4283      	cmp	r3, r0
 800f08e:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800f092:	f2c0 812a 	blt.w	800f2ea <silk_Decode+0x4fa>
 800f096:	fb02 f101 	mul.w	r1, r2, r1
 800f09a:	0049      	lsls	r1, r1, #1
 800f09c:	3108      	adds	r1, #8
 800f09e:	f021 0107 	bic.w	r1, r1, #7
 800f0a2:	f8c7 d004 	str.w	sp, [r7, #4]
 800f0a6:	ebad 0d01 	sub.w	sp, sp, r1
 800f0aa:	f10d 0a10 	add.w	sl, sp, #16
       samplesOut1_tmp[ 1 ] = samplesOut1_tmp_storage1 + channel_state[ 0 ].frame_length + 2;
 800f0ae:	eb0a 000c 	add.w	r0, sl, ip
       samplesOut1_tmp[ 0 ] = samplesOut1_tmp_storage1;
 800f0b2:	f107 0330 	add.w	r3, r7, #48	; 0x30
       samplesOut1_tmp[ 1 ] = samplesOut1_tmp_storage1 + channel_state[ 0 ].frame_length + 2;
 800f0b6:	6038      	str	r0, [r7, #0]
       samplesOut1_tmp[ 0 ] = samplesOut1_tmp_storage1;
 800f0b8:	61bb      	str	r3, [r7, #24]
       samplesOut1_tmp[ 1 ] = samplesOut1_tmp_storage1 + channel_state[ 0 ].frame_length + 2;
 800f0ba:	6058      	str	r0, [r3, #4]
       samplesOut1_tmp[ 0 ] = samplesOut1_tmp_storage1;
 800f0bc:	f8c7 a030 	str.w	sl, [r7, #48]	; 0x30
    if( lostFlag == FLAG_DECODE_NORMAL ) {
 800f0c0:	6a3b      	ldr	r3, [r7, #32]
 800f0c2:	2b00      	cmp	r3, #0
 800f0c4:	f040 80e9 	bne.w	800f29a <silk_Decode+0x4aa>
        has_side = !decode_only_middle;
 800f0c8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800f0ca:	fab1 fb81 	clz	fp, r1
 800f0ce:	ea4f 1b5b 	mov.w	fp, fp, lsr #5
    for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800f0d2:	2a00      	cmp	r2, #0
 800f0d4:	f340 80ef 	ble.w	800f2b6 <silk_Decode+0x4c6>
              || (decControl->nChannelsInternal == 2 && lostFlag == FLAG_DECODE_LBRR && channel_state[1].LBRR_flags[ channel_state[1].nFramesDecoded ] == 1 );
 800f0d8:	4652      	mov	r2, sl
 800f0da:	f04f 0900 	mov.w	r9, #0
            } else if( n > 0 && psDec->prev_decode_only_middle ) {
 800f0de:	f506 5305 	add.w	r3, r6, #8512	; 0x2140
 800f0e2:	3324      	adds	r3, #36	; 0x24
 800f0e4:	617b      	str	r3, [r7, #20]
 800f0e6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800f0ea:	46b0      	mov	r8, r6
 800f0ec:	61fb      	str	r3, [r7, #28]
 800f0ee:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 800f0f0:	3204      	adds	r2, #4
        if( n == 0 || has_side ) {
 800f0f2:	f1b9 0f00 	cmp.w	r9, #0
 800f0f6:	d003      	beq.n	800f100 <silk_Decode+0x310>
 800f0f8:	f1bb 0f00 	cmp.w	fp, #0
 800f0fc:	f000 8163 	beq.w	800f3c6 <silk_Decode+0x5d6>
            FrameIndex = channel_state[ 0 ].nFramesDecoded - n;
 800f100:	f8d6 3954 	ldr.w	r3, [r6, #2388]	; 0x954
 800f104:	eba3 0309 	sub.w	r3, r3, r9
            if( FrameIndex <= 0 ) {
 800f108:	2b00      	cmp	r3, #0
 800f10a:	dd35      	ble.n	800f178 <silk_Decode+0x388>
            } else if( lostFlag == FLAG_DECODE_LBRR ) {
 800f10c:	6a39      	ldr	r1, [r7, #32]
 800f10e:	2902      	cmp	r1, #2
 800f110:	f000 810d 	beq.w	800f32e <silk_Decode+0x53e>
            } else if( n > 0 && psDec->prev_decode_only_middle ) {
 800f114:	f1b9 0f01 	cmp.w	r9, #1
 800f118:	f040 81d7 	bne.w	800f4ca <silk_Decode+0x6da>
 800f11c:	697b      	ldr	r3, [r7, #20]
 800f11e:	681b      	ldr	r3, [r3, #0]
                condCoding = CODE_INDEPENDENTLY_NO_LTP_SCALING;
 800f120:	2b00      	cmp	r3, #0
 800f122:	bf0c      	ite	eq
 800f124:	2302      	moveq	r3, #2
 800f126:	2301      	movne	r3, #1
            ret += silk_decode_frame( &channel_state[ n ], psRangeDec, &samplesOut1_tmp[ n ][ 2 ], &nSamplesOutDec, lostFlag, condCoding, arch);
 800f128:	f8d7 12f4 	ldr.w	r1, [r7, #756]	; 0x2f4
 800f12c:	4640      	mov	r0, r8
 800f12e:	e9cd 3101 	strd	r3, r1, [sp, #4]
 800f132:	6a3b      	ldr	r3, [r7, #32]
 800f134:	9300      	str	r3, [sp, #0]
 800f136:	69fb      	ldr	r3, [r7, #28]
 800f138:	f8d7 12e8 	ldr.w	r1, [r7, #744]	; 0x2e8
 800f13c:	f000 ff54 	bl	800ffe8 <silk_decode_frame>
 800f140:	4405      	add	r5, r0
        channel_state[ n ].nFramesDecoded++;
 800f142:	f8d8 3954 	ldr.w	r3, [r8, #2388]	; 0x954
    for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800f146:	f109 0901 	add.w	r9, r9, #1
        channel_state[ n ].nFramesDecoded++;
 800f14a:	3301      	adds	r3, #1
 800f14c:	f8c8 3954 	str.w	r3, [r8, #2388]	; 0x954
    for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800f150:	6862      	ldr	r2, [r4, #4]
 800f152:	f508 5885 	add.w	r8, r8, #4256	; 0x10a0
 800f156:	454a      	cmp	r2, r9
 800f158:	f108 0808 	add.w	r8, r8, #8
 800f15c:	dd0e      	ble.n	800f17c <silk_Decode+0x38c>
 800f15e:	69bb      	ldr	r3, [r7, #24]
 800f160:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 800f164:	3204      	adds	r2, #4
        if( n == 0 || has_side ) {
 800f166:	f1b9 0f00 	cmp.w	r9, #0
 800f16a:	d1c5      	bne.n	800f0f8 <silk_Decode+0x308>
            FrameIndex = channel_state[ 0 ].nFramesDecoded - n;
 800f16c:	f8d6 3954 	ldr.w	r3, [r6, #2388]	; 0x954
 800f170:	eba3 0309 	sub.w	r3, r3, r9
            if( FrameIndex <= 0 ) {
 800f174:	2b00      	cmp	r3, #0
 800f176:	dcc9      	bgt.n	800f10c <silk_Decode+0x31c>
                condCoding = channel_state[ n ].LBRR_flags[ FrameIndex - 1 ] ? CODE_CONDITIONALLY : CODE_INDEPENDENTLY;
 800f178:	2300      	movs	r3, #0
 800f17a:	e7d5      	b.n	800f128 <silk_Decode+0x338>
 800f17c:	627d      	str	r5, [r7, #36]	; 0x24
 800f17e:	6825      	ldr	r5, [r4, #0]
 800f180:	69fb      	ldr	r3, [r7, #28]
    if( decControl->nChannelsAPI == 2 && decControl->nChannelsInternal == 2 ) {
 800f182:	2d02      	cmp	r5, #2
 800f184:	6819      	ldr	r1, [r3, #0]
 800f186:	f000 809d 	beq.w	800f2c4 <silk_Decode+0x4d4>
        silk_memcpy( samplesOut1_tmp[ 0 ], psDec->sStereo.sMid, 2 * sizeof( opus_int16 ) );
 800f18a:	f242 1354 	movw	r3, #8532	; 0x2154
 800f18e:	58f2      	ldr	r2, [r6, r3]
 800f190:	f8ca 2000 	str.w	r2, [sl]
        silk_memcpy( psDec->sStereo.sMid, &samplesOut1_tmp[ 0 ][ nSamplesOutDec ], 2 * sizeof( opus_int16 ) );
 800f194:	f85a 2011 	ldr.w	r2, [sl, r1, lsl #1]
 800f198:	50f2      	str	r2, [r6, r3]
    *nSamplesOut = silk_DIV32( nSamplesOutDec * decControl->API_sampleRate, silk_SMULBB( channel_state[ 0 ].fs_kHz, 1000 ) );
 800f19a:	68a3      	ldr	r3, [r4, #8]
 800f19c:	f9b6 290c 	ldrsh.w	r2, [r6, #2316]	; 0x90c
 800f1a0:	fb03 f301 	mul.w	r3, r3, r1
 800f1a4:	ebc2 1142 	rsb	r1, r2, r2, lsl #5
 800f1a8:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 800f1ac:	00d2      	lsls	r2, r2, #3
 800f1ae:	fb93 f3f2 	sdiv	r3, r3, r2
 800f1b2:	f8d7 22f0 	ldr.w	r2, [r7, #752]	; 0x2f0
 800f1b6:	6013      	str	r3, [r2, #0]
    ALLOC( samplesOut2_tmp,
 800f1b8:	f8d4 8000 	ldr.w	r8, [r4]
 800f1bc:	f1b8 0f02 	cmp.w	r8, #2
 800f1c0:	f000 80cb 	beq.w	800f35a <silk_Decode+0x56a>
 800f1c4:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 800f1c8:	617b      	str	r3, [r7, #20]
    ALLOC( samplesOut1_tmp_storage2, delay_stack_alloc
 800f1ca:	e9d7 2102 	ldrd	r2, r1, [r7, #8]
 800f1ce:	428a      	cmp	r2, r1
 800f1d0:	6863      	ldr	r3, [r4, #4]
 800f1d2:	da1b      	bge.n	800f20c <silk_Decode+0x41c>
 800f1d4:	f8d6 2918 	ldr.w	r2, [r6, #2328]	; 0x918
       OPUS_COPY(samplesOut1_tmp_storage2, samplesOut, decControl->nChannelsInternal*(channel_state[ 0 ].frame_length + 2));
 800f1d8:	f8d7 12ec 	ldr.w	r1, [r7, #748]	; 0x2ec
    ALLOC( samplesOut1_tmp_storage2, delay_stack_alloc
 800f1dc:	f102 0902 	add.w	r9, r2, #2
 800f1e0:	fb03 f209 	mul.w	r2, r3, r9
 800f1e4:	0052      	lsls	r2, r2, #1
 800f1e6:	f102 0008 	add.w	r0, r2, #8
 800f1ea:	f020 0007 	bic.w	r0, r0, #7
 800f1ee:	ebad 0d00 	sub.w	sp, sp, r0
 800f1f2:	f10d 0a10 	add.w	sl, sp, #16
       OPUS_COPY(samplesOut1_tmp_storage2, samplesOut, decControl->nChannelsInternal*(channel_state[ 0 ].frame_length + 2));
 800f1f6:	4650      	mov	r0, sl
    ALLOC( samplesOut1_tmp_storage2, delay_stack_alloc
 800f1f8:	60fb      	str	r3, [r7, #12]
       OPUS_COPY(samplesOut1_tmp_storage2, samplesOut, decControl->nChannelsInternal*(channel_state[ 0 ].frame_length + 2));
 800f1fa:	f004 ff71 	bl	80140e0 <memcpy>
       samplesOut1_tmp[ 1 ] = samplesOut1_tmp_storage2 + channel_state[ 0 ].frame_length + 2;
 800f1fe:	69bb      	ldr	r3, [r7, #24]
 800f200:	eb0a 0249 	add.w	r2, sl, r9, lsl #1
 800f204:	605a      	str	r2, [r3, #4]
       samplesOut1_tmp[ 0 ] = samplesOut1_tmp_storage2;
 800f206:	f8c3 a000 	str.w	sl, [r3]
 800f20a:	68fb      	ldr	r3, [r7, #12]
    for( n = 0; n < silk_min( decControl->nChannelsAPI, decControl->nChannelsInternal ); n++ ) {
 800f20c:	4598      	cmp	r8, r3
 800f20e:	4642      	mov	r2, r8
 800f210:	bfa8      	it	ge
 800f212:	461a      	movge	r2, r3
 800f214:	2a00      	cmp	r2, #0
 800f216:	dd26      	ble.n	800f266 <silk_Decode+0x476>
 800f218:	f04f 0900 	mov.w	r9, #0
 800f21c:	f8d7 a2ec 	ldr.w	sl, [r7, #748]	; 0x2ec
 800f220:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 800f222:	f8d7 8018 	ldr.w	r8, [r7, #24]
 800f226:	f506 6b18 	add.w	fp, r6, #2432	; 0x980
        ret += silk_resampler( &channel_state[ n ].resampler_state, resample_out_ptr, &samplesOut1_tmp[ n ][ 1 ], nSamplesOutDec );
 800f22a:	f858 2029 	ldr.w	r2, [r8, r9, lsl #2]
 800f22e:	69fb      	ldr	r3, [r7, #28]
 800f230:	3202      	adds	r2, #2
 800f232:	681b      	ldr	r3, [r3, #0]
 800f234:	6979      	ldr	r1, [r7, #20]
 800f236:	4658      	mov	r0, fp
 800f238:	f001 feb4 	bl	8010fa4 <silk_resampler>
        if( decControl->nChannelsAPI == 2 ) {
 800f23c:	6822      	ldr	r2, [r4, #0]
        ret += silk_resampler( &channel_state[ n ].resampler_state, resample_out_ptr, &samplesOut1_tmp[ n ][ 1 ], nSamplesOutDec );
 800f23e:	4405      	add	r5, r0
        if( decControl->nChannelsAPI == 2 ) {
 800f240:	2a02      	cmp	r2, #2
 800f242:	d062      	beq.n	800f30a <silk_Decode+0x51a>
    for( n = 0; n < silk_min( decControl->nChannelsAPI, decControl->nChannelsInternal ); n++ ) {
 800f244:	6863      	ldr	r3, [r4, #4]
 800f246:	4611      	mov	r1, r2
 800f248:	429a      	cmp	r2, r3
 800f24a:	bfa8      	it	ge
 800f24c:	4619      	movge	r1, r3
 800f24e:	f109 0901 	add.w	r9, r9, #1
 800f252:	f50b 5b85 	add.w	fp, fp, #4256	; 0x10a0
 800f256:	4549      	cmp	r1, r9
 800f258:	f10b 0b08 	add.w	fp, fp, #8
 800f25c:	f10a 0a02 	add.w	sl, sl, #2
 800f260:	dce3      	bgt.n	800f22a <silk_Decode+0x43a>
 800f262:	4690      	mov	r8, r2
 800f264:	627d      	str	r5, [r7, #36]	; 0x24
    if( decControl->nChannelsAPI == 2 && decControl->nChannelsInternal == 1 ) {
 800f266:	f1b8 0f02 	cmp.w	r8, #2
 800f26a:	f000 8092 	beq.w	800f392 <silk_Decode+0x5a2>
    if( channel_state[ 0 ].prevSignalType == TYPE_VOICED ) {
 800f26e:	f241 0344 	movw	r3, #4164	; 0x1044
 800f272:	58f3      	ldr	r3, [r6, r3]
 800f274:	2b02      	cmp	r3, #2
 800f276:	d079      	beq.n	800f36c <silk_Decode+0x57c>
        decControl->prevPitchLag = 0;
 800f278:	2300      	movs	r3, #0
 800f27a:	6163      	str	r3, [r4, #20]
    if( lostFlag == FLAG_PACKET_LOST ) {
 800f27c:	6a3b      	ldr	r3, [r7, #32]
 800f27e:	2b01      	cmp	r3, #1
 800f280:	d05d      	beq.n	800f33e <silk_Decode+0x54e>
       psDec->prev_decode_only_middle = decode_only_middle;
 800f282:	f242 1364 	movw	r3, #8548	; 0x2164
 800f286:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f288:	50f2      	str	r2, [r6, r3]
 800f28a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800f28c:	f8d7 d004 	ldr.w	sp, [r7, #4]
}
 800f290:	f507 7731 	add.w	r7, r7, #708	; 0x2c4
 800f294:	46bd      	mov	sp, r7
 800f296:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        has_side = !psDec->prev_decode_only_middle
 800f29a:	f242 1164 	movw	r1, #8548	; 0x2164
              || (decControl->nChannelsInternal == 2 && lostFlag == FLAG_DECODE_LBRR && channel_state[1].LBRR_flags[ channel_state[1].nFramesDecoded ] == 1 );
 800f29e:	5871      	ldr	r1, [r6, r1]
 800f2a0:	2900      	cmp	r1, #0
 800f2a2:	f000 8114 	beq.w	800f4ce <silk_Decode+0x6de>
 800f2a6:	2a02      	cmp	r2, #2
 800f2a8:	f000 81d5 	beq.w	800f656 <silk_Decode+0x866>
    for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800f2ac:	2a00      	cmp	r2, #0
              || (decControl->nChannelsInternal == 2 && lostFlag == FLAG_DECODE_LBRR && channel_state[1].LBRR_flags[ channel_state[1].nFramesDecoded ] == 1 );
 800f2ae:	f04f 0b00 	mov.w	fp, #0
    for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800f2b2:	f73f af11 	bgt.w	800f0d8 <silk_Decode+0x2e8>
 800f2b6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
    if( decControl->nChannelsAPI == 2 && decControl->nChannelsInternal == 2 ) {
 800f2ba:	2d02      	cmp	r5, #2
 800f2bc:	61fb      	str	r3, [r7, #28]
 800f2be:	6819      	ldr	r1, [r3, #0]
 800f2c0:	f47f af63 	bne.w	800f18a <silk_Decode+0x39a>
 800f2c4:	2a02      	cmp	r2, #2
 800f2c6:	f47f af60 	bne.w	800f18a <silk_Decode+0x39a>
        silk_stereo_MS_to_LR( &psDec->sStereo, samplesOut1_tmp[ 0 ], samplesOut1_tmp[ 1 ], MS_pred_Q13, channel_state[ 0 ].fs_kHz, nSamplesOutDec );
 800f2ca:	9101      	str	r1, [sp, #4]
 800f2cc:	f8d6 590c 	ldr.w	r5, [r6, #2316]	; 0x90c
 800f2d0:	f506 5005 	add.w	r0, r6, #8512	; 0x2140
 800f2d4:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800f2d8:	683a      	ldr	r2, [r7, #0]
 800f2da:	4651      	mov	r1, sl
 800f2dc:	9500      	str	r5, [sp, #0]
 800f2de:	3010      	adds	r0, #16
 800f2e0:	f002 fcf4 	bl	8011ccc <silk_stereo_MS_to_LR>
 800f2e4:	69fb      	ldr	r3, [r7, #28]
 800f2e6:	6819      	ldr	r1, [r3, #0]
 800f2e8:	e757      	b.n	800f19a <silk_Decode+0x3aa>
       samplesOut1_tmp[ 1 ] = samplesOut + channel_state[ 0 ].frame_length + 2;
 800f2ea:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
       samplesOut1_tmp[ 0 ] = samplesOut;
 800f2ee:	f8d7 12ec 	ldr.w	r1, [r7, #748]	; 0x2ec
       samplesOut1_tmp[ 1 ] = samplesOut + channel_state[ 0 ].frame_length + 2;
 800f2f2:	eb03 000c 	add.w	r0, r3, ip
       samplesOut1_tmp[ 0 ] = samplesOut;
 800f2f6:	f107 0330 	add.w	r3, r7, #48	; 0x30
       samplesOut1_tmp[ 1 ] = samplesOut + channel_state[ 0 ].frame_length + 2;
 800f2fa:	6038      	str	r0, [r7, #0]
       samplesOut1_tmp[ 0 ] = samplesOut;
 800f2fc:	61bb      	str	r3, [r7, #24]
       samplesOut1_tmp[ 1 ] = samplesOut + channel_state[ 0 ].frame_length + 2;
 800f2fe:	6058      	str	r0, [r3, #4]
       samplesOut1_tmp[ 0 ] = samplesOut;
 800f300:	6339      	str	r1, [r7, #48]	; 0x30
    ALLOC( samplesOut1_tmp_storage1, delay_stack_alloc ? ALLOC_NONE
 800f302:	f8c7 d004 	str.w	sp, [r7, #4]
 800f306:	468a      	mov	sl, r1
 800f308:	e6da      	b.n	800f0c0 <silk_Decode+0x2d0>
            for( i = 0; i < *nSamplesOut; i++ ) {
 800f30a:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 800f30e:	f8d3 c000 	ldr.w	ip, [r3]
 800f312:	f1bc 0f00 	cmp.w	ip, #0
 800f316:	dd95      	ble.n	800f244 <silk_Decode+0x454>
 800f318:	2300      	movs	r3, #0
 800f31a:	6979      	ldr	r1, [r7, #20]
 800f31c:	3902      	subs	r1, #2
                samplesOut[ n + 2 * i ] = resample_out_ptr[ i ];
 800f31e:	f931 0f02 	ldrsh.w	r0, [r1, #2]!
 800f322:	f82a 0023 	strh.w	r0, [sl, r3, lsl #2]
            for( i = 0; i < *nSamplesOut; i++ ) {
 800f326:	3301      	adds	r3, #1
 800f328:	4563      	cmp	r3, ip
 800f32a:	d1f8      	bne.n	800f31e <silk_Decode+0x52e>
 800f32c:	e78a      	b.n	800f244 <silk_Decode+0x454>
                condCoding = channel_state[ n ].LBRR_flags[ FrameIndex - 1 ] ? CODE_CONDITIONALLY : CODE_INDEPENDENTLY;
 800f32e:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 800f332:	f8d3 3970 	ldr.w	r3, [r3, #2416]	; 0x970
                condCoding = CODE_CONDITIONALLY;
 800f336:	2b00      	cmp	r3, #0
 800f338:	bf18      	it	ne
 800f33a:	2302      	movne	r3, #2
 800f33c:	e6f4      	b.n	800f128 <silk_Decode+0x338>
       for ( i = 0; i < psDec->nChannelsInternal; i++ )
 800f33e:	f242 1360 	movw	r3, #8544	; 0x2160
 800f342:	58f3      	ldr	r3, [r6, r3]
 800f344:	2b00      	cmp	r3, #0
 800f346:	dda0      	ble.n	800f28a <silk_Decode+0x49a>
          psDec->channel_state[ i ].LastGainIndex = 10;
 800f348:	220a      	movs	r2, #10
       for ( i = 0; i < psDec->nChannelsInternal; i++ )
 800f34a:	2b01      	cmp	r3, #1
          psDec->channel_state[ i ].LastGainIndex = 10;
 800f34c:	f886 2908 	strb.w	r2, [r6, #2312]	; 0x908
       for ( i = 0; i < psDec->nChannelsInternal; i++ )
 800f350:	d09b      	beq.n	800f28a <silk_Decode+0x49a>
          psDec->channel_state[ i ].LastGainIndex = 10;
 800f352:	f641 13b0 	movw	r3, #6576	; 0x19b0
 800f356:	54f2      	strb	r2, [r6, r3]
 800f358:	e797      	b.n	800f28a <silk_Decode+0x49a>
    ALLOC( samplesOut2_tmp,
 800f35a:	005b      	lsls	r3, r3, #1
 800f35c:	3308      	adds	r3, #8
 800f35e:	f023 0307 	bic.w	r3, r3, #7
 800f362:	ebad 0d03 	sub.w	sp, sp, r3
 800f366:	ab04      	add	r3, sp, #16
 800f368:	617b      	str	r3, [r7, #20]
 800f36a:	e72e      	b.n	800f1ca <silk_Decode+0x3da>
        int mult_tab[ 3 ] = { 6, 4, 3 };
 800f36c:	4bc6      	ldr	r3, [pc, #792]	; (800f688 <silk_Decode+0x898>)
 800f36e:	f107 0c40 	add.w	ip, r7, #64	; 0x40
 800f372:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
        decControl->prevPitchLag = channel_state[ 0 ].lagPrev * mult_tab[ ( channel_state[ 0 ].fs_kHz - 8 ) >> 2 ];
 800f376:	f8d6 390c 	ldr.w	r3, [r6, #2316]	; 0x90c
        int mult_tab[ 3 ] = { 6, 4, 3 };
 800f37a:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
        decControl->prevPitchLag = channel_state[ 0 ].lagPrev * mult_tab[ ( channel_state[ 0 ].fs_kHz - 8 ) >> 2 ];
 800f37e:	3b08      	subs	r3, #8
 800f380:	109b      	asrs	r3, r3, #2
 800f382:	f8d6 2904 	ldr.w	r2, [r6, #2308]	; 0x904
 800f386:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
 800f38a:	fb02 f203 	mul.w	r2, r2, r3
 800f38e:	6162      	str	r2, [r4, #20]
 800f390:	e774      	b.n	800f27c <silk_Decode+0x48c>
    if( decControl->nChannelsAPI == 2 && decControl->nChannelsInternal == 1 ) {
 800f392:	2b01      	cmp	r3, #1
 800f394:	f47f af6b 	bne.w	800f26e <silk_Decode+0x47e>
        if ( stereo_to_mono ){
 800f398:	693b      	ldr	r3, [r7, #16]
 800f39a:	2b00      	cmp	r3, #0
 800f39c:	f040 818d 	bne.w	800f6ba <silk_Decode+0x8ca>
            for( i = 0; i < *nSamplesOut; i++ ) {
 800f3a0:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 800f3a4:	6819      	ldr	r1, [r3, #0]
 800f3a6:	2900      	cmp	r1, #0
 800f3a8:	f77f af61 	ble.w	800f26e <silk_Decode+0x47e>
 800f3ac:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 800f3b0:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 800f3b2:	eb03 0181 	add.w	r1, r3, r1, lsl #2
                samplesOut[ 1 + 2 * i ] = samplesOut[ 0 + 2 * i ];
 800f3b6:	881a      	ldrh	r2, [r3, #0]
 800f3b8:	3304      	adds	r3, #4
 800f3ba:	f823 2c02 	strh.w	r2, [r3, #-2]
            for( i = 0; i < *nSamplesOut; i++ ) {
 800f3be:	4299      	cmp	r1, r3
 800f3c0:	d1f9      	bne.n	800f3b6 <silk_Decode+0x5c6>
 800f3c2:	627d      	str	r5, [r7, #36]	; 0x24
 800f3c4:	e753      	b.n	800f26e <silk_Decode+0x47e>
            silk_memset( &samplesOut1_tmp[ n ][ 2 ], 0, nSamplesOutDec * sizeof( opus_int16 ) );
 800f3c6:	69fb      	ldr	r3, [r7, #28]
 800f3c8:	4610      	mov	r0, r2
 800f3ca:	681b      	ldr	r3, [r3, #0]
 800f3cc:	4659      	mov	r1, fp
 800f3ce:	005a      	lsls	r2, r3, #1
 800f3d0:	f004 feaa 	bl	8014128 <memset>
 800f3d4:	e6b5      	b.n	800f142 <silk_Decode+0x352>
 800f3d6:	627d      	str	r5, [r7, #36]	; 0x24
        if( lostFlag == FLAG_DECODE_NORMAL ) {
 800f3d8:	6a3b      	ldr	r3, [r7, #32]
 800f3da:	2b00      	cmp	r3, #0
 800f3dc:	d17a      	bne.n	800f4d4 <silk_Decode+0x6e4>
            for( i = 0; i < channel_state[ 0 ].nFramesPerPacket; i++ ) {
 800f3de:	f8d6 3958 	ldr.w	r3, [r6, #2392]	; 0x958
 800f3e2:	2b00      	cmp	r3, #0
 800f3e4:	f340 8084 	ble.w	800f4f0 <silk_Decode+0x700>
 800f3e8:	4631      	mov	r1, r6
 800f3ea:	f8d7 b020 	ldr.w	fp, [r7, #32]
 800f3ee:	46a1      	mov	r9, r4
 800f3f0:	465e      	mov	r6, fp
 800f3f2:	468a      	mov	sl, r1
 800f3f4:	f8d7 82e8 	ldr.w	r8, [r7, #744]	; 0x2e8
                for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800f3f8:	2a00      	cmp	r2, #0
 800f3fa:	dd72      	ble.n	800f4e2 <silk_Decode+0x6f2>
 800f3fc:	2e00      	cmp	r6, #0
 800f3fe:	f000 80db 	beq.w	800f5b8 <silk_Decode+0x7c8>
                            if( channel_state[ 1 ].LBRR_flags[ i ] == 0 ) {
 800f402:	f50b 53d0 	add.w	r3, fp, #6656	; 0x1a00
 800f406:	331c      	adds	r3, #28
 800f408:	4453      	add	r3, sl
 800f40a:	4655      	mov	r5, sl
                for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800f40c:	2400      	movs	r4, #0
                            if( channel_state[ 1 ].LBRR_flags[ i ] == 0 ) {
 800f40e:	61fb      	str	r3, [r7, #28]
 800f410:	e020      	b.n	800f454 <silk_Decode+0x664>
                        if( i > 0 && channel_state[ n ].LBRR_flags[ i - 1 ] ) {
 800f412:	f8d3 1970 	ldr.w	r1, [r3, #2416]	; 0x970
                        silk_decode_indices( &channel_state[ n ], psRangeDec, i, 1, condCoding );
 800f416:	4632      	mov	r2, r6
                            condCoding = CODE_CONDITIONALLY;
 800f418:	2900      	cmp	r1, #0
 800f41a:	bf18      	it	ne
 800f41c:	2102      	movne	r1, #2
                        silk_decode_indices( &channel_state[ n ], psRangeDec, i, 1, condCoding );
 800f41e:	2301      	movs	r3, #1
 800f420:	9100      	str	r1, [sp, #0]
 800f422:	4628      	mov	r0, r5
 800f424:	4641      	mov	r1, r8
 800f426:	f000 fe87 	bl	8010138 <silk_decode_indices>
                        silk_decode_pulses( psRangeDec, pulses, channel_state[ n ].indices.signalType,
 800f42a:	f8d5 1918 	ldr.w	r1, [r5, #2328]	; 0x918
 800f42e:	f995 2acd 	ldrsb.w	r2, [r5, #2765]	; 0xacd
 800f432:	f995 3ace 	ldrsb.w	r3, [r5, #2766]	; 0xace
 800f436:	4640      	mov	r0, r8
 800f438:	9100      	str	r1, [sp, #0]
 800f43a:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800f43e:	f001 fa55 	bl	80108ec <silk_decode_pulses>
 800f442:	f8d9 2004 	ldr.w	r2, [r9, #4]
                for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800f446:	3401      	adds	r4, #1
 800f448:	f505 5585 	add.w	r5, r5, #4256	; 0x10a0
 800f44c:	4294      	cmp	r4, r2
 800f44e:	f105 0508 	add.w	r5, r5, #8
 800f452:	da44      	bge.n	800f4de <silk_Decode+0x6ee>
 800f454:	eb05 030b 	add.w	r3, r5, fp
                    if( channel_state[ n ].LBRR_flags[ i ] ) {
 800f458:	f8d3 1974 	ldr.w	r1, [r3, #2420]	; 0x974
 800f45c:	2900      	cmp	r1, #0
 800f45e:	d0f2      	beq.n	800f446 <silk_Decode+0x656>
                        if( decControl->nChannelsInternal == 2 && n == 0 ) {
 800f460:	2a02      	cmp	r2, #2
 800f462:	d1d6      	bne.n	800f412 <silk_Decode+0x622>
 800f464:	2c00      	cmp	r4, #0
 800f466:	d1d4      	bne.n	800f412 <silk_Decode+0x622>
                            silk_stereo_decode_pred( psRangeDec, MS_pred_Q13 );
 800f468:	f107 0138 	add.w	r1, r7, #56	; 0x38
 800f46c:	4640      	mov	r0, r8
 800f46e:	61bb      	str	r3, [r7, #24]
 800f470:	f002 fd1c 	bl	8011eac <silk_stereo_decode_pred>
                            if( channel_state[ 1 ].LBRR_flags[ i ] == 0 ) {
 800f474:	69fb      	ldr	r3, [r7, #28]
 800f476:	681a      	ldr	r2, [r3, #0]
 800f478:	69bb      	ldr	r3, [r7, #24]
 800f47a:	2a00      	cmp	r2, #0
 800f47c:	d1c9      	bne.n	800f412 <silk_Decode+0x622>
                                silk_stereo_decode_mid_only( psRangeDec, &decode_only_middle );
 800f47e:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800f482:	4640      	mov	r0, r8
 800f484:	f002 fd74 	bl	8011f70 <silk_stereo_decode_mid_only>
 800f488:	69bb      	ldr	r3, [r7, #24]
 800f48a:	e7c2      	b.n	800f412 <silk_Decode+0x622>
    if( decControl->nChannelsInternal == 2 ) {
 800f48c:	2a02      	cmp	r2, #2
 800f48e:	f47f adf1 	bne.w	800f074 <silk_Decode+0x284>
        if(   lostFlag == FLAG_DECODE_NORMAL ||
 800f492:	b37b      	cbz	r3, 800f4f4 <silk_Decode+0x704>
 800f494:	2b02      	cmp	r3, #2
 800f496:	d107      	bne.n	800f4a8 <silk_Decode+0x6b8>
            ( lostFlag == FLAG_DECODE_LBRR && channel_state[ 0 ].LBRR_flags[ channel_state[ 0 ].nFramesDecoded ] == 1 ) )
 800f498:	f8d6 3954 	ldr.w	r3, [r6, #2388]	; 0x954
 800f49c:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800f4a0:	f8d3 3974 	ldr.w	r3, [r3, #2420]	; 0x974
 800f4a4:	2b01      	cmp	r3, #1
 800f4a6:	d03e      	beq.n	800f526 <silk_Decode+0x736>
                MS_pred_Q13[ n ] = psDec->sStereo.pred_prev_Q13[ n ];
 800f4a8:	f242 1250 	movw	r2, #8528	; 0x2150
 800f4ac:	f242 1352 	movw	r3, #8530	; 0x2152
 800f4b0:	5eb2      	ldrsh	r2, [r6, r2]
 800f4b2:	5ef3      	ldrsh	r3, [r6, r3]
 800f4b4:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
    if( decControl->nChannelsInternal == 2 && decode_only_middle == 0 && psDec->prev_decode_only_middle == 1 ) {
 800f4b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f4ba:	2b00      	cmp	r3, #0
 800f4bc:	d04d      	beq.n	800f55a <silk_Decode+0x76a>
 800f4be:	e9d4 5200 	ldrd	r5, r2, [r4]
 800f4c2:	f8d4 c008 	ldr.w	ip, [r4, #8]
 800f4c6:	4629      	mov	r1, r5
 800f4c8:	e5d4      	b.n	800f074 <silk_Decode+0x284>
                condCoding = CODE_CONDITIONALLY;
 800f4ca:	2302      	movs	r3, #2
 800f4cc:	e62c      	b.n	800f128 <silk_Decode+0x338>
              || (decControl->nChannelsInternal == 2 && lostFlag == FLAG_DECODE_LBRR && channel_state[1].LBRR_flags[ channel_state[1].nFramesDecoded ] == 1 );
 800f4ce:	f04f 0b01 	mov.w	fp, #1
 800f4d2:	e5fe      	b.n	800f0d2 <silk_Decode+0x2e2>
    if( decControl->nChannelsInternal == 2 ) {
 800f4d4:	2a02      	cmp	r2, #2
 800f4d6:	d0dd      	beq.n	800f494 <silk_Decode+0x6a4>
 800f4d8:	68a0      	ldr	r0, [r4, #8]
 800f4da:	6825      	ldr	r5, [r4, #0]
 800f4dc:	e5c8      	b.n	800f070 <silk_Decode+0x280>
 800f4de:	f8da 3958 	ldr.w	r3, [sl, #2392]	; 0x958
            for( i = 0; i < channel_state[ 0 ].nFramesPerPacket; i++ ) {
 800f4e2:	3601      	adds	r6, #1
 800f4e4:	429e      	cmp	r6, r3
 800f4e6:	f10b 0b04 	add.w	fp, fp, #4
 800f4ea:	db85      	blt.n	800f3f8 <silk_Decode+0x608>
 800f4ec:	4656      	mov	r6, sl
 800f4ee:	464c      	mov	r4, r9
    if( decControl->nChannelsInternal == 2 ) {
 800f4f0:	2a02      	cmp	r2, #2
 800f4f2:	d1f1      	bne.n	800f4d8 <silk_Decode+0x6e8>
            silk_stereo_decode_pred( psRangeDec, MS_pred_Q13 );
 800f4f4:	f107 0138 	add.w	r1, r7, #56	; 0x38
 800f4f8:	f8d7 02e8 	ldr.w	r0, [r7, #744]	; 0x2e8
 800f4fc:	f002 fcd6 	bl	8011eac <silk_stereo_decode_pred>
            if( ( lostFlag == FLAG_DECODE_NORMAL && channel_state[ 1 ].VAD_flags[ channel_state[ 0 ].nFramesDecoded ] == 0 ) ||
 800f500:	f8d6 3954 	ldr.w	r3, [r6, #2388]	; 0x954
 800f504:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800f508:	f503 53d0 	add.w	r3, r3, #6656	; 0x1a00
 800f50c:	3308      	adds	r3, #8
 800f50e:	685b      	ldr	r3, [r3, #4]
 800f510:	b1cb      	cbz	r3, 800f546 <silk_Decode+0x756>
                decode_only_middle = 0;
 800f512:	2300      	movs	r3, #0
    if( decControl->nChannelsInternal == 2 && decode_only_middle == 0 && psDec->prev_decode_only_middle == 1 ) {
 800f514:	6862      	ldr	r2, [r4, #4]
                decode_only_middle = 0;
 800f516:	62bb      	str	r3, [r7, #40]	; 0x28
    if( decControl->nChannelsInternal == 2 && decode_only_middle == 0 && psDec->prev_decode_only_middle == 1 ) {
 800f518:	2a02      	cmp	r2, #2
 800f51a:	d01e      	beq.n	800f55a <silk_Decode+0x76a>
 800f51c:	6825      	ldr	r5, [r4, #0]
 800f51e:	f8d4 c008 	ldr.w	ip, [r4, #8]
 800f522:	4629      	mov	r1, r5
 800f524:	e5a6      	b.n	800f074 <silk_Decode+0x284>
            silk_stereo_decode_pred( psRangeDec, MS_pred_Q13 );
 800f526:	f107 0138 	add.w	r1, r7, #56	; 0x38
 800f52a:	f8d7 02e8 	ldr.w	r0, [r7, #744]	; 0x2e8
 800f52e:	f002 fcbd 	bl	8011eac <silk_stereo_decode_pred>
                ( lostFlag == FLAG_DECODE_LBRR && channel_state[ 1 ].LBRR_flags[ channel_state[ 0 ].nFramesDecoded ] == 0 ) )
 800f532:	f8d6 3954 	ldr.w	r3, [r6, #2388]	; 0x954
 800f536:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800f53a:	f503 53d0 	add.w	r3, r3, #6656	; 0x1a00
 800f53e:	3318      	adds	r3, #24
 800f540:	685b      	ldr	r3, [r3, #4]
 800f542:	2b00      	cmp	r3, #0
 800f544:	d1e5      	bne.n	800f512 <silk_Decode+0x722>
                silk_stereo_decode_mid_only( psRangeDec, &decode_only_middle );
 800f546:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800f54a:	f8d7 02e8 	ldr.w	r0, [r7, #744]	; 0x2e8
 800f54e:	f002 fd0f 	bl	8011f70 <silk_stereo_decode_mid_only>
 800f552:	6862      	ldr	r2, [r4, #4]
    if( decControl->nChannelsInternal == 2 && decode_only_middle == 0 && psDec->prev_decode_only_middle == 1 ) {
 800f554:	2a02      	cmp	r2, #2
 800f556:	d0af      	beq.n	800f4b8 <silk_Decode+0x6c8>
 800f558:	e7be      	b.n	800f4d8 <silk_Decode+0x6e8>
 800f55a:	f242 1364 	movw	r3, #8548	; 0x2164
 800f55e:	f856 8003 	ldr.w	r8, [r6, r3]
 800f562:	f1b8 0f01 	cmp.w	r8, #1
 800f566:	d1aa      	bne.n	800f4be <silk_Decode+0x6ce>
        silk_memset( psDec->channel_state[ 1 ].outBuf, 0, sizeof(psDec->channel_state[ 1 ].outBuf) );
 800f568:	f506 50af 	add.w	r0, r6, #5600	; 0x15e0
 800f56c:	f44f 7270 	mov.w	r2, #960	; 0x3c0
 800f570:	2100      	movs	r1, #0
 800f572:	300c      	adds	r0, #12
 800f574:	f004 fdd8 	bl	8014128 <memset>
        silk_memset( psDec->channel_state[ 1 ].sLPC_Q14_buf, 0, sizeof(psDec->channel_state[ 1 ].sLPC_Q14_buf) );
 800f578:	f506 50ad 	add.w	r0, r6, #5536	; 0x15a0
 800f57c:	2240      	movs	r2, #64	; 0x40
 800f57e:	2100      	movs	r1, #0
 800f580:	300c      	adds	r0, #12
 800f582:	f004 fdd1 	bl	8014128 <memset>
        psDec->channel_state[ 1 ].LastGainIndex  = 10;
 800f586:	220a      	movs	r2, #10
 800f588:	f641 13b0 	movw	r3, #6576	; 0x19b0
        psDec->channel_state[ 1 ].lagPrev        = 100;
 800f58c:	f641 19ac 	movw	r9, #6572	; 0x19ac
 800f590:	f04f 0a64 	mov.w	sl, #100	; 0x64
        psDec->channel_state[ 1 ].prevSignalType = TYPE_NO_VOICE_ACTIVITY;
 800f594:	f242 0eec 	movw	lr, #8428	; 0x20ec
 800f598:	f04f 0b00 	mov.w	fp, #0
        psDec->channel_state[ 1 ].first_frame_after_reset = 1;
 800f59c:	f641 10f0 	movw	r0, #6640	; 0x19f0
        psDec->channel_state[ 1 ].LastGainIndex  = 10;
 800f5a0:	54f2      	strb	r2, [r6, r3]
 800f5a2:	6825      	ldr	r5, [r4, #0]
 800f5a4:	e9d4 2c01 	ldrd	r2, ip, [r4, #4]
 800f5a8:	4629      	mov	r1, r5
        psDec->channel_state[ 1 ].lagPrev        = 100;
 800f5aa:	f846 a009 	str.w	sl, [r6, r9]
        psDec->channel_state[ 1 ].prevSignalType = TYPE_NO_VOICE_ACTIVITY;
 800f5ae:	f846 b00e 	str.w	fp, [r6, lr]
        psDec->channel_state[ 1 ].first_frame_after_reset = 1;
 800f5b2:	f846 8000 	str.w	r8, [r6, r0]
 800f5b6:	e55d      	b.n	800f074 <silk_Decode+0x284>
                            if( channel_state[ 1 ].LBRR_flags[ i ] == 0 ) {
 800f5b8:	f50b 53d0 	add.w	r3, fp, #6656	; 0x1a00
 800f5bc:	331c      	adds	r3, #28
 800f5be:	4453      	add	r3, sl
 800f5c0:	4654      	mov	r4, sl
                for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800f5c2:	4635      	mov	r5, r6
                            if( channel_state[ 1 ].LBRR_flags[ i ] == 0 ) {
 800f5c4:	61fb      	str	r3, [r7, #28]
 800f5c6:	e01c      	b.n	800f602 <silk_Decode+0x812>
                        silk_decode_indices( &channel_state[ n ], psRangeDec, i, 1, condCoding );
 800f5c8:	2200      	movs	r2, #0
 800f5ca:	2301      	movs	r3, #1
 800f5cc:	9200      	str	r2, [sp, #0]
 800f5ce:	4641      	mov	r1, r8
 800f5d0:	4620      	mov	r0, r4
 800f5d2:	f000 fdb1 	bl	8010138 <silk_decode_indices>
                        silk_decode_pulses( psRangeDec, pulses, channel_state[ n ].indices.signalType,
 800f5d6:	f8d4 1918 	ldr.w	r1, [r4, #2328]	; 0x918
 800f5da:	f994 2acd 	ldrsb.w	r2, [r4, #2765]	; 0xacd
 800f5de:	f994 3ace 	ldrsb.w	r3, [r4, #2766]	; 0xace
 800f5e2:	4640      	mov	r0, r8
 800f5e4:	9100      	str	r1, [sp, #0]
 800f5e6:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800f5ea:	f001 f97f 	bl	80108ec <silk_decode_pulses>
 800f5ee:	f8d9 2004 	ldr.w	r2, [r9, #4]
                for( n = 0; n < decControl->nChannelsInternal; n++ ) {
 800f5f2:	3501      	adds	r5, #1
 800f5f4:	f504 5485 	add.w	r4, r4, #4256	; 0x10a0
 800f5f8:	4295      	cmp	r5, r2
 800f5fa:	f104 0408 	add.w	r4, r4, #8
 800f5fe:	f6bf af6e 	bge.w	800f4de <silk_Decode+0x6ee>
                    if( channel_state[ n ].LBRR_flags[ i ] ) {
 800f602:	eb04 030b 	add.w	r3, r4, fp
 800f606:	f8d3 3974 	ldr.w	r3, [r3, #2420]	; 0x974
 800f60a:	2b00      	cmp	r3, #0
 800f60c:	d0f1      	beq.n	800f5f2 <silk_Decode+0x802>
                        if( decControl->nChannelsInternal == 2 && n == 0 ) {
 800f60e:	2a02      	cmp	r2, #2
 800f610:	d1da      	bne.n	800f5c8 <silk_Decode+0x7d8>
 800f612:	2d00      	cmp	r5, #0
 800f614:	d1d8      	bne.n	800f5c8 <silk_Decode+0x7d8>
                            silk_stereo_decode_pred( psRangeDec, MS_pred_Q13 );
 800f616:	f107 0138 	add.w	r1, r7, #56	; 0x38
 800f61a:	4640      	mov	r0, r8
 800f61c:	f002 fc46 	bl	8011eac <silk_stereo_decode_pred>
                            if( channel_state[ 1 ].LBRR_flags[ i ] == 0 ) {
 800f620:	69fb      	ldr	r3, [r7, #28]
 800f622:	681b      	ldr	r3, [r3, #0]
 800f624:	2b00      	cmp	r3, #0
 800f626:	d1cf      	bne.n	800f5c8 <silk_Decode+0x7d8>
                                silk_stereo_decode_mid_only( psRangeDec, &decode_only_middle );
 800f628:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800f62c:	4640      	mov	r0, r8
 800f62e:	f002 fc9f 	bl	8011f70 <silk_stereo_decode_mid_only>
 800f632:	e7c9      	b.n	800f5c8 <silk_Decode+0x7d8>
                     ( decControl->internalSampleRate == 1000*channel_state[ 0 ].fs_kHz );
 800f634:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800f638:	f8d6 090c 	ldr.w	r0, [r6, #2316]	; 0x90c
    stereo_to_mono = decControl->nChannelsInternal == 1 && psDec->nChannelsInternal == 2 &&
 800f63c:	68e1      	ldr	r1, [r4, #12]
                     ( decControl->internalSampleRate == 1000*channel_state[ 0 ].fs_kHz );
 800f63e:	fb03 f300 	mul.w	r3, r3, r0
    stereo_to_mono = decControl->nChannelsInternal == 1 && psDec->nChannelsInternal == 2 &&
 800f642:	4299      	cmp	r1, r3
 800f644:	f47f ad00 	bne.w	800f048 <silk_Decode+0x258>
    if( channel_state[ 0 ].nFramesDecoded == 0 ) {
 800f648:	693b      	ldr	r3, [r7, #16]
 800f64a:	2b00      	cmp	r3, #0
 800f64c:	d059      	beq.n	800f702 <silk_Decode+0x912>
    if( decControl->nChannelsAPI == 2 && decControl->nChannelsInternal == 2 && ( psDec->nChannelsAPI == 1 || psDec->nChannelsInternal == 1 ) ) {
 800f64e:	6825      	ldr	r5, [r4, #0]
    stereo_to_mono = decControl->nChannelsInternal == 1 && psDec->nChannelsInternal == 2 &&
 800f650:	613a      	str	r2, [r7, #16]
    if( decControl->nChannelsAPI == 2 && decControl->nChannelsInternal == 2 && ( psDec->nChannelsAPI == 1 || psDec->nChannelsInternal == 1 ) ) {
 800f652:	4629      	mov	r1, r5
 800f654:	e431      	b.n	800eeba <silk_Decode+0xca>
              || (decControl->nChannelsInternal == 2 && lostFlag == FLAG_DECODE_LBRR && channel_state[1].LBRR_flags[ channel_state[1].nFramesDecoded ] == 1 );
 800f656:	2b02      	cmp	r3, #2
 800f658:	d01a      	beq.n	800f690 <silk_Decode+0x8a0>
 800f65a:	f04f 0b00 	mov.w	fp, #0
 800f65e:	e53b      	b.n	800f0d8 <silk_Decode+0x2e8>
        silk_memset( psDec->sStereo.pred_prev_Q13, 0, sizeof( psDec->sStereo.pred_prev_Q13 ) );
 800f660:	2300      	movs	r3, #0
 800f662:	f242 1150 	movw	r1, #8528	; 0x2150
        silk_memset( psDec->sStereo.sSide, 0, sizeof( psDec->sStereo.sSide ) );
 800f666:	f242 1258 	movw	r2, #8536	; 0x2158
        silk_memcpy( &channel_state[ 1 ].resampler_state, &channel_state[ 0 ].resampler_state, sizeof( silk_resampler_state_struct ) );
 800f66a:	f506 50d1 	add.w	r0, r6, #6688	; 0x1a20
        silk_memset( psDec->sStereo.pred_prev_Q13, 0, sizeof( psDec->sStereo.pred_prev_Q13 ) );
 800f66e:	5073      	str	r3, [r6, r1]
        silk_memcpy( &channel_state[ 1 ].resampler_state, &channel_state[ 0 ].resampler_state, sizeof( silk_resampler_state_struct ) );
 800f670:	3008      	adds	r0, #8
        silk_memset( psDec->sStereo.sSide, 0, sizeof( psDec->sStereo.sSide ) );
 800f672:	50b3      	str	r3, [r6, r2]
        silk_memcpy( &channel_state[ 1 ].resampler_state, &channel_state[ 0 ].resampler_state, sizeof( silk_resampler_state_struct ) );
 800f674:	f506 6118 	add.w	r1, r6, #2432	; 0x980
 800f678:	f44f 7296 	mov.w	r2, #300	; 0x12c
 800f67c:	f004 fd30 	bl	80140e0 <memcpy>
 800f680:	e9d4 5200 	ldrd	r5, r2, [r4]
 800f684:	4629      	mov	r1, r5
 800f686:	e418      	b.n	800eeba <silk_Decode+0xca>
 800f688:	08014e90 	.word	0x08014e90
 800f68c:	08017b58 	.word	0x08017b58
              || (decControl->nChannelsInternal == 2 && lostFlag == FLAG_DECODE_LBRR && channel_state[1].LBRR_flags[ channel_state[1].nFramesDecoded ] == 1 );
 800f690:	f506 5385 	add.w	r3, r6, #4256	; 0x10a0
 800f694:	f8d3 295c 	ldr.w	r2, [r3, #2396]	; 0x95c
 800f698:	3308      	adds	r3, #8
 800f69a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800f69e:	f8d3 b974 	ldr.w	fp, [r3, #2420]	; 0x974
 800f6a2:	f1bb 0f01 	cmp.w	fp, #1
 800f6a6:	bf18      	it	ne
 800f6a8:	f04f 0b00 	movne.w	fp, #0
 800f6ac:	e514      	b.n	800f0d8 <silk_Decode+0x2e8>
                return SILK_DEC_INVALID_FRAME_SIZE;
 800f6ae:	f06f 03ca 	mvn.w	r3, #202	; 0xca
 800f6b2:	627b      	str	r3, [r7, #36]	; 0x24
 800f6b4:	4618      	mov	r0, r3
 800f6b6:	f7ff bbf4 	b.w	800eea2 <silk_Decode+0xb2>
            ret += silk_resampler( &channel_state[ 1 ].resampler_state, resample_out_ptr, &samplesOut1_tmp[ 0 ][ 1 ], nSamplesOutDec );
 800f6ba:	69bb      	ldr	r3, [r7, #24]
 800f6bc:	697d      	ldr	r5, [r7, #20]
 800f6be:	681a      	ldr	r2, [r3, #0]
 800f6c0:	69fb      	ldr	r3, [r7, #28]
 800f6c2:	f506 50d1 	add.w	r0, r6, #6688	; 0x1a20
 800f6c6:	3202      	adds	r2, #2
 800f6c8:	681b      	ldr	r3, [r3, #0]
 800f6ca:	3008      	adds	r0, #8
 800f6cc:	4629      	mov	r1, r5
 800f6ce:	f001 fc69 	bl	8010fa4 <silk_resampler>
            for( i = 0; i < *nSamplesOut; i++ ) {
 800f6d2:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
            ret += silk_resampler( &channel_state[ 1 ].resampler_state, resample_out_ptr, &samplesOut1_tmp[ 0 ][ 1 ], nSamplesOutDec );
 800f6d6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
            for( i = 0; i < *nSamplesOut; i++ ) {
 800f6d8:	681b      	ldr	r3, [r3, #0]
            ret += silk_resampler( &channel_state[ 1 ].resampler_state, resample_out_ptr, &samplesOut1_tmp[ 0 ][ 1 ], nSamplesOutDec );
 800f6da:	4402      	add	r2, r0
            for( i = 0; i < *nSamplesOut; i++ ) {
 800f6dc:	2b00      	cmp	r3, #0
            ret += silk_resampler( &channel_state[ 1 ].resampler_state, resample_out_ptr, &samplesOut1_tmp[ 0 ][ 1 ], nSamplesOutDec );
 800f6de:	627a      	str	r2, [r7, #36]	; 0x24
            for( i = 0; i < *nSamplesOut; i++ ) {
 800f6e0:	f77f adc5 	ble.w	800f26e <silk_Decode+0x47e>
 800f6e4:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 800f6e8:	1e98      	subs	r0, r3, #2
 800f6ea:	f8d7 22ec 	ldr.w	r2, [r7, #748]	; 0x2ec
 800f6ee:	1eab      	subs	r3, r5, #2
 800f6f0:	6a7d      	ldr	r5, [r7, #36]	; 0x24
                samplesOut[ 1 + 2 * i ] = resample_out_ptr[ i ];
 800f6f2:	f933 1f02 	ldrsh.w	r1, [r3, #2]!
 800f6f6:	3204      	adds	r2, #4
            for( i = 0; i < *nSamplesOut; i++ ) {
 800f6f8:	4298      	cmp	r0, r3
                samplesOut[ 1 + 2 * i ] = resample_out_ptr[ i ];
 800f6fa:	f822 1c02 	strh.w	r1, [r2, #-2]
            for( i = 0; i < *nSamplesOut; i++ ) {
 800f6fe:	d1f8      	bne.n	800f6f2 <silk_Decode+0x902>
 800f700:	e65f      	b.n	800f3c2 <silk_Decode+0x5d2>
    stereo_to_mono = decControl->nChannelsInternal == 1 && psDec->nChannelsInternal == 2 &&
 800f702:	613a      	str	r2, [r7, #16]
 800f704:	f7ff bba0 	b.w	800ee48 <silk_Decode+0x58>

0800f708 <silk_decode_core>:
    silk_decoder_control        *psDecCtrl,                     /* I    Decoder control                             */
    opus_int16                  xq[],                           /* O    Decoded speech                              */
    const opus_int16            pulses[ MAX_FRAME_LENGTH ],     /* I    Pulse signal                                */
    int                         arch                            /* I    Run-time architecture                       */
)
{
 800f708:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f70c:	b0ad      	sub	sp, #180	; 0xb4
 800f70e:	4605      	mov	r5, r0
    VARDECL( opus_int32, sLPC_Q14 );
    SAVE_STACK;

    silk_assert( psDec->prev_gain_Q16 != 0 );

    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800f710:	f8d0 0920 	ldr.w	r0, [r0, #2336]	; 0x920
    ALLOC( sLTP_Q15, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800f714:	f8d5 4918 	ldr.w	r4, [r5, #2328]	; 0x918
{
 800f718:	af02      	add	r7, sp, #8
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800f71a:	ea4f 0e40 	mov.w	lr, r0, lsl #1
 800f71e:	61f8      	str	r0, [r7, #28]
    ALLOC( res_Q14, psDec->subfr_length, opus_int32 );
 800f720:	f8d5 691c 	ldr.w	r6, [r5, #2332]	; 0x91c
    ALLOC( sLTP_Q15, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800f724:	4420      	add	r0, r4
 800f726:	f8c7 4084 	str.w	r4, [r7, #132]	; 0x84
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800f72a:	f10e 0e08 	add.w	lr, lr, #8
    ALLOC( sLPC_Q14, psDec->subfr_length + MAX_LPC_ORDER, opus_int32 );

    offset_Q10 = silk_Quantization_Offsets_Q10[ psDec->indices.signalType >> 1 ][ psDec->indices.quantOffsetType ];
 800f72e:	f995 4acd 	ldrsb.w	r4, [r5, #2765]	; 0xacd
    ALLOC( sLTP_Q15, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800f732:	0080      	lsls	r0, r0, #2
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800f734:	f02e 0e07 	bic.w	lr, lr, #7
    ALLOC( res_Q14, psDec->subfr_length, opus_int32 );
 800f738:	00b6      	lsls	r6, r6, #2
    ALLOC( sLTP_Q15, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800f73a:	300a      	adds	r0, #10
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800f73c:	ebad 0d0e 	sub.w	sp, sp, lr
    ALLOC( sLTP_Q15, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800f740:	f020 0007 	bic.w	r0, r0, #7
    ALLOC( res_Q14, psDec->subfr_length, opus_int32 );
 800f744:	f106 0e0a 	add.w	lr, r6, #10
    offset_Q10 = silk_Quantization_Offsets_Q10[ psDec->indices.signalType >> 1 ][ psDec->indices.quantOffsetType ];
 800f748:	f8c7 4080 	str.w	r4, [r7, #128]	; 0x80
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800f74c:	f10d 0c08 	add.w	ip, sp, #8
    ALLOC( res_Q14, psDec->subfr_length, opus_int32 );
 800f750:	f02e 0e07 	bic.w	lr, lr, #7
    ALLOC( sLTP_Q15, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800f754:	ebad 0d00 	sub.w	sp, sp, r0
    offset_Q10 = silk_Quantization_Offsets_Q10[ psDec->indices.signalType >> 1 ][ psDec->indices.quantOffsetType ];
 800f758:	f8d7 4080 	ldr.w	r4, [r7, #128]	; 0x80
    ALLOC( sLTP, psDec->ltp_mem_length, opus_int16 );
 800f75c:	f8c7 c00c 	str.w	ip, [r7, #12]
    ALLOC( sLTP_Q15, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800f760:	f10d 0c08 	add.w	ip, sp, #8
    ALLOC( res_Q14, psDec->subfr_length, opus_int32 );
 800f764:	ebad 0d0e 	sub.w	sp, sp, lr
    offset_Q10 = silk_Quantization_Offsets_Q10[ psDec->indices.signalType >> 1 ][ psDec->indices.quantOffsetType ];
 800f768:	f024 0e01 	bic.w	lr, r4, #1
    ALLOC( res_Q14, psDec->subfr_length, opus_int32 );
 800f76c:	ac02      	add	r4, sp, #8
    ALLOC( sLPC_Q14, psDec->subfr_length + MAX_LPC_ORDER, opus_int32 );
 800f76e:	364a      	adds	r6, #74	; 0x4a
    offset_Q10 = silk_Quantization_Offsets_Q10[ psDec->indices.signalType >> 1 ][ psDec->indices.quantOffsetType ];
 800f770:	f995 0ace 	ldrsb.w	r0, [r5, #2766]	; 0xace
    ALLOC( res_Q14, psDec->subfr_length, opus_int32 );
 800f774:	613c      	str	r4, [r7, #16]
        NLSF_interpolation_flag = 0;
    }

    /* Decode excitation */
    rand_seed = psDec->indices.Seed;
    for( i = 0; i < psDec->frame_length; i++ ) {
 800f776:	f8d7 4084 	ldr.w	r4, [r7, #132]	; 0x84
    ALLOC( sLTP_Q15, psDec->ltp_mem_length + psDec->frame_length, opus_int32 );
 800f77a:	f8c7 c014 	str.w	ip, [r7, #20]
{
 800f77e:	468b      	mov	fp, r1
    ALLOC( sLPC_Q14, psDec->subfr_length + MAX_LPC_ORDER, opus_int32 );
 800f780:	f026 0c07 	bic.w	ip, r6, #7
    if( psDec->indices.NLSFInterpCoef_Q2 < 1 << 2 ) {
 800f784:	f995 1acf 	ldrsb.w	r1, [r5, #2767]	; 0xacf
    offset_Q10 = silk_Quantization_Offsets_Q10[ psDec->indices.signalType >> 1 ][ psDec->indices.quantOffsetType ];
 800f788:	4e19      	ldr	r6, [pc, #100]	; (800f7f0 <silk_decode_core+0xe8>)
 800f78a:	4470      	add	r0, lr
    ALLOC( sLPC_Q14, psDec->subfr_length + MAX_LPC_ORDER, opus_int32 );
 800f78c:	ebad 0d0c 	sub.w	sp, sp, ip
    for( i = 0; i < psDec->frame_length; i++ ) {
 800f790:	2c00      	cmp	r4, #0
{
 800f792:	67fa      	str	r2, [r7, #124]	; 0x7c
    if( psDec->indices.NLSFInterpCoef_Q2 < 1 << 2 ) {
 800f794:	6079      	str	r1, [r7, #4]
    offset_Q10 = silk_Quantization_Offsets_Q10[ psDec->indices.signalType >> 1 ][ psDec->indices.quantOffsetType ];
 800f796:	f936 2010 	ldrsh.w	r2, [r6, r0, lsl #1]
    ALLOC( sLPC_Q14, psDec->subfr_length + MAX_LPC_ORDER, opus_int32 );
 800f79a:	f10d 0808 	add.w	r8, sp, #8
    rand_seed = psDec->indices.Seed;
 800f79e:	f995 1ad2 	ldrsb.w	r1, [r5, #2770]	; 0xad2
 800f7a2:	f105 0604 	add.w	r6, r5, #4
    for( i = 0; i < psDec->frame_length; i++ ) {
 800f7a6:	dd29      	ble.n	800f7fc <silk_decode_core+0xf4>
 800f7a8:	3b02      	subs	r3, #2
 800f7aa:	4630      	mov	r0, r6
        rand_seed = silk_RAND( rand_seed );
 800f7ac:	f8df a044 	ldr.w	sl, [pc, #68]	; 800f7f4 <silk_decode_core+0xec>
 800f7b0:	f8df 9044 	ldr.w	r9, [pc, #68]	; 800f7f8 <silk_decode_core+0xf0>
 800f7b4:	eb03 0e44 	add.w	lr, r3, r4, lsl #1
            psDec->exc_Q14[ i ] -= QUANT_LEVEL_ADJUST_Q10 << 4;
        } else
        if( psDec->exc_Q14[ i ] < 0 ) {
            psDec->exc_Q14[ i ] += QUANT_LEVEL_ADJUST_Q10 << 4;
        }
        psDec->exc_Q14[ i ] += offset_Q10 << 4;
 800f7b8:	ea4f 1c02 	mov.w	ip, r2, lsl #4
 800f7bc:	e00c      	b.n	800f7d8 <silk_decode_core+0xd0>
            psDec->exc_Q14[ i ] -= QUANT_LEVEL_ADJUST_Q10 << 4;
 800f7be:	f5a2 62a0 	sub.w	r2, r2, #1280	; 0x500
 800f7c2:	6002      	str	r2, [r0, #0]
        if( rand_seed < 0 ) {
 800f7c4:	2900      	cmp	r1, #0
        psDec->exc_Q14[ i ] += offset_Q10 << 4;
 800f7c6:	4462      	add	r2, ip
           psDec->exc_Q14[ i ] = -psDec->exc_Q14[ i ];
 800f7c8:	bfb8      	it	lt
 800f7ca:	4252      	neglt	r2, r2
    for( i = 0; i < psDec->frame_length; i++ ) {
 800f7cc:	459e      	cmp	lr, r3
        psDec->exc_Q14[ i ] += offset_Q10 << 4;
 800f7ce:	6002      	str	r2, [r0, #0]
        }

        rand_seed = silk_ADD32_ovflw( rand_seed, pulses[ i ] );
 800f7d0:	4421      	add	r1, r4
 800f7d2:	f100 0004 	add.w	r0, r0, #4
    for( i = 0; i < psDec->frame_length; i++ ) {
 800f7d6:	d011      	beq.n	800f7fc <silk_decode_core+0xf4>
        psDec->exc_Q14[ i ] = silk_LSHIFT( (opus_int32)pulses[ i ], 14 );
 800f7d8:	f933 4f02 	ldrsh.w	r4, [r3, #2]!
        rand_seed = silk_RAND( rand_seed );
 800f7dc:	fb0a 9101 	mla	r1, sl, r1, r9
        psDec->exc_Q14[ i ] = silk_LSHIFT( (opus_int32)pulses[ i ], 14 );
 800f7e0:	03a2      	lsls	r2, r4, #14
        if( psDec->exc_Q14[ i ] > 0 ) {
 800f7e2:	2a00      	cmp	r2, #0
 800f7e4:	dceb      	bgt.n	800f7be <silk_decode_core+0xb6>
            psDec->exc_Q14[ i ] += QUANT_LEVEL_ADJUST_Q10 << 4;
 800f7e6:	bf18      	it	ne
 800f7e8:	f502 62a0 	addne.w	r2, r2, #1280	; 0x500
        psDec->exc_Q14[ i ] = silk_LSHIFT( (opus_int32)pulses[ i ], 14 );
 800f7ec:	6002      	str	r2, [r0, #0]
 800f7ee:	e7e9      	b.n	800f7c4 <silk_decode_core+0xbc>
 800f7f0:	08017b7c 	.word	0x08017b7c
 800f7f4:	0bb38435 	.word	0x0bb38435
 800f7f8:	3619636b 	.word	0x3619636b
    }

    /* Copy LPC state */
    silk_memcpy( sLPC_Q14, psDec->sLPC_Q14_buf, MAX_LPC_ORDER * sizeof( opus_int32 ) );
 800f7fc:	f205 5304 	addw	r3, r5, #1284	; 0x504
 800f800:	461c      	mov	r4, r3
 800f802:	46c4      	mov	ip, r8
 800f804:	60bb      	str	r3, [r7, #8]
 800f806:	f205 5944 	addw	r9, r5, #1348	; 0x544
 800f80a:	46e6      	mov	lr, ip
 800f80c:	6820      	ldr	r0, [r4, #0]
 800f80e:	6861      	ldr	r1, [r4, #4]
 800f810:	68a2      	ldr	r2, [r4, #8]
 800f812:	68e3      	ldr	r3, [r4, #12]
 800f814:	3410      	adds	r4, #16
 800f816:	454c      	cmp	r4, r9
 800f818:	f10c 0c10 	add.w	ip, ip, #16
 800f81c:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 800f820:	d1f3      	bne.n	800f80a <silk_decode_core+0x102>

    pexc_Q14 = psDec->exc_Q14;
    pxq      = xq;
    sLTP_buf_idx = psDec->ltp_mem_length;
    /* Loop over subframes */
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800f822:	f8d5 3914 	ldr.w	r3, [r5, #2324]	; 0x914
    pexc_Q14 = psDec->exc_Q14;
 800f826:	657e      	str	r6, [r7, #84]	; 0x54
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800f828:	2b00      	cmp	r3, #0
 800f82a:	f340 8308 	ble.w	800fe3e <silk_decode_core+0x736>
 800f82e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800f830:	f8c7 b020 	str.w	fp, [r7, #32]
 800f834:	603b      	str	r3, [r7, #0]
    pxq      = xq;
 800f836:	653b      	str	r3, [r7, #80]	; 0x50
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800f838:	2300      	movs	r3, #0
 800f83a:	65bb      	str	r3, [r7, #88]	; 0x58
 800f83c:	465b      	mov	r3, fp
 800f83e:	46c3      	mov	fp, r8
 800f840:	3360      	adds	r3, #96	; 0x60
 800f842:	637b      	str	r3, [r7, #52]	; 0x34
 800f844:	f8d7 a080 	ldr.w	sl, [r7, #128]	; 0x80
 800f848:	f505 5382 	add.w	r3, r5, #4160	; 0x1040
 800f84c:	6dbc      	ldr	r4, [r7, #88]	; 0x58
 800f84e:	65fd      	str	r5, [r7, #92]	; 0x5c
 800f850:	61bb      	str	r3, [r7, #24]
        pres_Q14 = res_Q14;
        A_Q12 = psDecCtrl->PredCoef_Q12[ k >> 1 ];

        /* Preload LPC coeficients to array on stack. Gives small performance gain */
        silk_memcpy( A_Q12_tmp, A_Q12, psDec->LPC_order * sizeof( opus_int16 ) );
 800f852:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
        A_Q12 = psDecCtrl->PredCoef_Q12[ k >> 1 ];
 800f854:	6a3d      	ldr	r5, [r7, #32]
 800f856:	ea4f 0864 	mov.w	r8, r4, asr #1
        silk_memcpy( A_Q12_tmp, A_Q12, psDec->LPC_order * sizeof( opus_int16 ) );
 800f85a:	f8d3 3924 	ldr.w	r3, [r3, #2340]	; 0x924
        A_Q12 = psDecCtrl->PredCoef_Q12[ k >> 1 ];
 800f85e:	f108 0801 	add.w	r8, r8, #1
 800f862:	eb05 1848 	add.w	r8, r5, r8, lsl #5
        silk_memcpy( A_Q12_tmp, A_Q12, psDec->LPC_order * sizeof( opus_int16 ) );
 800f866:	005a      	lsls	r2, r3, #1
 800f868:	4641      	mov	r1, r8
 800f86a:	f107 0088 	add.w	r0, r7, #136	; 0x88
 800f86e:	67fb      	str	r3, [r7, #124]	; 0x7c
 800f870:	f004 fc36 	bl	80140e0 <memcpy>
        B_Q14        = &psDecCtrl->LTPCoef_Q14[ k * LTP_ORDER ];
        signalType   = psDec->indices.signalType;

        Gain_Q10     = silk_RSHIFT( psDecCtrl->Gains_Q16[ k ], 6 );
 800f874:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 800f878:	691c      	ldr	r4, [r3, #16]
 800f87a:	11a3      	asrs	r3, r4, #6
 800f87c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800f87e:	2c00      	cmp	r4, #0
 800f880:	f000 8231 	beq.w	800fce6 <silk_decode_core+0x5de>
    b_headrm = silk_CLZ32( silk_abs(b32) ) - 1;
 800f884:	ea84 76e4 	eor.w	r6, r4, r4, asr #31
 800f888:	eba6 76e4 	sub.w	r6, r6, r4, asr #31
 800f88c:	fab6 f686 	clz	r6, r6
 800f890:	3e01      	subs	r6, #1
 800f892:	f1c6 0c0e 	rsb	ip, r6, #14
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
 800f896:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
    b32_nrm = silk_LSHIFT(b32, b_headrm);                                       /* Q: b_headrm                */
 800f89a:	fa04 f006 	lsl.w	r0, r4, r6
    b32_inv = silk_DIV32_16( silk_int32_MAX >> 2, silk_RSHIFT(b32_nrm, 16) );   /* Q: 29 + 16 - b_headrm    */
 800f89e:	1403      	asrs	r3, r0, #16
 800f8a0:	fb92 f2f3 	sdiv	r2, r2, r3
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800f8a4:	0415      	lsls	r5, r2, #16
  __asm__(
 800f8a6:	fb80 3105 	smull	r3, r1, r0, r5
    err_Q32 = silk_LSHIFT( ((opus_int32)1<<29) - silk_SMULWB(b32_nrm, b32_inv), 3 );        /* Q32                        */
 800f8aa:	f1c1 5100 	rsb	r1, r1, #536870912	; 0x20000000
 800f8ae:	00c9      	lsls	r1, r1, #3
  __asm__(
 800f8b0:	fb81 e302 	smull	lr, r3, r1, r2
  return a+SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f8b4:	041b      	lsls	r3, r3, #16
 800f8b6:	eb03 4302 	add.w	r3, r3, r2, lsl #16
    if( lshift <= 0 ) {
 800f8ba:	f1bc 0f00 	cmp.w	ip, #0
 800f8be:	eb03 431e 	add.w	r3, r3, lr, lsr #16
 800f8c2:	f340 8214 	ble.w	800fcee <silk_decode_core+0x5e6>
            return silk_RSHIFT(result, lshift);
 800f8c6:	fa43 f90c 	asr.w	r9, r3, ip
        inv_gain_Q31 = silk_INVERSE32_varQ( psDecCtrl->Gains_Q16[ k ], 47 );

        /* Calculate gain adjustment factor */
        if( psDecCtrl->Gains_Q16[ k ] != psDec->prev_gain_Q16 ) {
 800f8ca:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f8cc:	681b      	ldr	r3, [r3, #0]
 800f8ce:	429c      	cmp	r4, r3
 800f8d0:	f000 8206 	beq.w	800fce0 <silk_decode_core+0x5d8>
 800f8d4:	2b00      	cmp	r3, #0
 800f8d6:	f000 82c6 	beq.w	800fe66 <silk_decode_core+0x75e>
    a_headrm = silk_CLZ32( silk_abs(a32) ) - 1;
 800f8da:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 800f8de:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 800f8e2:	fab2 f282 	clz	r2, r2
 800f8e6:	1e51      	subs	r1, r2, #1
 800f8e8:	321c      	adds	r2, #28
    a32_nrm = silk_LSHIFT(a32, a_headrm);                                       /* Q: a_headrm                  */
 800f8ea:	408b      	lsls	r3, r1
  __asm__(
 800f8ec:	fb83 1c05 	smull	r1, ip, r3, r5
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
 800f8f0:	fb80 010c 	smull	r0, r1, r0, ip
    lshift = 29 + a_headrm - b_headrm - Qres;
 800f8f4:	1b96      	subs	r6, r2, r6
    if( lshift < 0 ) {
 800f8f6:	f1b6 0e10 	subs.w	lr, r6, #16
    a32_nrm = silk_SUB32_ovflw(a32_nrm, silk_LSHIFT_ovflw( silk_SMMUL(b32_nrm, result), 3 ));  /* Q: a_headrm   */
 800f8fa:	eba3 03c1 	sub.w	r3, r3, r1, lsl #3
 800f8fe:	fb83 1205 	smull	r1, r2, r3, r5
    result = silk_SMLAWB(result, a32_nrm, b32_inv);                             /* Q: 29 + a_headrm - b_headrm  */
 800f902:	4494      	add	ip, r2
    if( lshift < 0 ) {
 800f904:	f100 82b2 	bmi.w	800fe6c <silk_decode_core+0x764>
        if( lshift < 32){
 800f908:	f1be 0f1f 	cmp.w	lr, #31
            return 0;
 800f90c:	bfcc      	ite	gt
 800f90e:	f04f 0e00 	movgt.w	lr, #0
            return silk_RSHIFT(result, lshift);
 800f912:	fa4c fe0e 	asrle.w	lr, ip, lr
  __asm__(
 800f916:	f8db 3000 	ldr.w	r3, [fp]
 800f91a:	fb8e 1203 	smull	r1, r2, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f91e:	0c09      	lsrs	r1, r1, #16
  __asm__(
 800f920:	f8db 3004 	ldr.w	r3, [fp, #4]
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f924:	eb01 4102 	add.w	r1, r1, r2, lsl #16
  __asm__(
 800f928:	fb8e 2003 	smull	r2, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f92c:	0c12      	lsrs	r2, r2, #16
 800f92e:	eb02 4200 	add.w	r2, r2, r0, lsl #16
  __asm__(
 800f932:	f8db 3008 	ldr.w	r3, [fp, #8]
            gain_adj_Q16 =  silk_DIV32_varQ( psDec->prev_gain_Q16, psDecCtrl->Gains_Q16[ k ], 16 );

            /* Scale short term state */
            for( i = 0; i < MAX_LPC_ORDER; i++ ) {
                sLPC_Q14[ i ] = silk_SMULWW( gain_adj_Q16, sLPC_Q14[ i ] );
 800f936:	f8cb 1000 	str.w	r1, [fp]
 800f93a:	fb8e 1003 	smull	r1, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f93e:	0c09      	lsrs	r1, r1, #16
 800f940:	eb01 4100 	add.w	r1, r1, r0, lsl #16
  __asm__(
 800f944:	f8db 300c 	ldr.w	r3, [fp, #12]
 800f948:	f8cb 2004 	str.w	r2, [fp, #4]
 800f94c:	fb8e 2003 	smull	r2, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f950:	0c12      	lsrs	r2, r2, #16
 800f952:	eb02 4200 	add.w	r2, r2, r0, lsl #16
  __asm__(
 800f956:	f8db 3010 	ldr.w	r3, [fp, #16]
 800f95a:	f8cb 1008 	str.w	r1, [fp, #8]
 800f95e:	fb8e 1003 	smull	r1, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f962:	0c09      	lsrs	r1, r1, #16
 800f964:	eb01 4100 	add.w	r1, r1, r0, lsl #16
  __asm__(
 800f968:	f8db 3014 	ldr.w	r3, [fp, #20]
 800f96c:	f8cb 200c 	str.w	r2, [fp, #12]
 800f970:	fb8e 2003 	smull	r2, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f974:	0c12      	lsrs	r2, r2, #16
 800f976:	eb02 4200 	add.w	r2, r2, r0, lsl #16
  __asm__(
 800f97a:	f8db 3018 	ldr.w	r3, [fp, #24]
 800f97e:	f8cb 1010 	str.w	r1, [fp, #16]
 800f982:	fb8e 1003 	smull	r1, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f986:	0c09      	lsrs	r1, r1, #16
 800f988:	eb01 4100 	add.w	r1, r1, r0, lsl #16
  __asm__(
 800f98c:	f8db 301c 	ldr.w	r3, [fp, #28]
 800f990:	f8cb 2014 	str.w	r2, [fp, #20]
 800f994:	fb8e 2003 	smull	r2, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f998:	0c12      	lsrs	r2, r2, #16
 800f99a:	eb02 4200 	add.w	r2, r2, r0, lsl #16
  __asm__(
 800f99e:	f8db 3020 	ldr.w	r3, [fp, #32]
 800f9a2:	f8cb 1018 	str.w	r1, [fp, #24]
 800f9a6:	fb8e 1003 	smull	r1, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f9aa:	0c09      	lsrs	r1, r1, #16
 800f9ac:	eb01 4100 	add.w	r1, r1, r0, lsl #16
  __asm__(
 800f9b0:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
 800f9b4:	f8cb 201c 	str.w	r2, [fp, #28]
 800f9b8:	fb8e 2003 	smull	r2, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f9bc:	0c12      	lsrs	r2, r2, #16
 800f9be:	eb02 4200 	add.w	r2, r2, r0, lsl #16
  __asm__(
 800f9c2:	f8db 3028 	ldr.w	r3, [fp, #40]	; 0x28
 800f9c6:	f8cb 1020 	str.w	r1, [fp, #32]
 800f9ca:	fb8e 1003 	smull	r1, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f9ce:	0c09      	lsrs	r1, r1, #16
 800f9d0:	eb01 4100 	add.w	r1, r1, r0, lsl #16
  __asm__(
 800f9d4:	f8db 302c 	ldr.w	r3, [fp, #44]	; 0x2c
 800f9d8:	f8cb 2024 	str.w	r2, [fp, #36]	; 0x24
 800f9dc:	fb8e 2003 	smull	r2, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f9e0:	0c12      	lsrs	r2, r2, #16
 800f9e2:	eb02 4200 	add.w	r2, r2, r0, lsl #16
  __asm__(
 800f9e6:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
 800f9ea:	f8cb 1028 	str.w	r1, [fp, #40]	; 0x28
 800f9ee:	fb8e 1003 	smull	r1, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800f9f2:	0c09      	lsrs	r1, r1, #16
 800f9f4:	eb01 4100 	add.w	r1, r1, r0, lsl #16
  __asm__(
 800f9f8:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 800f9fc:	f8cb 202c 	str.w	r2, [fp, #44]	; 0x2c
 800fa00:	fb8e 2003 	smull	r2, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800fa04:	0c12      	lsrs	r2, r2, #16
 800fa06:	eb02 4200 	add.w	r2, r2, r0, lsl #16
  __asm__(
 800fa0a:	f8db 3038 	ldr.w	r3, [fp, #56]	; 0x38
 800fa0e:	f8cb 1030 	str.w	r1, [fp, #48]	; 0x30
 800fa12:	fb8e 1003 	smull	r1, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800fa16:	0c09      	lsrs	r1, r1, #16
 800fa18:	eb01 4100 	add.w	r1, r1, r0, lsl #16
  __asm__(
 800fa1c:	f8db 303c 	ldr.w	r3, [fp, #60]	; 0x3c
 800fa20:	f8cb 2034 	str.w	r2, [fp, #52]	; 0x34
 800fa24:	fb8e 2003 	smull	r2, r0, lr, r3
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800fa28:	0c12      	lsrs	r2, r2, #16
 800fa2a:	eb02 4200 	add.w	r2, r2, r0, lsl #16
 800fa2e:	e9cb 120e 	strd	r1, r2, [fp, #56]	; 0x38
        /* Save inv_gain */
        silk_assert( inv_gain_Q31 != 0 );
        psDec->prev_gain_Q16 = psDecCtrl->Gains_Q16[ k ];

        /* Avoid abrupt transition from voiced PLC to unvoiced normal decoding */
        if( psDec->lossCnt && psDec->prevSignalType == TYPE_VOICED &&
 800fa32:	69bb      	ldr	r3, [r7, #24]
        psDec->prev_gain_Q16 = psDecCtrl->Gains_Q16[ k ];
 800fa34:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
        if( psDec->lossCnt && psDec->prevSignalType == TYPE_VOICED &&
 800fa36:	681b      	ldr	r3, [r3, #0]
        psDec->prev_gain_Q16 = psDecCtrl->Gains_Q16[ k ];
 800fa38:	6014      	str	r4, [r2, #0]
        if( psDec->lossCnt && psDec->prevSignalType == TYPE_VOICED &&
 800fa3a:	b12b      	cbz	r3, 800fa48 <silk_decode_core+0x340>
 800fa3c:	f241 0344 	movw	r3, #4164	; 0x1044
 800fa40:	58d3      	ldr	r3, [r2, r3]
 800fa42:	2b02      	cmp	r3, #2
 800fa44:	f000 8221 	beq.w	800fe8a <silk_decode_core+0x782>

            signalType = TYPE_VOICED;
            psDecCtrl->pitchL[ k ] = psDec->lagPrev;
        }

        if( signalType == TYPE_VOICED ) {
 800fa48:	f1ba 0f02 	cmp.w	sl, #2
 800fa4c:	f000 815c 	beq.w	800fd08 <silk_decode_core+0x600>
            }
        } else {
            pres_Q14 = pexc_Q14;
        }

        for( i = 0; i < psDec->subfr_length; i++ ) {
 800fa50:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fa52:	f8d3 391c 	ldr.w	r3, [r3, #2332]	; 0x91c
 800fa56:	009a      	lsls	r2, r3, #2
 800fa58:	2b00      	cmp	r3, #0
 800fa5a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800fa5e:	633a      	str	r2, [r7, #48]	; 0x30
 800fa60:	f340 80fa 	ble.w	800fc58 <silk_decode_core+0x550>
 800fa64:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fa66:	677b      	str	r3, [r7, #116]	; 0x74
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800fa68:	f9b7 a08a 	ldrsh.w	sl, [r7, #138]	; 0x8a
 800fa6c:	f9b7 c092 	ldrsh.w	ip, [r7, #146]	; 0x92
 800fa70:	ea4f 4a0a 	mov.w	sl, sl, lsl #16
 800fa74:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 800fa78:	f8c7 c068 	str.w	ip, [r7, #104]	; 0x68
 800fa7c:	465b      	mov	r3, fp
 800fa7e:	2400      	movs	r4, #0
 800fa80:	46d4      	mov	ip, sl
 800fa82:	f9b7 009a 	ldrsh.w	r0, [r7, #154]	; 0x9a
 800fa86:	f9b7 1098 	ldrsh.w	r1, [r7, #152]	; 0x98
 800fa8a:	67b8      	str	r0, [r7, #120]	; 0x78
 800fa8c:	f9b7 009e 	ldrsh.w	r0, [r7, #158]	; 0x9e
 800fa90:	f9b7 2088 	ldrsh.w	r2, [r7, #136]	; 0x88
 800fa94:	64f8      	str	r0, [r7, #76]	; 0x4c
 800fa96:	f9b7 00a0 	ldrsh.w	r0, [r7, #160]	; 0xa0
 800fa9a:	f8c7 1084 	str.w	r1, [r7, #132]	; 0x84
 800fa9e:	f9b7 5096 	ldrsh.w	r5, [r7, #150]	; 0x96
 800faa2:	64b8      	str	r0, [r7, #72]	; 0x48
 800faa4:	0412      	lsls	r2, r2, #16
 800faa6:	f9b7 00a2 	ldrsh.w	r0, [r7, #162]	; 0xa2
 800faaa:	663a      	str	r2, [r7, #96]	; 0x60
 800faac:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800fab0:	f9b7 6094 	ldrsh.w	r6, [r7, #148]	; 0x94
 800fab4:	6478      	str	r0, [r7, #68]	; 0x44
 800fab6:	042d      	lsls	r5, r5, #16
 800fab8:	f9b7 00a4 	ldrsh.w	r0, [r7, #164]	; 0xa4
 800fabc:	f9b7 e090 	ldrsh.w	lr, [r7, #144]	; 0x90
 800fac0:	f9b7 109c 	ldrsh.w	r1, [r7, #156]	; 0x9c
 800fac4:	673d      	str	r5, [r7, #112]	; 0x70
 800fac6:	0415      	lsls	r5, r2, #16
 800fac8:	6fba      	ldr	r2, [r7, #120]	; 0x78
 800faca:	62b8      	str	r0, [r7, #40]	; 0x28
 800facc:	0436      	lsls	r6, r6, #16
 800face:	f9b7 00a6 	ldrsh.w	r0, [r7, #166]	; 0xa6
 800fad2:	66fe      	str	r6, [r7, #108]	; 0x6c
 800fad4:	0409      	lsls	r1, r1, #16
 800fad6:	0416      	lsls	r6, r2, #16
 800fad8:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 800fadc:	f9b7 908c 	ldrsh.w	r9, [r7, #140]	; 0x8c
 800fae0:	f9b7 808e 	ldrsh.w	r8, [r7, #142]	; 0x8e
 800fae4:	6278      	str	r0, [r7, #36]	; 0x24
 800fae6:	f8c7 e064 	str.w	lr, [r7, #100]	; 0x64
 800faea:	6f78      	ldr	r0, [r7, #116]	; 0x74
 800faec:	677e      	str	r6, [r7, #116]	; 0x74
 800faee:	63b9      	str	r1, [r7, #56]	; 0x38
 800faf0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800faf2:	3804      	subs	r0, #4
 800faf4:	0411      	lsls	r1, r2, #16
 800faf6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800faf8:	63f9      	str	r1, [r7, #60]	; 0x3c
 800fafa:	0411      	lsls	r1, r2, #16
 800fafc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800fafe:	6439      	str	r1, [r7, #64]	; 0x40
 800fb00:	0411      	lsls	r1, r2, #16
 800fb02:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800fb04:	6479      	str	r1, [r7, #68]	; 0x44
 800fb06:	0411      	lsls	r1, r2, #16
 800fb08:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800fb0a:	64b9      	str	r1, [r7, #72]	; 0x48
 800fb0c:	0412      	lsls	r2, r2, #16
 800fb0e:	64fa      	str	r2, [r7, #76]	; 0x4c
            /* Short-term prediction */
            celt_assert( psDec->LPC_order == 10 || psDec->LPC_order == 16 );
            /* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
            LPC_pred_Q10 = silk_RSHIFT( psDec->LPC_order, 1 );
 800fb10:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800fb12:	ea4f 4909 	mov.w	r9, r9, lsl #16
 800fb16:	1052      	asrs	r2, r2, #1
 800fb18:	67ba      	str	r2, [r7, #120]	; 0x78
 800fb1a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800fb1c:	ea4f 4808 	mov.w	r8, r8, lsl #16
 800fb20:	1e91      	subs	r1, r2, #2
 800fb22:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800fb24:	f8c7 1084 	str.w	r1, [r7, #132]	; 0x84
 800fb28:	f8c7 b028 	str.w	fp, [r7, #40]	; 0x28
  __asm__(
 800fb2c:	6bde      	ldr	r6, [r3, #60]	; 0x3c
 800fb2e:	6e39      	ldr	r1, [r7, #96]	; 0x60
 800fb30:	fb86 ae01 	smull	sl, lr, r6, r1
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i -  1 ], A_Q12_tmp[ 0 ] );
 800fb34:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 800fb36:	6b9e      	ldr	r6, [r3, #56]	; 0x38
 800fb38:	eb01 0a0e 	add.w	sl, r1, lr
 800fb3c:	fb86 be0c 	smull	fp, lr, r6, ip
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i -  2 ], A_Q12_tmp[ 1 ] );
 800fb40:	44d6      	add	lr, sl
 800fb42:	6b5e      	ldr	r6, [r3, #52]	; 0x34
 800fb44:	fb86 ba09 	smull	fp, sl, r6, r9
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i -  3 ], A_Q12_tmp[ 2 ] );
 800fb48:	44d6      	add	lr, sl
 800fb4a:	6b1e      	ldr	r6, [r3, #48]	; 0x30
 800fb4c:	fb86 ba08 	smull	fp, sl, r6, r8
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i -  4 ], A_Q12_tmp[ 3 ] );
 800fb50:	44f2      	add	sl, lr
 800fb52:	6ade      	ldr	r6, [r3, #44]	; 0x2c
 800fb54:	6e79      	ldr	r1, [r7, #100]	; 0x64
 800fb56:	fb86 be01 	smull	fp, lr, r6, r1
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i -  5 ], A_Q12_tmp[ 4 ] );
 800fb5a:	44f2      	add	sl, lr
 800fb5c:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 800fb5e:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 800fb60:	fb86 be01 	smull	fp, lr, r6, r1
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i -  6 ], A_Q12_tmp[ 5 ] );
 800fb64:	44d6      	add	lr, sl
 800fb66:	6a5e      	ldr	r6, [r3, #36]	; 0x24
 800fb68:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 800fb6a:	fb86 ba01 	smull	fp, sl, r6, r1
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i -  7 ], A_Q12_tmp[ 6 ] );
 800fb6e:	44d6      	add	lr, sl
 800fb70:	6a1e      	ldr	r6, [r3, #32]
 800fb72:	6f39      	ldr	r1, [r7, #112]	; 0x70
 800fb74:	fb86 ba01 	smull	fp, sl, r6, r1
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i -  8 ], A_Q12_tmp[ 7 ] );
 800fb78:	44f2      	add	sl, lr
 800fb7a:	69de      	ldr	r6, [r3, #28]
 800fb7c:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800fb7e:	fb86 be05 	smull	fp, lr, r6, r5
 800fb82:	699e      	ldr	r6, [r3, #24]
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i -  9 ], A_Q12_tmp[ 8 ] );
 800fb84:	44f2      	add	sl, lr
 800fb86:	fb86 be01 	smull	fp, lr, r6, r1
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i - 10 ], A_Q12_tmp[ 9 ] );
            if( psDec->LPC_order == 16 ) {
 800fb8a:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 800fb8c:	3401      	adds	r4, #1
 800fb8e:	2910      	cmp	r1, #16
            LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i - 10 ], A_Q12_tmp[ 9 ] );
 800fb90:	44d6      	add	lr, sl
            if( psDec->LPC_order == 16 ) {
 800fb92:	d11d      	bne.n	800fbd0 <silk_decode_core+0x4c8>
 800fb94:	695e      	ldr	r6, [r3, #20]
 800fb96:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800fb98:	fb86 ba01 	smull	fp, sl, r6, r1
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i - 11 ], A_Q12_tmp[ 10 ] );
 800fb9c:	44d6      	add	lr, sl
 800fb9e:	691e      	ldr	r6, [r3, #16]
 800fba0:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800fba2:	fb86 ba01 	smull	fp, sl, r6, r1
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i - 12 ], A_Q12_tmp[ 11 ] );
 800fba6:	44d6      	add	lr, sl
 800fba8:	68de      	ldr	r6, [r3, #12]
 800fbaa:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800fbac:	fb86 ba01 	smull	fp, sl, r6, r1
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i - 13 ], A_Q12_tmp[ 12 ] );
 800fbb0:	44d6      	add	lr, sl
 800fbb2:	689e      	ldr	r6, [r3, #8]
 800fbb4:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800fbb6:	fb86 ba01 	smull	fp, sl, r6, r1
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i - 14 ], A_Q12_tmp[ 13 ] );
 800fbba:	44f2      	add	sl, lr
 800fbbc:	685e      	ldr	r6, [r3, #4]
 800fbbe:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800fbc0:	fb86 be01 	smull	fp, lr, r6, r1
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i - 15 ], A_Q12_tmp[ 14 ] );
 800fbc4:	44f2      	add	sl, lr
 800fbc6:	681e      	ldr	r6, [r3, #0]
 800fbc8:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800fbca:	fb86 be01 	smull	fp, lr, r6, r1
                LPC_pred_Q10 = silk_SMLAWB( LPC_pred_Q10, sLPC_Q14[ MAX_LPC_ORDER + i - 16 ], A_Q12_tmp[ 15 ] );
 800fbce:	44d6      	add	lr, sl
            }

            /* Add prediction to LPC excitation */
            sLPC_Q14[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( pres_Q14[ i ], silk_LSHIFT_SAT32( LPC_pred_Q10, 4 ) );
 800fbd0:	f1be 6f00 	cmp.w	lr, #134217728	; 0x8000000
 800fbd4:	f850 6f04 	ldr.w	r6, [r0, #4]!
 800fbd8:	da68      	bge.n	800fcac <silk_decode_core+0x5a4>
 800fbda:	f1be 4f78 	cmp.w	lr, #4160749568	; 0xf8000000
 800fbde:	db79      	blt.n	800fcd4 <silk_decode_core+0x5cc>
 800fbe0:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
 800fbe4:	eb16 0f0e 	cmn.w	r6, lr
 800fbe8:	d469      	bmi.n	800fcbe <silk_decode_core+0x5b6>
 800fbea:	ea16 0f0e 	tst.w	r6, lr
 800fbee:	d45a      	bmi.n	800fca6 <silk_decode_core+0x59e>
 800fbf0:	4476      	add	r6, lr
  __asm__(
 800fbf2:	fb86 ea02 	smull	lr, sl, r6, r2
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800fbf6:	ea4f 4e1e 	mov.w	lr, lr, lsr #16
 800fbfa:	eb0e 4e0a 	add.w	lr, lr, sl, lsl #16

            /* Scale with gain */
            pxq[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( sLPC_Q14[ MAX_LPC_ORDER + i ], Gain_Q10 ), 8 ) );
 800fbfe:	ea4f 1eee 	mov.w	lr, lr, asr #7
 800fc02:	f10e 0e01 	add.w	lr, lr, #1
 800fc06:	f5be 3f80 	cmp.w	lr, #65536	; 0x10000
            sLPC_Q14[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( pres_Q14[ i ], silk_LSHIFT_SAT32( LPC_pred_Q10, 4 ) );
 800fc0a:	641e      	str	r6, [r3, #64]	; 0x40
            pxq[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( sLPC_Q14[ MAX_LPC_ORDER + i ], Gain_Q10 ), 8 ) );
 800fc0c:	da5d      	bge.n	800fcca <silk_decode_core+0x5c2>
  __asm__(
 800fc0e:	fb86 ea02 	smull	lr, sl, r6, r2
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800fc12:	ea4f 4e1e 	mov.w	lr, lr, lsr #16
 800fc16:	eb0e 4e0a 	add.w	lr, lr, sl, lsl #16
 800fc1a:	ea4f 1eee 	mov.w	lr, lr, asr #7
 800fc1e:	f10e 0e01 	add.w	lr, lr, #1
 800fc22:	f51e 3f80 	cmn.w	lr, #65536	; 0x10000
 800fc26:	db53      	blt.n	800fcd0 <silk_decode_core+0x5c8>
  __asm__(
 800fc28:	fb86 ea02 	smull	lr, sl, r6, r2
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800fc2c:	ea4f 4e1e 	mov.w	lr, lr, lsr #16
 800fc30:	eb0e 460a 	add.w	r6, lr, sl, lsl #16
 800fc34:	11f6      	asrs	r6, r6, #7
 800fc36:	3601      	adds	r6, #1
 800fc38:	f346 064f 	sbfx	r6, r6, #1, #16
 800fc3c:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
 800fc40:	3304      	adds	r3, #4
 800fc42:	f821 6f02 	strh.w	r6, [r1, #2]!
 800fc46:	f8c7 1084 	str.w	r1, [r7, #132]	; 0x84
        for( i = 0; i < psDec->subfr_length; i++ ) {
 800fc4a:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 800fc4e:	42a1      	cmp	r1, r4
 800fc50:	f73f af6c 	bgt.w	800fb2c <silk_decode_core+0x424>
 800fc54:	f8d7 b028 	ldr.w	fp, [r7, #40]	; 0x28
        }

        /* Update LPC filter state */
        silk_memcpy( sLPC_Q14, &sLPC_Q14[ psDec->subfr_length ], MAX_LPC_ORDER * sizeof( opus_int32 ) );
 800fc58:	465c      	mov	r4, fp
 800fc5a:	6b3e      	ldr	r6, [r7, #48]	; 0x30
 800fc5c:	eb0b 0506 	add.w	r5, fp, r6
 800fc60:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800fc62:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800fc64:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800fc66:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800fc68:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800fc6a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800fc6c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 800fc70:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        pexc_Q14 += psDec->subfr_length;
 800fc74:	6d79      	ldr	r1, [r7, #84]	; 0x54
        pxq      += psDec->subfr_length;
 800fc76:	f8d7 4080 	ldr.w	r4, [r7, #128]	; 0x80
        pexc_Q14 += psDec->subfr_length;
 800fc7a:	4431      	add	r1, r6
 800fc7c:	6579      	str	r1, [r7, #84]	; 0x54
        pxq      += psDec->subfr_length;
 800fc7e:	6d39      	ldr	r1, [r7, #80]	; 0x50
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800fc80:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 800fc82:	6dba      	ldr	r2, [r7, #88]	; 0x58
        pxq      += psDec->subfr_length;
 800fc84:	eb01 0144 	add.w	r1, r1, r4, lsl #1
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800fc88:	f8d0 3914 	ldr.w	r3, [r0, #2324]	; 0x914
        pxq      += psDec->subfr_length;
 800fc8c:	6539      	str	r1, [r7, #80]	; 0x50
 800fc8e:	6b79      	ldr	r1, [r7, #52]	; 0x34
    for( k = 0; k < psDec->nb_subfr; k++ ) {
 800fc90:	3201      	adds	r2, #1
 800fc92:	310a      	adds	r1, #10
 800fc94:	4293      	cmp	r3, r2
 800fc96:	65ba      	str	r2, [r7, #88]	; 0x58
 800fc98:	6379      	str	r1, [r7, #52]	; 0x34
 800fc9a:	f340 80cf 	ble.w	800fe3c <silk_decode_core+0x734>
 800fc9e:	f990 aacd 	ldrsb.w	sl, [r0, #2765]	; 0xacd
 800fca2:	4614      	mov	r4, r2
 800fca4:	e5d5      	b.n	800f852 <silk_decode_core+0x14a>
            sLPC_Q14[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( pres_Q14[ i ], silk_LSHIFT_SAT32( LPC_pred_Q10, 4 ) );
 800fca6:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
 800fcaa:	e7a2      	b.n	800fbf2 <silk_decode_core+0x4ea>
 800fcac:	f106 4e00 	add.w	lr, r6, #2147483648	; 0x80000000
 800fcb0:	f1ae 0e10 	sub.w	lr, lr, #16
 800fcb4:	f1be 0f00 	cmp.w	lr, #0
 800fcb8:	f8df e328 	ldr.w	lr, [pc, #808]	; 800ffe4 <silk_decode_core+0x8dc>
 800fcbc:	da95      	bge.n	800fbea <silk_decode_core+0x4e2>
 800fcbe:	ea56 010e 	orrs.w	r1, r6, lr
 800fcc2:	d495      	bmi.n	800fbf0 <silk_decode_core+0x4e8>
 800fcc4:	f06f 4600 	mvn.w	r6, #2147483648	; 0x80000000
 800fcc8:	e793      	b.n	800fbf2 <silk_decode_core+0x4ea>
            pxq[ i ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( silk_SMULWW( sLPC_Q14[ MAX_LPC_ORDER + i ], Gain_Q10 ), 8 ) );
 800fcca:	f647 76ff 	movw	r6, #32767	; 0x7fff
 800fcce:	e7b5      	b.n	800fc3c <silk_decode_core+0x534>
 800fcd0:	4ec3      	ldr	r6, [pc, #780]	; (800ffe0 <silk_decode_core+0x8d8>)
 800fcd2:	e7b3      	b.n	800fc3c <silk_decode_core+0x534>
            sLPC_Q14[ MAX_LPC_ORDER + i ] = silk_ADD_SAT32( pres_Q14[ i ], silk_LSHIFT_SAT32( LPC_pred_Q10, 4 ) );
 800fcd4:	f1b6 4f00 	cmp.w	r6, #2147483648	; 0x80000000
 800fcd8:	f04f 4e00 	mov.w	lr, #2147483648	; 0x80000000
 800fcdc:	d585      	bpl.n	800fbea <silk_decode_core+0x4e2>
 800fcde:	e7ee      	b.n	800fcbe <silk_decode_core+0x5b6>
            gain_adj_Q16 = (opus_int32)1 << 16;
 800fce0:	f44f 3e80 	mov.w	lr, #65536	; 0x10000
 800fce4:	e6a5      	b.n	800fa32 <silk_decode_core+0x32a>
 800fce6:	f06f 0c10 	mvn.w	ip, #16
 800fcea:	261f      	movs	r6, #31
 800fcec:	e5d3      	b.n	800f896 <silk_decode_core+0x18e>
        return silk_LSHIFT_SAT32(result, -lshift);
 800fcee:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 800fcf2:	f1cc 0c00 	rsb	ip, ip, #0
 800fcf6:	fa42 f20c 	asr.w	r2, r2, ip
 800fcfa:	4293      	cmp	r3, r2
 800fcfc:	f340 812d 	ble.w	800ff5a <silk_decode_core+0x852>
 800fd00:	4613      	mov	r3, r2
 800fd02:	fa03 f90c 	lsl.w	r9, r3, ip
 800fd06:	e5e0      	b.n	800f8ca <silk_decode_core+0x1c2>
 800fd08:	6a3b      	ldr	r3, [r7, #32]
 800fd0a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800fd0c:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
 800fd10:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fd12:	f8d3 391c 	ldr.w	r3, [r3, #2332]	; 0x91c
 800fd16:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
            if( k == 0 || ( k == 2 && NLSF_interpolation_flag ) ) {
 800fd1a:	2a00      	cmp	r2, #0
 800fd1c:	f000 80d4 	beq.w	800fec8 <silk_decode_core+0x7c0>
 800fd20:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 800fd24:	2a02      	cmp	r2, #2
 800fd26:	f8c7 c030 	str.w	ip, [r7, #48]	; 0x30
 800fd2a:	f000 8126 	beq.w	800ff7a <silk_decode_core+0x872>
                if( gain_adj_Q16 != (opus_int32)1 << 16 ) {
 800fd2e:	f5be 3f80 	cmp.w	lr, #65536	; 0x10000
 800fd32:	d012      	beq.n	800fd5a <silk_decode_core+0x652>
                    for( i = 0; i < lag + LTP_ORDER/2; i++ ) {
 800fd34:	1c63      	adds	r3, r4, #1
 800fd36:	db10      	blt.n	800fd5a <silk_decode_core+0x652>
 800fd38:	2000      	movs	r0, #0
 800fd3a:	697b      	ldr	r3, [r7, #20]
 800fd3c:	69fa      	ldr	r2, [r7, #28]
 800fd3e:	1ca6      	adds	r6, r4, #2
 800fd40:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  __asm__(
 800fd44:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 800fd48:	3001      	adds	r0, #1
 800fd4a:	fb8e 5302 	smull	r5, r3, lr, r2
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 800fd4e:	041b      	lsls	r3, r3, #16
 800fd50:	eb03 4315 	add.w	r3, r3, r5, lsr #16
 800fd54:	42b0      	cmp	r0, r6
                        sLTP_Q15[ sLTP_buf_idx - i - 1 ] = silk_SMULWW( gain_adj_Q16, sLTP_Q15[ sLTP_buf_idx - i - 1 ] );
 800fd56:	600b      	str	r3, [r1, #0]
                    for( i = 0; i < lag + LTP_ORDER/2; i++ ) {
 800fd58:	d1f4      	bne.n	800fd44 <silk_decode_core+0x63c>
            pred_lag_ptr = &sLTP_Q15[ sLTP_buf_idx - lag + LTP_ORDER / 2 ];
 800fd5a:	69fb      	ldr	r3, [r7, #28]
 800fd5c:	1b1a      	subs	r2, r3, r4
 800fd5e:	697b      	ldr	r3, [r7, #20]
 800fd60:	3202      	adds	r2, #2
 800fd62:	eb03 0382 	add.w	r3, r3, r2, lsl #2
            for( i = 0; i < psDec->subfr_length; i++ ) {
 800fd66:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800fd6a:	2a00      	cmp	r2, #0
 800fd6c:	f77f af74 	ble.w	800fc58 <silk_decode_core+0x550>
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800fd70:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800fd72:	6978      	ldr	r0, [r7, #20]
 800fd74:	f9b1 4002 	ldrsh.w	r4, [r1, #2]
 800fd78:	f9b1 6006 	ldrsh.w	r6, [r1, #6]
 800fd7c:	4686      	mov	lr, r0
 800fd7e:	0424      	lsls	r4, r4, #16
 800fd80:	67bc      	str	r4, [r7, #120]	; 0x78
 800fd82:	0434      	lsls	r4, r6, #16
 800fd84:	f8c7 b070 	str.w	fp, [r7, #112]	; 0x70
 800fd88:	46a3      	mov	fp, r4
 800fd8a:	f9b1 2004 	ldrsh.w	r2, [r1, #4]
 800fd8e:	f9b1 5000 	ldrsh.w	r5, [r1]
 800fd92:	0412      	lsls	r2, r2, #16
 800fd94:	f9b1 a008 	ldrsh.w	sl, [r1, #8]
 800fd98:	69f8      	ldr	r0, [r7, #28]
 800fd9a:	1f19      	subs	r1, r3, #4
 800fd9c:	67fa      	str	r2, [r7, #124]	; 0x7c
 800fd9e:	f1a3 0210 	sub.w	r2, r3, #16
 800fda2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fda4:	eb0e 0080 	add.w	r0, lr, r0, lsl #2
 800fda8:	1f1e      	subs	r6, r3, #4
 800fdaa:	693b      	ldr	r3, [r7, #16]
 800fdac:	042d      	lsls	r5, r5, #16
 800fdae:	3804      	subs	r0, #4
 800fdb0:	677d      	str	r5, [r7, #116]	; 0x74
 800fdb2:	ea4f 4a0a 	mov.w	sl, sl, lsl #16
 800fdb6:	448c      	add	ip, r1
 800fdb8:	1f1d      	subs	r5, r3, #4
 800fdba:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84
 800fdbe:	4696      	mov	lr, r2
  __asm__(
 800fdc0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800fdc2:	f851 4f04 	ldr.w	r4, [r1, #4]!
 800fdc6:	4699      	mov	r9, r3
 800fdc8:	fb84 8309 	smull	r8, r3, r4, r9
 800fdcc:	6fbc      	ldr	r4, [r7, #120]	; 0x78
                LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[  0 ], B_Q14[ 0 ] );
 800fdce:	f103 0802 	add.w	r8, r3, #2
 800fdd2:	4620      	mov	r0, r4
 800fdd4:	68d3      	ldr	r3, [r2, #12]
 800fdd6:	fb83 9400 	smull	r9, r4, r3, r0
                LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -1 ], B_Q14[ 1 ] );
 800fdda:	eb08 0304 	add.w	r3, r8, r4
 800fdde:	6894      	ldr	r4, [r2, #8]
 800fde0:	f8de e000 	ldr.w	lr, [lr]
 800fde4:	4620      	mov	r0, r4
 800fde6:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
            for( i = 0; i < psDec->subfr_length; i++ ) {
 800fde8:	4561      	cmp	r1, ip
 800fdea:	46a1      	mov	r9, r4
 800fdec:	fb80 8409 	smull	r8, r4, r0, r9
                LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -2 ], B_Q14[ 2 ] );
 800fdf0:	441c      	add	r4, r3
 800fdf2:	f852 3f04 	ldr.w	r3, [r2, #4]!
 800fdf6:	fb83 980b 	smull	r9, r8, r3, fp
                LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -3 ], B_Q14[ 3 ] );
 800fdfa:	4444      	add	r4, r8
                pres_Q14[ i ] = silk_ADD_LSHIFT32( pexc_Q14[ i ], LTP_pred_Q13, 1 );
 800fdfc:	f856 8f04 	ldr.w	r8, [r6, #4]!
 800fe00:	fb8e 930a 	smull	r9, r3, lr, sl
                LTP_pred_Q13 = silk_SMLAWB( LTP_pred_Q13, pred_lag_ptr[ -4 ], B_Q14[ 4 ] );
 800fe04:	4423      	add	r3, r4
                pres_Q14[ i ] = silk_ADD_LSHIFT32( pexc_Q14[ i ], LTP_pred_Q13, 1 );
 800fe06:	eb08 0343 	add.w	r3, r8, r3, lsl #1
                sLTP_Q15[ sLTP_buf_idx ] = silk_LSHIFT( pres_Q14[ i ], 1 );
 800fe0a:	ea4f 0443 	mov.w	r4, r3, lsl #1
                pres_Q14[ i ] = silk_ADD_LSHIFT32( pexc_Q14[ i ], LTP_pred_Q13, 1 );
 800fe0e:	f845 3f04 	str.w	r3, [r5, #4]!
                sLTP_Q15[ sLTP_buf_idx ] = silk_LSHIFT( pres_Q14[ i ], 1 );
 800fe12:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800fe16:	f843 4f04 	str.w	r4, [r3, #4]!
 800fe1a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
            for( i = 0; i < psDec->subfr_length; i++ ) {
 800fe1e:	d1ce      	bne.n	800fdbe <silk_decode_core+0x6b6>
 800fe20:	69fb      	ldr	r3, [r7, #28]
 800fe22:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800fe26:	f8d7 b070 	ldr.w	fp, [r7, #112]	; 0x70
 800fe2a:	4413      	add	r3, r2
 800fe2c:	61fb      	str	r3, [r7, #28]
 800fe2e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fe30:	f8d3 3924 	ldr.w	r3, [r3, #2340]	; 0x924
 800fe34:	67fb      	str	r3, [r7, #124]	; 0x7c
        pres_Q14 = res_Q14;
 800fe36:	693b      	ldr	r3, [r7, #16]
 800fe38:	677b      	str	r3, [r7, #116]	; 0x74
 800fe3a:	e615      	b.n	800fa68 <silk_decode_core+0x360>
 800fe3c:	46d8      	mov	r8, fp
    }

    /* Save LPC state */
    silk_memcpy( psDec->sLPC_Q14_buf, sLPC_Q14, MAX_LPC_ORDER * sizeof( opus_int32 ) );
 800fe3e:	4644      	mov	r4, r8
 800fe40:	68bd      	ldr	r5, [r7, #8]
 800fe42:	f108 0c40 	add.w	ip, r8, #64	; 0x40
 800fe46:	4626      	mov	r6, r4
 800fe48:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800fe4a:	4566      	cmp	r6, ip
 800fe4c:	6028      	str	r0, [r5, #0]
 800fe4e:	6069      	str	r1, [r5, #4]
 800fe50:	60aa      	str	r2, [r5, #8]
 800fe52:	60eb      	str	r3, [r5, #12]
 800fe54:	f104 0410 	add.w	r4, r4, #16
 800fe58:	f105 0510 	add.w	r5, r5, #16
 800fe5c:	d1f3      	bne.n	800fe46 <silk_decode_core+0x73e>
    RESTORE_STACK;
}
 800fe5e:	37ac      	adds	r7, #172	; 0xac
 800fe60:	46bd      	mov	sp, r7
 800fe62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fe66:	223c      	movs	r2, #60	; 0x3c
 800fe68:	211f      	movs	r1, #31
 800fe6a:	e53e      	b.n	800f8ea <silk_decode_core+0x1e2>
        return silk_LSHIFT_SAT32(result, -lshift);
 800fe6c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800fe70:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 800fe74:	f1c6 0610 	rsb	r6, r6, #16
 800fe78:	4133      	asrs	r3, r6
 800fe7a:	4131      	asrs	r1, r6
 800fe7c:	428b      	cmp	r3, r1
 800fe7e:	dd74      	ble.n	800ff6a <silk_decode_core+0x862>
 800fe80:	459c      	cmp	ip, r3
 800fe82:	f340 80a9 	ble.w	800ffd8 <silk_decode_core+0x8d0>
 800fe86:	469c      	mov	ip, r3
 800fe88:	e074      	b.n	800ff74 <silk_decode_core+0x86c>
        if( psDec->lossCnt && psDec->prevSignalType == TYPE_VOICED &&
 800fe8a:	f1ba 0f02 	cmp.w	sl, #2
 800fe8e:	f43f af3b 	beq.w	800fd08 <silk_decode_core+0x600>
            psDec->indices.signalType != TYPE_VOICED && k < MAX_NB_SUBFR/2 ) {
 800fe92:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800fe94:	2b01      	cmp	r3, #1
 800fe96:	f73f addb 	bgt.w	800fa50 <silk_decode_core+0x348>
            silk_memset( B_Q14, 0, LTP_ORDER * sizeof( opus_int16 ) );
 800fe9a:	2300      	movs	r3, #0
            B_Q14[ LTP_ORDER/2 ] = SILK_FIX_CONST( 0.25, 14 );
 800fe9c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
            silk_memset( B_Q14, 0, LTP_ORDER * sizeof( opus_int16 ) );
 800fea0:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800fea2:	604b      	str	r3, [r1, #4]
 800fea4:	600b      	str	r3, [r1, #0]
 800fea6:	810b      	strh	r3, [r1, #8]
            psDecCtrl->pitchL[ k ] = psDec->lagPrev;
 800fea8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800feaa:	f8d3 4904 	ldr.w	r4, [r3, #2308]	; 0x904
            B_Q14[ LTP_ORDER/2 ] = SILK_FIX_CONST( 0.25, 14 );
 800feae:	808a      	strh	r2, [r1, #4]
            psDecCtrl->pitchL[ k ] = psDec->lagPrev;
 800feb0:	6a3b      	ldr	r3, [r7, #32]
 800feb2:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800feb4:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 800feb8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800feba:	f8d3 391c 	ldr.w	r3, [r3, #2332]	; 0x91c
 800febe:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
            if( k == 0 || ( k == 2 && NLSF_interpolation_flag ) ) {
 800fec2:	2a00      	cmp	r2, #0
 800fec4:	f47f af2c 	bne.w	800fd20 <silk_decode_core+0x618>
                start_idx = psDec->ltp_mem_length - lag - psDec->LPC_order - LTP_ORDER / 2;
 800fec8:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &psDec->outBuf[ start_idx + k * psDec->subfr_length ],
 800feca:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
                start_idx = psDec->ltp_mem_length - lag - psDec->LPC_order - LTP_ORDER / 2;
 800fece:	f8d6 3920 	ldr.w	r3, [r6, #2336]	; 0x920
 800fed2:	f8d6 5924 	ldr.w	r5, [r6, #2340]	; 0x924
 800fed6:	1b19      	subs	r1, r3, r4
 800fed8:	1b49      	subs	r1, r1, r5
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &psDec->outBuf[ start_idx + k * psDec->subfr_length ],
 800feda:	9500      	str	r5, [sp, #0]
 800fedc:	68fd      	ldr	r5, [r7, #12]
                start_idx = psDec->ltp_mem_length - lag - psDec->LPC_order - LTP_ORDER / 2;
 800fede:	1e88      	subs	r0, r1, #2
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &psDec->outBuf[ start_idx + k * psDec->subfr_length ],
 800fee0:	f501 7128 	add.w	r1, r1, #672	; 0x2a0
 800fee4:	1a1b      	subs	r3, r3, r0
 800fee6:	9201      	str	r2, [sp, #4]
 800fee8:	eb06 0141 	add.w	r1, r6, r1, lsl #1
 800feec:	4642      	mov	r2, r8
 800feee:	eb05 0040 	add.w	r0, r5, r0, lsl #1
 800fef2:	f7fc fd91 	bl	800ca18 <silk_LPC_analysis_filter>
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800fef6:	6a3b      	ldr	r3, [r7, #32]
 800fef8:	f9b3 3088 	ldrsh.w	r3, [r3, #136]	; 0x88
 800fefc:	041b      	lsls	r3, r3, #16
  __asm__(
 800fefe:	fb89 1203 	smull	r1, r2, r9, r3
                    inv_gain_Q31 = silk_LSHIFT( silk_SMULWB( inv_gain_Q31, psDecCtrl->LTP_scale_Q14 ), 2 );
 800ff02:	ea4f 0982 	mov.w	r9, r2, lsl #2
 800ff06:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
                for( i = 0; i < lag + LTP_ORDER/2; i++ ) {
 800ff08:	1c61      	adds	r1, r4, #1
 800ff0a:	f8d2 391c 	ldr.w	r3, [r2, #2332]	; 0x91c
 800ff0e:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 800ff12:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800ff16:	f8c7 c030 	str.w	ip, [r7, #48]	; 0x30
 800ff1a:	f6ff af1e 	blt.w	800fd5a <silk_decode_core+0x652>
 800ff1e:	f8d2 3920 	ldr.w	r3, [r2, #2336]	; 0x920
 800ff22:	69fa      	ldr	r2, [r7, #28]
 800ff24:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 800ff28:	3b01      	subs	r3, #1
 800ff2a:	005b      	lsls	r3, r3, #1
 800ff2c:	f102 4180 	add.w	r1, r2, #1073741824	; 0x40000000
 800ff30:	68fa      	ldr	r2, [r7, #12]
 800ff32:	1f1d      	subs	r5, r3, #4
 800ff34:	4415      	add	r5, r2
 800ff36:	441a      	add	r2, r3
 800ff38:	697b      	ldr	r3, [r7, #20]
 800ff3a:	3901      	subs	r1, #1
 800ff3c:	eba5 0544 	sub.w	r5, r5, r4, lsl #1
 800ff40:	eb03 0181 	add.w	r1, r3, r1, lsl #2
                    sLTP_Q15[ sLTP_buf_idx - i - 1 ] = silk_SMULWB( inv_gain_Q31, sLTP[ psDec->ltp_mem_length - i - 1 ] );
 800ff44:	f932 3902 	ldrsh.w	r3, [r2], #-2
                for( i = 0; i < lag + LTP_ORDER/2; i++ ) {
 800ff48:	4295      	cmp	r5, r2
      : "%r"(a), "r"(SAFE_SHL(b,16))
 800ff4a:	ea4f 4303 	mov.w	r3, r3, lsl #16
  __asm__(
 800ff4e:	fb89 6003 	smull	r6, r0, r9, r3
                    sLTP_Q15[ sLTP_buf_idx - i - 1 ] = silk_SMULWB( inv_gain_Q31, sLTP[ psDec->ltp_mem_length - i - 1 ] );
 800ff52:	f841 0904 	str.w	r0, [r1], #-4
                for( i = 0; i < lag + LTP_ORDER/2; i++ ) {
 800ff56:	d1f5      	bne.n	800ff44 <silk_decode_core+0x83c>
 800ff58:	e6ff      	b.n	800fd5a <silk_decode_core+0x652>
        return silk_LSHIFT_SAT32(result, -lshift);
 800ff5a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800ff5e:	fa42 f20c 	asr.w	r2, r2, ip
 800ff62:	4293      	cmp	r3, r2
 800ff64:	bfb8      	it	lt
 800ff66:	4613      	movlt	r3, r2
 800ff68:	e6cb      	b.n	800fd02 <silk_decode_core+0x5fa>
        return silk_LSHIFT_SAT32(result, -lshift);
 800ff6a:	458c      	cmp	ip, r1
 800ff6c:	dc32      	bgt.n	800ffd4 <silk_decode_core+0x8cc>
 800ff6e:	459c      	cmp	ip, r3
 800ff70:	bfb8      	it	lt
 800ff72:	469c      	movlt	ip, r3
 800ff74:	fa0c fe06 	lsl.w	lr, ip, r6
 800ff78:	e4cd      	b.n	800f916 <silk_decode_core+0x20e>
            if( k == 0 || ( k == 2 && NLSF_interpolation_flag ) ) {
 800ff7a:	687b      	ldr	r3, [r7, #4]
 800ff7c:	2b03      	cmp	r3, #3
 800ff7e:	f73f aed6 	bgt.w	800fd2e <silk_decode_core+0x626>
                start_idx = psDec->ltp_mem_length - lag - psDec->LPC_order - LTP_ORDER / 2;
 800ff82:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
                    silk_memcpy( &psDec->outBuf[ psDec->ltp_mem_length ], xq, 2 * psDec->subfr_length * sizeof( opus_int16 ) );
 800ff84:	4662      	mov	r2, ip
                start_idx = psDec->ltp_mem_length - lag - psDec->LPC_order - LTP_ORDER / 2;
 800ff86:	f8d6 0920 	ldr.w	r0, [r6, #2336]	; 0x920
 800ff8a:	f8d6 3924 	ldr.w	r3, [r6, #2340]	; 0x924
 800ff8e:	1b01      	subs	r1, r0, r4
                    silk_memcpy( &psDec->outBuf[ psDec->ltp_mem_length ], xq, 2 * psDec->subfr_length * sizeof( opus_int16 ) );
 800ff90:	f200 20a2 	addw	r0, r0, #674	; 0x2a2
                start_idx = psDec->ltp_mem_length - lag - psDec->LPC_order - LTP_ORDER / 2;
 800ff94:	1acb      	subs	r3, r1, r3
                    silk_memcpy( &psDec->outBuf[ psDec->ltp_mem_length ], xq, 2 * psDec->subfr_length * sizeof( opus_int16 ) );
 800ff96:	eb06 0040 	add.w	r0, r6, r0, lsl #1
 800ff9a:	6839      	ldr	r1, [r7, #0]
                start_idx = psDec->ltp_mem_length - lag - psDec->LPC_order - LTP_ORDER / 2;
 800ff9c:	1e9d      	subs	r5, r3, #2
                    silk_memcpy( &psDec->outBuf[ psDec->ltp_mem_length ], xq, 2 * psDec->subfr_length * sizeof( opus_int16 ) );
 800ff9e:	f004 f89f 	bl	80140e0 <memcpy>
                silk_LPC_analysis_filter( &sLTP[ start_idx ], &psDec->outBuf[ start_idx + k * psDec->subfr_length ],
 800ffa2:	4630      	mov	r0, r6
 800ffa4:	f8d6 291c 	ldr.w	r2, [r6, #2332]	; 0x91c
 800ffa8:	f8d6 3920 	ldr.w	r3, [r6, #2336]	; 0x920
 800ffac:	eb05 0242 	add.w	r2, r5, r2, lsl #1
 800ffb0:	f202 21a2 	addw	r1, r2, #674	; 0x2a2
 800ffb4:	f8d6 6924 	ldr.w	r6, [r6, #2340]	; 0x924
 800ffb8:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 800ffbc:	eb00 0141 	add.w	r1, r0, r1, lsl #1
 800ffc0:	68f8      	ldr	r0, [r7, #12]
 800ffc2:	9201      	str	r2, [sp, #4]
 800ffc4:	1b5b      	subs	r3, r3, r5
 800ffc6:	4642      	mov	r2, r8
 800ffc8:	eb00 0045 	add.w	r0, r0, r5, lsl #1
 800ffcc:	9600      	str	r6, [sp, #0]
 800ffce:	f7fc fd23 	bl	800ca18 <silk_LPC_analysis_filter>
 800ffd2:	e798      	b.n	800ff06 <silk_decode_core+0x7fe>
 800ffd4:	468c      	mov	ip, r1
 800ffd6:	e7cd      	b.n	800ff74 <silk_decode_core+0x86c>
 800ffd8:	458c      	cmp	ip, r1
 800ffda:	bfb8      	it	lt
 800ffdc:	468c      	movlt	ip, r1
 800ffde:	e7c9      	b.n	800ff74 <silk_decode_core+0x86c>
 800ffe0:	ffff8000 	.word	0xffff8000
 800ffe4:	7ffffff0 	.word	0x7ffffff0

0800ffe8 <silk_decode_frame>:
    opus_int32                  *pN,                            /* O    Pointer to size of output frame             */
    opus_int                    lostFlag,                       /* I    0: no loss, 1 loss, 2 decode fec            */
    opus_int                    condCoding,                     /* I    The type of conditional coding to use       */
    int                         arch                            /* I    Run-time architecture                       */
)
{
 800ffe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ffec:	b0a7      	sub	sp, #156	; 0x9c
 800ffee:	4604      	mov	r4, r0
    opus_int         L, mv_len, ret = 0;
    SAVE_STACK;

    L = psDec->frame_length;
    ALLOC( psDecCtrl, 1, silk_decoder_control );
    psDecCtrl->LTP_scale_Q14 = 0;
 800fff0:	f04f 0c00 	mov.w	ip, #0
{
 800fff4:	af02      	add	r7, sp, #8
 800fff6:	f8d7 00b8 	ldr.w	r0, [r7, #184]	; 0xb8
 800fffa:	4688      	mov	r8, r1
 800fffc:	4615      	mov	r5, r2
 800fffe:	4699      	mov	r9, r3
    L = psDec->frame_length;
 8010000:	f8d4 6918 	ldr.w	r6, [r4, #2328]	; 0x918
    psDecCtrl->LTP_scale_Q14 = 0;
 8010004:	f8c7 c08c 	str.w	ip, [r7, #140]	; 0x8c

    /* Safety checks */
    celt_assert( L > 0 && L <= MAX_FRAME_LENGTH );

    if(   lostFlag == FLAG_DECODE_NORMAL ||
 8010008:	2800      	cmp	r0, #0
 801000a:	d04e      	beq.n	80100aa <silk_decode_frame+0xc2>
 801000c:	2802      	cmp	r0, #2
 801000e:	d107      	bne.n	8010020 <silk_decode_frame+0x38>
        ( lostFlag == FLAG_DECODE_LBRR && psDec->LBRR_flags[ psDec->nFramesDecoded ] == 1 ) )
 8010010:	f8d4 2954 	ldr.w	r2, [r4, #2388]	; 0x954
 8010014:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 8010018:	f8d3 3974 	ldr.w	r3, [r3, #2420]	; 0x974
 801001c:	2b01      	cmp	r3, #1
 801001e:	d046      	beq.n	80100ae <silk_decode_frame+0xc6>

        /* A frame has been decoded without errors */
        psDec->first_frame_after_reset = 0;
    } else {
        /* Handle packet loss by extrapolation */
        psDec->indices.signalType = psDec->prevSignalType;
 8010020:	f241 0344 	movw	r3, #4164	; 0x1044
 8010024:	58e3      	ldr	r3, [r4, r3]
        silk_PLC( psDec, psDecCtrl, pOut, 1, arch );
 8010026:	f107 0804 	add.w	r8, r7, #4
        psDec->indices.signalType = psDec->prevSignalType;
 801002a:	f884 3acd 	strb.w	r3, [r4, #2765]	; 0xacd
        silk_PLC( psDec, psDecCtrl, pOut, 1, arch );
 801002e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8010032:	4641      	mov	r1, r8
 8010034:	9300      	str	r3, [sp, #0]
 8010036:	462a      	mov	r2, r5
 8010038:	2301      	movs	r3, #1
 801003a:	4620      	mov	r0, r4
 801003c:	f7fd fe30 	bl	800dca0 <silk_PLC>

    /*************************/
    /* Update output buffer. */
    /*************************/
    celt_assert( psDec->ltp_mem_length >= psDec->frame_length );
    mv_len = psDec->ltp_mem_length - psDec->frame_length;
 8010040:	f8d4 3918 	ldr.w	r3, [r4, #2328]	; 0x918
 8010044:	f8d4 0920 	ldr.w	r0, [r4, #2336]	; 0x920
    silk_memmove( psDec->outBuf, &psDec->outBuf[ psDec->frame_length ], mv_len * sizeof(opus_int16) );
 8010048:	f203 21a2 	addw	r1, r3, #674	; 0x2a2
    mv_len = psDec->ltp_mem_length - psDec->frame_length;
 801004c:	1ac0      	subs	r0, r0, r3
    silk_memmove( psDec->outBuf, &psDec->outBuf[ psDec->frame_length ], mv_len * sizeof(opus_int16) );
 801004e:	ea4f 0a40 	mov.w	sl, r0, lsl #1
 8010052:	eb04 0141 	add.w	r1, r4, r1, lsl #1
 8010056:	4652      	mov	r2, sl
 8010058:	f204 5044 	addw	r0, r4, #1348	; 0x544
 801005c:	f004 f84b 	bl	80140f6 <memmove>
    silk_memcpy( &psDec->outBuf[ mv_len ], pOut, psDec->frame_length * sizeof( opus_int16 ) );
 8010060:	f8d4 2918 	ldr.w	r2, [r4, #2328]	; 0x918
 8010064:	f20a 5044 	addw	r0, sl, #1348	; 0x544
 8010068:	4629      	mov	r1, r5
 801006a:	4420      	add	r0, r4
 801006c:	0052      	lsls	r2, r2, #1
 801006e:	f004 f837 	bl	80140e0 <memcpy>

    /************************************************/
    /* Comfort noise generation / estimation        */
    /************************************************/
    silk_CNG( psDec, psDecCtrl, pOut, L );
 8010072:	4633      	mov	r3, r6
 8010074:	462a      	mov	r2, r5
 8010076:	4641      	mov	r1, r8
 8010078:	4620      	mov	r0, r4
 801007a:	f7fc f83f 	bl	800c0fc <silk_CNG>

    /****************************************************************/
    /* Ensure smooth connection of extrapolated and good frames     */
    /****************************************************************/
    silk_PLC_glue_frames( psDec, pOut, L );
 801007e:	4632      	mov	r2, r6
 8010080:	4620      	mov	r0, r4
 8010082:	4629      	mov	r1, r5
 8010084:	f7fe fc70 	bl	800e968 <silk_PLC_glue_frames>
    /* Set output frame length */
    *pN = L;

    RESTORE_STACK;
    return ret;
}
 8010088:	2000      	movs	r0, #0
    psDec->lagPrev = psDecCtrl->pitchL[ psDec->nb_subfr - 1 ];
 801008a:	f8d4 3914 	ldr.w	r3, [r4, #2324]	; 0x914
 801008e:	f107 0290 	add.w	r2, r7, #144	; 0x90
 8010092:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8010096:	f853 3c90 	ldr.w	r3, [r3, #-144]
}
 801009a:	3794      	adds	r7, #148	; 0x94
    psDec->lagPrev = psDecCtrl->pitchL[ psDec->nb_subfr - 1 ];
 801009c:	f8c4 3904 	str.w	r3, [r4, #2308]	; 0x904
    *pN = L;
 80100a0:	f8c9 6000 	str.w	r6, [r9]
}
 80100a4:	46bd      	mov	sp, r7
 80100a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80100aa:	f8d4 2954 	ldr.w	r2, [r4, #2388]	; 0x954
        ALLOC( pulses, (L + SHELL_CODEC_FRAME_LENGTH - 1) &
 80100ae:	f106 030f 	add.w	r3, r6, #15
 80100b2:	f023 030f 	bic.w	r3, r3, #15
 80100b6:	005b      	lsls	r3, r3, #1
        silk_decode_indices( psDec, psRangeDec, psDec->nFramesDecoded, lostFlag, condCoding );
 80100b8:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
        ALLOC( pulses, (L + SHELL_CODEC_FRAME_LENGTH - 1) &
 80100bc:	3308      	adds	r3, #8
    {
 80100be:	46eb      	mov	fp, sp
        ALLOC( pulses, (L + SHELL_CODEC_FRAME_LENGTH - 1) &
 80100c0:	ebad 0d03 	sub.w	sp, sp, r3
        silk_decode_indices( psDec, psRangeDec, psDec->nFramesDecoded, lostFlag, condCoding );
 80100c4:	9100      	str	r1, [sp, #0]
 80100c6:	4603      	mov	r3, r0
 80100c8:	4641      	mov	r1, r8
 80100ca:	4620      	mov	r0, r4
 80100cc:	f000 f834 	bl	8010138 <silk_decode_indices>
        silk_decode_pulses( psRangeDec, pulses, psDec->indices.signalType,
 80100d0:	f8d4 1918 	ldr.w	r1, [r4, #2328]	; 0x918
        ALLOC( pulses, (L + SHELL_CODEC_FRAME_LENGTH - 1) &
 80100d4:	f10d 0a08 	add.w	sl, sp, #8
        silk_decode_pulses( psRangeDec, pulses, psDec->indices.signalType,
 80100d8:	f994 3ace 	ldrsb.w	r3, [r4, #2766]	; 0xace
 80100dc:	f994 2acd 	ldrsb.w	r2, [r4, #2765]	; 0xacd
 80100e0:	4640      	mov	r0, r8
 80100e2:	9100      	str	r1, [sp, #0]
        silk_decode_parameters( psDec, psDecCtrl, condCoding );
 80100e4:	f107 0804 	add.w	r8, r7, #4
        silk_decode_pulses( psRangeDec, pulses, psDec->indices.signalType,
 80100e8:	4651      	mov	r1, sl
 80100ea:	f000 fbff 	bl	80108ec <silk_decode_pulses>
        silk_decode_parameters( psDec, psDecCtrl, condCoding );
 80100ee:	4641      	mov	r1, r8
 80100f0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80100f4:	4620      	mov	r0, r4
 80100f6:	f000 f983 	bl	8010400 <silk_decode_parameters>
        silk_decode_core( psDec, psDecCtrl, pOut, pulses, arch );
 80100fa:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80100fe:	4653      	mov	r3, sl
 8010100:	9200      	str	r2, [sp, #0]
 8010102:	4641      	mov	r1, r8
 8010104:	462a      	mov	r2, r5
 8010106:	4620      	mov	r0, r4
 8010108:	f7ff fafe 	bl	800f708 <silk_decode_core>
        silk_PLC( psDec, psDecCtrl, pOut, 0, arch );
 801010c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8010110:	4641      	mov	r1, r8
 8010112:	9300      	str	r3, [sp, #0]
 8010114:	462a      	mov	r2, r5
 8010116:	2300      	movs	r3, #0
 8010118:	4620      	mov	r0, r4
 801011a:	f7fd fdc1 	bl	800dca0 <silk_PLC>
        psDec->lossCnt = 0;
 801011e:	2300      	movs	r3, #0
        psDec->prevSignalType = psDec->indices.signalType;
 8010120:	f241 0244 	movw	r2, #4164	; 0x1044
        psDec->lossCnt = 0;
 8010124:	f504 5182 	add.w	r1, r4, #4160	; 0x1040
 8010128:	600b      	str	r3, [r1, #0]
        psDec->prevSignalType = psDec->indices.signalType;
 801012a:	f994 1acd 	ldrsb.w	r1, [r4, #2765]	; 0xacd
        psDec->first_frame_after_reset = 0;
 801012e:	f8c4 3948 	str.w	r3, [r4, #2376]	; 0x948
        psDec->prevSignalType = psDec->indices.signalType;
 8010132:	50a1      	str	r1, [r4, r2]
 8010134:	46dd      	mov	sp, fp
    {
 8010136:	e783      	b.n	8010040 <silk_decode_frame+0x58>

08010138 <silk_decode_indices>:
    ec_dec                      *psRangeDec,                    /* I/O  Compressor data structure                   */
    opus_int                    FrameIndex,                     /* I    Frame number                                */
    opus_int                    decode_LBRR,                    /* I    Flag indicating LBRR data is being decoded  */
    opus_int                    condCoding                      /* I    The type of conditional coding to use       */
)
{
 8010138:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801013c:	b08c      	sub	sp, #48	; 0x30
 801013e:	4604      	mov	r4, r0
 8010140:	460d      	mov	r5, r1
 8010142:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
    opus_uint8 pred_Q8[ MAX_LPC_ORDER ];

    /*******************************************/
    /* Decode signal type and quantizer offset */
    /*******************************************/
    if( decode_LBRR || psDec->VAD_flags[ FrameIndex ] ) {
 8010146:	b933      	cbnz	r3, 8010156 <silk_decode_indices+0x1e>
 8010148:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 801014c:	f8d2 3964 	ldr.w	r3, [r2, #2404]	; 0x964
 8010150:	2b00      	cmp	r3, #0
 8010152:	f000 809c 	beq.w	801028e <silk_decode_indices+0x156>
        Ix = ec_dec_icdf( psRangeDec, silk_type_offset_VAD_iCDF, 8 ) + 2;
 8010156:	2208      	movs	r2, #8
 8010158:	499a      	ldr	r1, [pc, #616]	; (80103c4 <silk_decode_indices+0x28c>)
 801015a:	4628      	mov	r0, r5
 801015c:	f7f8 fa16 	bl	800858c <ec_dec_icdf>
 8010160:	3002      	adds	r0, #2
    } else {
        Ix = ec_dec_icdf( psRangeDec, silk_type_offset_no_VAD_iCDF, 8 );
    }
    psDec->indices.signalType      = (opus_int8)silk_RSHIFT( Ix, 1 );
 8010162:	f340 0347 	sbfx	r3, r0, #1, #8

    /****************/
    /* Decode gains */
    /****************/
    /* First subframe */
    if( condCoding == CODE_CONDITIONALLY ) {
 8010166:	f1b9 0f02 	cmp.w	r9, #2
    psDec->indices.quantOffsetType = (opus_int8)( Ix & 1 );
 801016a:	f000 0001 	and.w	r0, r0, #1
    psDec->indices.signalType      = (opus_int8)silk_RSHIFT( Ix, 1 );
 801016e:	f884 3acd 	strb.w	r3, [r4, #2765]	; 0xacd
    psDec->indices.quantOffsetType = (opus_int8)( Ix & 1 );
 8010172:	f884 0ace 	strb.w	r0, [r4, #2766]	; 0xace
    if( condCoding == CODE_CONDITIONALLY ) {
 8010176:	f000 80e4 	beq.w	8010342 <silk_decode_indices+0x20a>
        /* Conditional coding */
        psDec->indices.GainsIndices[ 0 ] = (opus_int8)ec_dec_icdf( psRangeDec, silk_delta_gain_iCDF, 8 );
    } else {
        /* Independent coding, in two stages: MSB bits followed by 3 LSBs */
        psDec->indices.GainsIndices[ 0 ]  = (opus_int8)silk_LSHIFT( ec_dec_icdf( psRangeDec, silk_gain_iCDF[ psDec->indices.signalType ], 8 ), 3 );
 801017a:	4993      	ldr	r1, [pc, #588]	; (80103c8 <silk_decode_indices+0x290>)
 801017c:	2208      	movs	r2, #8
 801017e:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8010182:	4628      	mov	r0, r5
 8010184:	f7f8 fa02 	bl	800858c <ec_dec_icdf>
 8010188:	00c0      	lsls	r0, r0, #3
 801018a:	f884 0ab0 	strb.w	r0, [r4, #2736]	; 0xab0
        psDec->indices.GainsIndices[ 0 ] += (opus_int8)ec_dec_icdf( psRangeDec, silk_uniform8_iCDF, 8 );
 801018e:	2208      	movs	r2, #8
 8010190:	498e      	ldr	r1, [pc, #568]	; (80103cc <silk_decode_indices+0x294>)
 8010192:	4628      	mov	r0, r5
 8010194:	f7f8 f9fa 	bl	800858c <ec_dec_icdf>
 8010198:	f894 3ab0 	ldrb.w	r3, [r4, #2736]	; 0xab0
 801019c:	4418      	add	r0, r3
 801019e:	f884 0ab0 	strb.w	r0, [r4, #2736]	; 0xab0
    }

    /* Remaining subframes */
    for( i = 1; i < psDec->nb_subfr; i++ ) {
 80101a2:	f8d4 3914 	ldr.w	r3, [r4, #2324]	; 0x914
 80101a6:	2b01      	cmp	r3, #1
 80101a8:	dd10      	ble.n	80101cc <silk_decode_indices+0x94>
 80101aa:	2601      	movs	r6, #1
        psDec->indices.GainsIndices[ i ] = (opus_int8)ec_dec_icdf( psRangeDec, silk_delta_gain_iCDF, 8 );
 80101ac:	f8df 8238 	ldr.w	r8, [pc, #568]	; 80103e8 <silk_decode_indices+0x2b0>
 80101b0:	f604 27b1 	addw	r7, r4, #2737	; 0xab1
 80101b4:	2208      	movs	r2, #8
 80101b6:	4641      	mov	r1, r8
 80101b8:	4628      	mov	r0, r5
 80101ba:	f7f8 f9e7 	bl	800858c <ec_dec_icdf>
 80101be:	f807 0b01 	strb.w	r0, [r7], #1
    for( i = 1; i < psDec->nb_subfr; i++ ) {
 80101c2:	f8d4 3914 	ldr.w	r3, [r4, #2324]	; 0x914
 80101c6:	3601      	adds	r6, #1
 80101c8:	42b3      	cmp	r3, r6
 80101ca:	dcf3      	bgt.n	80101b4 <silk_decode_indices+0x7c>
    }

    /**********************/
    /* Decode LSF Indices */
    /**********************/
    psDec->indices.NLSFIndices[ 0 ] = (opus_int8)ec_dec_icdf( psRangeDec, &psDec->psNLSF_CB->CB1_iCDF[ ( psDec->indices.signalType >> 1 ) * psDec->psNLSF_CB->nVectors ], 8 );
 80101cc:	f8d4 2aac 	ldr.w	r2, [r4, #2732]	; 0xaac
 80101d0:	f994 3acd 	ldrsb.w	r3, [r4, #2765]	; 0xacd
 80101d4:	f9b2 1000 	ldrsh.w	r1, [r2]
 80101d8:	6912      	ldr	r2, [r2, #16]
 80101da:	105b      	asrs	r3, r3, #1
 80101dc:	fb01 2103 	mla	r1, r1, r3, r2
 80101e0:	4628      	mov	r0, r5
 80101e2:	2208      	movs	r2, #8
 80101e4:	f7f8 f9d2 	bl	800858c <ec_dec_icdf>
 80101e8:	b243      	sxtb	r3, r0
 80101ea:	f884 3ab8 	strb.w	r3, [r4, #2744]	; 0xab8
    silk_NLSF_unpack( ec_ix, pred_Q8, psDec->psNLSF_CB, psDec->indices.NLSFIndices[ 0 ] );
 80101ee:	f8d4 2aac 	ldr.w	r2, [r4, #2732]	; 0xaac
 80101f2:	a804      	add	r0, sp, #16
 80101f4:	4669      	mov	r1, sp
 80101f6:	f7fd fcff 	bl	800dbf8 <silk_NLSF_unpack>
    celt_assert( psDec->psNLSF_CB->order == psDec->LPC_order );
    for( i = 0; i < psDec->psNLSF_CB->order; i++ ) {
 80101fa:	f8d4 3aac 	ldr.w	r3, [r4, #2732]	; 0xaac
 80101fe:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8010202:	2a00      	cmp	r2, #0
 8010204:	dd25      	ble.n	8010252 <silk_decode_indices+0x11a>
 8010206:	4f72      	ldr	r7, [pc, #456]	; (80103d0 <silk_decode_indices+0x298>)
 8010208:	ae04      	add	r6, sp, #16
        Ix = ec_dec_icdf( psRangeDec, &psDec->psNLSF_CB->ec_iCDF[ ec_ix[ i ] ], 8 );
        if( Ix == 0 ) {
            Ix -= ec_dec_icdf( psRangeDec, silk_NLSF_EXT_iCDF, 8 );
        } else if( Ix == 2 * NLSF_QUANT_MAX_AMPLITUDE ) {
            Ix += ec_dec_icdf( psRangeDec, silk_NLSF_EXT_iCDF, 8 );
 801020a:	f8df 81ec 	ldr.w	r8, [pc, #492]	; 80103f8 <silk_decode_indices+0x2c0>
 801020e:	1b3f      	subs	r7, r7, r4
 8010210:	f604 2ab8 	addw	sl, r4, #2744	; 0xab8
 8010214:	e00c      	b.n	8010230 <silk_decode_indices+0xf8>
        } else if( Ix == 2 * NLSF_QUANT_MAX_AMPLITUDE ) {
 8010216:	2808      	cmp	r0, #8
 8010218:	d032      	beq.n	8010280 <silk_decode_indices+0x148>
        }
        psDec->indices.NLSFIndices[ i+1 ] = (opus_int8)( Ix - NLSF_QUANT_MAX_AMPLITUDE );
 801021a:	3804      	subs	r0, #4
 801021c:	eb07 020a 	add.w	r2, r7, sl
 8010220:	f80a 0f01 	strb.w	r0, [sl, #1]!
    for( i = 0; i < psDec->psNLSF_CB->order; i++ ) {
 8010224:	f8d4 3aac 	ldr.w	r3, [r4, #2732]	; 0xaac
 8010228:	f9b3 1002 	ldrsh.w	r1, [r3, #2]
 801022c:	4291      	cmp	r1, r2
 801022e:	dd10      	ble.n	8010252 <silk_decode_indices+0x11a>
        Ix = ec_dec_icdf( psRangeDec, &psDec->psNLSF_CB->ec_iCDF[ ec_ix[ i ] ], 8 );
 8010230:	69d9      	ldr	r1, [r3, #28]
 8010232:	f936 3b02 	ldrsh.w	r3, [r6], #2
 8010236:	2208      	movs	r2, #8
 8010238:	4419      	add	r1, r3
 801023a:	4628      	mov	r0, r5
 801023c:	f7f8 f9a6 	bl	800858c <ec_dec_icdf>
        if( Ix == 0 ) {
 8010240:	2800      	cmp	r0, #0
 8010242:	d1e8      	bne.n	8010216 <silk_decode_indices+0xde>
            Ix -= ec_dec_icdf( psRangeDec, silk_NLSF_EXT_iCDF, 8 );
 8010244:	2208      	movs	r2, #8
 8010246:	4641      	mov	r1, r8
 8010248:	4628      	mov	r0, r5
 801024a:	f7f8 f99f 	bl	800858c <ec_dec_icdf>
 801024e:	4240      	negs	r0, r0
 8010250:	e7e3      	b.n	801021a <silk_decode_indices+0xe2>
    }

    /* Decode LSF interpolation factor */
    if( psDec->nb_subfr == MAX_NB_SUBFR ) {
 8010252:	f8d4 3914 	ldr.w	r3, [r4, #2324]	; 0x914
 8010256:	2b04      	cmp	r3, #4
 8010258:	d07b      	beq.n	8010352 <silk_decode_indices+0x21a>
        psDec->indices.NLSFInterpCoef_Q2 = (opus_int8)ec_dec_icdf( psRangeDec, silk_NLSF_interpolation_factor_iCDF, 8 );
    } else {
        psDec->indices.NLSFInterpCoef_Q2 = 4;
 801025a:	2304      	movs	r3, #4
 801025c:	f884 3acf 	strb.w	r3, [r4, #2767]	; 0xacf
    }

    if( psDec->indices.signalType == TYPE_VOICED )
 8010260:	f994 3acd 	ldrsb.w	r3, [r4, #2765]	; 0xacd
 8010264:	2b02      	cmp	r3, #2
 8010266:	d018      	beq.n	801029a <silk_decode_indices+0x162>
            psDec->indices.LTP_scaleIndex = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTPscale_iCDF, 8 );
        } else {
            psDec->indices.LTP_scaleIndex = 0;
        }
    }
    psDec->ec_prevSignalType = psDec->indices.signalType;
 8010268:	f8c4 395c 	str.w	r3, [r4, #2396]	; 0x95c

    /***************/
    /* Decode seed */
    /***************/
    psDec->indices.Seed = (opus_int8)ec_dec_icdf( psRangeDec, silk_uniform4_iCDF, 8 );
 801026c:	4628      	mov	r0, r5
 801026e:	2208      	movs	r2, #8
 8010270:	4958      	ldr	r1, [pc, #352]	; (80103d4 <silk_decode_indices+0x29c>)
 8010272:	f7f8 f98b 	bl	800858c <ec_dec_icdf>
 8010276:	f884 0ad2 	strb.w	r0, [r4, #2770]	; 0xad2
}
 801027a:	b00c      	add	sp, #48	; 0x30
 801027c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            Ix += ec_dec_icdf( psRangeDec, silk_NLSF_EXT_iCDF, 8 );
 8010280:	4602      	mov	r2, r0
 8010282:	4641      	mov	r1, r8
 8010284:	4628      	mov	r0, r5
 8010286:	f7f8 f981 	bl	800858c <ec_dec_icdf>
 801028a:	3008      	adds	r0, #8
 801028c:	e7c5      	b.n	801021a <silk_decode_indices+0xe2>
        Ix = ec_dec_icdf( psRangeDec, silk_type_offset_no_VAD_iCDF, 8 );
 801028e:	2208      	movs	r2, #8
 8010290:	4951      	ldr	r1, [pc, #324]	; (80103d8 <silk_decode_indices+0x2a0>)
 8010292:	4628      	mov	r0, r5
 8010294:	f7f8 f97a 	bl	800858c <ec_dec_icdf>
 8010298:	e763      	b.n	8010162 <silk_decode_indices+0x2a>
        if( condCoding == CODE_CONDITIONALLY && psDec->ec_prevSignalType == TYPE_VOICED ) {
 801029a:	f1b9 0f02 	cmp.w	r9, #2
 801029e:	d103      	bne.n	80102a8 <silk_decode_indices+0x170>
 80102a0:	f8d4 395c 	ldr.w	r3, [r4, #2396]	; 0x95c
 80102a4:	2b02      	cmp	r3, #2
 80102a6:	d066      	beq.n	8010376 <silk_decode_indices+0x23e>
            psDec->indices.lagIndex  = (opus_int16)ec_dec_icdf( psRangeDec, silk_pitch_lag_iCDF, 8 ) * silk_RSHIFT( psDec->fs_kHz, 1 );
 80102a8:	2208      	movs	r2, #8
 80102aa:	494c      	ldr	r1, [pc, #304]	; (80103dc <silk_decode_indices+0x2a4>)
 80102ac:	4628      	mov	r0, r5
 80102ae:	f7f8 f96d 	bl	800858c <ec_dec_icdf>
 80102b2:	f8d4 390c 	ldr.w	r3, [r4, #2316]	; 0x90c
            psDec->indices.lagIndex += (opus_int16)ec_dec_icdf( psRangeDec, psDec->pitch_lag_low_bits_iCDF, 8 );
 80102b6:	2208      	movs	r2, #8
            psDec->indices.lagIndex  = (opus_int16)ec_dec_icdf( psRangeDec, silk_pitch_lag_iCDF, 8 ) * silk_RSHIFT( psDec->fs_kHz, 1 );
 80102b8:	105b      	asrs	r3, r3, #1
 80102ba:	fb13 f000 	smulbb	r0, r3, r0
            psDec->indices.lagIndex += (opus_int16)ec_dec_icdf( psRangeDec, psDec->pitch_lag_low_bits_iCDF, 8 );
 80102be:	f8d4 194c 	ldr.w	r1, [r4, #2380]	; 0x94c
            psDec->indices.lagIndex  = (opus_int16)ec_dec_icdf( psRangeDec, silk_pitch_lag_iCDF, 8 ) * silk_RSHIFT( psDec->fs_kHz, 1 );
 80102c2:	f8a4 0aca 	strh.w	r0, [r4, #2762]	; 0xaca
            psDec->indices.lagIndex += (opus_int16)ec_dec_icdf( psRangeDec, psDec->pitch_lag_low_bits_iCDF, 8 );
 80102c6:	4628      	mov	r0, r5
 80102c8:	f7f8 f960 	bl	800858c <ec_dec_icdf>
 80102cc:	f8b4 3aca 	ldrh.w	r3, [r4, #2762]	; 0xaca
        psDec->indices.contourIndex = (opus_int8)ec_dec_icdf( psRangeDec, psDec->pitch_contour_iCDF, 8 );
 80102d0:	2208      	movs	r2, #8
            psDec->indices.lagIndex += (opus_int16)ec_dec_icdf( psRangeDec, psDec->pitch_lag_low_bits_iCDF, 8 );
 80102d2:	4418      	add	r0, r3
 80102d4:	b200      	sxth	r0, r0
 80102d6:	f8a4 0aca 	strh.w	r0, [r4, #2762]	; 0xaca
        psDec->ec_prevLagIndex = psDec->indices.lagIndex;
 80102da:	f8a4 0960 	strh.w	r0, [r4, #2400]	; 0x960
        psDec->indices.contourIndex = (opus_int8)ec_dec_icdf( psRangeDec, psDec->pitch_contour_iCDF, 8 );
 80102de:	f8d4 1950 	ldr.w	r1, [r4, #2384]	; 0x950
 80102e2:	4628      	mov	r0, r5
 80102e4:	f7f8 f952 	bl	800858c <ec_dec_icdf>
        psDec->indices.PERIndex = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTP_per_index_iCDF, 8 );
 80102e8:	2208      	movs	r2, #8
        psDec->indices.contourIndex = (opus_int8)ec_dec_icdf( psRangeDec, psDec->pitch_contour_iCDF, 8 );
 80102ea:	f884 0acc 	strb.w	r0, [r4, #2764]	; 0xacc
        psDec->indices.PERIndex = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTP_per_index_iCDF, 8 );
 80102ee:	493c      	ldr	r1, [pc, #240]	; (80103e0 <silk_decode_indices+0x2a8>)
 80102f0:	4628      	mov	r0, r5
 80102f2:	f7f8 f94b 	bl	800858c <ec_dec_icdf>
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 80102f6:	f8d4 3914 	ldr.w	r3, [r4, #2324]	; 0x914
        psDec->indices.PERIndex = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTP_per_index_iCDF, 8 );
 80102fa:	b240      	sxtb	r0, r0
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 80102fc:	2b00      	cmp	r3, #0
        psDec->indices.PERIndex = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTP_per_index_iCDF, 8 );
 80102fe:	f884 0ad0 	strb.w	r0, [r4, #2768]	; 0xad0
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 8010302:	dd15      	ble.n	8010330 <silk_decode_indices+0x1f8>
 8010304:	4f37      	ldr	r7, [pc, #220]	; (80103e4 <silk_decode_indices+0x2ac>)
 8010306:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 80103fc <silk_decode_indices+0x2c4>
 801030a:	1b3f      	subs	r7, r7, r4
 801030c:	f604 26b4 	addw	r6, r4, #2740	; 0xab4
 8010310:	e001      	b.n	8010316 <silk_decode_indices+0x1de>
 8010312:	f994 0ad0 	ldrsb.w	r0, [r4, #2768]	; 0xad0
            psDec->indices.LTPIndex[ k ] = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTP_gain_iCDF_ptrs[ psDec->indices.PERIndex ], 8 );
 8010316:	f858 1020 	ldr.w	r1, [r8, r0, lsl #2]
 801031a:	2208      	movs	r2, #8
 801031c:	4628      	mov	r0, r5
 801031e:	f7f8 f935 	bl	800858c <ec_dec_icdf>
 8010322:	f806 0b01 	strb.w	r0, [r6], #1
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 8010326:	f8d4 2914 	ldr.w	r2, [r4, #2324]	; 0x914
 801032a:	19bb      	adds	r3, r7, r6
 801032c:	429a      	cmp	r2, r3
 801032e:	dcf0      	bgt.n	8010312 <silk_decode_indices+0x1da>
        if( condCoding == CODE_INDEPENDENTLY ) {
 8010330:	f1b9 0f00 	cmp.w	r9, #0
 8010334:	d015      	beq.n	8010362 <silk_decode_indices+0x22a>
            psDec->indices.LTP_scaleIndex = 0;
 8010336:	2200      	movs	r2, #0
 8010338:	f994 3acd 	ldrsb.w	r3, [r4, #2765]	; 0xacd
 801033c:	f884 2ad1 	strb.w	r2, [r4, #2769]	; 0xad1
 8010340:	e792      	b.n	8010268 <silk_decode_indices+0x130>
        psDec->indices.GainsIndices[ 0 ] = (opus_int8)ec_dec_icdf( psRangeDec, silk_delta_gain_iCDF, 8 );
 8010342:	2208      	movs	r2, #8
 8010344:	4928      	ldr	r1, [pc, #160]	; (80103e8 <silk_decode_indices+0x2b0>)
 8010346:	4628      	mov	r0, r5
 8010348:	f7f8 f920 	bl	800858c <ec_dec_icdf>
 801034c:	f884 0ab0 	strb.w	r0, [r4, #2736]	; 0xab0
 8010350:	e727      	b.n	80101a2 <silk_decode_indices+0x6a>
        psDec->indices.NLSFInterpCoef_Q2 = (opus_int8)ec_dec_icdf( psRangeDec, silk_NLSF_interpolation_factor_iCDF, 8 );
 8010352:	2208      	movs	r2, #8
 8010354:	4925      	ldr	r1, [pc, #148]	; (80103ec <silk_decode_indices+0x2b4>)
 8010356:	4628      	mov	r0, r5
 8010358:	f7f8 f918 	bl	800858c <ec_dec_icdf>
 801035c:	f884 0acf 	strb.w	r0, [r4, #2767]	; 0xacf
 8010360:	e77e      	b.n	8010260 <silk_decode_indices+0x128>
            psDec->indices.LTP_scaleIndex = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTPscale_iCDF, 8 );
 8010362:	2208      	movs	r2, #8
 8010364:	4922      	ldr	r1, [pc, #136]	; (80103f0 <silk_decode_indices+0x2b8>)
 8010366:	4628      	mov	r0, r5
 8010368:	f7f8 f910 	bl	800858c <ec_dec_icdf>
 801036c:	f994 3acd 	ldrsb.w	r3, [r4, #2765]	; 0xacd
 8010370:	f884 0ad1 	strb.w	r0, [r4, #2769]	; 0xad1
 8010374:	e778      	b.n	8010268 <silk_decode_indices+0x130>
            delta_lagIndex = (opus_int16)ec_dec_icdf( psRangeDec, silk_pitch_delta_iCDF, 8 );
 8010376:	2208      	movs	r2, #8
 8010378:	491e      	ldr	r1, [pc, #120]	; (80103f4 <silk_decode_indices+0x2bc>)
 801037a:	4628      	mov	r0, r5
 801037c:	f7f8 f906 	bl	800858c <ec_dec_icdf>
 8010380:	b200      	sxth	r0, r0
            if( delta_lagIndex > 0 ) {
 8010382:	2800      	cmp	r0, #0
 8010384:	dd90      	ble.n	80102a8 <silk_decode_indices+0x170>
                psDec->indices.lagIndex = (opus_int16)( psDec->ec_prevLagIndex + delta_lagIndex );
 8010386:	f8b4 2960 	ldrh.w	r2, [r4, #2400]	; 0x960
                delta_lagIndex = delta_lagIndex - 9;
 801038a:	f1a0 0309 	sub.w	r3, r0, #9
                psDec->indices.lagIndex = (opus_int16)( psDec->ec_prevLagIndex + delta_lagIndex );
 801038e:	4413      	add	r3, r2
 8010390:	b21b      	sxth	r3, r3
 8010392:	f8a4 3aca 	strh.w	r3, [r4, #2762]	; 0xaca
        psDec->ec_prevLagIndex = psDec->indices.lagIndex;
 8010396:	f8a4 3960 	strh.w	r3, [r4, #2400]	; 0x960
        psDec->indices.contourIndex = (opus_int8)ec_dec_icdf( psRangeDec, psDec->pitch_contour_iCDF, 8 );
 801039a:	2208      	movs	r2, #8
 801039c:	f8d4 1950 	ldr.w	r1, [r4, #2384]	; 0x950
 80103a0:	4628      	mov	r0, r5
 80103a2:	f7f8 f8f3 	bl	800858c <ec_dec_icdf>
        psDec->indices.PERIndex = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTP_per_index_iCDF, 8 );
 80103a6:	2208      	movs	r2, #8
        psDec->indices.contourIndex = (opus_int8)ec_dec_icdf( psRangeDec, psDec->pitch_contour_iCDF, 8 );
 80103a8:	f884 0acc 	strb.w	r0, [r4, #2764]	; 0xacc
        psDec->indices.PERIndex = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTP_per_index_iCDF, 8 );
 80103ac:	490c      	ldr	r1, [pc, #48]	; (80103e0 <silk_decode_indices+0x2a8>)
 80103ae:	4628      	mov	r0, r5
 80103b0:	f7f8 f8ec 	bl	800858c <ec_dec_icdf>
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 80103b4:	f8d4 3914 	ldr.w	r3, [r4, #2324]	; 0x914
        psDec->indices.PERIndex = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTP_per_index_iCDF, 8 );
 80103b8:	b240      	sxtb	r0, r0
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 80103ba:	2b00      	cmp	r3, #0
        psDec->indices.PERIndex = (opus_int8)ec_dec_icdf( psRangeDec, silk_LTP_per_index_iCDF, 8 );
 80103bc:	f884 0ad0 	strb.w	r0, [r4, #2768]	; 0xad0
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 80103c0:	dca0      	bgt.n	8010304 <silk_decode_indices+0x1cc>
 80103c2:	e7b8      	b.n	8010336 <silk_decode_indices+0x1fe>
 80103c4:	08017bc8 	.word	0x08017bc8
 80103c8:	08017b34 	.word	0x08017b34
 80103cc:	08017be8 	.word	0x08017be8
 80103d0:	fffff549 	.word	0xfffff549
 80103d4:	08017bd4 	.word	0x08017bd4
 80103d8:	08017bcc 	.word	0x08017bcc
 80103dc:	08017c48 	.word	0x08017c48
 80103e0:	08016d38 	.word	0x08016d38
 80103e4:	fffff54c 	.word	0xfffff54c
 80103e8:	08017b08 	.word	0x08017b08
 80103ec:	08017b74 	.word	0x08017b74
 80103f0:	08017b68 	.word	0x08017b68
 80103f4:	08017c30 	.word	0x08017c30
 80103f8:	08017b6c 	.word	0x08017b6c
 80103fc:	08016c14 	.word	0x08016c14

08010400 <silk_decode_parameters>:
    opus_int   i, k, Ix;
    opus_int16 pNLSF_Q15[ MAX_LPC_ORDER ], pNLSF0_Q15[ MAX_LPC_ORDER ];
    const opus_int8 *cbk_ptr_Q7;

    /* Dequant Gains */
    silk_gains_dequant( psDecCtrl->Gains_Q16, psDec->indices.GainsIndices,
 8010400:	f1a2 0302 	sub.w	r3, r2, #2
{
 8010404:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    silk_gains_dequant( psDecCtrl->Gains_Q16, psDec->indices.GainsIndices,
 8010408:	fab3 f383 	clz	r3, r3
{
 801040c:	460d      	mov	r5, r1
 801040e:	4604      	mov	r4, r0
    silk_gains_dequant( psDecCtrl->Gains_Q16, psDec->indices.GainsIndices,
 8010410:	f8d0 1914 	ldr.w	r1, [r0, #2324]	; 0x914
{
 8010414:	b092      	sub	sp, #72	; 0x48
    silk_gains_dequant( psDecCtrl->Gains_Q16, psDec->indices.GainsIndices,
 8010416:	095b      	lsrs	r3, r3, #5
 8010418:	f600 1208 	addw	r2, r0, #2312	; 0x908
 801041c:	9100      	str	r1, [sp, #0]
 801041e:	f500 612b 	add.w	r1, r0, #2736	; 0xab0
 8010422:	f105 0010 	add.w	r0, r5, #16
 8010426:	f000 fbd3 	bl	8010bd0 <silk_gains_dequant>
        &psDec->LastGainIndex, condCoding == CODE_CONDITIONALLY, psDec->nb_subfr );

    /****************/
    /* Decode NLSFs */
    /****************/
    silk_NLSF_decode( pNLSF_Q15, psDec->indices.NLSFIndices, psDec->psNLSF_CB );
 801042a:	f8d4 2aac 	ldr.w	r2, [r4, #2732]	; 0xaac
 801042e:	f604 21b8 	addw	r1, r4, #2744	; 0xab8
 8010432:	a802      	add	r0, sp, #8
 8010434:	f7fd fa46 	bl	800d8c4 <silk_NLSF_decode>

    /* Convert NLSF parameters to AR prediction filter coefficients */
    silk_NLSF2A( psDecCtrl->PredCoef_Q12[ 1 ], pNLSF_Q15, psDec->LPC_order, psDec->arch );
 8010438:	f241 0348 	movw	r3, #4168	; 0x1048
 801043c:	f105 0640 	add.w	r6, r5, #64	; 0x40
 8010440:	58e3      	ldr	r3, [r4, r3]
 8010442:	4630      	mov	r0, r6
 8010444:	f8d4 2924 	ldr.w	r2, [r4, #2340]	; 0x924
 8010448:	a902      	add	r1, sp, #8
 801044a:	f7fc fe71 	bl	800d130 <silk_NLSF2A>

    /* If just reset, e.g., because internal Fs changed, do not allow interpolation */
    /* improves the case of packet loss in the first frame after a switch           */
    if( psDec->first_frame_after_reset == 1 ) {
 801044e:	f8d4 3948 	ldr.w	r3, [r4, #2376]	; 0x948
 8010452:	2b01      	cmp	r3, #1
 8010454:	f000 8122 	beq.w	801069c <silk_decode_parameters+0x29c>
        psDec->indices.NLSFInterpCoef_Q2 = 4;
    }

    if( psDec->indices.NLSFInterpCoef_Q2 < 4 ) {
 8010458:	f994 3acf 	ldrsb.w	r3, [r4, #2767]	; 0xacf
 801045c:	f8d4 2924 	ldr.w	r2, [r4, #2340]	; 0x924
 8010460:	2b03      	cmp	r3, #3
 8010462:	f300 8120 	bgt.w	80106a6 <silk_decode_parameters+0x2a6>
        /* Calculation of the interpolated NLSF0 vector from the interpolation factor, */
        /* the previous NLSF1, and the current NLSF1                                   */
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010466:	2a00      	cmp	r2, #0
 8010468:	f340 80e3 	ble.w	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 801046c:	f9b4 0928 	ldrsh.w	r0, [r4, #2344]	; 0x928
 8010470:	f9bd 1008 	ldrsh.w	r1, [sp, #8]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010474:	2a01      	cmp	r2, #1
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 8010476:	eba1 0100 	sub.w	r1, r1, r0
 801047a:	fb03 f101 	mul.w	r1, r3, r1
 801047e:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 8010482:	f8ad 1028 	strh.w	r1, [sp, #40]	; 0x28
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010486:	f000 80d4 	beq.w	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 801048a:	f9b4 092a 	ldrsh.w	r0, [r4, #2346]	; 0x92a
 801048e:	f9bd 100a 	ldrsh.w	r1, [sp, #10]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010492:	2a02      	cmp	r2, #2
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 8010494:	eba1 0100 	sub.w	r1, r1, r0
 8010498:	fb03 f101 	mul.w	r1, r3, r1
 801049c:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 80104a0:	f8ad 102a 	strh.w	r1, [sp, #42]	; 0x2a
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80104a4:	f000 80c5 	beq.w	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80104a8:	f9b4 092c 	ldrsh.w	r0, [r4, #2348]	; 0x92c
 80104ac:	f9bd 100c 	ldrsh.w	r1, [sp, #12]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80104b0:	2a03      	cmp	r2, #3
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80104b2:	eba1 0100 	sub.w	r1, r1, r0
 80104b6:	fb03 f101 	mul.w	r1, r3, r1
 80104ba:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 80104be:	f8ad 102c 	strh.w	r1, [sp, #44]	; 0x2c
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80104c2:	f000 80b6 	beq.w	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80104c6:	f9b4 092e 	ldrsh.w	r0, [r4, #2350]	; 0x92e
 80104ca:	f9bd 100e 	ldrsh.w	r1, [sp, #14]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80104ce:	2a04      	cmp	r2, #4
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80104d0:	eba1 0100 	sub.w	r1, r1, r0
 80104d4:	fb03 f101 	mul.w	r1, r3, r1
 80104d8:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 80104dc:	f8ad 102e 	strh.w	r1, [sp, #46]	; 0x2e
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80104e0:	f000 80a7 	beq.w	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80104e4:	f9b4 0930 	ldrsh.w	r0, [r4, #2352]	; 0x930
 80104e8:	f9bd 1010 	ldrsh.w	r1, [sp, #16]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80104ec:	2a05      	cmp	r2, #5
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80104ee:	eba1 0100 	sub.w	r1, r1, r0
 80104f2:	fb03 f101 	mul.w	r1, r3, r1
 80104f6:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 80104fa:	f8ad 1030 	strh.w	r1, [sp, #48]	; 0x30
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80104fe:	f000 8098 	beq.w	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 8010502:	f9b4 0932 	ldrsh.w	r0, [r4, #2354]	; 0x932
 8010506:	f9bd 1012 	ldrsh.w	r1, [sp, #18]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 801050a:	2a06      	cmp	r2, #6
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 801050c:	eba1 0100 	sub.w	r1, r1, r0
 8010510:	fb03 f101 	mul.w	r1, r3, r1
 8010514:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 8010518:	f8ad 1032 	strh.w	r1, [sp, #50]	; 0x32
        for( i = 0; i < psDec->LPC_order; i++ ) {
 801051c:	f000 8089 	beq.w	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 8010520:	f9b4 0934 	ldrsh.w	r0, [r4, #2356]	; 0x934
 8010524:	f9bd 1014 	ldrsh.w	r1, [sp, #20]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010528:	2a07      	cmp	r2, #7
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 801052a:	eba1 0100 	sub.w	r1, r1, r0
 801052e:	fb03 f101 	mul.w	r1, r3, r1
 8010532:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 8010536:	f8ad 1034 	strh.w	r1, [sp, #52]	; 0x34
        for( i = 0; i < psDec->LPC_order; i++ ) {
 801053a:	d07a      	beq.n	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 801053c:	f9b4 0936 	ldrsh.w	r0, [r4, #2358]	; 0x936
 8010540:	f9bd 1016 	ldrsh.w	r1, [sp, #22]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010544:	2a08      	cmp	r2, #8
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 8010546:	eba1 0100 	sub.w	r1, r1, r0
 801054a:	fb03 f101 	mul.w	r1, r3, r1
 801054e:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 8010552:	f8ad 1036 	strh.w	r1, [sp, #54]	; 0x36
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010556:	d06c      	beq.n	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 8010558:	f9b4 0938 	ldrsh.w	r0, [r4, #2360]	; 0x938
 801055c:	f9bd 1018 	ldrsh.w	r1, [sp, #24]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010560:	2a09      	cmp	r2, #9
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 8010562:	eba1 0100 	sub.w	r1, r1, r0
 8010566:	fb03 f101 	mul.w	r1, r3, r1
 801056a:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 801056e:	f8ad 1038 	strh.w	r1, [sp, #56]	; 0x38
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010572:	d05e      	beq.n	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 8010574:	f9b4 093a 	ldrsh.w	r0, [r4, #2362]	; 0x93a
 8010578:	f9bd 101a 	ldrsh.w	r1, [sp, #26]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 801057c:	2a0a      	cmp	r2, #10
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 801057e:	eba1 0100 	sub.w	r1, r1, r0
 8010582:	fb03 f101 	mul.w	r1, r3, r1
 8010586:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 801058a:	f8ad 103a 	strh.w	r1, [sp, #58]	; 0x3a
        for( i = 0; i < psDec->LPC_order; i++ ) {
 801058e:	d050      	beq.n	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 8010590:	f9b4 093c 	ldrsh.w	r0, [r4, #2364]	; 0x93c
 8010594:	f9bd 101c 	ldrsh.w	r1, [sp, #28]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010598:	2a0b      	cmp	r2, #11
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 801059a:	eba1 0100 	sub.w	r1, r1, r0
 801059e:	fb03 f101 	mul.w	r1, r3, r1
 80105a2:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 80105a6:	f8ad 103c 	strh.w	r1, [sp, #60]	; 0x3c
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80105aa:	d042      	beq.n	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80105ac:	f9b4 093e 	ldrsh.w	r0, [r4, #2366]	; 0x93e
 80105b0:	f9bd 101e 	ldrsh.w	r1, [sp, #30]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80105b4:	2a0c      	cmp	r2, #12
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80105b6:	eba1 0100 	sub.w	r1, r1, r0
 80105ba:	fb03 f101 	mul.w	r1, r3, r1
 80105be:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 80105c2:	f8ad 103e 	strh.w	r1, [sp, #62]	; 0x3e
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80105c6:	d034      	beq.n	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80105c8:	f9b4 0940 	ldrsh.w	r0, [r4, #2368]	; 0x940
 80105cc:	f9bd 1020 	ldrsh.w	r1, [sp, #32]
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80105d0:	2a0d      	cmp	r2, #13
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80105d2:	eba1 0100 	sub.w	r1, r1, r0
 80105d6:	fb03 f101 	mul.w	r1, r3, r1
 80105da:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 80105de:	f8ad 1040 	strh.w	r1, [sp, #64]	; 0x40
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80105e2:	d026      	beq.n	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80105e4:	f9b4 0942 	ldrsh.w	r0, [r4, #2370]	; 0x942
 80105e8:	f9bd 1022 	ldrsh.w	r1, [sp, #34]	; 0x22
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80105ec:	2a0e      	cmp	r2, #14
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 80105ee:	eba1 0100 	sub.w	r1, r1, r0
 80105f2:	fb03 f101 	mul.w	r1, r3, r1
 80105f6:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 80105fa:	f8ad 1042 	strh.w	r1, [sp, #66]	; 0x42
        for( i = 0; i < psDec->LPC_order; i++ ) {
 80105fe:	d018      	beq.n	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 8010600:	f9b4 0944 	ldrsh.w	r0, [r4, #2372]	; 0x944
 8010604:	f9bd 1024 	ldrsh.w	r1, [sp, #36]	; 0x24
        for( i = 0; i < psDec->LPC_order; i++ ) {
 8010608:	2a0f      	cmp	r2, #15
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 801060a:	eba1 0100 	sub.w	r1, r1, r0
 801060e:	fb03 f101 	mul.w	r1, r3, r1
 8010612:	eb00 01a1 	add.w	r1, r0, r1, asr #2
 8010616:	f8ad 1044 	strh.w	r1, [sp, #68]	; 0x44
        for( i = 0; i < psDec->LPC_order; i++ ) {
 801061a:	d00a      	beq.n	8010632 <silk_decode_parameters+0x232>
            pNLSF0_Q15[ i ] = psDec->prevNLSF_Q15[ i ] + silk_RSHIFT( silk_MUL( psDec->indices.NLSFInterpCoef_Q2,
 801061c:	f9b4 1946 	ldrsh.w	r1, [r4, #2374]	; 0x946
 8010620:	f9bd 0026 	ldrsh.w	r0, [sp, #38]	; 0x26
 8010624:	1a40      	subs	r0, r0, r1
 8010626:	fb03 f300 	mul.w	r3, r3, r0
 801062a:	eb01 03a3 	add.w	r3, r1, r3, asr #2
 801062e:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
                pNLSF_Q15[ i ] - psDec->prevNLSF_Q15[ i ] ), 2 );
        }

        /* Convert NLSF parameters to AR prediction filter coefficients */
        silk_NLSF2A( psDecCtrl->PredCoef_Q12[ 0 ], pNLSF0_Q15, psDec->LPC_order, psDec->arch );
 8010632:	f241 0348 	movw	r3, #4168	; 0x1048
 8010636:	f105 0720 	add.w	r7, r5, #32
 801063a:	58e3      	ldr	r3, [r4, r3]
 801063c:	4638      	mov	r0, r7
 801063e:	a90a      	add	r1, sp, #40	; 0x28
 8010640:	f7fc fd76 	bl	800d130 <silk_NLSF2A>
    } else {
        /* Copy LPC coefficients for first half from second half */
        silk_memcpy( psDecCtrl->PredCoef_Q12[ 0 ], psDecCtrl->PredCoef_Q12[ 1 ], psDec->LPC_order * sizeof( opus_int16 ) );
    }

    silk_memcpy( psDec->prevNLSF_Q15, pNLSF_Q15, psDec->LPC_order * sizeof( opus_int16 ) );
 8010644:	f8d4 8924 	ldr.w	r8, [r4, #2340]	; 0x924
 8010648:	a902      	add	r1, sp, #8
 801064a:	ea4f 0248 	mov.w	r2, r8, lsl #1
 801064e:	f604 1028 	addw	r0, r4, #2344	; 0x928
 8010652:	f003 fd45 	bl	80140e0 <memcpy>

    /* After a packet loss do BWE of LPC coefs */
    if( psDec->lossCnt ) {
 8010656:	f504 5382 	add.w	r3, r4, #4160	; 0x1040
 801065a:	681b      	ldr	r3, [r3, #0]
 801065c:	2b00      	cmp	r3, #0
 801065e:	f040 80d0 	bne.w	8010802 <silk_decode_parameters+0x402>
        silk_bwexpander( psDecCtrl->PredCoef_Q12[ 0 ], psDec->LPC_order, BWE_AFTER_LOSS_Q16 );
        silk_bwexpander( psDecCtrl->PredCoef_Q12[ 1 ], psDec->LPC_order, BWE_AFTER_LOSS_Q16 );
    }

    if( psDec->indices.signalType == TYPE_VOICED ) {
 8010662:	f994 3acd 	ldrsb.w	r3, [r4, #2765]	; 0xacd
 8010666:	f8d4 2914 	ldr.w	r2, [r4, #2324]	; 0x914
 801066a:	2b02      	cmp	r3, #2
 801066c:	d023      	beq.n	80106b6 <silk_decode_parameters+0x2b6>
        /* Decode LTP scaling */
        /**********************/
        Ix = psDec->indices.LTP_scaleIndex;
        psDecCtrl->LTP_scale_Q14 = silk_LTPScales_table_Q14[ Ix ];
    } else {
        silk_memset( psDecCtrl->pitchL,      0,             psDec->nb_subfr * sizeof( opus_int   ) );
 801066e:	0092      	lsls	r2, r2, #2
 8010670:	2100      	movs	r1, #0
 8010672:	4628      	mov	r0, r5
 8010674:	f003 fd58 	bl	8014128 <memset>
        silk_memset( psDecCtrl->LTPCoef_Q14, 0, LTP_ORDER * psDec->nb_subfr * sizeof( opus_int16 ) );
 8010678:	f8d4 2914 	ldr.w	r2, [r4, #2324]	; 0x914
 801067c:	2100      	movs	r1, #0
 801067e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8010682:	0052      	lsls	r2, r2, #1
 8010684:	f105 0060 	add.w	r0, r5, #96	; 0x60
 8010688:	f003 fd4e 	bl	8014128 <memset>
        psDec->indices.PERIndex  = 0;
 801068c:	2300      	movs	r3, #0
 801068e:	f884 3ad0 	strb.w	r3, [r4, #2768]	; 0xad0
        psDecCtrl->LTP_scale_Q14 = 0;
 8010692:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
    }
}
 8010696:	b012      	add	sp, #72	; 0x48
 8010698:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        psDec->indices.NLSFInterpCoef_Q2 = 4;
 801069c:	2304      	movs	r3, #4
 801069e:	f8d4 2924 	ldr.w	r2, [r4, #2340]	; 0x924
 80106a2:	f884 3acf 	strb.w	r3, [r4, #2767]	; 0xacf
        silk_memcpy( psDecCtrl->PredCoef_Q12[ 0 ], psDecCtrl->PredCoef_Q12[ 1 ], psDec->LPC_order * sizeof( opus_int16 ) );
 80106a6:	f105 0720 	add.w	r7, r5, #32
 80106aa:	0052      	lsls	r2, r2, #1
 80106ac:	4638      	mov	r0, r7
 80106ae:	4631      	mov	r1, r6
 80106b0:	f003 fd16 	bl	80140e0 <memcpy>
 80106b4:	e7c6      	b.n	8010644 <silk_decode_parameters+0x244>
        silk_decode_pitch( psDec->indices.lagIndex, psDec->indices.contourIndex, psDecCtrl->pitchL, psDec->fs_kHz, psDec->nb_subfr );
 80106b6:	f994 1acc 	ldrsb.w	r1, [r4, #2764]	; 0xacc
 80106ba:	f8d4 390c 	ldr.w	r3, [r4, #2316]	; 0x90c
 80106be:	f9b4 0aca 	ldrsh.w	r0, [r4, #2762]	; 0xaca
 80106c2:	9200      	str	r2, [sp, #0]
 80106c4:	462a      	mov	r2, r5
 80106c6:	f000 f8af 	bl	8010828 <silk_decode_pitch>
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 80106ca:	f8d4 1914 	ldr.w	r1, [r4, #2324]	; 0x914
        cbk_ptr_Q7 = silk_LTP_vq_ptrs_Q7[ psDec->indices.PERIndex ]; /* set pointer to start of codebook */
 80106ce:	f994 2ad0 	ldrsb.w	r2, [r4, #2768]	; 0xad0
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 80106d2:	2900      	cmp	r1, #0
 80106d4:	f340 808b 	ble.w	80107ee <silk_decode_parameters+0x3ee>
        cbk_ptr_Q7 = silk_LTP_vq_ptrs_Q7[ psDec->indices.PERIndex ]; /* set pointer to start of codebook */
 80106d8:	4851      	ldr	r0, [pc, #324]	; (8010820 <silk_decode_parameters+0x420>)
                psDecCtrl->LTPCoef_Q14[ k * LTP_ORDER + i ] = silk_LSHIFT( cbk_ptr_Q7[ Ix * LTP_ORDER + i ], 7 );
 80106da:	f994 3ab4 	ldrsb.w	r3, [r4, #2740]	; 0xab4
        cbk_ptr_Q7 = silk_LTP_vq_ptrs_Q7[ psDec->indices.PERIndex ]; /* set pointer to start of codebook */
 80106de:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
                psDecCtrl->LTPCoef_Q14[ k * LTP_ORDER + i ] = silk_LSHIFT( cbk_ptr_Q7[ Ix * LTP_ORDER + i ], 7 );
 80106e2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80106e6:	56d0      	ldrsb	r0, [r2, r3]
 80106e8:	4413      	add	r3, r2
 80106ea:	01c0      	lsls	r0, r0, #7
 80106ec:	f8a5 0060 	strh.w	r0, [r5, #96]	; 0x60
 80106f0:	f993 0001 	ldrsb.w	r0, [r3, #1]
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 80106f4:	2901      	cmp	r1, #1
                psDecCtrl->LTPCoef_Q14[ k * LTP_ORDER + i ] = silk_LSHIFT( cbk_ptr_Q7[ Ix * LTP_ORDER + i ], 7 );
 80106f6:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 80106fa:	f8a5 0062 	strh.w	r0, [r5, #98]	; 0x62
 80106fe:	f993 0002 	ldrsb.w	r0, [r3, #2]
 8010702:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 8010706:	f8a5 0064 	strh.w	r0, [r5, #100]	; 0x64
 801070a:	f993 0003 	ldrsb.w	r0, [r3, #3]
 801070e:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 8010712:	f8a5 0066 	strh.w	r0, [r5, #102]	; 0x66
 8010716:	f993 3004 	ldrsb.w	r3, [r3, #4]
 801071a:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 801071e:	f8a5 3068 	strh.w	r3, [r5, #104]	; 0x68
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 8010722:	d064      	beq.n	80107ee <silk_decode_parameters+0x3ee>
                psDecCtrl->LTPCoef_Q14[ k * LTP_ORDER + i ] = silk_LSHIFT( cbk_ptr_Q7[ Ix * LTP_ORDER + i ], 7 );
 8010724:	f994 3ab5 	ldrsb.w	r3, [r4, #2741]	; 0xab5
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 8010728:	2902      	cmp	r1, #2
                psDecCtrl->LTPCoef_Q14[ k * LTP_ORDER + i ] = silk_LSHIFT( cbk_ptr_Q7[ Ix * LTP_ORDER + i ], 7 );
 801072a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 801072e:	56d0      	ldrsb	r0, [r2, r3]
 8010730:	4413      	add	r3, r2
 8010732:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 8010736:	f8a5 006a 	strh.w	r0, [r5, #106]	; 0x6a
 801073a:	f993 0001 	ldrsb.w	r0, [r3, #1]
 801073e:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 8010742:	f8a5 006c 	strh.w	r0, [r5, #108]	; 0x6c
 8010746:	f993 0002 	ldrsb.w	r0, [r3, #2]
 801074a:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 801074e:	f8a5 006e 	strh.w	r0, [r5, #110]	; 0x6e
 8010752:	f993 0003 	ldrsb.w	r0, [r3, #3]
 8010756:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 801075a:	f8a5 0070 	strh.w	r0, [r5, #112]	; 0x70
 801075e:	f993 3004 	ldrsb.w	r3, [r3, #4]
 8010762:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 8010766:	f8a5 3072 	strh.w	r3, [r5, #114]	; 0x72
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 801076a:	d040      	beq.n	80107ee <silk_decode_parameters+0x3ee>
                psDecCtrl->LTPCoef_Q14[ k * LTP_ORDER + i ] = silk_LSHIFT( cbk_ptr_Q7[ Ix * LTP_ORDER + i ], 7 );
 801076c:	f994 3ab6 	ldrsb.w	r3, [r4, #2742]	; 0xab6
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 8010770:	2903      	cmp	r1, #3
                psDecCtrl->LTPCoef_Q14[ k * LTP_ORDER + i ] = silk_LSHIFT( cbk_ptr_Q7[ Ix * LTP_ORDER + i ], 7 );
 8010772:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8010776:	56d0      	ldrsb	r0, [r2, r3]
 8010778:	4413      	add	r3, r2
 801077a:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 801077e:	f8a5 0074 	strh.w	r0, [r5, #116]	; 0x74
 8010782:	f993 0001 	ldrsb.w	r0, [r3, #1]
 8010786:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 801078a:	f8a5 0076 	strh.w	r0, [r5, #118]	; 0x76
 801078e:	f993 0002 	ldrsb.w	r0, [r3, #2]
 8010792:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 8010796:	f8a5 0078 	strh.w	r0, [r5, #120]	; 0x78
 801079a:	f993 0003 	ldrsb.w	r0, [r3, #3]
 801079e:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 80107a2:	f8a5 007a 	strh.w	r0, [r5, #122]	; 0x7a
 80107a6:	f993 3004 	ldrsb.w	r3, [r3, #4]
 80107aa:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 80107ae:	f8a5 307c 	strh.w	r3, [r5, #124]	; 0x7c
        for( k = 0; k < psDec->nb_subfr; k++ ) {
 80107b2:	d01c      	beq.n	80107ee <silk_decode_parameters+0x3ee>
                psDecCtrl->LTPCoef_Q14[ k * LTP_ORDER + i ] = silk_LSHIFT( cbk_ptr_Q7[ Ix * LTP_ORDER + i ], 7 );
 80107b4:	f994 3ab7 	ldrsb.w	r3, [r4, #2743]	; 0xab7
 80107b8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80107bc:	56d1      	ldrsb	r1, [r2, r3]
 80107be:	441a      	add	r2, r3
 80107c0:	01cb      	lsls	r3, r1, #7
 80107c2:	f8a5 307e 	strh.w	r3, [r5, #126]	; 0x7e
 80107c6:	f992 3001 	ldrsb.w	r3, [r2, #1]
 80107ca:	01db      	lsls	r3, r3, #7
 80107cc:	f8a5 3080 	strh.w	r3, [r5, #128]	; 0x80
 80107d0:	f992 3002 	ldrsb.w	r3, [r2, #2]
 80107d4:	01db      	lsls	r3, r3, #7
 80107d6:	f8a5 3082 	strh.w	r3, [r5, #130]	; 0x82
 80107da:	f992 3003 	ldrsb.w	r3, [r2, #3]
 80107de:	01db      	lsls	r3, r3, #7
 80107e0:	f8a5 3084 	strh.w	r3, [r5, #132]	; 0x84
 80107e4:	f992 3004 	ldrsb.w	r3, [r2, #4]
 80107e8:	01db      	lsls	r3, r3, #7
 80107ea:	f8a5 3086 	strh.w	r3, [r5, #134]	; 0x86
        Ix = psDec->indices.LTP_scaleIndex;
 80107ee:	f994 2ad1 	ldrsb.w	r2, [r4, #2769]	; 0xad1
        psDecCtrl->LTP_scale_Q14 = silk_LTPScales_table_Q14[ Ix ];
 80107f2:	4b0c      	ldr	r3, [pc, #48]	; (8010824 <silk_decode_parameters+0x424>)
 80107f4:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 80107f8:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
}
 80107fc:	b012      	add	sp, #72	; 0x48
 80107fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        silk_bwexpander( psDecCtrl->PredCoef_Q12[ 0 ], psDec->LPC_order, BWE_AFTER_LOSS_Q16 );
 8010802:	4641      	mov	r1, r8
 8010804:	4638      	mov	r0, r7
 8010806:	f64f 0252 	movw	r2, #63570	; 0xf852
 801080a:	f7fe f947 	bl	800ea9c <silk_bwexpander>
        silk_bwexpander( psDecCtrl->PredCoef_Q12[ 1 ], psDec->LPC_order, BWE_AFTER_LOSS_Q16 );
 801080e:	4630      	mov	r0, r6
 8010810:	f64f 0252 	movw	r2, #63570	; 0xf852
 8010814:	f8d4 1924 	ldr.w	r1, [r4, #2340]	; 0x924
 8010818:	f7fe f940 	bl	800ea9c <silk_bwexpander>
 801081c:	e721      	b.n	8010662 <silk_decode_parameters+0x262>
 801081e:	bf00      	nop
 8010820:	08016d3c 	.word	0x08016d3c
 8010824:	08017b60 	.word	0x08017b60

08010828 <silk_decode_pitch>:
    opus_int8                   contourIndex,       /* O                                                                */
    opus_int                    pitch_lags[],       /* O    4 pitch values                                              */
    const opus_int              Fs_kHz,             /* I    sampling frequency (kHz)                                    */
    const opus_int              nb_subfr            /* I    number of sub frames                                        */
)
{
 8010828:	b5f0      	push	{r4, r5, r6, r7, lr}
    opus_int   lag, k, min_lag, max_lag, cbk_size;
    const opus_int8 *Lag_CB_ptr;

    if( Fs_kHz == 8 ) {
 801082a:	2b08      	cmp	r3, #8
{
 801082c:	4694      	mov	ip, r2
 801082e:	9c05      	ldr	r4, [sp, #20]
    if( Fs_kHz == 8 ) {
 8010830:	d04b      	beq.n	80108ca <silk_decode_pitch+0xa2>
            celt_assert( nb_subfr == PE_MAX_NB_SUBFR >> 1 );
            Lag_CB_ptr = &silk_CB_lags_stage2_10_ms[ 0 ][ 0 ];
            cbk_size   = PE_NB_CBKS_STAGE2_10MS;
        }
    } else {
        if( nb_subfr == PE_MAX_NB_SUBFR ) {
 8010832:	2c04      	cmp	r4, #4
 8010834:	d038      	beq.n	80108a8 <silk_decode_pitch+0x80>
            Lag_CB_ptr = &silk_CB_lags_stage3[ 0 ][ 0 ];
            cbk_size   = PE_NB_CBKS_STAGE3_MAX;
        } else {
            celt_assert( nb_subfr == PE_MAX_NB_SUBFR >> 1 );
            Lag_CB_ptr = &silk_CB_lags_stage3_10_ms[ 0 ][ 0 ];
            cbk_size   = PE_NB_CBKS_STAGE3_10MS;
 8010836:	250c      	movs	r5, #12
            Lag_CB_ptr = &silk_CB_lags_stage3_10_ms[ 0 ][ 0 ];
 8010838:	4f28      	ldr	r7, [pc, #160]	; (80108dc <silk_decode_pitch+0xb4>)
        }
    }

    min_lag = silk_SMULBB( PE_MIN_LAG_MS, Fs_kHz );
 801083a:	b21b      	sxth	r3, r3
 801083c:	005e      	lsls	r6, r3, #1
    max_lag = silk_SMULBB( PE_MAX_LAG_MS, Fs_kHz );
    lag = min_lag + lagIndex;

    for( k = 0; k < nb_subfr; k++ ) {
 801083e:	2c00      	cmp	r4, #0
    max_lag = silk_SMULBB( PE_MAX_LAG_MS, Fs_kHz );
 8010840:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    lag = min_lag + lagIndex;
 8010844:	4430      	add	r0, r6
    max_lag = silk_SMULBB( PE_MAX_LAG_MS, Fs_kHz );
 8010846:	ea4f 0243 	mov.w	r2, r3, lsl #1
    for( k = 0; k < nb_subfr; k++ ) {
 801084a:	dd15      	ble.n	8010878 <silk_decode_pitch+0x50>
 801084c:	4296      	cmp	r6, r2
            cbk_size   = PE_NB_CBKS_STAGE3_10MS;
 801084e:	f04f 0e00 	mov.w	lr, #0
 8010852:	4439      	add	r1, r7
 8010854:	f1ac 0c04 	sub.w	ip, ip, #4
 8010858:	dc16      	bgt.n	8010888 <silk_decode_pitch+0x60>
        pitch_lags[ k ] = lag + matrix_ptr( Lag_CB_ptr, k, contourIndex, cbk_size );
 801085a:	f991 3000 	ldrsb.w	r3, [r1]
 801085e:	4403      	add	r3, r0
        pitch_lags[ k ] = silk_LIMIT( pitch_lags[ k ], min_lag, max_lag );
 8010860:	429a      	cmp	r2, r3
 8010862:	db2a      	blt.n	80108ba <silk_decode_pitch+0x92>
 8010864:	42b3      	cmp	r3, r6
 8010866:	bfb8      	it	lt
 8010868:	4633      	movlt	r3, r6
    for( k = 0; k < nb_subfr; k++ ) {
 801086a:	f10e 0e01 	add.w	lr, lr, #1
 801086e:	4574      	cmp	r4, lr
        pitch_lags[ k ] = silk_LIMIT( pitch_lags[ k ], min_lag, max_lag );
 8010870:	f84c 3f04 	str.w	r3, [ip, #4]!
 8010874:	4429      	add	r1, r5
    for( k = 0; k < nb_subfr; k++ ) {
 8010876:	dcf0      	bgt.n	801085a <silk_decode_pitch+0x32>
    }
}
 8010878:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for( k = 0; k < nb_subfr; k++ ) {
 801087a:	f10e 0e01 	add.w	lr, lr, #1
 801087e:	4574      	cmp	r4, lr
        pitch_lags[ k ] = silk_LIMIT( pitch_lags[ k ], min_lag, max_lag );
 8010880:	f84c 6f04 	str.w	r6, [ip, #4]!
 8010884:	4429      	add	r1, r5
    for( k = 0; k < nb_subfr; k++ ) {
 8010886:	ddf7      	ble.n	8010878 <silk_decode_pitch+0x50>
        pitch_lags[ k ] = lag + matrix_ptr( Lag_CB_ptr, k, contourIndex, cbk_size );
 8010888:	f991 3000 	ldrsb.w	r3, [r1]
 801088c:	4403      	add	r3, r0
        pitch_lags[ k ] = silk_LIMIT( pitch_lags[ k ], min_lag, max_lag );
 801088e:	429e      	cmp	r6, r3
 8010890:	dbf3      	blt.n	801087a <silk_decode_pitch+0x52>
 8010892:	4293      	cmp	r3, r2
 8010894:	bfb8      	it	lt
 8010896:	4613      	movlt	r3, r2
    for( k = 0; k < nb_subfr; k++ ) {
 8010898:	f10e 0e01 	add.w	lr, lr, #1
 801089c:	4574      	cmp	r4, lr
        pitch_lags[ k ] = silk_LIMIT( pitch_lags[ k ], min_lag, max_lag );
 801089e:	f84c 3f04 	str.w	r3, [ip, #4]!
 80108a2:	4429      	add	r1, r5
    for( k = 0; k < nb_subfr; k++ ) {
 80108a4:	dcf0      	bgt.n	8010888 <silk_decode_pitch+0x60>
}
 80108a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
            cbk_size   = PE_NB_CBKS_STAGE3_MAX;
 80108a8:	2522      	movs	r5, #34	; 0x22
            Lag_CB_ptr = &silk_CB_lags_stage3[ 0 ][ 0 ];
 80108aa:	4f0d      	ldr	r7, [pc, #52]	; (80108e0 <silk_decode_pitch+0xb8>)
    min_lag = silk_SMULBB( PE_MIN_LAG_MS, Fs_kHz );
 80108ac:	b21b      	sxth	r3, r3
 80108ae:	005e      	lsls	r6, r3, #1
    max_lag = silk_SMULBB( PE_MAX_LAG_MS, Fs_kHz );
 80108b0:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    lag = min_lag + lagIndex;
 80108b4:	4430      	add	r0, r6
    max_lag = silk_SMULBB( PE_MAX_LAG_MS, Fs_kHz );
 80108b6:	005a      	lsls	r2, r3, #1
 80108b8:	e7c8      	b.n	801084c <silk_decode_pitch+0x24>
    for( k = 0; k < nb_subfr; k++ ) {
 80108ba:	f10e 0e01 	add.w	lr, lr, #1
 80108be:	4574      	cmp	r4, lr
        pitch_lags[ k ] = silk_LIMIT( pitch_lags[ k ], min_lag, max_lag );
 80108c0:	f84c 2f04 	str.w	r2, [ip, #4]!
 80108c4:	4429      	add	r1, r5
    for( k = 0; k < nb_subfr; k++ ) {
 80108c6:	dcc8      	bgt.n	801085a <silk_decode_pitch+0x32>
}
 80108c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( nb_subfr == PE_MAX_NB_SUBFR ) {
 80108ca:	2c04      	cmp	r4, #4
 80108cc:	d002      	beq.n	80108d4 <silk_decode_pitch+0xac>
            Lag_CB_ptr = &silk_CB_lags_stage2_10_ms[ 0 ][ 0 ];
 80108ce:	4f05      	ldr	r7, [pc, #20]	; (80108e4 <silk_decode_pitch+0xbc>)
            cbk_size   = PE_NB_CBKS_STAGE2_10MS;
 80108d0:	2503      	movs	r5, #3
 80108d2:	e7b2      	b.n	801083a <silk_decode_pitch+0x12>
            Lag_CB_ptr = &silk_CB_lags_stage2[ 0 ][ 0 ];
 80108d4:	4f04      	ldr	r7, [pc, #16]	; (80108e8 <silk_decode_pitch+0xc0>)
            cbk_size   = PE_NB_CBKS_STAGE2_EXT;
 80108d6:	250b      	movs	r5, #11
 80108d8:	e7e8      	b.n	80108ac <silk_decode_pitch+0x84>
 80108da:	bf00      	nop
 80108dc:	08016948 	.word	0x08016948
 80108e0:	080168c0 	.word	0x080168c0
 80108e4:	080168b8 	.word	0x080168b8
 80108e8:	0801688c 	.word	0x0801688c

080108ec <silk_decode_pulses>:
    opus_int16                  pulses[],                       /* O    Excitation signal                           */
    const opus_int              signalType,                     /* I    Sigtype                                     */
    const opus_int              quantOffsetType,                /* I    quantOffsetType                             */
    const opus_int              frame_length                    /* I    Frame length                                */
)
{
 80108ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80108f0:	b0b3      	sub	sp, #204	; 0xcc
 80108f2:	9208      	str	r2, [sp, #32]
    const opus_uint8 *cdf_ptr;

    /*********************/
    /* Decode rate level */
    /*********************/
    RateLevelIndex = ec_dec_icdf( psRangeDec, silk_rate_levels_iCDF[ signalType >> 1 ], 8 );
 80108f4:	4d59      	ldr	r5, [pc, #356]	; (8010a5c <silk_decode_pulses+0x170>)
 80108f6:	1052      	asrs	r2, r2, #1
 80108f8:	eb02 04c2 	add.w	r4, r2, r2, lsl #3
{
 80108fc:	9107      	str	r1, [sp, #28]
    RateLevelIndex = ec_dec_icdf( psRangeDec, silk_rate_levels_iCDF[ signalType >> 1 ], 8 );
 80108fe:	1929      	adds	r1, r5, r4

    /* Calculate number of shell blocks */
    silk_assert( 1 << LOG2_SHELL_CODEC_FRAME_LENGTH == SHELL_CODEC_FRAME_LENGTH );
    iter = silk_RSHIFT( frame_length, LOG2_SHELL_CODEC_FRAME_LENGTH );
 8010900:	9c3c      	ldr	r4, [sp, #240]	; 0xf0
    RateLevelIndex = ec_dec_icdf( psRangeDec, silk_rate_levels_iCDF[ signalType >> 1 ], 8 );
 8010902:	2208      	movs	r2, #8
    iter = silk_RSHIFT( frame_length, LOG2_SHELL_CODEC_FRAME_LENGTH );
 8010904:	1124      	asrs	r4, r4, #4
{
 8010906:	9309      	str	r3, [sp, #36]	; 0x24
    iter = silk_RSHIFT( frame_length, LOG2_SHELL_CODEC_FRAME_LENGTH );
 8010908:	9403      	str	r4, [sp, #12]
{
 801090a:	4605      	mov	r5, r0
    RateLevelIndex = ec_dec_icdf( psRangeDec, silk_rate_levels_iCDF[ signalType >> 1 ], 8 );
 801090c:	f7f7 fe3e 	bl	800858c <ec_dec_icdf>
    if( iter * SHELL_CODEC_FRAME_LENGTH < frame_length ) {
 8010910:	9b3c      	ldr	r3, [sp, #240]	; 0xf0
 8010912:	ebb3 1f04 	cmp.w	r3, r4, lsl #4
 8010916:	dd02      	ble.n	801091e <silk_decode_pulses+0x32>
        celt_assert( frame_length == 12 * 10 ); /* Make sure only happens for 10 ms @ 12 kHz */
        iter++;
 8010918:	4623      	mov	r3, r4
 801091a:	3301      	adds	r3, #1
 801091c:	9303      	str	r3, [sp, #12]

    /***************************************************/
    /* Sum-Weighted-Pulses Decoding                    */
    /***************************************************/
    cdf_ptr = silk_pulses_per_block_iCDF[ RateLevelIndex ];
    for( i = 0; i < iter; i++ ) {
 801091e:	9b03      	ldr	r3, [sp, #12]
    cdf_ptr = silk_pulses_per_block_iCDF[ RateLevelIndex ];
 8010920:	4f4f      	ldr	r7, [pc, #316]	; (8010a60 <silk_decode_pulses+0x174>)
 8010922:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    for( i = 0; i < iter; i++ ) {
 8010926:	2b00      	cmp	r3, #0
    cdf_ptr = silk_pulses_per_block_iCDF[ RateLevelIndex ];
 8010928:	eb07 0940 	add.w	r9, r7, r0, lsl #1
    for( i = 0; i < iter; i++ ) {
 801092c:	f340 8092 	ble.w	8010a54 <silk_decode_pulses+0x168>
 8010930:	461a      	mov	r2, r3
 8010932:	ab1e      	add	r3, sp, #120	; 0x78

        /* LSB indication */
        while( sum_pulses[ i ] == SILK_MAX_PULSES + 1 ) {
            nLshifts[ i ]++;
            /* When we've already got 10 LSBs, we shift the table to not allow (SILK_MAX_PULSES + 1) */
            sum_pulses[ i ] = ec_dec_icdf( psRangeDec,
 8010934:	469a      	mov	sl, r3
 8010936:	f107 08a3 	add.w	r8, r7, #163	; 0xa3
 801093a:	9302      	str	r3, [sp, #8]
 801093c:	eb03 0b82 	add.w	fp, r3, r2, lsl #2
 8010940:	ae09      	add	r6, sp, #36	; 0x24
 8010942:	37a2      	adds	r7, #162	; 0xa2
        nLshifts[ i ] = 0;
 8010944:	2300      	movs	r3, #0
        sum_pulses[ i ] = ec_dec_icdf( psRangeDec, cdf_ptr, 8 );
 8010946:	2208      	movs	r2, #8
 8010948:	4649      	mov	r1, r9
 801094a:	4628      	mov	r0, r5
        nLshifts[ i ] = 0;
 801094c:	f84a 3b04 	str.w	r3, [sl], #4
        sum_pulses[ i ] = ec_dec_icdf( psRangeDec, cdf_ptr, 8 );
 8010950:	f7f7 fe1c 	bl	800858c <ec_dec_icdf>
        while( sum_pulses[ i ] == SILK_MAX_PULSES + 1 ) {
 8010954:	2811      	cmp	r0, #17
        sum_pulses[ i ] = ec_dec_icdf( psRangeDec, cdf_ptr, 8 );
 8010956:	f846 0f04 	str.w	r0, [r6, #4]!
        while( sum_pulses[ i ] == SILK_MAX_PULSES + 1 ) {
 801095a:	d10f      	bne.n	801097c <silk_decode_pulses+0x90>
 801095c:	2401      	movs	r4, #1
            sum_pulses[ i ] = ec_dec_icdf( psRangeDec,
 801095e:	2c0a      	cmp	r4, #10
            nLshifts[ i ]++;
 8010960:	f84a 4c04 	str.w	r4, [sl, #-4]
            sum_pulses[ i ] = ec_dec_icdf( psRangeDec,
 8010964:	f04f 0208 	mov.w	r2, #8
 8010968:	f104 0401 	add.w	r4, r4, #1
 801096c:	d065      	beq.n	8010a3a <silk_decode_pulses+0x14e>
 801096e:	4639      	mov	r1, r7
 8010970:	4628      	mov	r0, r5
 8010972:	f7f7 fe0b 	bl	800858c <ec_dec_icdf>
        while( sum_pulses[ i ] == SILK_MAX_PULSES + 1 ) {
 8010976:	2811      	cmp	r0, #17
            sum_pulses[ i ] = ec_dec_icdf( psRangeDec,
 8010978:	6030      	str	r0, [r6, #0]
        while( sum_pulses[ i ] == SILK_MAX_PULSES + 1 ) {
 801097a:	d0f0      	beq.n	801095e <silk_decode_pulses+0x72>
    for( i = 0; i < iter; i++ ) {
 801097c:	45da      	cmp	sl, fp
 801097e:	d1e1      	bne.n	8010944 <silk_decode_pulses+0x58>
 8010980:	ab0a      	add	r3, sp, #40	; 0x28
 8010982:	9304      	str	r3, [sp, #16]
 8010984:	461f      	mov	r7, r3
 8010986:	9a03      	ldr	r2, [sp, #12]
 8010988:	9b07      	ldr	r3, [sp, #28]
 801098a:	461c      	mov	r4, r3
 801098c:	eb03 1642 	add.w	r6, r3, r2, lsl #5
 8010990:	e006      	b.n	80109a0 <silk_decode_pulses+0xb4>
    /***************************************************/
    /* Shell decoding                                  */
    /***************************************************/
    for( i = 0; i < iter; i++ ) {
        if( sum_pulses[ i ] > 0 ) {
            silk_shell_decoder( &pulses[ silk_SMULBB( i, SHELL_CODEC_FRAME_LENGTH ) ], psRangeDec, sum_pulses[ i ] );
 8010992:	4620      	mov	r0, r4
 8010994:	4629      	mov	r1, r5
 8010996:	3420      	adds	r4, #32
 8010998:	f001 f828 	bl	80119ec <silk_shell_decoder>
    for( i = 0; i < iter; i++ ) {
 801099c:	42a6      	cmp	r6, r4
 801099e:	d00b      	beq.n	80109b8 <silk_decode_pulses+0xcc>
        if( sum_pulses[ i ] > 0 ) {
 80109a0:	f857 2b04 	ldr.w	r2, [r7], #4
 80109a4:	2a00      	cmp	r2, #0
 80109a6:	dcf4      	bgt.n	8010992 <silk_decode_pulses+0xa6>
        } else {
            silk_memset( &pulses[ silk_SMULBB( i, SHELL_CODEC_FRAME_LENGTH ) ], 0, SHELL_CODEC_FRAME_LENGTH * sizeof( pulses[0] ) );
 80109a8:	4620      	mov	r0, r4
 80109aa:	2220      	movs	r2, #32
 80109ac:	2100      	movs	r1, #0
 80109ae:	3420      	adds	r4, #32
 80109b0:	f003 fbba 	bl	8014128 <memset>
    for( i = 0; i < iter; i++ ) {
 80109b4:	42a6      	cmp	r6, r4
 80109b6:	d1f3      	bne.n	80109a0 <silk_decode_pulses+0xb4>
 80109b8:	f04f 0a00 	mov.w	sl, #0
 80109bc:	9b07      	ldr	r3, [sp, #28]
            pulses_ptr = &pulses[ silk_SMULBB( i, SHELL_CODEC_FRAME_LENGTH ) ];
            for( k = 0; k < SHELL_CODEC_FRAME_LENGTH; k++ ) {
                abs_q = pulses_ptr[ k ];
                for( j = 0; j < nLS; j++ ) {
                    abs_q = silk_LSHIFT( abs_q, 1 );
                    abs_q += ec_dec_icdf( psRangeDec, silk_lsb_iCDF, 8 );
 80109be:	4f29      	ldr	r7, [pc, #164]	; (8010a64 <silk_decode_pulses+0x178>)
 80109c0:	1e9a      	subs	r2, r3, #2
 80109c2:	331e      	adds	r3, #30
 80109c4:	9205      	str	r2, [sp, #20]
 80109c6:	9306      	str	r3, [sp, #24]
        if( nLshifts[ i ] > 0 ) {
 80109c8:	9b02      	ldr	r3, [sp, #8]
 80109ca:	f853 6b04 	ldr.w	r6, [r3], #4
 80109ce:	2e00      	cmp	r6, #0
 80109d0:	9302      	str	r3, [sp, #8]
 80109d2:	dd20      	ble.n	8010a16 <silk_decode_pulses+0x12a>
 80109d4:	9b05      	ldr	r3, [sp, #20]
 80109d6:	ea4f 194a 	mov.w	r9, sl, lsl #5
 80109da:	eb03 0809 	add.w	r8, r3, r9
 80109de:	9b06      	ldr	r3, [sp, #24]
 80109e0:	4499      	add	r9, r3
                for( j = 0; j < nLS; j++ ) {
 80109e2:	f04f 0b00 	mov.w	fp, #0
                abs_q = pulses_ptr[ k ];
 80109e6:	f938 4f02 	ldrsh.w	r4, [r8, #2]!
                    abs_q += ec_dec_icdf( psRangeDec, silk_lsb_iCDF, 8 );
 80109ea:	2208      	movs	r2, #8
 80109ec:	4639      	mov	r1, r7
 80109ee:	4628      	mov	r0, r5
 80109f0:	f7f7 fdcc 	bl	800858c <ec_dec_icdf>
                for( j = 0; j < nLS; j++ ) {
 80109f4:	f10b 0b01 	add.w	fp, fp, #1
                    abs_q = silk_LSHIFT( abs_q, 1 );
 80109f8:	0064      	lsls	r4, r4, #1
                for( j = 0; j < nLS; j++ ) {
 80109fa:	455e      	cmp	r6, fp
                    abs_q += ec_dec_icdf( psRangeDec, silk_lsb_iCDF, 8 );
 80109fc:	4404      	add	r4, r0
                for( j = 0; j < nLS; j++ ) {
 80109fe:	d1f4      	bne.n	80109ea <silk_decode_pulses+0xfe>
            for( k = 0; k < SHELL_CODEC_FRAME_LENGTH; k++ ) {
 8010a00:	45c1      	cmp	r9, r8
                }
                pulses_ptr[ k ] = abs_q;
 8010a02:	f8a8 4000 	strh.w	r4, [r8]
            for( k = 0; k < SHELL_CODEC_FRAME_LENGTH; k++ ) {
 8010a06:	d1ec      	bne.n	80109e2 <silk_decode_pulses+0xf6>
            }
            /* Mark the number of pulses non-zero for sign decoding. */
            sum_pulses[ i ] |= nLS << 5;
 8010a08:	9a04      	ldr	r2, [sp, #16]
 8010a0a:	f852 302a 	ldr.w	r3, [r2, sl, lsl #2]
 8010a0e:	ea43 1346 	orr.w	r3, r3, r6, lsl #5
 8010a12:	f842 302a 	str.w	r3, [r2, sl, lsl #2]
    for( i = 0; i < iter; i++ ) {
 8010a16:	9b03      	ldr	r3, [sp, #12]
 8010a18:	f10a 0a01 	add.w	sl, sl, #1
 8010a1c:	4553      	cmp	r3, sl
 8010a1e:	d1d3      	bne.n	80109c8 <silk_decode_pulses+0xdc>
    }

    /****************************************/
    /* Decode and add signs to pulse signal */
    /****************************************/
    silk_decode_signs( psRangeDec, pulses, frame_length, signalType, quantOffsetType, sum_pulses );
 8010a20:	9b04      	ldr	r3, [sp, #16]
 8010a22:	9a3c      	ldr	r2, [sp, #240]	; 0xf0
 8010a24:	9301      	str	r3, [sp, #4]
 8010a26:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010a28:	9907      	ldr	r1, [sp, #28]
 8010a2a:	9300      	str	r3, [sp, #0]
 8010a2c:	4628      	mov	r0, r5
 8010a2e:	9b08      	ldr	r3, [sp, #32]
 8010a30:	f7fe f884 	bl	800eb3c <silk_decode_signs>
}
 8010a34:	b033      	add	sp, #204	; 0xcc
 8010a36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            sum_pulses[ i ] = ec_dec_icdf( psRangeDec,
 8010a3a:	4641      	mov	r1, r8
 8010a3c:	4628      	mov	r0, r5
 8010a3e:	f7f7 fda5 	bl	800858c <ec_dec_icdf>
        while( sum_pulses[ i ] == SILK_MAX_PULSES + 1 ) {
 8010a42:	2811      	cmp	r0, #17
 8010a44:	f04f 040b 	mov.w	r4, #11
            sum_pulses[ i ] = ec_dec_icdf( psRangeDec,
 8010a48:	6030      	str	r0, [r6, #0]
        while( sum_pulses[ i ] == SILK_MAX_PULSES + 1 ) {
 8010a4a:	d088      	beq.n	801095e <silk_decode_pulses+0x72>
    for( i = 0; i < iter; i++ ) {
 8010a4c:	45da      	cmp	sl, fp
 8010a4e:	f47f af79 	bne.w	8010944 <silk_decode_pulses+0x58>
 8010a52:	e795      	b.n	8010980 <silk_decode_pulses+0x94>
 8010a54:	ab0a      	add	r3, sp, #40	; 0x28
 8010a56:	9304      	str	r3, [sp, #16]
 8010a58:	e7e2      	b.n	8010a20 <silk_decode_pulses+0x134>
 8010a5a:	bf00      	nop
 8010a5c:	08017d1c 	.word	0x08017d1c
 8010a60:	08017c68 	.word	0x08017c68
 8010a64:	08017b84 	.word	0x08017b84

08010a68 <silk_decoder_set_fs>:
opus_int silk_decoder_set_fs(
    silk_decoder_state          *psDec,                         /* I/O  Decoder state pointer                       */
    opus_int                    fs_kHz,                         /* I    Sampling frequency (kHz)                    */
    opus_int32                  fs_API_Hz                       /* I    API Sampling frequency (Hz)                 */
)
{
 8010a68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8010a6c:	460e      	mov	r6, r1

    celt_assert( fs_kHz == 8 || fs_kHz == 12 || fs_kHz == 16 );
    celt_assert( psDec->nb_subfr == MAX_NB_SUBFR || psDec->nb_subfr == MAX_NB_SUBFR/2 );

    /* New (sub)frame length */
    psDec->subfr_length = silk_SMULBB( SUB_FRAME_LENGTH_MS, fs_kHz );
 8010a6e:	b20d      	sxth	r5, r1
    frame_length = silk_SMULBB( psDec->nb_subfr, psDec->subfr_length );

    /* Initialize resampler when switching internal or external sampling frequency */
    if( psDec->fs_kHz != fs_kHz || psDec->fs_API_hz != fs_API_Hz ) {
 8010a70:	f8d0 190c 	ldr.w	r1, [r0, #2316]	; 0x90c
    psDec->subfr_length = silk_SMULBB( SUB_FRAME_LENGTH_MS, fs_kHz );
 8010a74:	ea4f 0985 	mov.w	r9, r5, lsl #2
    frame_length = silk_SMULBB( psDec->nb_subfr, psDec->subfr_length );
 8010a78:	f8d0 7914 	ldr.w	r7, [r0, #2324]	; 0x914
    psDec->subfr_length = silk_SMULBB( SUB_FRAME_LENGTH_MS, fs_kHz );
 8010a7c:	eb09 0305 	add.w	r3, r9, r5
    if( psDec->fs_kHz != fs_kHz || psDec->fs_API_hz != fs_API_Hz ) {
 8010a80:	42b1      	cmp	r1, r6
{
 8010a82:	4604      	mov	r4, r0
 8010a84:	4690      	mov	r8, r2
    psDec->subfr_length = silk_SMULBB( SUB_FRAME_LENGTH_MS, fs_kHz );
 8010a86:	f8c0 391c 	str.w	r3, [r0, #2332]	; 0x91c
    frame_length = silk_SMULBB( psDec->nb_subfr, psDec->subfr_length );
 8010a8a:	fb17 f703 	smulbb	r7, r7, r3
    if( psDec->fs_kHz != fs_kHz || psDec->fs_API_hz != fs_API_Hz ) {
 8010a8e:	d103      	bne.n	8010a98 <silk_decoder_set_fs+0x30>
 8010a90:	f8d0 3910 	ldr.w	r3, [r0, #2320]	; 0x910
 8010a94:	4293      	cmp	r3, r2
 8010a96:	d063      	beq.n	8010b60 <silk_decoder_set_fs+0xf8>
        /* Initialize the resampler for dec_API.c preparing resampling from fs_kHz to API_fs_Hz */
        ret += silk_resampler_init( &psDec->resampler_state, silk_SMULBB( fs_kHz, 1000 ), fs_API_Hz, 0 );
 8010a98:	ebc5 1145 	rsb	r1, r5, r5, lsl #5
 8010a9c:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 8010aa0:	2300      	movs	r3, #0
 8010aa2:	00c9      	lsls	r1, r1, #3
 8010aa4:	4642      	mov	r2, r8
 8010aa6:	f504 6018 	add.w	r0, r4, #2432	; 0x980
 8010aaa:	f000 f959 	bl	8010d60 <silk_resampler_init>

        psDec->fs_API_hz = fs_API_Hz;
    }

    if( psDec->fs_kHz != fs_kHz || frame_length != psDec->frame_length ) {
 8010aae:	f8d4 390c 	ldr.w	r3, [r4, #2316]	; 0x90c
        ret += silk_resampler_init( &psDec->resampler_state, silk_SMULBB( fs_kHz, 1000 ), fs_API_Hz, 0 );
 8010ab2:	4682      	mov	sl, r0
    if( psDec->fs_kHz != fs_kHz || frame_length != psDec->frame_length ) {
 8010ab4:	42b3      	cmp	r3, r6
        psDec->fs_API_hz = fs_API_Hz;
 8010ab6:	f8c4 8910 	str.w	r8, [r4, #2320]	; 0x910
    if( psDec->fs_kHz != fs_kHz || frame_length != psDec->frame_length ) {
 8010aba:	d053      	beq.n	8010b64 <silk_decoder_set_fs+0xfc>
        if( fs_kHz == 8 ) {
 8010abc:	2e08      	cmp	r6, #8
 8010abe:	f8d4 2914 	ldr.w	r2, [r4, #2324]	; 0x914
 8010ac2:	d058      	beq.n	8010b76 <silk_decoder_set_fs+0x10e>
                psDec->pitch_contour_iCDF = silk_pitch_contour_NB_iCDF;
            } else {
                psDec->pitch_contour_iCDF = silk_pitch_contour_10_ms_NB_iCDF;
            }
        } else {
            if( psDec->nb_subfr == MAX_NB_SUBFR ) {
 8010ac4:	2a04      	cmp	r2, #4
 8010ac6:	d036      	beq.n	8010b36 <silk_decoder_set_fs+0xce>
                psDec->pitch_contour_iCDF = silk_pitch_contour_iCDF;
            } else {
                psDec->pitch_contour_iCDF = silk_pitch_contour_10_ms_iCDF;
 8010ac8:	4a38      	ldr	r2, [pc, #224]	; (8010bac <silk_decoder_set_fs+0x144>)
            }
        }
        if( psDec->fs_kHz != fs_kHz ) {
 8010aca:	429e      	cmp	r6, r3
                psDec->pitch_contour_iCDF = silk_pitch_contour_10_ms_iCDF;
 8010acc:	f8c4 2950 	str.w	r2, [r4, #2384]	; 0x950
        if( psDec->fs_kHz != fs_kHz ) {
 8010ad0:	d02a      	beq.n	8010b28 <silk_decoder_set_fs+0xc0>
            psDec->ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
 8010ad2:	444d      	add	r5, r9
 8010ad4:	00ad      	lsls	r5, r5, #2
            if( fs_kHz == 8 || fs_kHz == 12 ) {
 8010ad6:	2e0c      	cmp	r6, #12
            psDec->ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
 8010ad8:	f8c4 5920 	str.w	r5, [r4, #2336]	; 0x920
            if( fs_kHz == 8 || fs_kHz == 12 ) {
 8010adc:	d036      	beq.n	8010b4c <silk_decoder_set_fs+0xe4>
 8010ade:	2210      	movs	r2, #16
 8010ae0:	4b33      	ldr	r3, [pc, #204]	; (8010bb0 <silk_decoder_set_fs+0x148>)
                psDec->psNLSF_CB = &silk_NLSF_CB_NB_MB;
            } else {
                psDec->LPC_order = MAX_LPC_ORDER;
                psDec->psNLSF_CB = &silk_NLSF_CB_WB;
            }
            if( fs_kHz == 16 ) {
 8010ae2:	4296      	cmp	r6, r2
 8010ae4:	f8c4 2924 	str.w	r2, [r4, #2340]	; 0x924
 8010ae8:	f8c4 3aac 	str.w	r3, [r4, #2732]	; 0xaac
 8010aec:	d102      	bne.n	8010af4 <silk_decoder_set_fs+0x8c>
                psDec->pitch_lag_low_bits_iCDF = silk_uniform8_iCDF;
 8010aee:	4b31      	ldr	r3, [pc, #196]	; (8010bb4 <silk_decoder_set_fs+0x14c>)
 8010af0:	f8c4 394c 	str.w	r3, [r4, #2380]	; 0x94c
                celt_assert( 0 );
            }
            psDec->first_frame_after_reset = 1;
            psDec->lagPrev                 = 100;
            psDec->LastGainIndex           = 10;
            psDec->prevSignalType          = TYPE_NO_VOICE_ACTIVITY;
 8010af4:	2500      	movs	r5, #0
            psDec->first_frame_after_reset = 1;
 8010af6:	2001      	movs	r0, #1
            psDec->lagPrev                 = 100;
 8010af8:	2164      	movs	r1, #100	; 0x64
            psDec->LastGainIndex           = 10;
 8010afa:	220a      	movs	r2, #10
            psDec->prevSignalType          = TYPE_NO_VOICE_ACTIVITY;
 8010afc:	f241 0344 	movw	r3, #4164	; 0x1044
            psDec->first_frame_after_reset = 1;
 8010b00:	f8c4 0948 	str.w	r0, [r4, #2376]	; 0x948
            psDec->lagPrev                 = 100;
 8010b04:	f8c4 1904 	str.w	r1, [r4, #2308]	; 0x904
            psDec->LastGainIndex           = 10;
 8010b08:	f884 2908 	strb.w	r2, [r4, #2312]	; 0x908
            silk_memset( psDec->outBuf, 0, sizeof(psDec->outBuf));
 8010b0c:	4629      	mov	r1, r5
 8010b0e:	f44f 7270 	mov.w	r2, #960	; 0x3c0
            psDec->prevSignalType          = TYPE_NO_VOICE_ACTIVITY;
 8010b12:	50e5      	str	r5, [r4, r3]
            silk_memset( psDec->outBuf, 0, sizeof(psDec->outBuf));
 8010b14:	f204 5044 	addw	r0, r4, #1348	; 0x544
 8010b18:	f003 fb06 	bl	8014128 <memset>
            silk_memset( psDec->sLPC_Q14_buf, 0, sizeof(psDec->sLPC_Q14_buf) );
 8010b1c:	4629      	mov	r1, r5
 8010b1e:	2240      	movs	r2, #64	; 0x40
 8010b20:	f204 5004 	addw	r0, r4, #1284	; 0x504
 8010b24:	f003 fb00 	bl	8014128 <memset>
        }

        psDec->fs_kHz       = fs_kHz;
 8010b28:	f8c4 690c 	str.w	r6, [r4, #2316]	; 0x90c
        psDec->frame_length = frame_length;
 8010b2c:	f8c4 7918 	str.w	r7, [r4, #2328]	; 0x918

    /* Check that settings are valid */
    celt_assert( psDec->frame_length > 0 && psDec->frame_length <= MAX_FRAME_LENGTH );

    return ret;
}
 8010b30:	4650      	mov	r0, sl
 8010b32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                psDec->pitch_contour_iCDF = silk_pitch_contour_iCDF;
 8010b36:	4a20      	ldr	r2, [pc, #128]	; (8010bb8 <silk_decoder_set_fs+0x150>)
        if( psDec->fs_kHz != fs_kHz ) {
 8010b38:	429e      	cmp	r6, r3
                psDec->pitch_contour_iCDF = silk_pitch_contour_iCDF;
 8010b3a:	f8c4 2950 	str.w	r2, [r4, #2384]	; 0x950
        if( psDec->fs_kHz != fs_kHz ) {
 8010b3e:	d0f3      	beq.n	8010b28 <silk_decoder_set_fs+0xc0>
            psDec->ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
 8010b40:	444d      	add	r5, r9
 8010b42:	00ad      	lsls	r5, r5, #2
            if( fs_kHz == 8 || fs_kHz == 12 ) {
 8010b44:	2e0c      	cmp	r6, #12
            psDec->ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
 8010b46:	f8c4 5920 	str.w	r5, [r4, #2336]	; 0x920
            if( fs_kHz == 8 || fs_kHz == 12 ) {
 8010b4a:	d1c8      	bne.n	8010ade <silk_decoder_set_fs+0x76>
 8010b4c:	230a      	movs	r3, #10
 8010b4e:	4a1b      	ldr	r2, [pc, #108]	; (8010bbc <silk_decoder_set_fs+0x154>)
 8010b50:	f8c4 3924 	str.w	r3, [r4, #2340]	; 0x924
                psDec->pitch_lag_low_bits_iCDF = silk_uniform6_iCDF;
 8010b54:	4b1a      	ldr	r3, [pc, #104]	; (8010bc0 <silk_decoder_set_fs+0x158>)
 8010b56:	f8c4 2aac 	str.w	r2, [r4, #2732]	; 0xaac
 8010b5a:	f8c4 394c 	str.w	r3, [r4, #2380]	; 0x94c
 8010b5e:	e7c9      	b.n	8010af4 <silk_decoder_set_fs+0x8c>
    opus_int frame_length, ret = 0;
 8010b60:	f04f 0a00 	mov.w	sl, #0
    if( psDec->fs_kHz != fs_kHz || frame_length != psDec->frame_length ) {
 8010b64:	f8d4 3918 	ldr.w	r3, [r4, #2328]	; 0x918
 8010b68:	42bb      	cmp	r3, r7
 8010b6a:	d0e1      	beq.n	8010b30 <silk_decoder_set_fs+0xc8>
        if( fs_kHz == 8 ) {
 8010b6c:	2e08      	cmp	r6, #8
 8010b6e:	4633      	mov	r3, r6
 8010b70:	f8d4 2914 	ldr.w	r2, [r4, #2324]	; 0x914
 8010b74:	d1a6      	bne.n	8010ac4 <silk_decoder_set_fs+0x5c>
            if( psDec->nb_subfr == MAX_NB_SUBFR ) {
 8010b76:	2a04      	cmp	r2, #4
 8010b78:	d012      	beq.n	8010ba0 <silk_decoder_set_fs+0x138>
                psDec->pitch_contour_iCDF = silk_pitch_contour_10_ms_NB_iCDF;
 8010b7a:	4a12      	ldr	r2, [pc, #72]	; (8010bc4 <silk_decoder_set_fs+0x15c>)
        if( psDec->fs_kHz != fs_kHz ) {
 8010b7c:	2b08      	cmp	r3, #8
                psDec->pitch_contour_iCDF = silk_pitch_contour_10_ms_NB_iCDF;
 8010b7e:	f8c4 2950 	str.w	r2, [r4, #2384]	; 0x950
        if( psDec->fs_kHz != fs_kHz ) {
 8010b82:	d0d1      	beq.n	8010b28 <silk_decoder_set_fs+0xc0>
 8010b84:	230a      	movs	r3, #10
            psDec->ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
 8010b86:	444d      	add	r5, r9
 8010b88:	4a0c      	ldr	r2, [pc, #48]	; (8010bbc <silk_decoder_set_fs+0x154>)
 8010b8a:	f8c4 3924 	str.w	r3, [r4, #2340]	; 0x924
                psDec->pitch_lag_low_bits_iCDF = silk_uniform4_iCDF;
 8010b8e:	4b0e      	ldr	r3, [pc, #56]	; (8010bc8 <silk_decoder_set_fs+0x160>)
            psDec->ltp_mem_length = silk_SMULBB( LTP_MEM_LENGTH_MS, fs_kHz );
 8010b90:	00ad      	lsls	r5, r5, #2
 8010b92:	f8c4 5920 	str.w	r5, [r4, #2336]	; 0x920
 8010b96:	f8c4 2aac 	str.w	r2, [r4, #2732]	; 0xaac
                psDec->pitch_lag_low_bits_iCDF = silk_uniform4_iCDF;
 8010b9a:	f8c4 394c 	str.w	r3, [r4, #2380]	; 0x94c
 8010b9e:	e7a9      	b.n	8010af4 <silk_decoder_set_fs+0x8c>
                psDec->pitch_contour_iCDF = silk_pitch_contour_NB_iCDF;
 8010ba0:	4a0a      	ldr	r2, [pc, #40]	; (8010bcc <silk_decoder_set_fs+0x164>)
        if( psDec->fs_kHz != fs_kHz ) {
 8010ba2:	2b08      	cmp	r3, #8
                psDec->pitch_contour_iCDF = silk_pitch_contour_NB_iCDF;
 8010ba4:	f8c4 2950 	str.w	r2, [r4, #2384]	; 0x950
        if( psDec->fs_kHz != fs_kHz ) {
 8010ba8:	d1ec      	bne.n	8010b84 <silk_decoder_set_fs+0x11c>
 8010baa:	e7bd      	b.n	8010b28 <silk_decoder_set_fs+0xc0>
 8010bac:	08017bf4 	.word	0x08017bf4
 8010bb0:	08017a9c 	.word	0x08017a9c
 8010bb4:	08017be8 	.word	0x08017be8
 8010bb8:	08017c0c 	.word	0x08017c0c
 8010bbc:	08017278 	.word	0x08017278
 8010bc0:	08017be0 	.word	0x08017be0
 8010bc4:	08017bf0 	.word	0x08017bf0
 8010bc8:	08017bd4 	.word	0x08017bd4
 8010bcc:	08017c00 	.word	0x08017c00

08010bd0 <silk_gains_dequant>:
    const opus_int8             ind[ MAX_NB_SUBFR ],            /* I    gain indices                                */
    opus_int8                   *prev_ind,                      /* I/O  last index in previous frame                */
    const opus_int              conditional,                    /* I    first gain is delta coded if 1              */
    const opus_int              nb_subfr                        /* I    number of subframes                          */
)
{
 8010bd0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010bd4:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    opus_int   k, ind_tmp, double_step_size_threshold;

    for( k = 0; k < nb_subfr; k++ ) {
 8010bd6:	2e00      	cmp	r6, #0
 8010bd8:	dd30      	ble.n	8010c3c <silk_gains_dequant+0x6c>
 8010bda:	4693      	mov	fp, r2
 8010bdc:	460d      	mov	r5, r1
 8010bde:	bb7b      	cbnz	r3, 8010c40 <silk_gains_dequant+0x70>
 8010be0:	4699      	mov	r9, r3
    return (((a) < (b)) ? (a) : (b));
 8010be2:	f640 787f 	movw	r8, #3967	; 0xf7f
 8010be6:	4f3b      	ldr	r7, [pc, #236]	; (8010cd4 <silk_gains_dequant+0x104>)
 8010be8:	f1a0 0a04 	sub.w	sl, r0, #4
 8010bec:	f99b 4000 	ldrsb.w	r4, [fp]
        if( k == 0 && conditional == 0 ) {
 8010bf0:	f1b9 0f00 	cmp.w	r9, #0
 8010bf4:	d066      	beq.n	8010cc4 <silk_gains_dequant+0xf4>
            /* Gain index is not allowed to go down more than 16 steps (~21.8 dB) */
            *prev_ind = silk_max_int( ind[ k ], *prev_ind - 16 );
        } else {
            /* Delta index */
            ind_tmp = ind[ k ] + MIN_DELTA_GAIN_QUANT;
 8010bf6:	f915 3009 	ldrsb.w	r3, [r5, r9]

            /* Accumulate deltas */
            double_step_size_threshold = 2 * MAX_DELTA_GAIN_QUANT - N_LEVELS_QGAIN + *prev_ind;
 8010bfa:	f104 0108 	add.w	r1, r4, #8
            ind_tmp = ind[ k ] + MIN_DELTA_GAIN_QUANT;
 8010bfe:	3b04      	subs	r3, #4
 8010c00:	b2e4      	uxtb	r4, r4
            if( ind_tmp > double_step_size_threshold ) {
                *prev_ind += silk_LSHIFT( ind_tmp, 1 ) - double_step_size_threshold;
 8010c02:	1a62      	subs	r2, r4, r1
            if( ind_tmp > double_step_size_threshold ) {
 8010c04:	428b      	cmp	r3, r1
 8010c06:	b2d8      	uxtb	r0, r3
                *prev_ind += silk_LSHIFT( ind_tmp, 1 ) - double_step_size_threshold;
 8010c08:	eb02 0240 	add.w	r2, r2, r0, lsl #1
            } else {
                *prev_ind += ind_tmp;
 8010c0c:	bfd6      	itet	le
 8010c0e:	1824      	addle	r4, r4, r0
                *prev_ind += silk_LSHIFT( ind_tmp, 1 ) - double_step_size_threshold;
 8010c10:	b254      	sxtbgt	r4, r2
                *prev_ind += ind_tmp;
 8010c12:	b264      	sxtble	r4, r4
 8010c14:	f384 0406 	usat	r4, #6, r4
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8010c18:	0423      	lsls	r3, r4, #16
  __asm__(
 8010c1a:	fb87 2003 	smull	r2, r0, r7, r3
            }
        }
        *prev_ind = silk_LIMIT_int( *prev_ind, 0, N_LEVELS_QGAIN - 1 );

        /* Scale and convert to linear scale */
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
 8010c1e:	f600 002a 	addw	r0, r0, #2090	; 0x82a
 8010c22:	4540      	cmp	r0, r8
 8010c24:	bfa8      	it	ge
 8010c26:	4640      	movge	r0, r8
        *prev_ind = silk_LIMIT_int( *prev_ind, 0, N_LEVELS_QGAIN - 1 );
 8010c28:	f88b 4000 	strb.w	r4, [fp]
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
 8010c2c:	f000 f86a 	bl	8010d04 <silk_log2lin>
    for( k = 0; k < nb_subfr; k++ ) {
 8010c30:	f109 0901 	add.w	r9, r9, #1
 8010c34:	454e      	cmp	r6, r9
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
 8010c36:	f84a 0f04 	str.w	r0, [sl, #4]!
    for( k = 0; k < nb_subfr; k++ ) {
 8010c3a:	d1d7      	bne.n	8010bec <silk_gains_dequant+0x1c>
    }
}
 8010c3c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010c40:	f640 747f 	movw	r4, #3967	; 0xf7f
 8010c44:	1e4d      	subs	r5, r1, #1
 8010c46:	4f23      	ldr	r7, [pc, #140]	; (8010cd4 <silk_gains_dequant+0x104>)
 8010c48:	442e      	add	r6, r5
 8010c4a:	f1a0 0a04 	sub.w	sl, r0, #4
            ind_tmp = ind[ k ] + MIN_DELTA_GAIN_QUANT;
 8010c4e:	f915 1f01 	ldrsb.w	r1, [r5, #1]!
 8010c52:	f99b c000 	ldrsb.w	ip, [fp]
 8010c56:	3904      	subs	r1, #4
            double_step_size_threshold = 2 * MAX_DELTA_GAIN_QUANT - N_LEVELS_QGAIN + *prev_ind;
 8010c58:	f10c 0008 	add.w	r0, ip, #8
 8010c5c:	b2cb      	uxtb	r3, r1
 8010c5e:	fa5f fc8c 	uxtb.w	ip, ip
                *prev_ind += silk_LSHIFT( ind_tmp, 1 ) - double_step_size_threshold;
 8010c62:	eb0c 0243 	add.w	r2, ip, r3, lsl #1
 8010c66:	1a12      	subs	r2, r2, r0
                *prev_ind += ind_tmp;
 8010c68:	4463      	add	r3, ip
        *prev_ind = silk_LIMIT_int( *prev_ind, 0, N_LEVELS_QGAIN - 1 );
 8010c6a:	b25b      	sxtb	r3, r3
 8010c6c:	b252      	sxtb	r2, r2
 8010c6e:	f383 0306 	usat	r3, #6, r3
 8010c72:	f382 0206 	usat	r2, #6, r2
            if( ind_tmp > double_step_size_threshold ) {
 8010c76:	4288      	cmp	r0, r1
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8010c78:	ea4f 4e03 	mov.w	lr, r3, lsl #16
 8010c7c:	ea4f 4c02 	mov.w	ip, r2, lsl #16
 8010c80:	db0f      	blt.n	8010ca2 <silk_gains_dequant+0xd2>
  __asm__(
 8010c82:	fb87 200e 	smull	r2, r0, r7, lr
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
 8010c86:	f600 002a 	addw	r0, r0, #2090	; 0x82a
 8010c8a:	42a0      	cmp	r0, r4
 8010c8c:	bfa8      	it	ge
 8010c8e:	4620      	movge	r0, r4
        *prev_ind = silk_LIMIT_int( *prev_ind, 0, N_LEVELS_QGAIN - 1 );
 8010c90:	f88b 3000 	strb.w	r3, [fp]
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
 8010c94:	f000 f836 	bl	8010d04 <silk_log2lin>
    for( k = 0; k < nb_subfr; k++ ) {
 8010c98:	42b5      	cmp	r5, r6
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
 8010c9a:	f84a 0f04 	str.w	r0, [sl, #4]!
    for( k = 0; k < nb_subfr; k++ ) {
 8010c9e:	d1d6      	bne.n	8010c4e <silk_gains_dequant+0x7e>
 8010ca0:	e7cc      	b.n	8010c3c <silk_gains_dequant+0x6c>
 8010ca2:	fb87 300c 	smull	r3, r0, r7, ip
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
 8010ca6:	f600 002a 	addw	r0, r0, #2090	; 0x82a
 8010caa:	42a0      	cmp	r0, r4
 8010cac:	bfa8      	it	ge
 8010cae:	4620      	movge	r0, r4
        *prev_ind = silk_LIMIT_int( *prev_ind, 0, N_LEVELS_QGAIN - 1 );
 8010cb0:	f88b 2000 	strb.w	r2, [fp]
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
 8010cb4:	f000 f826 	bl	8010d04 <silk_log2lin>
    for( k = 0; k < nb_subfr; k++ ) {
 8010cb8:	42b5      	cmp	r5, r6
        gain_Q16[ k ] = silk_log2lin( silk_min_32( silk_SMULWB( INV_SCALE_Q16, *prev_ind ) + OFFSET, 3967 ) ); /* 3967 = 31 in Q7 */
 8010cba:	f84a 0f04 	str.w	r0, [sl, #4]!
    for( k = 0; k < nb_subfr; k++ ) {
 8010cbe:	d1c6      	bne.n	8010c4e <silk_gains_dequant+0x7e>
}
 8010cc0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            *prev_ind = silk_max_int( ind[ k ], *prev_ind - 16 );
 8010cc4:	f995 3000 	ldrsb.w	r3, [r5]
 8010cc8:	3c10      	subs	r4, #16
    return (((a) > (b)) ? (a) : (b));
 8010cca:	429c      	cmp	r4, r3
 8010ccc:	bfb8      	it	lt
 8010cce:	461c      	movlt	r4, r3
 8010cd0:	b264      	sxtb	r4, r4
 8010cd2:	e79f      	b.n	8010c14 <silk_gains_dequant+0x44>
 8010cd4:	001d1c71 	.word	0x001d1c71

08010cd8 <silk_init_decoder>:
/* Init Decoder State   */
/************************/
opus_int silk_init_decoder(
    silk_decoder_state          *psDec                          /* I/O  Decoder state pointer                       */
)
{
 8010cd8:	b510      	push	{r4, lr}
    /* Clear the entire encoder state, except anything copied */
    silk_memset( psDec, 0, sizeof( silk_decoder_state ) );
 8010cda:	2100      	movs	r1, #0
 8010cdc:	f241 02a8 	movw	r2, #4264	; 0x10a8
{
 8010ce0:	4604      	mov	r4, r0
    silk_memset( psDec, 0, sizeof( silk_decoder_state ) );
 8010ce2:	f003 fa21 	bl	8014128 <memset>

    /* Used to deactivate LSF interpolation */
    psDec->first_frame_after_reset = 1;
 8010ce6:	2201      	movs	r2, #1
    psDec->prev_gain_Q16 = 65536;
 8010ce8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    psDec->first_frame_after_reset = 1;
 8010cec:	f8c4 2948 	str.w	r2, [r4, #2376]	; 0x948
    psDec->prev_gain_Q16 = 65536;
 8010cf0:	6023      	str	r3, [r4, #0]
    psDec->arch = opus_select_arch();

    /* Reset CNG state */
    silk_CNG_Reset( psDec );
 8010cf2:	4620      	mov	r0, r4
 8010cf4:	f7fb f99e 	bl	800c034 <silk_CNG_Reset>

    /* Reset PLC state */
    silk_PLC_Reset( psDec );
 8010cf8:	4620      	mov	r0, r4
 8010cfa:	f7fc ffb7 	bl	800dc6c <silk_PLC_Reset>

    return(0);
}
 8010cfe:	2000      	movs	r0, #0
 8010d00:	bd10      	pop	{r4, pc}
 8010d02:	bf00      	nop

08010d04 <silk_log2lin>:
    const opus_int32            inLog_Q7            /* I  input on log scale                                            */
)
{
    opus_int32 out, frac_Q7;

    if( inLog_Q7 < 0 ) {
 8010d04:	2800      	cmp	r0, #0
 8010d06:	db1e      	blt.n	8010d46 <silk_log2lin+0x42>
        return 0;
    } else if ( inLog_Q7 >= 3967 ) {
 8010d08:	f640 737e 	movw	r3, #3966	; 0xf7e
 8010d0c:	4298      	cmp	r0, r3
 8010d0e:	dc17      	bgt.n	8010d40 <silk_log2lin+0x3c>
        return silk_int32_MAX;
    }

    out = silk_LSHIFT( 1, silk_RSHIFT( inLog_Q7, 7 ) );
 8010d10:	2101      	movs	r1, #1
    frac_Q7 = inLog_Q7 & 0x7F;
 8010d12:	f000 027f 	and.w	r2, r0, #127	; 0x7f
 8010d16:	f1c2 0380 	rsb	r3, r2, #128	; 0x80
{
 8010d1a:	b470      	push	{r4, r5, r6}
 8010d1c:	b29b      	uxth	r3, r3
    out = silk_LSHIFT( 1, silk_RSHIFT( inLog_Q7, 7 ) );
 8010d1e:	11c4      	asrs	r4, r0, #7
    if( inLog_Q7 < 2048 ) {
 8010d20:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 8010d24:	fb02 f303 	mul.w	r3, r2, r3
    out = silk_LSHIFT( 1, silk_RSHIFT( inLog_Q7, 7 ) );
 8010d28:	fa01 f104 	lsl.w	r1, r1, r4
    if( inLog_Q7 < 2048 ) {
 8010d2c:	db0d      	blt.n	8010d4a <silk_log2lin+0x46>
 8010d2e:	4c0b      	ldr	r4, [pc, #44]	; (8010d5c <silk_log2lin+0x58>)
        /* Piece-wise parabolic approximation */
        out = silk_ADD_RSHIFT32( out, silk_MUL( out, silk_SMLAWB( frac_Q7, silk_SMULBB( frac_Q7, 128 - frac_Q7 ), -174 ) ), 7 );
    } else {
        /* Piece-wise parabolic approximation */
        out = silk_MLA( out, silk_RSHIFT( out, 7 ), silk_SMLAWB( frac_Q7, silk_SMULBB( frac_Q7, 128 - frac_Q7 ), -174 ) );
 8010d30:	11cd      	asrs	r5, r1, #7
 8010d32:	fb83 6004 	smull	r6, r0, r3, r4
 8010d36:	4402      	add	r2, r0
#undef silk_MLA
static OPUS_INLINE opus_int32 silk_MLA_armv4(opus_int32 a, opus_int32 b,
 opus_int32 c)
{
  opus_int32 res;
  __asm__(
 8010d38:	fb05 1002 	mla	r0, r5, r2, r1
    }
    return out;
}
 8010d3c:	bc70      	pop	{r4, r5, r6}
 8010d3e:	4770      	bx	lr
        return silk_int32_MAX;
 8010d40:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
}
 8010d44:	4770      	bx	lr
        return 0;
 8010d46:	2000      	movs	r0, #0
 8010d48:	4770      	bx	lr
 8010d4a:	4d04      	ldr	r5, [pc, #16]	; (8010d5c <silk_log2lin+0x58>)
 8010d4c:	fb83 6005 	smull	r6, r0, r3, r5
        out = silk_ADD_RSHIFT32( out, silk_MUL( out, silk_SMLAWB( frac_Q7, silk_SMULBB( frac_Q7, 128 - frac_Q7 ), -174 ) ), 7 );
 8010d50:	4410      	add	r0, r2
 8010d52:	40a0      	lsls	r0, r4
 8010d54:	eb01 10e0 	add.w	r0, r1, r0, asr #7
}
 8010d58:	bc70      	pop	{r4, r5, r6}
 8010d5a:	4770      	bx	lr
 8010d5c:	ff520000 	.word	0xff520000

08010d60 <silk_resampler_init>:
    silk_resampler_state_struct *S,                 /* I/O  Resampler state                                             */
    opus_int32                  Fs_Hz_in,           /* I    Input sampling rate (Hz)                                    */
    opus_int32                  Fs_Hz_out,          /* I    Output sampling rate (Hz)                                   */
    opus_int                    forEnc              /* I    If 1: encoder; if 0: decoder                                */
)
{
 8010d60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010d62:	461f      	mov	r7, r3
 8010d64:	460d      	mov	r5, r1
 8010d66:	4614      	mov	r4, r2
    opus_int up2x;

    /* Clear state */
    silk_memset( S, 0, sizeof( silk_resampler_state_struct ) );
 8010d68:	2100      	movs	r1, #0
 8010d6a:	f44f 7296 	mov.w	r2, #300	; 0x12c
{
 8010d6e:	4606      	mov	r6, r0
    silk_memset( S, 0, sizeof( silk_resampler_state_struct ) );
 8010d70:	f003 f9da 	bl	8014128 <memset>

    /* Input checking */
    if( forEnc ) {
 8010d74:	2f00      	cmp	r7, #0
 8010d76:	d07e      	beq.n	8010e76 <silk_resampler_init+0x116>
        if( ( Fs_Hz_in  != 8000 && Fs_Hz_in  != 12000 && Fs_Hz_in  != 16000 && Fs_Hz_in  != 24000 && Fs_Hz_in  != 48000 ) ||
 8010d78:	f5b5 5ffa 	cmp.w	r5, #8000	; 0x1f40
 8010d7c:	d00f      	beq.n	8010d9e <silk_resampler_init+0x3e>
 8010d7e:	f642 63e0 	movw	r3, #12000	; 0x2ee0
 8010d82:	429d      	cmp	r5, r3
 8010d84:	d00b      	beq.n	8010d9e <silk_resampler_init+0x3e>
 8010d86:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 8010d8a:	d008      	beq.n	8010d9e <silk_resampler_init+0x3e>
 8010d8c:	f645 53c0 	movw	r3, #24000	; 0x5dc0
 8010d90:	429d      	cmp	r5, r3
 8010d92:	d004      	beq.n	8010d9e <silk_resampler_init+0x3e>
 8010d94:	f64b 3380 	movw	r3, #48000	; 0xbb80
 8010d98:	429d      	cmp	r5, r3
 8010d9a:	f040 80e5 	bne.w	8010f68 <silk_resampler_init+0x208>
 8010d9e:	f5b4 5ffa 	cmp.w	r4, #8000	; 0x1f40
 8010da2:	d007      	beq.n	8010db4 <silk_resampler_init+0x54>
            ( Fs_Hz_out != 8000 && Fs_Hz_out != 12000 && Fs_Hz_out != 16000 ) ) {
 8010da4:	f642 63e0 	movw	r3, #12000	; 0x2ee0
 8010da8:	429c      	cmp	r4, r3
 8010daa:	d003      	beq.n	8010db4 <silk_resampler_init+0x54>
 8010dac:	f5b4 5f7a 	cmp.w	r4, #16000	; 0x3e80
 8010db0:	f040 80da 	bne.w	8010f68 <silk_resampler_init+0x208>
            celt_assert( 0 );
            return -1;
        }
        S->inputDelay = delay_matrix_enc[ rateID( Fs_Hz_in ) ][ rateID( Fs_Hz_out ) ];
 8010db4:	f645 52c0 	movw	r2, #24000	; 0x5dc0
 8010db8:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 8010dbc:	bfd4      	ite	le
 8010dbe:	2300      	movle	r3, #0
 8010dc0:	2301      	movgt	r3, #1
 8010dc2:	4295      	cmp	r5, r2
 8010dc4:	bfd4      	ite	le
 8010dc6:	2700      	movle	r7, #0
 8010dc8:	2701      	movgt	r7, #1
 8010dca:	f5b4 5f7a 	cmp.w	r4, #16000	; 0x3e80
 8010dce:	bfd4      	ite	le
 8010dd0:	2100      	movle	r1, #0
 8010dd2:	2101      	movgt	r1, #1
 8010dd4:	4294      	cmp	r4, r2
 8010dd6:	bfd4      	ite	le
 8010dd8:	2000      	movle	r0, #0
 8010dda:	2001      	movgt	r0, #1
 8010ddc:	ebc3 3325 	rsb	r3, r3, r5, asr #12
 8010de0:	413b      	asrs	r3, r7
 8010de2:	3b01      	subs	r3, #1
 8010de4:	4a66      	ldr	r2, [pc, #408]	; (8010f80 <silk_resampler_init+0x220>)
 8010de6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
        if( ( Fs_Hz_in  != 8000 && Fs_Hz_in  != 12000 && Fs_Hz_in  != 16000 ) ||
            ( Fs_Hz_out != 8000 && Fs_Hz_out != 12000 && Fs_Hz_out != 16000 && Fs_Hz_out != 24000 && Fs_Hz_out != 48000 ) ) {
            celt_assert( 0 );
            return -1;
        }
        S->inputDelay = delay_matrix_dec[ rateID( Fs_Hz_in ) ][ rateID( Fs_Hz_out ) ];
 8010dea:	ebc1 3124 	rsb	r1, r1, r4, asr #12
 8010dee:	4413      	add	r3, r2
 8010df0:	fa41 f200 	asr.w	r2, r1, r0
    }

    S->Fs_in_kHz  = silk_DIV32_16( Fs_Hz_in,  1000 );
 8010df4:	4963      	ldr	r1, [pc, #396]	; (8010f84 <silk_resampler_init+0x224>)
        S->inputDelay = delay_matrix_dec[ rateID( Fs_Hz_in ) ][ rateID( Fs_Hz_out ) ];
 8010df6:	4413      	add	r3, r2
    S->Fs_in_kHz  = silk_DIV32_16( Fs_Hz_in,  1000 );
 8010df8:	fb81 2005 	smull	r2, r0, r1, r5
        S->inputDelay = delay_matrix_dec[ rateID( Fs_Hz_in ) ][ rateID( Fs_Hz_out ) ];
 8010dfc:	f913 3c01 	ldrsb.w	r3, [r3, #-1]
    S->Fs_out_kHz = silk_DIV32_16( Fs_Hz_out, 1000 );
 8010e00:	fb81 2104 	smull	r2, r1, r1, r4
        S->inputDelay = delay_matrix_dec[ rateID( Fs_Hz_in ) ][ rateID( Fs_Hz_out ) ];
 8010e04:	f8c6 3124 	str.w	r3, [r6, #292]	; 0x124
    S->Fs_in_kHz  = silk_DIV32_16( Fs_Hz_in,  1000 );
 8010e08:	17eb      	asrs	r3, r5, #31
 8010e0a:	ebc3 13a0 	rsb	r3, r3, r0, asr #6

    /* Number of samples processed per batch */
    S->batchSize = S->Fs_in_kHz * RESAMPLER_MAX_BATCH_SIZE_MS;
 8010e0e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    S->Fs_out_kHz = silk_DIV32_16( Fs_Hz_out, 1000 );
 8010e12:	17e2      	asrs	r2, r4, #31
    S->batchSize = S->Fs_in_kHz * RESAMPLER_MAX_BATCH_SIZE_MS;
 8010e14:	0040      	lsls	r0, r0, #1
    S->Fs_out_kHz = silk_DIV32_16( Fs_Hz_out, 1000 );
 8010e16:	ebc2 12a1 	rsb	r2, r2, r1, asr #6

    /* Find resampler with the right sampling ratio */
    up2x = 0;
    if( Fs_Hz_out > Fs_Hz_in ) {
 8010e1a:	42a5      	cmp	r5, r4
    S->Fs_in_kHz  = silk_DIV32_16( Fs_Hz_in,  1000 );
 8010e1c:	f8c6 311c 	str.w	r3, [r6, #284]	; 0x11c
    S->batchSize = S->Fs_in_kHz * RESAMPLER_MAX_BATCH_SIZE_MS;
 8010e20:	f8c6 010c 	str.w	r0, [r6, #268]	; 0x10c
    S->Fs_out_kHz = silk_DIV32_16( Fs_Hz_out, 1000 );
 8010e24:	f8c6 2120 	str.w	r2, [r6, #288]	; 0x120
    if( Fs_Hz_out > Fs_Hz_in ) {
 8010e28:	da5e      	bge.n	8010ee8 <silk_resampler_init+0x188>
        /* Upsample */
        if( Fs_Hz_out == silk_MUL( Fs_Hz_in, 2 ) ) {                            /* Fs_out : Fs_in = 2 : 1 */
 8010e2a:	006a      	lsls	r2, r5, #1
 8010e2c:	42a2      	cmp	r2, r4
 8010e2e:	462b      	mov	r3, r5
 8010e30:	f000 8085 	beq.w	8010f3e <silk_resampler_init+0x1de>
            /* Special case: directly use 2x upsampler */
            S->resampler_function = USE_silk_resampler_private_up2_HQ_wrapper;
        } else {
            /* Default resampler */
            S->resampler_function = USE_silk_resampler_private_IIR_FIR;
 8010e34:	2102      	movs	r1, #2
 8010e36:	4615      	mov	r5, r2
 8010e38:	220f      	movs	r2, #15
 8010e3a:	f8c6 1108 	str.w	r1, [r6, #264]	; 0x108
        /* Input and output sampling rates are equal: copy */
        S->resampler_function = USE_silk_resampler_copy;
    }

    /* Ratio of input/output samples */
    S->invRatio_Q16 = silk_LSHIFT32( silk_DIV32( silk_LSHIFT32( Fs_Hz_in, 14 + up2x ), Fs_Hz_out ), 2 );
 8010e3e:	4093      	lsls	r3, r2
 8010e40:	fb93 f3f4 	sdiv	r3, r3, r4
 8010e44:	009b      	lsls	r3, r3, #2
  __asm__(
 8010e46:	fb83 1204 	smull	r1, r2, r3, r4
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 8010e4a:	0412      	lsls	r2, r2, #16
 8010e4c:	eb02 4211 	add.w	r2, r2, r1, lsr #16
    /* Make sure the ratio is rounded up */
    while( silk_SMULWW( S->invRatio_Q16, Fs_Hz_out ) < silk_LSHIFT32( Fs_Hz_in, up2x ) ) {
 8010e50:	42aa      	cmp	r2, r5
    S->invRatio_Q16 = silk_LSHIFT32( silk_DIV32( silk_LSHIFT32( Fs_Hz_in, 14 + up2x ), Fs_Hz_out ), 2 );
 8010e52:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
    while( silk_SMULWW( S->invRatio_Q16, Fs_Hz_out ) < silk_LSHIFT32( Fs_Hz_in, up2x ) ) {
 8010e56:	da0c      	bge.n	8010e72 <silk_resampler_init+0x112>
 8010e58:	3301      	adds	r3, #1
  __asm__(
 8010e5a:	fb83 2104 	smull	r2, r1, r3, r4
  return SAFE_SHL(rd_hi,16)+(rd_lo>>16);
 8010e5e:	0c12      	lsrs	r2, r2, #16
 8010e60:	eb02 4201 	add.w	r2, r2, r1, lsl #16
 8010e64:	42aa      	cmp	r2, r5
        S->invRatio_Q16++;
 8010e66:	4619      	mov	r1, r3
 8010e68:	f103 0301 	add.w	r3, r3, #1
    while( silk_SMULWW( S->invRatio_Q16, Fs_Hz_out ) < silk_LSHIFT32( Fs_Hz_in, up2x ) ) {
 8010e6c:	dbf5      	blt.n	8010e5a <silk_resampler_init+0xfa>
 8010e6e:	f8c6 1110 	str.w	r1, [r6, #272]	; 0x110
    }

    return 0;
 8010e72:	2000      	movs	r0, #0
}
 8010e74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if( ( Fs_Hz_in  != 8000 && Fs_Hz_in  != 12000 && Fs_Hz_in  != 16000 ) ||
 8010e76:	f5b5 5ffa 	cmp.w	r5, #8000	; 0x1f40
 8010e7a:	d006      	beq.n	8010e8a <silk_resampler_init+0x12a>
 8010e7c:	f642 63e0 	movw	r3, #12000	; 0x2ee0
 8010e80:	429d      	cmp	r5, r3
 8010e82:	d002      	beq.n	8010e8a <silk_resampler_init+0x12a>
 8010e84:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 8010e88:	d16e      	bne.n	8010f68 <silk_resampler_init+0x208>
 8010e8a:	f5b4 5ffa 	cmp.w	r4, #8000	; 0x1f40
 8010e8e:	d00e      	beq.n	8010eae <silk_resampler_init+0x14e>
            ( Fs_Hz_out != 8000 && Fs_Hz_out != 12000 && Fs_Hz_out != 16000 && Fs_Hz_out != 24000 && Fs_Hz_out != 48000 ) ) {
 8010e90:	f642 63e0 	movw	r3, #12000	; 0x2ee0
 8010e94:	429c      	cmp	r4, r3
 8010e96:	d00a      	beq.n	8010eae <silk_resampler_init+0x14e>
 8010e98:	f5b4 5f7a 	cmp.w	r4, #16000	; 0x3e80
 8010e9c:	d007      	beq.n	8010eae <silk_resampler_init+0x14e>
 8010e9e:	f645 53c0 	movw	r3, #24000	; 0x5dc0
 8010ea2:	429c      	cmp	r4, r3
 8010ea4:	d003      	beq.n	8010eae <silk_resampler_init+0x14e>
 8010ea6:	f64b 3380 	movw	r3, #48000	; 0xbb80
 8010eaa:	429c      	cmp	r4, r3
 8010eac:	d15c      	bne.n	8010f68 <silk_resampler_init+0x208>
        S->inputDelay = delay_matrix_dec[ rateID( Fs_Hz_in ) ][ rateID( Fs_Hz_out ) ];
 8010eae:	f645 52c0 	movw	r2, #24000	; 0x5dc0
 8010eb2:	f5b5 5f7a 	cmp.w	r5, #16000	; 0x3e80
 8010eb6:	bfd4      	ite	le
 8010eb8:	2300      	movle	r3, #0
 8010eba:	2301      	movgt	r3, #1
 8010ebc:	4295      	cmp	r5, r2
 8010ebe:	bfd4      	ite	le
 8010ec0:	2700      	movle	r7, #0
 8010ec2:	2701      	movgt	r7, #1
 8010ec4:	ebc3 3325 	rsb	r3, r3, r5, asr #12
 8010ec8:	f5b4 5f7a 	cmp.w	r4, #16000	; 0x3e80
 8010ecc:	fa43 f307 	asr.w	r3, r3, r7
 8010ed0:	bfd4      	ite	le
 8010ed2:	2100      	movle	r1, #0
 8010ed4:	2101      	movgt	r1, #1
 8010ed6:	3b01      	subs	r3, #1
 8010ed8:	4294      	cmp	r4, r2
 8010eda:	bfd4      	ite	le
 8010edc:	2000      	movle	r0, #0
 8010ede:	2001      	movgt	r0, #1
 8010ee0:	4a29      	ldr	r2, [pc, #164]	; (8010f88 <silk_resampler_init+0x228>)
 8010ee2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8010ee6:	e780      	b.n	8010dea <silk_resampler_init+0x8a>
    } else if ( Fs_Hz_out < Fs_Hz_in ) {
 8010ee8:	dd18      	ble.n	8010f1c <silk_resampler_init+0x1bc>
         S->resampler_function = USE_silk_resampler_private_down_FIR;
 8010eea:	2203      	movs	r2, #3
        if( silk_MUL( Fs_Hz_out, 4 ) == silk_MUL( Fs_Hz_in, 3 ) ) {             /* Fs_out : Fs_in = 3 : 4 */
 8010eec:	006b      	lsls	r3, r5, #1
 8010eee:	1958      	adds	r0, r3, r5
 8010ef0:	00a1      	lsls	r1, r4, #2
 8010ef2:	4281      	cmp	r1, r0
         S->resampler_function = USE_silk_resampler_private_down_FIR;
 8010ef4:	f8c6 2108 	str.w	r2, [r6, #264]	; 0x108
        if( silk_MUL( Fs_Hz_out, 4 ) == silk_MUL( Fs_Hz_in, 3 ) ) {             /* Fs_out : Fs_in = 3 : 4 */
 8010ef8:	d016      	beq.n	8010f28 <silk_resampler_init+0x1c8>
        } else if( silk_MUL( Fs_Hz_out, 3 ) == silk_MUL( Fs_Hz_in, 2 ) ) {      /* Fs_out : Fs_in = 2 : 3 */
 8010efa:	0062      	lsls	r2, r4, #1
 8010efc:	1910      	adds	r0, r2, r4
 8010efe:	4298      	cmp	r0, r3
 8010f00:	d022      	beq.n	8010f48 <silk_resampler_init+0x1e8>
        } else if( silk_MUL( Fs_Hz_out, 2 ) == Fs_Hz_in ) {                     /* Fs_out : Fs_in = 1 : 2 */
 8010f02:	42aa      	cmp	r2, r5
 8010f04:	d033      	beq.n	8010f6e <silk_resampler_init+0x20e>
        } else if( silk_MUL( Fs_Hz_out, 3 ) == Fs_Hz_in ) {                     /* Fs_out : Fs_in = 1 : 3 */
 8010f06:	42a8      	cmp	r0, r5
 8010f08:	d02a      	beq.n	8010f60 <silk_resampler_init+0x200>
        } else if( silk_MUL( Fs_Hz_out, 4 ) == Fs_Hz_in ) {                     /* Fs_out : Fs_in = 1 : 4 */
 8010f0a:	42a9      	cmp	r1, r5
 8010f0c:	d033      	beq.n	8010f76 <silk_resampler_init+0x216>
        } else if( silk_MUL( Fs_Hz_out, 6 ) == Fs_Hz_in ) {                     /* Fs_out : Fs_in = 1 : 6 */
 8010f0e:	ebb5 0f40 	cmp.w	r5, r0, lsl #1
 8010f12:	d129      	bne.n	8010f68 <silk_resampler_init+0x208>
            S->FIR_Fracs = 1;
 8010f14:	2101      	movs	r1, #1
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR2;
 8010f16:	2224      	movs	r2, #36	; 0x24
            S->Coefs = silk_Resampler_1_6_COEFS;
 8010f18:	4b1c      	ldr	r3, [pc, #112]	; (8010f8c <silk_resampler_init+0x22c>)
 8010f1a:	e018      	b.n	8010f4e <silk_resampler_init+0x1ee>
        S->resampler_function = USE_silk_resampler_copy;
 8010f1c:	2100      	movs	r1, #0
 8010f1e:	462b      	mov	r3, r5
 8010f20:	220e      	movs	r2, #14
 8010f22:	f8c6 1108 	str.w	r1, [r6, #264]	; 0x108
 8010f26:	e78a      	b.n	8010e3e <silk_resampler_init+0xde>
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR0;
 8010f28:	2112      	movs	r1, #18
            S->Coefs = silk_Resampler_3_4_COEFS;
 8010f2a:	4b19      	ldr	r3, [pc, #100]	; (8010f90 <silk_resampler_init+0x230>)
            S->FIR_Fracs = 3;
 8010f2c:	f8c6 2118 	str.w	r2, [r6, #280]	; 0x118
            S->Coefs = silk_Resampler_3_4_COEFS;
 8010f30:	f8c6 3128 	str.w	r3, [r6, #296]	; 0x128
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR0;
 8010f34:	f8c6 1114 	str.w	r1, [r6, #276]	; 0x114
 8010f38:	462b      	mov	r3, r5
 8010f3a:	220e      	movs	r2, #14
 8010f3c:	e77f      	b.n	8010e3e <silk_resampler_init+0xde>
            S->resampler_function = USE_silk_resampler_private_up2_HQ_wrapper;
 8010f3e:	2201      	movs	r2, #1
 8010f40:	f8c6 2108 	str.w	r2, [r6, #264]	; 0x108
 8010f44:	220e      	movs	r2, #14
 8010f46:	e77a      	b.n	8010e3e <silk_resampler_init+0xde>
            S->FIR_Fracs = 2;
 8010f48:	2102      	movs	r1, #2
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR0;
 8010f4a:	2212      	movs	r2, #18
            S->Coefs = silk_Resampler_2_3_COEFS;
 8010f4c:	4b11      	ldr	r3, [pc, #68]	; (8010f94 <silk_resampler_init+0x234>)
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR2;
 8010f4e:	f8c6 2114 	str.w	r2, [r6, #276]	; 0x114
            S->Coefs = silk_Resampler_1_4_COEFS;
 8010f52:	f8c6 3128 	str.w	r3, [r6, #296]	; 0x128
            S->FIR_Fracs = 1;
 8010f56:	f8c6 1118 	str.w	r1, [r6, #280]	; 0x118
 8010f5a:	462b      	mov	r3, r5
 8010f5c:	220e      	movs	r2, #14
 8010f5e:	e76e      	b.n	8010e3e <silk_resampler_init+0xde>
            S->FIR_Fracs = 1;
 8010f60:	2101      	movs	r1, #1
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR2;
 8010f62:	2224      	movs	r2, #36	; 0x24
            S->Coefs = silk_Resampler_1_3_COEFS;
 8010f64:	4b0c      	ldr	r3, [pc, #48]	; (8010f98 <silk_resampler_init+0x238>)
 8010f66:	e7f2      	b.n	8010f4e <silk_resampler_init+0x1ee>
            return -1;
 8010f68:	f04f 30ff 	mov.w	r0, #4294967295
}
 8010f6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            S->FIR_Fracs = 1;
 8010f6e:	2101      	movs	r1, #1
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR1;
 8010f70:	2218      	movs	r2, #24
            S->Coefs = silk_Resampler_1_2_COEFS;
 8010f72:	4b0a      	ldr	r3, [pc, #40]	; (8010f9c <silk_resampler_init+0x23c>)
 8010f74:	e7eb      	b.n	8010f4e <silk_resampler_init+0x1ee>
            S->FIR_Fracs = 1;
 8010f76:	2101      	movs	r1, #1
            S->FIR_Order = RESAMPLER_DOWN_ORDER_FIR2;
 8010f78:	2224      	movs	r2, #36	; 0x24
            S->Coefs = silk_Resampler_1_4_COEFS;
 8010f7a:	4b09      	ldr	r3, [pc, #36]	; (8010fa0 <silk_resampler_init+0x240>)
 8010f7c:	e7e7      	b.n	8010f4e <silk_resampler_init+0x1ee>
 8010f7e:	bf00      	nop
 8010f80:	08016970 	.word	0x08016970
 8010f84:	10624dd3 	.word	0x10624dd3
 8010f88:	08016960 	.word	0x08016960
 8010f8c:	080169ec 	.word	0x080169ec
 8010f90:	08016a3c 	.word	0x08016a3c
 8010f94:	08016a14 	.word	0x08016a14
 8010f98:	0801699c 	.word	0x0801699c
 8010f9c:	08016980 	.word	0x08016980
 8010fa0:	080169c4 	.word	0x080169c4

08010fa4 <silk_resampler>:
    silk_resampler_state_struct *S,                 /* I/O  Resampler state                                             */
    opus_int16                  out[],              /* O    Output signal                                               */
    const opus_int16            in[],               /* I    Input signal                                                */
    opus_int32                  inLen               /* I    Number of input samples                                     */
)
{
 8010fa4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010fa8:	4604      	mov	r4, r0
 8010faa:	4617      	mov	r7, r2
    /* Need at least 1 ms of input data */
    celt_assert( inLen >= S->Fs_in_kHz );
    /* Delay can't exceed the 1 ms of buffering */
    celt_assert( S->inputDelay <= S->Fs_in_kHz );

    nSamples = S->Fs_in_kHz - S->inputDelay;
 8010fac:	f8d0 511c 	ldr.w	r5, [r0, #284]	; 0x11c
 8010fb0:	f8d0 2124 	ldr.w	r2, [r0, #292]	; 0x124
{
 8010fb4:	4689      	mov	r9, r1
    nSamples = S->Fs_in_kHz - S->inputDelay;
 8010fb6:	1aad      	subs	r5, r5, r2

    /* Copy to delay buffer */
    silk_memcpy( &S->delayBuf[ S->inputDelay ], in, nSamples * sizeof( opus_int16 ) );
 8010fb8:	f102 0054 	add.w	r0, r2, #84	; 0x54
 8010fbc:	006d      	lsls	r5, r5, #1
 8010fbe:	462a      	mov	r2, r5
 8010fc0:	eb04 0040 	add.w	r0, r4, r0, lsl #1
 8010fc4:	4639      	mov	r1, r7
{
 8010fc6:	461e      	mov	r6, r3
    silk_memcpy( &S->delayBuf[ S->inputDelay ], in, nSamples * sizeof( opus_int16 ) );
 8010fc8:	f003 f88a 	bl	80140e0 <memcpy>

    switch( S->resampler_function ) {
 8010fcc:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
 8010fd0:	443d      	add	r5, r7
 8010fd2:	2b02      	cmp	r3, #2
 8010fd4:	f104 08a8 	add.w	r8, r4, #168	; 0xa8
 8010fd8:	d047      	beq.n	801106a <silk_resampler+0xc6>
 8010fda:	2b03      	cmp	r3, #3
 8010fdc:	d032      	beq.n	8011044 <silk_resampler+0xa0>
 8010fde:	2b01      	cmp	r3, #1
 8010fe0:	d01d      	beq.n	801101e <silk_resampler+0x7a>
        case USE_silk_resampler_private_down_FIR:
            silk_resampler_private_down_FIR( S, out, S->delayBuf, S->Fs_in_kHz );
            silk_resampler_private_down_FIR( S, &out[ S->Fs_out_kHz ], &in[ nSamples ], inLen - S->Fs_in_kHz );
            break;
        default:
            silk_memcpy( out, S->delayBuf, S->Fs_in_kHz * sizeof( opus_int16 ) );
 8010fe2:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
 8010fe6:	4641      	mov	r1, r8
 8010fe8:	0052      	lsls	r2, r2, #1
 8010fea:	4648      	mov	r0, r9
 8010fec:	f003 f878 	bl	80140e0 <memcpy>
            silk_memcpy( &out[ S->Fs_out_kHz ], &in[ nSamples ], ( inLen - S->Fs_in_kHz ) * sizeof( opus_int16 ) );
 8010ff0:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
 8010ff4:	f8d4 0120 	ldr.w	r0, [r4, #288]	; 0x120
 8010ff8:	1ab2      	subs	r2, r6, r2
 8010ffa:	4629      	mov	r1, r5
 8010ffc:	0052      	lsls	r2, r2, #1
 8010ffe:	eb09 0040 	add.w	r0, r9, r0, lsl #1
 8011002:	f003 f86d 	bl	80140e0 <memcpy>
    }

    /* Copy to delay buffer */
    silk_memcpy( S->delayBuf, &in[ inLen - S->inputDelay ], S->inputDelay * sizeof( opus_int16 ) );
 8011006:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
 801100a:	4640      	mov	r0, r8
 801100c:	1ab1      	subs	r1, r6, r2
 801100e:	eb07 0141 	add.w	r1, r7, r1, lsl #1
 8011012:	0052      	lsls	r2, r2, #1
 8011014:	f003 f864 	bl	80140e0 <memcpy>

    return 0;
}
 8011018:	2000      	movs	r0, #0
 801101a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            silk_resampler_private_up2_HQ_wrapper( S, out, S->delayBuf, S->Fs_in_kHz );
 801101e:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 8011022:	4642      	mov	r2, r8
 8011024:	4649      	mov	r1, r9
 8011026:	4620      	mov	r0, r4
 8011028:	f000 fc48 	bl	80118bc <silk_resampler_private_up2_HQ_wrapper>
            silk_resampler_private_up2_HQ_wrapper( S, &out[ S->Fs_out_kHz ], &in[ nSamples ], inLen - S->Fs_in_kHz );
 801102c:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 8011030:	f8d4 1120 	ldr.w	r1, [r4, #288]	; 0x120
 8011034:	462a      	mov	r2, r5
 8011036:	1af3      	subs	r3, r6, r3
 8011038:	eb09 0141 	add.w	r1, r9, r1, lsl #1
 801103c:	4620      	mov	r0, r4
 801103e:	f000 fc3d 	bl	80118bc <silk_resampler_private_up2_HQ_wrapper>
            break;
 8011042:	e7e0      	b.n	8011006 <silk_resampler+0x62>
            silk_resampler_private_down_FIR( S, out, S->delayBuf, S->Fs_in_kHz );
 8011044:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 8011048:	4642      	mov	r2, r8
 801104a:	4649      	mov	r1, r9
 801104c:	4620      	mov	r0, r4
 801104e:	f000 f8f7 	bl	8011240 <silk_resampler_private_down_FIR>
            silk_resampler_private_down_FIR( S, &out[ S->Fs_out_kHz ], &in[ nSamples ], inLen - S->Fs_in_kHz );
 8011052:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 8011056:	f8d4 1120 	ldr.w	r1, [r4, #288]	; 0x120
 801105a:	462a      	mov	r2, r5
 801105c:	1af3      	subs	r3, r6, r3
 801105e:	eb09 0141 	add.w	r1, r9, r1, lsl #1
 8011062:	4620      	mov	r0, r4
 8011064:	f000 f8ec 	bl	8011240 <silk_resampler_private_down_FIR>
            break;
 8011068:	e7cd      	b.n	8011006 <silk_resampler+0x62>
            silk_resampler_private_IIR_FIR( S, out, S->delayBuf, S->Fs_in_kHz );
 801106a:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 801106e:	4642      	mov	r2, r8
 8011070:	4649      	mov	r1, r9
 8011072:	4620      	mov	r0, r4
 8011074:	f000 f82e 	bl	80110d4 <silk_resampler_private_IIR_FIR>
            silk_resampler_private_IIR_FIR( S, &out[ S->Fs_out_kHz ], &in[ nSamples ], inLen - S->Fs_in_kHz );
 8011078:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 801107c:	f8d4 1120 	ldr.w	r1, [r4, #288]	; 0x120
 8011080:	462a      	mov	r2, r5
 8011082:	1af3      	subs	r3, r6, r3
 8011084:	eb09 0141 	add.w	r1, r9, r1, lsl #1
 8011088:	4620      	mov	r0, r4
 801108a:	f000 f823 	bl	80110d4 <silk_resampler_private_IIR_FIR>
            break;
 801108e:	e7ba      	b.n	8011006 <silk_resampler+0x62>

08011090 <silk_resampler_private_AR2>:
    opus_int32                      out_Q8[],       /* O    Output signal               */
    const opus_int16                in[],           /* I    Input signal                */
    const opus_int16                A_Q14[],        /* I    AR coefficients, Q14        */
    opus_int32                      len             /* I    Signal length               */
)
{
 8011090:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011092:	9d05      	ldr	r5, [sp, #20]
    opus_int32    k;
    opus_int32    out32;

    for( k = 0; k < len; k++ ) {
 8011094:	2d00      	cmp	r5, #0
 8011096:	dd1b      	ble.n	80110d0 <silk_resampler_private_AR2+0x40>
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011098:	f9b3 7000 	ldrsh.w	r7, [r3]
 801109c:	f9b3 6002 	ldrsh.w	r6, [r3, #2]
 80110a0:	3a02      	subs	r2, #2
 80110a2:	6804      	ldr	r4, [r0, #0]
 80110a4:	eb02 0c45 	add.w	ip, r2, r5, lsl #1
 80110a8:	3904      	subs	r1, #4
 80110aa:	043f      	lsls	r7, r7, #16
 80110ac:	0436      	lsls	r6, r6, #16
        out32       = silk_ADD_LSHIFT32( S[ 0 ], (opus_int32)in[ k ], 8 );
 80110ae:	f932 3f02 	ldrsh.w	r3, [r2, #2]!
 80110b2:	eb04 2303 	add.w	r3, r4, r3, lsl #8
        out_Q8[ k ] = out32;
 80110b6:	f841 3f04 	str.w	r3, [r1, #4]!
        out32       = silk_LSHIFT( out32, 2 );
        S[ 0 ]      = silk_SMLAWB( S[ 1 ], out32, A_Q14[ 0 ] );
 80110ba:	6845      	ldr	r5, [r0, #4]
        out32       = silk_LSHIFT( out32, 2 );
 80110bc:	009b      	lsls	r3, r3, #2
    for( k = 0; k < len; k++ ) {
 80110be:	4594      	cmp	ip, r2
  __asm__(
 80110c0:	fb83 e407 	smull	lr, r4, r3, r7
        S[ 0 ]      = silk_SMLAWB( S[ 1 ], out32, A_Q14[ 0 ] );
 80110c4:	442c      	add	r4, r5
 80110c6:	6004      	str	r4, [r0, #0]
 80110c8:	fb83 e506 	smull	lr, r5, r3, r6
        S[ 1 ]      = silk_SMULWB( out32, A_Q14[ 1 ] );
 80110cc:	6045      	str	r5, [r0, #4]
    for( k = 0; k < len; k++ ) {
 80110ce:	d1ee      	bne.n	80110ae <silk_resampler_private_AR2+0x1e>
    }
}
 80110d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80110d2:	bf00      	nop

080110d4 <silk_resampler_private_IIR_FIR>:
    void                            *SS,            /* I/O  Resampler state             */
    opus_int16                      out[],          /* O    Output signal               */
    const opus_int16                in[],           /* I    Input signal                */
    opus_int32                      inLen           /* I    Number of input samples     */
)
{
 80110d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80110d8:	b089      	sub	sp, #36	; 0x24
 80110da:	4604      	mov	r4, r0
    opus_int32 nSamplesIn;
    opus_int32 max_index_Q16, index_increment_Q16;
    VARDECL( opus_int16, buf );
    SAVE_STACK;

    ALLOC( buf, 2 * S->batchSize + RESAMPLER_ORDER_FIR_12, opus_int16 );
 80110dc:	f8d0 610c 	ldr.w	r6, [r0, #268]	; 0x10c
{
 80110e0:	af00      	add	r7, sp, #0
 80110e2:	6178      	str	r0, [r7, #20]
 80110e4:	e9c7 3206 	strd	r3, r2, [r7, #24]
    ALLOC( buf, 2 * S->batchSize + RESAMPLER_ORDER_FIR_12, opus_int16 );
 80110e8:	00b0      	lsls	r0, r6, #2

    /* Copy buffered samples to start of buffer */
    silk_memcpy( buf, S->sFIR.i16, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
 80110ea:	4623      	mov	r3, r4
    ALLOC( buf, 2 * S->batchSize + RESAMPLER_ORDER_FIR_12, opus_int16 );
 80110ec:	3018      	adds	r0, #24
 80110ee:	f020 0007 	bic.w	r0, r0, #7
 80110f2:	ebad 0d00 	sub.w	sp, sp, r0
 80110f6:	466d      	mov	r5, sp
    silk_memcpy( buf, S->sFIR.i16, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
 80110f8:	f853 0f18 	ldr.w	r0, [r3, #24]!

    /* Iterate over blocks of frameSizeIn input samples */
    index_increment_Q16 = S->invRatio_Q16;
 80110fc:	f8d4 2110 	ldr.w	r2, [r4, #272]	; 0x110
{
 8011100:	4688      	mov	r8, r1
    silk_memcpy( buf, S->sFIR.i16, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
 8011102:	607b      	str	r3, [r7, #4]
 8011104:	6859      	ldr	r1, [r3, #4]
    index_increment_Q16 = S->invRatio_Q16;
 8011106:	60ba      	str	r2, [r7, #8]
    silk_memcpy( buf, S->sFIR.i16, RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
 8011108:	689a      	ldr	r2, [r3, #8]
 801110a:	68db      	ldr	r3, [r3, #12]
 801110c:	6069      	str	r1, [r5, #4]
 801110e:	60eb      	str	r3, [r5, #12]
 8011110:	f105 0310 	add.w	r3, r5, #16
 8011114:	4619      	mov	r1, r3
 8011116:	6028      	str	r0, [r5, #0]
 8011118:	4c47      	ldr	r4, [pc, #284]	; (8011238 <silk_resampler_private_IIR_FIR+0x164>)
 801111a:	6978      	ldr	r0, [r7, #20]
 801111c:	60aa      	str	r2, [r5, #8]
 801111e:	60fb      	str	r3, [r7, #12]
    while( 1 ) {
        nSamplesIn = silk_min( inLen, S->batchSize );
 8011120:	69bb      	ldr	r3, [r7, #24]

        /* Upsample 2x */
        silk_resampler_private_up2_HQ( S->sIIR, &buf[ RESAMPLER_ORDER_FIR_12 ], in, nSamplesIn );
 8011122:	69fa      	ldr	r2, [r7, #28]
        nSamplesIn = silk_min( inLen, S->batchSize );
 8011124:	429e      	cmp	r6, r3
 8011126:	bfa8      	it	ge
 8011128:	461e      	movge	r6, r3
        silk_resampler_private_up2_HQ( S->sIIR, &buf[ RESAMPLER_ORDER_FIR_12 ], in, nSamplesIn );
 801112a:	4633      	mov	r3, r6

        max_index_Q16 = silk_LSHIFT32( nSamplesIn, 16 + 1 );         /* + 1 because 2x upsampling */
 801112c:	ea4f 4a46 	mov.w	sl, r6, lsl #17
        silk_resampler_private_up2_HQ( S->sIIR, &buf[ RESAMPLER_ORDER_FIR_12 ], in, nSamplesIn );
 8011130:	f000 fb2c 	bl	801178c <silk_resampler_private_up2_HQ>
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 8011134:	f1ba 0f00 	cmp.w	sl, #0
 8011138:	dd58      	ble.n	80111ec <silk_resampler_private_IIR_FIR+0x118>
 801113a:	613e      	str	r6, [r7, #16]
 801113c:	f04f 0e00 	mov.w	lr, #0
 8011140:	f44f 2940 	mov.w	r9, #786432	; 0xc0000
 8011144:	68be      	ldr	r6, [r7, #8]
 8011146:	e008      	b.n	801115a <silk_resampler_private_IIR_FIR+0x86>
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
 8011148:	f511 4f00 	cmn.w	r1, #32768	; 0x8000
 801114c:	db67      	blt.n	801121e <silk_resampler_private_IIR_FIR+0x14a>
 801114e:	b209      	sxth	r1, r1
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 8011150:	44b6      	add	lr, r6
 8011152:	45f2      	cmp	sl, lr
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
 8011154:	f828 1b02 	strh.w	r1, [r8], #2
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 8011158:	dd47      	ble.n	80111ea <silk_resampler_private_IIR_FIR+0x116>
        buf_ptr = &buf[ index_Q16 >> 16 ];
 801115a:	ea4f 432e 	mov.w	r3, lr, asr #16
 801115e:	eb05 0243 	add.w	r2, r5, r3, lsl #1
        table_index = silk_SMULWB( index_Q16 & 0xFFFF, 12 );
 8011162:	fa1f f08e 	uxth.w	r0, lr
 8011166:	fb80 c109 	smull	ip, r1, r0, r9
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 1 ], silk_resampler_frac_FIR_12[      table_index ][ 1 ] );
 801116a:	eb04 00c1 	add.w	r0, r4, r1, lsl #3
 801116e:	f8b0 b002 	ldrh.w	fp, [r0, #2]
 8011172:	f8b2 c002 	ldrh.w	ip, [r2, #2]
 8011176:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
 801117a:	fb1c fc0b 	smulbb	ip, ip, fp
 801117e:	f834 b031 	ldrh.w	fp, [r4, r1, lsl #3]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 4 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 3 ] );
 8011182:	f1c1 010b 	rsb	r1, r1, #11
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 1 ], silk_resampler_frac_FIR_12[      table_index ][ 1 ] );
 8011186:	fb13 c30b 	smlabb	r3, r3, fp, ip
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 2 ], silk_resampler_frac_FIR_12[      table_index ][ 2 ] );
 801118a:	f8b0 b004 	ldrh.w	fp, [r0, #4]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 3 ], silk_resampler_frac_FIR_12[      table_index ][ 3 ] );
 801118e:	f8b0 c006 	ldrh.w	ip, [r0, #6]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 2 ], silk_resampler_frac_FIR_12[      table_index ][ 2 ] );
 8011192:	8890      	ldrh	r0, [r2, #4]
 8011194:	fb10 330b 	smlabb	r3, r0, fp, r3
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 3 ], silk_resampler_frac_FIR_12[      table_index ][ 3 ] );
 8011198:	f8b2 b006 	ldrh.w	fp, [r2, #6]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 4 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 3 ] );
 801119c:	eb04 00c1 	add.w	r0, r4, r1, lsl #3
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 3 ], silk_resampler_frac_FIR_12[      table_index ][ 3 ] );
 80111a0:	fb1b 330c 	smlabb	r3, fp, ip, r3
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 4 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 3 ] );
 80111a4:	f8b0 c006 	ldrh.w	ip, [r0, #6]
 80111a8:	f8b2 b008 	ldrh.w	fp, [r2, #8]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 7 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 0 ] );
 80111ac:	f834 1031 	ldrh.w	r1, [r4, r1, lsl #3]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 4 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 3 ] );
 80111b0:	fb1b 330c 	smlabb	r3, fp, ip, r3
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 5 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 2 ] );
 80111b4:	f8b0 c004 	ldrh.w	ip, [r0, #4]
 80111b8:	f8b2 b00a 	ldrh.w	fp, [r2, #10]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 6 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 1 ] );
 80111bc:	8840      	ldrh	r0, [r0, #2]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 5 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 2 ] );
 80111be:	fb1b 330c 	smlabb	r3, fp, ip, r3
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 6 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 1 ] );
 80111c2:	f8b2 c00c 	ldrh.w	ip, [r2, #12]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 7 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 0 ] );
 80111c6:	89d2      	ldrh	r2, [r2, #14]
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 6 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 1 ] );
 80111c8:	fb1c 3c00 	smlabb	ip, ip, r0, r3
        res_Q15 = silk_SMLABB( res_Q15, buf_ptr[ 7 ], silk_resampler_frac_FIR_12[ 11 - table_index ][ 0 ] );
 80111cc:	fb12 c101 	smlabb	r1, r2, r1, ip
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
 80111d0:	1389      	asrs	r1, r1, #14
 80111d2:	3101      	adds	r1, #1
 80111d4:	1049      	asrs	r1, r1, #1
 80111d6:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80111da:	dbb5      	blt.n	8011148 <silk_resampler_private_IIR_FIR+0x74>
 80111dc:	f647 71ff 	movw	r1, #32767	; 0x7fff
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 80111e0:	44b6      	add	lr, r6
 80111e2:	45f2      	cmp	sl, lr
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
 80111e4:	f828 1b02 	strh.w	r1, [r8], #2
    for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 80111e8:	dcb7      	bgt.n	801115a <silk_resampler_private_IIR_FIR+0x86>
 80111ea:	693e      	ldr	r6, [r7, #16]
        out = silk_resampler_private_IIR_FIR_INTERPOL( out, buf, max_index_Q16, index_increment_Q16 );
        in += nSamplesIn;
        inLen -= nSamplesIn;
 80111ec:	69bb      	ldr	r3, [r7, #24]
        in += nSamplesIn;
 80111ee:	69fa      	ldr	r2, [r7, #28]
        inLen -= nSamplesIn;
 80111f0:	1b9b      	subs	r3, r3, r6
        in += nSamplesIn;
 80111f2:	eb02 0246 	add.w	r2, r2, r6, lsl #1

        if( inLen > 0 ) {
 80111f6:	2b00      	cmp	r3, #0
 80111f8:	eb05 0686 	add.w	r6, r5, r6, lsl #2
        inLen -= nSamplesIn;
 80111fc:	61bb      	str	r3, [r7, #24]
        in += nSamplesIn;
 80111fe:	61fa      	str	r2, [r7, #28]
            /* More iterations to do; copy last part of filtered signal to beginning of buffer */
            silk_memcpy( buf, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
 8011200:	6830      	ldr	r0, [r6, #0]
 8011202:	6871      	ldr	r1, [r6, #4]
 8011204:	68b2      	ldr	r2, [r6, #8]
 8011206:	68f3      	ldr	r3, [r6, #12]
        if( inLen > 0 ) {
 8011208:	dd0b      	ble.n	8011222 <silk_resampler_private_IIR_FIR+0x14e>
            silk_memcpy( buf, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
 801120a:	60eb      	str	r3, [r5, #12]
 801120c:	697b      	ldr	r3, [r7, #20]
 801120e:	6028      	str	r0, [r5, #0]
 8011210:	6069      	str	r1, [r5, #4]
 8011212:	60aa      	str	r2, [r5, #8]
 8011214:	f8d3 610c 	ldr.w	r6, [r3, #268]	; 0x10c
 8011218:	68f9      	ldr	r1, [r7, #12]
 801121a:	4618      	mov	r0, r3
        nSamplesIn = silk_min( inLen, S->batchSize );
 801121c:	e780      	b.n	8011120 <silk_resampler_private_IIR_FIR+0x4c>
        *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q15, 15 ) );
 801121e:	4907      	ldr	r1, [pc, #28]	; (801123c <silk_resampler_private_IIR_FIR+0x168>)
 8011220:	e796      	b.n	8011150 <silk_resampler_private_IIR_FIR+0x7c>
            break;
        }
    }

    /* Copy last part of filtered signal to the state for the next call */
    silk_memcpy( S->sFIR.i16, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
 8011222:	697c      	ldr	r4, [r7, #20]
 8011224:	61a0      	str	r0, [r4, #24]
 8011226:	6878      	ldr	r0, [r7, #4]
    RESTORE_STACK;
}
 8011228:	3724      	adds	r7, #36	; 0x24
    silk_memcpy( S->sFIR.i16, &buf[ nSamplesIn << 1 ], RESAMPLER_ORDER_FIR_12 * sizeof( opus_int16 ) );
 801122a:	6041      	str	r1, [r0, #4]
 801122c:	6082      	str	r2, [r0, #8]
 801122e:	60c3      	str	r3, [r0, #12]
}
 8011230:	46bd      	mov	sp, r7
 8011232:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011236:	bf00      	nop
 8011238:	08016a78 	.word	0x08016a78
 801123c:	ffff8000 	.word	0xffff8000

08011240 <silk_resampler_private_down_FIR>:
    void                            *SS,            /* I/O  Resampler state             */
    opus_int16                      out[],          /* O    Output signal               */
    const opus_int16                in[],           /* I    Input signal                */
    opus_int32                      inLen           /* I    Number of input samples     */
)
{
 8011240:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011244:	b091      	sub	sp, #68	; 0x44
 8011246:	4606      	mov	r6, r0
 8011248:	af02      	add	r7, sp, #8
    opus_int32 max_index_Q16, index_increment_Q16;
    VARDECL( opus_int32, buf );
    const opus_int16 *FIR_Coefs;
    SAVE_STACK;

    ALLOC( buf, S->batchSize + S->FIR_Order, opus_int32 );
 801124a:	f8d0 510c 	ldr.w	r5, [r0, #268]	; 0x10c
 801124e:	f8d0 4114 	ldr.w	r4, [r0, #276]	; 0x114
{
 8011252:	6278      	str	r0, [r7, #36]	; 0x24

    /* Copy buffered samples to start of buffer */
    silk_memcpy( buf, S->sFIR.i32, S->FIR_Order * sizeof( opus_int32 ) );
 8011254:	3018      	adds	r0, #24
 8011256:	60f8      	str	r0, [r7, #12]
    ALLOC( buf, S->batchSize + S->FIR_Order, opus_int32 );
 8011258:	1928      	adds	r0, r5, r4
 801125a:	0080      	lsls	r0, r0, #2
 801125c:	300a      	adds	r0, #10
 801125e:	f020 0007 	bic.w	r0, r0, #7
 8011262:	ebad 0d00 	sub.w	sp, sp, r0
    silk_memcpy( buf, S->sFIR.i32, S->FIR_Order * sizeof( opus_int32 ) );
 8011266:	00a4      	lsls	r4, r4, #2
    ALLOC( buf, S->batchSize + S->FIR_Order, opus_int32 );
 8011268:	f10d 0b08 	add.w	fp, sp, #8
{
 801126c:	633a      	str	r2, [r7, #48]	; 0x30
 801126e:	4688      	mov	r8, r1
    silk_memcpy( buf, S->sFIR.i32, S->FIR_Order * sizeof( opus_int32 ) );
 8011270:	4622      	mov	r2, r4
 8011272:	68f9      	ldr	r1, [r7, #12]
 8011274:	4658      	mov	r0, fp
{
 8011276:	62fb      	str	r3, [r7, #44]	; 0x2c
    silk_memcpy( buf, S->sFIR.i32, S->FIR_Order * sizeof( opus_int32 ) );
 8011278:	f002 ff32 	bl	80140e0 <memcpy>

    FIR_Coefs = &S->Coefs[ 2 ];
 801127c:	4633      	mov	r3, r6
 801127e:	f8d6 6128 	ldr.w	r6, [r6, #296]	; 0x128

    /* Iterate over blocks of frameSizeIn input samples */
    index_increment_Q16 = S->invRatio_Q16;
 8011282:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
    FIR_Coefs = &S->Coefs[ 2 ];
 8011286:	1d32      	adds	r2, r6, #4
    index_increment_Q16 = S->invRatio_Q16;
 8011288:	61bb      	str	r3, [r7, #24]
    FIR_Coefs = &S->Coefs[ 2 ];
 801128a:	607a      	str	r2, [r7, #4]
 801128c:	4633      	mov	r3, r6
 801128e:	4629      	mov	r1, r5
 8011290:	e01f      	b.n	80112d2 <silk_resampler_private_down_FIR+0x92>
    switch( FIR_Order ) {
 8011292:	2b24      	cmp	r3, #36	; 0x24
 8011294:	f000 8191 	beq.w	80115ba <silk_resampler_private_down_FIR+0x37a>
 8011298:	2b12      	cmp	r3, #18
 801129a:	f000 80c8 	beq.w	801142e <silk_resampler_private_down_FIR+0x1ee>
        /* Interpolate filtered signal */
        out = silk_resampler_private_down_FIR_INTERPOL( out, buf, FIR_Coefs, S->FIR_Order,
            S->FIR_Fracs, max_index_Q16, index_increment_Q16 );

        in += nSamplesIn;
        inLen -= nSamplesIn;
 801129e:	6a3b      	ldr	r3, [r7, #32]
 80112a0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80112a2:	1ad0      	subs	r0, r2, r3
        in += nSamplesIn;
 80112a4:	6b3a      	ldr	r2, [r7, #48]	; 0x30

        if( inLen > 1 ) {
 80112a6:	2801      	cmp	r0, #1
        in += nSamplesIn;
 80112a8:	4611      	mov	r1, r2
 80112aa:	eb01 0243 	add.w	r2, r1, r3, lsl #1
 80112ae:	eb0b 0183 	add.w	r1, fp, r3, lsl #2
 80112b2:	69fb      	ldr	r3, [r7, #28]
 80112b4:	633a      	str	r2, [r7, #48]	; 0x30
 80112b6:	ea4f 0483 	mov.w	r4, r3, lsl #2
        inLen -= nSamplesIn;
 80112ba:	62f8      	str	r0, [r7, #44]	; 0x2c
            /* More iterations to do; copy last part of filtered signal to beginning of buffer */
            silk_memcpy( buf, &buf[ nSamplesIn ], S->FIR_Order * sizeof( opus_int32 ) );
 80112bc:	4622      	mov	r2, r4
        if( inLen > 1 ) {
 80112be:	f340 825c 	ble.w	801177a <silk_resampler_private_down_FIR+0x53a>
            silk_memcpy( buf, &buf[ nSamplesIn ], S->FIR_Order * sizeof( opus_int32 ) );
 80112c2:	4658      	mov	r0, fp
 80112c4:	f002 ff0c 	bl	80140e0 <memcpy>
 80112c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80112ca:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80112ce:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
        nSamplesIn = silk_min( inLen, S->batchSize );
 80112d2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80112d4:	460d      	mov	r5, r1
 80112d6:	4291      	cmp	r1, r2
 80112d8:	bfa8      	it	ge
 80112da:	4615      	movge	r5, r2
        silk_resampler_private_AR2( S->sIIR, &buf[ S->FIR_Order ], in, S->Coefs, nSamplesIn );
 80112dc:	eb0b 0104 	add.w	r1, fp, r4
 80112e0:	6a7c      	ldr	r4, [r7, #36]	; 0x24
 80112e2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80112e4:	9500      	str	r5, [sp, #0]
 80112e6:	4620      	mov	r0, r4
        nSamplesIn = silk_min( inLen, S->batchSize );
 80112e8:	623d      	str	r5, [r7, #32]
        silk_resampler_private_AR2( S->sIIR, &buf[ S->FIR_Order ], in, S->Coefs, nSamplesIn );
 80112ea:	f7ff fed1 	bl	8011090 <silk_resampler_private_AR2>
        out = silk_resampler_private_down_FIR_INTERPOL( out, buf, FIR_Coefs, S->FIR_Order,
 80112ee:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
        max_index_Q16 = silk_LSHIFT32( nSamplesIn, 16 );
 80112f2:	042a      	lsls	r2, r5, #16
    switch( FIR_Order ) {
 80112f4:	2b18      	cmp	r3, #24
        out = silk_resampler_private_down_FIR_INTERPOL( out, buf, FIR_Coefs, S->FIR_Order,
 80112f6:	61fb      	str	r3, [r7, #28]
        max_index_Q16 = silk_LSHIFT32( nSamplesIn, 16 );
 80112f8:	637a      	str	r2, [r7, #52]	; 0x34
    switch( FIR_Order ) {
 80112fa:	d1ca      	bne.n	8011292 <silk_resampler_private_down_FIR+0x52>
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 80112fc:	2a00      	cmp	r2, #0
 80112fe:	ddce      	ble.n	801129e <silk_resampler_private_down_FIR+0x5e>
 8011300:	2400      	movs	r4, #0
 8011302:	69b8      	ldr	r0, [r7, #24]
 8011304:	e00a      	b.n	801131c <silk_resampler_private_down_FIR+0xdc>
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
 8011306:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 801130a:	f2c0 808e 	blt.w	801142a <silk_resampler_private_down_FIR+0x1ea>
 801130e:	b21b      	sxth	r3, r3
 8011310:	f828 3b02 	strh.w	r3, [r8], #2
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 8011314:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011316:	4404      	add	r4, r0
 8011318:	42a3      	cmp	r3, r4
 801131a:	ddc0      	ble.n	801129e <silk_resampler_private_down_FIR+0x5e>
                buf_ptr = buf + silk_RSHIFT( index_Q16, 16 );
 801131c:	1422      	asrs	r2, r4, #16
 801131e:	eb0b 0382 	add.w	r3, fp, r2, lsl #2
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 23 ] ), FIR_Coefs[  0 ] );
 8011322:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8011324:	f85b 2022 	ldr.w	r2, [fp, r2, lsl #2]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
 8011328:	685d      	ldr	r5, [r3, #4]
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 23 ] ), FIR_Coefs[  0 ] );
 801132a:	eb02 0901 	add.w	r9, r2, r1
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801132e:	f9b6 a004 	ldrsh.w	sl, [r6, #4]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
 8011332:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8011334:	f9b6 e006 	ldrsh.w	lr, [r6, #6]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 21 ] ), FIR_Coefs[  2 ] );
 8011338:	6899      	ldr	r1, [r3, #8]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
 801133a:	442a      	add	r2, r5
 801133c:	ea4f 4a0a 	mov.w	sl, sl, lsl #16
 8011340:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 8011344:	fb89 5c0a 	smull	r5, ip, r9, sl
 8011348:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 21 ] ), FIR_Coefs[  2 ] );
 801134c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801134e:	f9b6 e008 	ldrsh.w	lr, [r6, #8]
 8011352:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 22 ] ), FIR_Coefs[  1 ] );
 8011354:	44ac      	add	ip, r5
 8011356:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
 801135a:	68dd      	ldr	r5, [r3, #12]
  __asm__(
 801135c:	fb82 a90e 	smull	sl, r9, r2, lr
 8011360:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011362:	f9b6 e00a 	ldrsh.w	lr, [r6, #10]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 19 ] ), FIR_Coefs[  4 ] );
 8011366:	6919      	ldr	r1, [r3, #16]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 21 ] ), FIR_Coefs[  2 ] );
 8011368:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
 801136a:	442a      	add	r2, r5
 801136c:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 8011370:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 19 ] ), FIR_Coefs[  4 ] );
 8011374:	6cda      	ldr	r2, [r3, #76]	; 0x4c
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011376:	f9b6 e00c 	ldrsh.w	lr, [r6, #12]
 801137a:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 20 ] ), FIR_Coefs[  3 ] );
 801137c:	44ac      	add	ip, r5
 801137e:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 18 ] ), FIR_Coefs[  5 ] );
 8011382:	695d      	ldr	r5, [r3, #20]
  __asm__(
 8011384:	fb82 a90e 	smull	sl, r9, r2, lr
 8011388:	6c9a      	ldr	r2, [r3, #72]	; 0x48
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801138a:	f9b6 e00e 	ldrsh.w	lr, [r6, #14]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 17 ] ), FIR_Coefs[  6 ] );
 801138e:	6999      	ldr	r1, [r3, #24]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 19 ] ), FIR_Coefs[  4 ] );
 8011390:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 18 ] ), FIR_Coefs[  5 ] );
 8011392:	442a      	add	r2, r5
 8011394:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 8011398:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 17 ] ), FIR_Coefs[  6 ] );
 801139c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801139e:	f9b6 e010 	ldrsh.w	lr, [r6, #16]
 80113a2:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 18 ] ), FIR_Coefs[  5 ] );
 80113a4:	44ac      	add	ip, r5
 80113a6:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 16 ] ), FIR_Coefs[  7 ] );
 80113aa:	69dd      	ldr	r5, [r3, #28]
  __asm__(
 80113ac:	fb82 a90e 	smull	sl, r9, r2, lr
 80113b0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80113b2:	f9b6 e012 	ldrsh.w	lr, [r6, #18]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 15 ] ), FIR_Coefs[  8 ] );
 80113b6:	6a19      	ldr	r1, [r3, #32]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 17 ] ), FIR_Coefs[  6 ] );
 80113b8:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 16 ] ), FIR_Coefs[  7 ] );
 80113ba:	442a      	add	r2, r5
 80113bc:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 80113c0:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 15 ] ), FIR_Coefs[  8 ] );
 80113c4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80113c6:	f9b6 e014 	ldrsh.w	lr, [r6, #20]
 80113ca:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 16 ] ), FIR_Coefs[  7 ] );
 80113cc:	44ac      	add	ip, r5
 80113ce:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 14 ] ), FIR_Coefs[  9 ] );
 80113d2:	6a5d      	ldr	r5, [r3, #36]	; 0x24
  __asm__(
 80113d4:	fb82 a90e 	smull	sl, r9, r2, lr
 80113d8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80113da:	f9b6 e016 	ldrsh.w	lr, [r6, #22]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 15 ] ), FIR_Coefs[  8 ] );
 80113de:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 14 ] ), FIR_Coefs[  9 ] );
 80113e0:	442a      	add	r2, r5
 80113e2:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 80113e6:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
 80113ea:	6b5a      	ldr	r2, [r3, #52]	; 0x34
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 14 ] ), FIR_Coefs[  9 ] );
 80113ec:	4465      	add	r5, ip
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80113ee:	f9b6 c018 	ldrsh.w	ip, [r6, #24]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
 80113f2:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80113f4:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 80113f8:	eb01 0902 	add.w	r9, r1, r2
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 12 ] ), FIR_Coefs[ 11 ] );
 80113fc:	e9d3 2e0b 	ldrd	r2, lr, [r3, #44]	; 0x2c
  __asm__(
 8011400:	fb89 a30c 	smull	sl, r3, r9, ip
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011404:	f9b6 c01a 	ldrsh.w	ip, [r6, #26]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 13 ] ), FIR_Coefs[ 10 ] );
 8011408:	442b      	add	r3, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 12 ] ), FIR_Coefs[ 11 ] );
 801140a:	4472      	add	r2, lr
 801140c:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  __asm__(
 8011410:	fb82 e50c 	smull	lr, r5, r2, ip
 8011414:	442b      	add	r3, r5
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
 8011416:	115b      	asrs	r3, r3, #5
 8011418:	3301      	adds	r3, #1
 801141a:	105b      	asrs	r3, r3, #1
 801141c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8011420:	f6ff af71 	blt.w	8011306 <silk_resampler_private_down_FIR+0xc6>
 8011424:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8011428:	e772      	b.n	8011310 <silk_resampler_private_down_FIR+0xd0>
 801142a:	4b67      	ldr	r3, [pc, #412]	; (80115c8 <silk_resampler_private_down_FIR+0x388>)
 801142c:	e770      	b.n	8011310 <silk_resampler_private_down_FIR+0xd0>
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 801142e:	2a00      	cmp	r2, #0
 8011430:	f77f af35 	ble.w	801129e <silk_resampler_private_down_FIR+0x5e>
        out = silk_resampler_private_down_FIR_INTERPOL( out, buf, FIR_Coefs, S->FIR_Order,
 8011434:	6a7b      	ldr	r3, [r7, #36]	; 0x24
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 8011436:	2500      	movs	r5, #0
        out = silk_resampler_private_down_FIR_INTERPOL( out, buf, FIR_Coefs, S->FIR_Order,
 8011438:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 801143c:	60be      	str	r6, [r7, #8]
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801143e:	041a      	lsls	r2, r3, #16
 8011440:	3b01      	subs	r3, #1
 8011442:	617a      	str	r2, [r7, #20]
 8011444:	613b      	str	r3, [r7, #16]
 8011446:	6879      	ldr	r1, [r7, #4]
 8011448:	e00c      	b.n	8011464 <silk_resampler_private_down_FIR+0x224>
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
 801144a:	f514 4f00 	cmn.w	r4, #32768	; 0x8000
 801144e:	f2c0 80b2 	blt.w	80115b6 <silk_resampler_private_down_FIR+0x376>
 8011452:	b224      	sxth	r4, r4
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 8011454:	69bb      	ldr	r3, [r7, #24]
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
 8011456:	f828 4b02 	strh.w	r4, [r8], #2
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 801145a:	441d      	add	r5, r3
 801145c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801145e:	42ab      	cmp	r3, r5
 8011460:	f340 8189 	ble.w	8011776 <silk_resampler_private_down_FIR+0x536>
  __asm__(
 8011464:	697b      	ldr	r3, [r7, #20]
                interpol_ind = silk_SMULWB( index_Q16 & 0xFFFF, FIR_Fracs );
 8011466:	b2aa      	uxth	r2, r5
 8011468:	461c      	mov	r4, r3
 801146a:	fb82 0304 	smull	r0, r3, r2, r4
                interpol_ptr = &FIR_Coefs[ RESAMPLER_DOWN_ORDER_FIR0 / 2 * interpol_ind ];
 801146e:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 8011472:	eb01 0442 	add.w	r4, r1, r2, lsl #1
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011476:	f931 0012 	ldrsh.w	r0, [r1, r2, lsl #1]
 801147a:	f9b4 e002 	ldrsh.w	lr, [r4, #2]
 801147e:	f9b4 c004 	ldrsh.w	ip, [r4, #4]
                buf_ptr = buf + silk_RSHIFT( index_Q16, 16 );
 8011482:	142e      	asrs	r6, r5, #16
 8011484:	eb0b 0286 	add.w	r2, fp, r6, lsl #2
 8011488:	0400      	lsls	r0, r0, #16
  __asm__(
 801148a:	f85b 6026 	ldr.w	r6, [fp, r6, lsl #2]
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801148e:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 8011492:	fb86 a900 	smull	sl, r9, r6, r0
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011496:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  __asm__(
 801149a:	6850      	ldr	r0, [r2, #4]
 801149c:	fb80 a60e 	smull	sl, r6, r0, lr
 80114a0:	6890      	ldr	r0, [r2, #8]
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80114a2:	f9b4 e006 	ldrsh.w	lr, [r4, #6]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 1 ], interpol_ptr[ 1 ] );
 80114a6:	444e      	add	r6, r9
  __asm__(
 80114a8:	fb80 a90c 	smull	sl, r9, r0, ip
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80114ac:	f9b4 c008 	ldrsh.w	ip, [r4, #8]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 2 ], interpol_ptr[ 2 ] );
 80114b0:	444e      	add	r6, r9
  __asm__(
 80114b2:	68d0      	ldr	r0, [r2, #12]
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80114b4:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 80114b8:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  __asm__(
 80114bc:	fb80 a90e 	smull	sl, r9, r0, lr
 80114c0:	6910      	ldr	r0, [r2, #16]
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80114c2:	f9b4 e00a 	ldrsh.w	lr, [r4, #10]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 3 ], interpol_ptr[ 3 ] );
 80114c6:	444e      	add	r6, r9
  __asm__(
 80114c8:	fb80 a90c 	smull	sl, r9, r0, ip
                interpol_ptr = &FIR_Coefs[ RESAMPLER_DOWN_ORDER_FIR0 / 2 * ( FIR_Fracs - 1 - interpol_ind ) ];
 80114cc:	6938      	ldr	r0, [r7, #16]
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80114ce:	f9b4 c00c 	ldrsh.w	ip, [r4, #12]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 4 ], interpol_ptr[ 4 ] );
 80114d2:	444e      	add	r6, r9
                interpol_ptr = &FIR_Coefs[ RESAMPLER_DOWN_ORDER_FIR0 / 2 * ( FIR_Fracs - 1 - interpol_ind ) ];
 80114d4:	1ac3      	subs	r3, r0, r3
 80114d6:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 80114da:	6950      	ldr	r0, [r2, #20]
 80114dc:	fb80 a90e 	smull	sl, r9, r0, lr
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80114e0:	f9b4 e00e 	ldrsh.w	lr, [r4, #14]
 80114e4:	f9b4 a010 	ldrsh.w	sl, [r4, #16]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 5 ], interpol_ptr[ 5 ] );
 80114e8:	444e      	add	r6, r9
                interpol_ptr = &FIR_Coefs[ RESAMPLER_DOWN_ORDER_FIR0 / 2 * ( FIR_Fracs - 1 - interpol_ind ) ];
 80114ea:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
  __asm__(
 80114ee:	6990      	ldr	r0, [r2, #24]
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80114f0:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 80114f4:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 80114f8:	fb80 940c 	smull	r9, r4, r0, ip
 80114fc:	69d0      	ldr	r0, [r2, #28]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 6 ], interpol_ptr[ 6 ] );
 80114fe:	4426      	add	r6, r4
 8011500:	fb80 c40e 	smull	ip, r4, r0, lr
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011504:	f931 e013 	ldrsh.w	lr, [r1, r3, lsl #1]
                interpol_ptr = &FIR_Coefs[ RESAMPLER_DOWN_ORDER_FIR0 / 2 * ( FIR_Fracs - 1 - interpol_ind ) ];
 8011508:	eb01 0343 	add.w	r3, r1, r3, lsl #1
  __asm__(
 801150c:	6a10      	ldr	r0, [r2, #32]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 7 ], interpol_ptr[ 7 ] );
 801150e:	4426      	add	r6, r4
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011510:	ea4f 4a0a 	mov.w	sl, sl, lsl #16
  __asm__(
 8011514:	fb80 c40a 	smull	ip, r4, r0, sl
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011518:	f9b3 c002 	ldrsh.w	ip, [r3, #2]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 8 ], interpol_ptr[ 8 ] );
 801151c:	4434      	add	r4, r6
  __asm__(
 801151e:	6c50      	ldr	r0, [r2, #68]	; 0x44
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011520:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 8011524:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  __asm__(
 8011528:	fb80 690e 	smull	r6, r9, r0, lr
 801152c:	6c10      	ldr	r0, [r2, #64]	; 0x40
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801152e:	f9b3 6004 	ldrsh.w	r6, [r3, #4]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 17 ], interpol_ptr[ 0 ] );
 8011532:	444c      	add	r4, r9
  __asm__(
 8011534:	fb80 9e0c 	smull	r9, lr, r0, ip
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011538:	f9b3 c006 	ldrsh.w	ip, [r3, #6]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 16 ], interpol_ptr[ 1 ] );
 801153c:	4474      	add	r4, lr
  __asm__(
 801153e:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011540:	0436      	lsls	r6, r6, #16
 8011542:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  __asm__(
 8011546:	fb80 9e06 	smull	r9, lr, r0, r6
 801154a:	6b90      	ldr	r0, [r2, #56]	; 0x38
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801154c:	f9b3 6008 	ldrsh.w	r6, [r3, #8]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 15 ], interpol_ptr[ 2 ] );
 8011550:	4474      	add	r4, lr
  __asm__(
 8011552:	fb80 9e0c 	smull	r9, lr, r0, ip
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011556:	f9b3 c00a 	ldrsh.w	ip, [r3, #10]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 14 ], interpol_ptr[ 3 ] );
 801155a:	4474      	add	r4, lr
  __asm__(
 801155c:	6b50      	ldr	r0, [r2, #52]	; 0x34
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801155e:	0436      	lsls	r6, r6, #16
 8011560:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  __asm__(
 8011564:	fb80 9e06 	smull	r9, lr, r0, r6
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011568:	f9b3 600c 	ldrsh.w	r6, [r3, #12]
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 13 ], interpol_ptr[ 4 ] );
 801156c:	4474      	add	r4, lr
  __asm__(
 801156e:	6b10      	ldr	r0, [r2, #48]	; 0x30
 8011570:	fb80 9e0c 	smull	r9, lr, r0, ip
 8011574:	6a90      	ldr	r0, [r2, #40]	; 0x28
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 12 ], interpol_ptr[ 5 ] );
 8011576:	4474      	add	r4, lr
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011578:	f9b3 900e 	ldrsh.w	r9, [r3, #14]
  __asm__(
 801157c:	62b8      	str	r0, [r7, #40]	; 0x28
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801157e:	0436      	lsls	r6, r6, #16
  __asm__(
 8011580:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011582:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
  __asm__(
 8011586:	fb80 ec06 	smull	lr, ip, r0, r6
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 11 ], interpol_ptr[ 6 ] );
 801158a:	4464      	add	r4, ip
 801158c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801158e:	ea4f 4909 	mov.w	r9, r9, lsl #16
  __asm__(
 8011592:	fb80 c609 	smull	ip, r6, r0, r9
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[ 10 ], interpol_ptr[ 7 ] );
 8011596:	4434      	add	r4, r6
 8011598:	6a52      	ldr	r2, [r2, #36]	; 0x24
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801159a:	041b      	lsls	r3, r3, #16
  __asm__(
 801159c:	fb82 0603 	smull	r0, r6, r2, r3
                res_Q6 = silk_SMLAWB( res_Q6, buf_ptr[  9 ], interpol_ptr[ 8 ] );
 80115a0:	4434      	add	r4, r6
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
 80115a2:	1164      	asrs	r4, r4, #5
 80115a4:	3401      	adds	r4, #1
 80115a6:	1064      	asrs	r4, r4, #1
 80115a8:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
 80115ac:	f6ff af4d 	blt.w	801144a <silk_resampler_private_down_FIR+0x20a>
 80115b0:	f647 74ff 	movw	r4, #32767	; 0x7fff
 80115b4:	e74e      	b.n	8011454 <silk_resampler_private_down_FIR+0x214>
 80115b6:	4c04      	ldr	r4, [pc, #16]	; (80115c8 <silk_resampler_private_down_FIR+0x388>)
 80115b8:	e74c      	b.n	8011454 <silk_resampler_private_down_FIR+0x214>
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 80115ba:	2a00      	cmp	r2, #0
 80115bc:	f77f ae6f 	ble.w	801129e <silk_resampler_private_down_FIR+0x5e>
 80115c0:	2400      	movs	r4, #0
 80115c2:	69b8      	ldr	r0, [r7, #24]
 80115c4:	e00e      	b.n	80115e4 <silk_resampler_private_down_FIR+0x3a4>
 80115c6:	bf00      	nop
 80115c8:	ffff8000 	.word	0xffff8000
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
 80115cc:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 80115d0:	f2c0 80cf 	blt.w	8011772 <silk_resampler_private_down_FIR+0x532>
 80115d4:	b21b      	sxth	r3, r3
 80115d6:	f828 3b02 	strh.w	r3, [r8], #2
            for( index_Q16 = 0; index_Q16 < max_index_Q16; index_Q16 += index_increment_Q16 ) {
 80115da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80115dc:	4404      	add	r4, r0
 80115de:	42a3      	cmp	r3, r4
 80115e0:	f77f ae5d 	ble.w	801129e <silk_resampler_private_down_FIR+0x5e>
                buf_ptr = buf + silk_RSHIFT( index_Q16, 16 );
 80115e4:	1422      	asrs	r2, r4, #16
 80115e6:	eb0b 0382 	add.w	r3, fp, r2, lsl #2
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 35 ] ), FIR_Coefs[  0 ] );
 80115ea:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 80115ee:	f85b 2022 	ldr.w	r2, [fp, r2, lsl #2]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 34 ] ), FIR_Coefs[  1 ] );
 80115f2:	685d      	ldr	r5, [r3, #4]
                res_Q6 = silk_SMULWB(         silk_ADD32( buf_ptr[  0 ], buf_ptr[ 35 ] ), FIR_Coefs[  0 ] );
 80115f4:	eb02 0901 	add.w	r9, r2, r1
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80115f8:	f9b6 a004 	ldrsh.w	sl, [r6, #4]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 34 ] ), FIR_Coefs[  1 ] );
 80115fc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8011600:	f9b6 e006 	ldrsh.w	lr, [r6, #6]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 33 ] ), FIR_Coefs[  2 ] );
 8011604:	6899      	ldr	r1, [r3, #8]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 34 ] ), FIR_Coefs[  1 ] );
 8011606:	442a      	add	r2, r5
 8011608:	ea4f 4a0a 	mov.w	sl, sl, lsl #16
 801160c:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 8011610:	fb89 5c0a 	smull	r5, ip, r9, sl
 8011614:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 33 ] ), FIR_Coefs[  2 ] );
 8011618:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801161c:	f9b6 e008 	ldrsh.w	lr, [r6, #8]
 8011620:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  1 ], buf_ptr[ 34 ] ), FIR_Coefs[  1 ] );
 8011622:	44ac      	add	ip, r5
 8011624:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 32 ] ), FIR_Coefs[  3 ] );
 8011628:	68dd      	ldr	r5, [r3, #12]
  __asm__(
 801162a:	fb82 a90e 	smull	sl, r9, r2, lr
 801162e:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011632:	f9b6 e00a 	ldrsh.w	lr, [r6, #10]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 31 ] ), FIR_Coefs[  4 ] );
 8011636:	6919      	ldr	r1, [r3, #16]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  2 ], buf_ptr[ 33 ] ), FIR_Coefs[  2 ] );
 8011638:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 32 ] ), FIR_Coefs[  3 ] );
 801163a:	442a      	add	r2, r5
 801163c:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 8011640:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 31 ] ), FIR_Coefs[  4 ] );
 8011644:	6fda      	ldr	r2, [r3, #124]	; 0x7c
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011646:	f9b6 e00c 	ldrsh.w	lr, [r6, #12]
 801164a:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  3 ], buf_ptr[ 32 ] ), FIR_Coefs[  3 ] );
 801164c:	44ac      	add	ip, r5
 801164e:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
 8011652:	695d      	ldr	r5, [r3, #20]
  __asm__(
 8011654:	fb82 a90e 	smull	sl, r9, r2, lr
 8011658:	6f9a      	ldr	r2, [r3, #120]	; 0x78
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801165a:	f9b6 e00e 	ldrsh.w	lr, [r6, #14]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 29 ] ), FIR_Coefs[  6 ] );
 801165e:	6999      	ldr	r1, [r3, #24]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  4 ], buf_ptr[ 31 ] ), FIR_Coefs[  4 ] );
 8011660:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
 8011662:	442a      	add	r2, r5
 8011664:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 8011668:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 29 ] ), FIR_Coefs[  6 ] );
 801166c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801166e:	f9b6 e010 	ldrsh.w	lr, [r6, #16]
 8011672:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  5 ], buf_ptr[ 30 ] ), FIR_Coefs[  5 ] );
 8011674:	44ac      	add	ip, r5
 8011676:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 28 ] ), FIR_Coefs[  7 ] );
 801167a:	69dd      	ldr	r5, [r3, #28]
  __asm__(
 801167c:	fb82 a90e 	smull	sl, r9, r2, lr
 8011680:	6f1a      	ldr	r2, [r3, #112]	; 0x70
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011682:	f9b6 e012 	ldrsh.w	lr, [r6, #18]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
 8011686:	6a19      	ldr	r1, [r3, #32]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  6 ], buf_ptr[ 29 ] ), FIR_Coefs[  6 ] );
 8011688:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 28 ] ), FIR_Coefs[  7 ] );
 801168a:	442a      	add	r2, r5
 801168c:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 8011690:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
 8011694:	6eda      	ldr	r2, [r3, #108]	; 0x6c
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011696:	f9b6 e014 	ldrsh.w	lr, [r6, #20]
 801169a:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  7 ], buf_ptr[ 28 ] ), FIR_Coefs[  7 ] );
 801169c:	44ac      	add	ip, r5
 801169e:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 26 ] ), FIR_Coefs[  9 ] );
 80116a2:	6a5d      	ldr	r5, [r3, #36]	; 0x24
  __asm__(
 80116a4:	fb82 a90e 	smull	sl, r9, r2, lr
 80116a8:	6e9a      	ldr	r2, [r3, #104]	; 0x68
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80116aa:	f9b6 e016 	ldrsh.w	lr, [r6, #22]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  8 ], buf_ptr[ 27 ] ), FIR_Coefs[  8 ] );
 80116ae:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 26 ] ), FIR_Coefs[  9 ] );
 80116b0:	442a      	add	r2, r5
 80116b2:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 80116b6:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 25 ] ), FIR_Coefs[ 10 ] );
 80116ba:	6e5a      	ldr	r2, [r3, #100]	; 0x64
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80116bc:	f9b6 e018 	ldrsh.w	lr, [r6, #24]
 80116c0:	6a99      	ldr	r1, [r3, #40]	; 0x28
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[  9 ], buf_ptr[ 26 ] ), FIR_Coefs[  9 ] );
 80116c2:	44ac      	add	ip, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 25 ] ), FIR_Coefs[ 10 ] );
 80116c4:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
 80116c6:	6add      	ldr	r5, [r3, #44]	; 0x2c
 80116c8:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 80116cc:	fb82 a90e 	smull	sl, r9, r2, lr
 80116d0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80116d2:	f9b6 e01a 	ldrsh.w	lr, [r6, #26]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 12 ], buf_ptr[ 23 ] ), FIR_Coefs[ 12 ] );
 80116d6:	6b19      	ldr	r1, [r3, #48]	; 0x30
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 10 ], buf_ptr[ 25 ] ), FIR_Coefs[ 10 ] );
 80116d8:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
 80116da:	442a      	add	r2, r5
 80116dc:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 80116e0:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 12 ], buf_ptr[ 23 ] ), FIR_Coefs[ 12 ] );
 80116e4:	6dda      	ldr	r2, [r3, #92]	; 0x5c
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80116e6:	f9b6 e01c 	ldrsh.w	lr, [r6, #28]
 80116ea:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 11 ], buf_ptr[ 24 ] ), FIR_Coefs[ 11 ] );
 80116ec:	44ac      	add	ip, r5
 80116ee:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 13 ], buf_ptr[ 22 ] ), FIR_Coefs[ 13 ] );
 80116f2:	6b5d      	ldr	r5, [r3, #52]	; 0x34
  __asm__(
 80116f4:	fb82 a90e 	smull	sl, r9, r2, lr
 80116f8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
      : "%r"(a), "r"(SAFE_SHL(b,16))
 80116fa:	f9b6 e01e 	ldrsh.w	lr, [r6, #30]
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 14 ], buf_ptr[ 21 ] ), FIR_Coefs[ 14 ] );
 80116fe:	6b99      	ldr	r1, [r3, #56]	; 0x38
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 12 ], buf_ptr[ 23 ] ), FIR_Coefs[ 12 ] );
 8011700:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 13 ], buf_ptr[ 22 ] ), FIR_Coefs[ 13 ] );
 8011702:	442a      	add	r2, r5
 8011704:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
  __asm__(
 8011708:	fb82 950e 	smull	r9, r5, r2, lr
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 14 ], buf_ptr[ 21 ] ), FIR_Coefs[ 14 ] );
 801170c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801170e:	f9b6 e020 	ldrsh.w	lr, [r6, #32]
 8011712:	440a      	add	r2, r1
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 13 ], buf_ptr[ 22 ] ), FIR_Coefs[ 13 ] );
 8011714:	44ac      	add	ip, r5
 8011716:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
 801171a:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
  __asm__(
 801171c:	fb82 a90e 	smull	sl, r9, r2, lr
 8011720:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011722:	f9b6 e022 	ldrsh.w	lr, [r6, #34]	; 0x22
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 14 ], buf_ptr[ 21 ] ), FIR_Coefs[ 14 ] );
 8011726:	44cc      	add	ip, r9
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
 8011728:	442a      	add	r2, r5
 801172a:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 16 ], buf_ptr[ 19 ] ), FIR_Coefs[ 16 ] );
 801172e:	6c19      	ldr	r1, [r3, #64]	; 0x40
  __asm__(
 8011730:	fb82 950e 	smull	r9, r5, r2, lr
 8011734:	6cda      	ldr	r2, [r3, #76]	; 0x4c
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 15 ], buf_ptr[ 20 ] ), FIR_Coefs[ 15 ] );
 8011736:	4465      	add	r5, ip
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011738:	f9b6 c024 	ldrsh.w	ip, [r6, #36]	; 0x24
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 16 ], buf_ptr[ 19 ] ), FIR_Coefs[ 16 ] );
 801173c:	eb01 0902 	add.w	r9, r1, r2
 8011740:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 17 ], buf_ptr[ 18 ] ), FIR_Coefs[ 17 ] );
 8011744:	e9d3 2e11 	ldrd	r2, lr, [r3, #68]	; 0x44
  __asm__(
 8011748:	fb89 a30c 	smull	sl, r3, r9, ip
      : "%r"(a), "r"(SAFE_SHL(b,16))
 801174c:	f9b6 c026 	ldrsh.w	ip, [r6, #38]	; 0x26
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 16 ], buf_ptr[ 19 ] ), FIR_Coefs[ 16 ] );
 8011750:	442b      	add	r3, r5
                res_Q6 = silk_SMLAWB( res_Q6, silk_ADD32( buf_ptr[ 17 ], buf_ptr[ 18 ] ), FIR_Coefs[ 17 ] );
 8011752:	4472      	add	r2, lr
 8011754:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  __asm__(
 8011758:	fb82 e50c 	smull	lr, r5, r2, ip
 801175c:	442b      	add	r3, r5
                *out++ = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( res_Q6, 6 ) );
 801175e:	115b      	asrs	r3, r3, #5
 8011760:	3301      	adds	r3, #1
 8011762:	105b      	asrs	r3, r3, #1
 8011764:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8011768:	f6ff af30 	blt.w	80115cc <silk_resampler_private_down_FIR+0x38c>
 801176c:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8011770:	e731      	b.n	80115d6 <silk_resampler_private_down_FIR+0x396>
 8011772:	4b05      	ldr	r3, [pc, #20]	; (8011788 <silk_resampler_private_down_FIR+0x548>)
 8011774:	e72f      	b.n	80115d6 <silk_resampler_private_down_FIR+0x396>
 8011776:	68be      	ldr	r6, [r7, #8]
 8011778:	e591      	b.n	801129e <silk_resampler_private_down_FIR+0x5e>
            break;
        }
    }

    /* Copy last part of filtered signal to the state for the next call */
    silk_memcpy( S->sFIR.i32, &buf[ nSamplesIn ], S->FIR_Order * sizeof( opus_int32 ) );
 801177a:	68f8      	ldr	r0, [r7, #12]
 801177c:	f002 fcb0 	bl	80140e0 <memcpy>
    RESTORE_STACK;
}
 8011780:	373c      	adds	r7, #60	; 0x3c
 8011782:	46bd      	mov	sp, r7
 8011784:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011788:	ffff8000 	.word	0xffff8000

0801178c <silk_resampler_private_up2_HQ>:
    opus_int32                      *S,             /* I/O  Resampler state [ 6 ]       */
    opus_int16                      *out,           /* O    Output signal [ 2 * len ]   */
    const opus_int16                *in,            /* I    Input signal [ len ]        */
    opus_int32                      len             /* I    Number of input samples     */
)
{
 801178c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    silk_assert( silk_resampler_up2_hq_1[ 0 ] > 0 );
    silk_assert( silk_resampler_up2_hq_1[ 1 ] > 0 );
    silk_assert( silk_resampler_up2_hq_1[ 2 ] < 0 );

    /* Internal variables and state are in Q10 format */
    for( k = 0; k < len; k++ ) {
 8011790:	2b00      	cmp	r3, #0
{
 8011792:	b087      	sub	sp, #28
 8011794:	9005      	str	r0, [sp, #20]
    for( k = 0; k < len; k++ ) {
 8011796:	dd7b      	ble.n	8011890 <silk_resampler_private_up2_HQ+0x104>
 8011798:	e9d0 7600 	ldrd	r7, r6, [r0]
 801179c:	e9d0 be02 	ldrd	fp, lr, [r0, #8]
 80117a0:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 80117a4:	f8d0 c010 	ldr.w	ip, [r0, #16]
 80117a8:	6940      	ldr	r0, [r0, #20]
 80117aa:	9304      	str	r3, [sp, #16]
 80117ac:	1e93      	subs	r3, r2, #2
 80117ae:	e9cd 0301 	strd	r0, r3, [sp, #4]
 80117b2:	e033      	b.n	801181c <silk_resampler_private_up2_HQ+0x90>
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_0[ 2 ] );
        out32_1 = silk_ADD32( S[ 2 ], X );
        S[ 2 ]  = silk_ADD32( out32_2, X );

        /* Apply gain in Q15, convert back to int16 and store to output */
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 80117b4:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 80117b8:	db6d      	blt.n	8011896 <silk_resampler_private_up2_HQ+0x10a>
 80117ba:	b21b      	sxth	r3, r3
 80117bc:	9303      	str	r3, [sp, #12]

        /* First all-pass section for odd output sample */
        Y       = silk_SUB32( in32, S[ 3 ] );
 80117be:	eba4 020e 	sub.w	r2, r4, lr
 80117c2:	4837      	ldr	r0, [pc, #220]	; (80118a0 <silk_resampler_private_up2_HQ+0x114>)
 80117c4:	fb82 5300 	smull	r5, r3, r2, r0
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_1[ 0 ] );
        out32_1 = silk_ADD32( S[ 3 ], X );
 80117c8:	eb03 0a0e 	add.w	sl, r3, lr
        S[ 3 ]  = silk_ADD32( in32, X );

        /* Second all-pass section for odd output sample */
        Y       = silk_SUB32( out32_1, S[ 4 ] );
 80117cc:	ebaa 020c 	sub.w	r2, sl, ip
 80117d0:	4834      	ldr	r0, [pc, #208]	; (80118a4 <silk_resampler_private_up2_HQ+0x118>)
 80117d2:	fb82 5900 	smull	r5, r9, r2, r0
        X       = silk_SMULWB( Y, silk_resampler_up2_hq_1[ 1 ] );
        out32_2 = silk_ADD32( S[ 4 ], X );
        S[ 4 ]  = silk_ADD32( out32_1, X );

        /* Third all-pass section for odd output sample */
        Y       = silk_SUB32( out32_2, S[ 5 ] );
 80117d6:	9a01      	ldr	r2, [sp, #4]
        out32_2 = silk_ADD32( S[ 4 ], X );
 80117d8:	eb09 080c 	add.w	r8, r9, ip
        Y       = silk_SUB32( out32_2, S[ 5 ] );
 80117dc:	eba8 0202 	sub.w	r2, r8, r2
 80117e0:	4831      	ldr	r0, [pc, #196]	; (80118a8 <silk_resampler_private_up2_HQ+0x11c>)
 80117e2:	fb82 c500 	smull	ip, r5, r2, r0
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_1[ 2 ] );
        out32_1 = silk_ADD32( S[ 5 ], X );
 80117e6:	9801      	ldr	r0, [sp, #4]
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_1[ 2 ] );
 80117e8:	442a      	add	r2, r5
        out32_1 = silk_ADD32( S[ 5 ], X );
 80117ea:	4410      	add	r0, r2
        S[ 5 ]  = silk_ADD32( out32_2, X );

        /* Apply gain in Q15, convert back to int16 and store to output */
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 80117ec:	1245      	asrs	r5, r0, #9
 80117ee:	3501      	adds	r5, #1
 80117f0:	106d      	asrs	r5, r5, #1
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 80117f2:	9803      	ldr	r0, [sp, #12]
        S[ 3 ]  = silk_ADD32( in32, X );
 80117f4:	eb04 0e03 	add.w	lr, r4, r3
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 80117f8:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
        S[ 5 ]  = silk_ADD32( out32_2, X );
 80117fc:	eb08 0302 	add.w	r3, r8, r2
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011800:	8008      	strh	r0, [r1, #0]
        S[ 4 ]  = silk_ADD32( out32_1, X );
 8011802:	eb0a 0c09 	add.w	ip, sl, r9
        S[ 5 ]  = silk_ADD32( out32_2, X );
 8011806:	9301      	str	r3, [sp, #4]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011808:	da32      	bge.n	8011870 <silk_resampler_private_up2_HQ+0xe4>
 801180a:	f515 4f00 	cmn.w	r5, #32768	; 0x8000
 801180e:	db45      	blt.n	801189c <silk_resampler_private_up2_HQ+0x110>
 8011810:	b22d      	sxth	r5, r5
    for( k = 0; k < len; k++ ) {
 8011812:	9b04      	ldr	r3, [sp, #16]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011814:	804d      	strh	r5, [r1, #2]
 8011816:	3104      	adds	r1, #4
    for( k = 0; k < len; k++ ) {
 8011818:	4299      	cmp	r1, r3
 801181a:	d030      	beq.n	801187e <silk_resampler_private_up2_HQ+0xf2>
        in32 = silk_LSHIFT( (opus_int32)in[ k ], 10 );
 801181c:	9b02      	ldr	r3, [sp, #8]
 801181e:	4d23      	ldr	r5, [pc, #140]	; (80118ac <silk_resampler_private_up2_HQ+0x120>)
 8011820:	f933 4f02 	ldrsh.w	r4, [r3, #2]!
 8011824:	02a4      	lsls	r4, r4, #10
 8011826:	9302      	str	r3, [sp, #8]
        Y       = silk_SUB32( in32, S[ 0 ] );
 8011828:	1be3      	subs	r3, r4, r7
 801182a:	fb83 2a05 	smull	r2, sl, r3, r5
        out32_1 = silk_ADD32( S[ 0 ], X );
 801182e:	eb0a 0907 	add.w	r9, sl, r7
        Y       = silk_SUB32( out32_1, S[ 1 ] );
 8011832:	eba9 0306 	sub.w	r3, r9, r6
 8011836:	4d1e      	ldr	r5, [pc, #120]	; (80118b0 <silk_resampler_private_up2_HQ+0x124>)
 8011838:	fb83 2805 	smull	r2, r8, r3, r5
        out32_2 = silk_ADD32( S[ 1 ], X );
 801183c:	eb08 0506 	add.w	r5, r8, r6
        Y       = silk_SUB32( out32_2, S[ 2 ] );
 8011840:	eba5 030b 	sub.w	r3, r5, fp
 8011844:	4f1b      	ldr	r7, [pc, #108]	; (80118b4 <silk_resampler_private_up2_HQ+0x128>)
 8011846:	fb83 6207 	smull	r6, r2, r3, r7
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_0[ 2 ] );
 801184a:	441a      	add	r2, r3
        out32_1 = silk_ADD32( S[ 2 ], X );
 801184c:	eb02 030b 	add.w	r3, r2, fp
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011850:	125b      	asrs	r3, r3, #9
 8011852:	3301      	adds	r3, #1
 8011854:	105b      	asrs	r3, r3, #1
 8011856:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
        S[ 0 ]  = silk_ADD32( in32, X );
 801185a:	eb04 070a 	add.w	r7, r4, sl
        S[ 1 ]  = silk_ADD32( out32_1, X );
 801185e:	eb09 0608 	add.w	r6, r9, r8
        S[ 2 ]  = silk_ADD32( out32_2, X );
 8011862:	eb05 0b02 	add.w	fp, r5, r2
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011866:	dba5      	blt.n	80117b4 <silk_resampler_private_up2_HQ+0x28>
 8011868:	f647 73ff 	movw	r3, #32767	; 0x7fff
 801186c:	9303      	str	r3, [sp, #12]
 801186e:	e7a6      	b.n	80117be <silk_resampler_private_up2_HQ+0x32>
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011870:	f647 75ff 	movw	r5, #32767	; 0x7fff
    for( k = 0; k < len; k++ ) {
 8011874:	9b04      	ldr	r3, [sp, #16]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011876:	804d      	strh	r5, [r1, #2]
 8011878:	3104      	adds	r1, #4
    for( k = 0; k < len; k++ ) {
 801187a:	4299      	cmp	r1, r3
 801187c:	d1ce      	bne.n	801181c <silk_resampler_private_up2_HQ+0x90>
 801187e:	9b05      	ldr	r3, [sp, #20]
 8011880:	9801      	ldr	r0, [sp, #4]
 8011882:	e9c3 ec03 	strd	lr, ip, [r3, #12]
 8011886:	e9c3 7600 	strd	r7, r6, [r3]
 801188a:	6158      	str	r0, [r3, #20]
 801188c:	f8c3 b008 	str.w	fp, [r3, #8]
    }
}
 8011890:	b007      	add	sp, #28
 8011892:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011896:	4b08      	ldr	r3, [pc, #32]	; (80118b8 <silk_resampler_private_up2_HQ+0x12c>)
 8011898:	9303      	str	r3, [sp, #12]
 801189a:	e790      	b.n	80117be <silk_resampler_private_up2_HQ+0x32>
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 801189c:	4d06      	ldr	r5, [pc, #24]	; (80118b8 <silk_resampler_private_up2_HQ+0x12c>)
 801189e:	e7b8      	b.n	8011812 <silk_resampler_private_up2_HQ+0x86>
 80118a0:	1ac60000 	.word	0x1ac60000
 80118a4:	64a90000 	.word	0x64a90000
 80118a8:	d8f60000 	.word	0xd8f60000
 80118ac:	06d20000 	.word	0x06d20000
 80118b0:	3a8a0000 	.word	0x3a8a0000
 80118b4:	98ab0000 	.word	0x98ab0000
 80118b8:	ffff8000 	.word	0xffff8000

080118bc <silk_resampler_private_up2_HQ_wrapper>:
    void                            *SS,            /* I/O  Resampler state (unused)    */
    opus_int16                      *out,           /* O    Output signal [ 2 * len ]   */
    const opus_int16                *in,            /* I    Input signal [ len ]        */
    opus_int32                      len             /* I    Number of input samples     */
)
{
 80118bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    for( k = 0; k < len; k++ ) {
 80118c0:	2b00      	cmp	r3, #0
{
 80118c2:	b087      	sub	sp, #28
 80118c4:	9005      	str	r0, [sp, #20]
    for( k = 0; k < len; k++ ) {
 80118c6:	dd7b      	ble.n	80119c0 <silk_resampler_private_up2_HQ_wrapper+0x104>
 80118c8:	e9d0 7600 	ldrd	r7, r6, [r0]
 80118cc:	e9d0 be02 	ldrd	fp, lr, [r0, #8]
 80118d0:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 80118d4:	f8d0 c010 	ldr.w	ip, [r0, #16]
 80118d8:	6940      	ldr	r0, [r0, #20]
 80118da:	9304      	str	r3, [sp, #16]
 80118dc:	1e93      	subs	r3, r2, #2
 80118de:	e9cd 0301 	strd	r0, r3, [sp, #4]
 80118e2:	e033      	b.n	801194c <silk_resampler_private_up2_HQ_wrapper+0x90>
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 80118e4:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 80118e8:	db6d      	blt.n	80119c6 <silk_resampler_private_up2_HQ_wrapper+0x10a>
 80118ea:	b21b      	sxth	r3, r3
 80118ec:	9303      	str	r3, [sp, #12]
        Y       = silk_SUB32( in32, S[ 3 ] );
 80118ee:	eba4 020e 	sub.w	r2, r4, lr
 80118f2:	4837      	ldr	r0, [pc, #220]	; (80119d0 <silk_resampler_private_up2_HQ_wrapper+0x114>)
 80118f4:	fb82 5300 	smull	r5, r3, r2, r0
        out32_1 = silk_ADD32( S[ 3 ], X );
 80118f8:	eb03 0a0e 	add.w	sl, r3, lr
        Y       = silk_SUB32( out32_1, S[ 4 ] );
 80118fc:	ebaa 020c 	sub.w	r2, sl, ip
 8011900:	4834      	ldr	r0, [pc, #208]	; (80119d4 <silk_resampler_private_up2_HQ_wrapper+0x118>)
 8011902:	fb82 5900 	smull	r5, r9, r2, r0
        Y       = silk_SUB32( out32_2, S[ 5 ] );
 8011906:	9a01      	ldr	r2, [sp, #4]
        out32_2 = silk_ADD32( S[ 4 ], X );
 8011908:	eb09 080c 	add.w	r8, r9, ip
        Y       = silk_SUB32( out32_2, S[ 5 ] );
 801190c:	eba8 0202 	sub.w	r2, r8, r2
 8011910:	4831      	ldr	r0, [pc, #196]	; (80119d8 <silk_resampler_private_up2_HQ_wrapper+0x11c>)
 8011912:	fb82 c500 	smull	ip, r5, r2, r0
        out32_1 = silk_ADD32( S[ 5 ], X );
 8011916:	9801      	ldr	r0, [sp, #4]
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_1[ 2 ] );
 8011918:	442a      	add	r2, r5
        out32_1 = silk_ADD32( S[ 5 ], X );
 801191a:	4410      	add	r0, r2
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 801191c:	1245      	asrs	r5, r0, #9
 801191e:	3501      	adds	r5, #1
 8011920:	106d      	asrs	r5, r5, #1
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011922:	9803      	ldr	r0, [sp, #12]
        S[ 3 ]  = silk_ADD32( in32, X );
 8011924:	eb04 0e03 	add.w	lr, r4, r3
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011928:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
        S[ 5 ]  = silk_ADD32( out32_2, X );
 801192c:	eb08 0302 	add.w	r3, r8, r2
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011930:	8008      	strh	r0, [r1, #0]
        S[ 4 ]  = silk_ADD32( out32_1, X );
 8011932:	eb0a 0c09 	add.w	ip, sl, r9
        S[ 5 ]  = silk_ADD32( out32_2, X );
 8011936:	9301      	str	r3, [sp, #4]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011938:	da32      	bge.n	80119a0 <silk_resampler_private_up2_HQ_wrapper+0xe4>
 801193a:	f515 4f00 	cmn.w	r5, #32768	; 0x8000
 801193e:	db45      	blt.n	80119cc <silk_resampler_private_up2_HQ_wrapper+0x110>
 8011940:	b22d      	sxth	r5, r5
    for( k = 0; k < len; k++ ) {
 8011942:	9b04      	ldr	r3, [sp, #16]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011944:	804d      	strh	r5, [r1, #2]
 8011946:	3104      	adds	r1, #4
    for( k = 0; k < len; k++ ) {
 8011948:	4299      	cmp	r1, r3
 801194a:	d030      	beq.n	80119ae <silk_resampler_private_up2_HQ_wrapper+0xf2>
        in32 = silk_LSHIFT( (opus_int32)in[ k ], 10 );
 801194c:	9b02      	ldr	r3, [sp, #8]
 801194e:	4d23      	ldr	r5, [pc, #140]	; (80119dc <silk_resampler_private_up2_HQ_wrapper+0x120>)
 8011950:	f933 4f02 	ldrsh.w	r4, [r3, #2]!
 8011954:	02a4      	lsls	r4, r4, #10
 8011956:	9302      	str	r3, [sp, #8]
        Y       = silk_SUB32( in32, S[ 0 ] );
 8011958:	1be3      	subs	r3, r4, r7
 801195a:	fb83 2a05 	smull	r2, sl, r3, r5
        out32_1 = silk_ADD32( S[ 0 ], X );
 801195e:	eb0a 0907 	add.w	r9, sl, r7
        Y       = silk_SUB32( out32_1, S[ 1 ] );
 8011962:	eba9 0306 	sub.w	r3, r9, r6
 8011966:	4d1e      	ldr	r5, [pc, #120]	; (80119e0 <silk_resampler_private_up2_HQ_wrapper+0x124>)
 8011968:	fb83 2805 	smull	r2, r8, r3, r5
        out32_2 = silk_ADD32( S[ 1 ], X );
 801196c:	eb08 0506 	add.w	r5, r8, r6
        Y       = silk_SUB32( out32_2, S[ 2 ] );
 8011970:	eba5 020b 	sub.w	r2, r5, fp
 8011974:	4f1b      	ldr	r7, [pc, #108]	; (80119e4 <silk_resampler_private_up2_HQ_wrapper+0x128>)
 8011976:	fb82 6307 	smull	r6, r3, r2, r7
        X       = silk_SMLAWB( Y, Y, silk_resampler_up2_hq_0[ 2 ] );
 801197a:	441a      	add	r2, r3
        out32_1 = silk_ADD32( S[ 2 ], X );
 801197c:	eb02 030b 	add.w	r3, r2, fp
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011980:	125b      	asrs	r3, r3, #9
 8011982:	3301      	adds	r3, #1
 8011984:	105b      	asrs	r3, r3, #1
 8011986:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
        S[ 0 ]  = silk_ADD32( in32, X );
 801198a:	eb04 070a 	add.w	r7, r4, sl
        S[ 1 ]  = silk_ADD32( out32_1, X );
 801198e:	eb09 0608 	add.w	r6, r9, r8
        S[ 2 ]  = silk_ADD32( out32_2, X );
 8011992:	eb05 0b02 	add.w	fp, r5, r2
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 8011996:	dba5      	blt.n	80118e4 <silk_resampler_private_up2_HQ_wrapper+0x28>
 8011998:	f647 73ff 	movw	r3, #32767	; 0x7fff
 801199c:	9303      	str	r3, [sp, #12]
 801199e:	e7a6      	b.n	80118ee <silk_resampler_private_up2_HQ_wrapper+0x32>
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 80119a0:	f647 75ff 	movw	r5, #32767	; 0x7fff
    for( k = 0; k < len; k++ ) {
 80119a4:	9b04      	ldr	r3, [sp, #16]
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 80119a6:	804d      	strh	r5, [r1, #2]
 80119a8:	3104      	adds	r1, #4
    for( k = 0; k < len; k++ ) {
 80119aa:	4299      	cmp	r1, r3
 80119ac:	d1ce      	bne.n	801194c <silk_resampler_private_up2_HQ_wrapper+0x90>
 80119ae:	9b05      	ldr	r3, [sp, #20]
 80119b0:	9801      	ldr	r0, [sp, #4]
 80119b2:	e9c3 ec03 	strd	lr, ip, [r3, #12]
 80119b6:	e9c3 7600 	strd	r7, r6, [r3]
 80119ba:	6158      	str	r0, [r3, #20]
 80119bc:	f8c3 b008 	str.w	fp, [r3, #8]
    silk_resampler_state_struct *S = (silk_resampler_state_struct *)SS;
    silk_resampler_private_up2_HQ( S->sIIR, out, in, len );
}
 80119c0:	b007      	add	sp, #28
 80119c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        out[ 2 * k ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 80119c6:	4b08      	ldr	r3, [pc, #32]	; (80119e8 <silk_resampler_private_up2_HQ_wrapper+0x12c>)
 80119c8:	9303      	str	r3, [sp, #12]
 80119ca:	e790      	b.n	80118ee <silk_resampler_private_up2_HQ_wrapper+0x32>
        out[ 2 * k + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( out32_1, 10 ) );
 80119cc:	4d06      	ldr	r5, [pc, #24]	; (80119e8 <silk_resampler_private_up2_HQ_wrapper+0x12c>)
 80119ce:	e7b8      	b.n	8011942 <silk_resampler_private_up2_HQ_wrapper+0x86>
 80119d0:	1ac60000 	.word	0x1ac60000
 80119d4:	64a90000 	.word	0x64a90000
 80119d8:	d8f60000 	.word	0xd8f60000
 80119dc:	06d20000 	.word	0x06d20000
 80119e0:	3a8a0000 	.word	0x3a8a0000
 80119e4:	98ab0000 	.word	0x98ab0000
 80119e8:	ffff8000 	.word	0xffff8000

080119ec <silk_shell_decoder>:
void silk_shell_decoder(
    opus_int16                  *pulses0,                       /* O    data: nonnegative pulse amplitudes          */
    ec_dec                      *psRangeDec,                    /* I/O  Compressor data structure                   */
    const opus_int              pulses4                         /* I    number of pulses per pulse-subframe         */
)
{
 80119ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( p > 0 ) {
 80119f0:	1e15      	subs	r5, r2, #0
{
 80119f2:	b083      	sub	sp, #12
 80119f4:	4604      	mov	r4, r0
 80119f6:	460e      	mov	r6, r1
    if( p > 0 ) {
 80119f8:	dc17      	bgt.n	8011a2a <silk_shell_decoder+0x3e>
 80119fa:	f04f 0900 	mov.w	r9, #0
        p_child2[ 0 ] = 0;
 80119fe:	464d      	mov	r5, r9
        p_child1[ 0 ] = 0;
 8011a00:	2300      	movs	r3, #0
 8011a02:	6023      	str	r3, [r4, #0]
 8011a04:	6063      	str	r3, [r4, #4]
 8011a06:	2300      	movs	r3, #0
 8011a08:	60a3      	str	r3, [r4, #8]
 8011a0a:	2300      	movs	r3, #0
    if( p > 0 ) {
 8011a0c:	f1b9 0f00 	cmp.w	r9, #0
        p_child1[ 0 ] = 0;
 8011a10:	60e3      	str	r3, [r4, #12]
    if( p > 0 ) {
 8011a12:	f300 8099 	bgt.w	8011b48 <silk_shell_decoder+0x15c>
        p_child1[ 0 ] = 0;
 8011a16:	2300      	movs	r3, #0
 8011a18:	6123      	str	r3, [r4, #16]
 8011a1a:	6163      	str	r3, [r4, #20]
 8011a1c:	2300      	movs	r3, #0
 8011a1e:	61a3      	str	r3, [r4, #24]
 8011a20:	2300      	movs	r3, #0
 8011a22:	61e3      	str	r3, [r4, #28]
    decode_split( &pulses0[ 10 ], &pulses0[ 11 ], psRangeDec, pulses1[ 5 ], silk_shell_code_table0 );

    decode_split( &pulses1[  6 ], &pulses1[  7 ], psRangeDec, pulses2[ 3 ], silk_shell_code_table1 );
    decode_split( &pulses0[ 12 ], &pulses0[ 13 ], psRangeDec, pulses1[ 6 ], silk_shell_code_table0 );
    decode_split( &pulses0[ 14 ], &pulses0[ 15 ], psRangeDec, pulses1[ 7 ], silk_shell_code_table0 );
}
 8011a24:	b003      	add	sp, #12
 8011a26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011a2a:	4f8d      	ldr	r7, [pc, #564]	; (8011c60 <silk_shell_decoder+0x274>)
 8011a2c:	498d      	ldr	r1, [pc, #564]	; (8011c64 <silk_shell_decoder+0x278>)
 8011a2e:	5d7b      	ldrb	r3, [r7, r5]
 8011a30:	2208      	movs	r2, #8
 8011a32:	4419      	add	r1, r3
 8011a34:	4630      	mov	r0, r6
 8011a36:	f7f6 fda9 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011a3a:	fa1f f980 	uxth.w	r9, r0
    decode_split( &pulses2[  0 ], &pulses2[  1 ], psRangeDec, pulses3[ 0 ], silk_shell_code_table2 );
 8011a3e:	b200      	sxth	r0, r0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011a40:	eba5 0509 	sub.w	r5, r5, r9
    if( p > 0 ) {
 8011a44:	2800      	cmp	r0, #0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011a46:	b22d      	sxth	r5, r5
    if( p > 0 ) {
 8011a48:	f340 80f2 	ble.w	8011c30 <silk_shell_decoder+0x244>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011a4c:	5c3b      	ldrb	r3, [r7, r0]
 8011a4e:	4986      	ldr	r1, [pc, #536]	; (8011c68 <silk_shell_decoder+0x27c>)
 8011a50:	2208      	movs	r2, #8
 8011a52:	4419      	add	r1, r3
 8011a54:	4630      	mov	r0, r6
 8011a56:	f7f6 fd99 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011a5a:	fa1f f880 	uxth.w	r8, r0
 8011a5e:	eba9 0908 	sub.w	r9, r9, r8
    decode_split( &pulses1[  0 ], &pulses1[  1 ], psRangeDec, pulses2[ 0 ], silk_shell_code_table1 );
 8011a62:	b200      	sxth	r0, r0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011a64:	fa1f f389 	uxth.w	r3, r9
    if( p > 0 ) {
 8011a68:	2800      	cmp	r0, #0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011a6a:	9300      	str	r3, [sp, #0]
 8011a6c:	fa0f fb83 	sxth.w	fp, r3
 8011a70:	46a9      	mov	r9, r5
    if( p > 0 ) {
 8011a72:	f340 80df 	ble.w	8011c34 <silk_shell_decoder+0x248>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011a76:	5c3b      	ldrb	r3, [r7, r0]
 8011a78:	497c      	ldr	r1, [pc, #496]	; (8011c6c <silk_shell_decoder+0x280>)
 8011a7a:	2208      	movs	r2, #8
 8011a7c:	4419      	add	r1, r3
 8011a7e:	4630      	mov	r0, r6
 8011a80:	f7f6 fd84 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011a84:	fa1f fa80 	uxth.w	sl, r0
 8011a88:	eba8 080a 	sub.w	r8, r8, sl
    decode_split( &pulses0[  0 ], &pulses0[  1 ], psRangeDec, pulses1[ 0 ], silk_shell_code_table0 );
 8011a8c:	b200      	sxth	r0, r0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011a8e:	fa1f f888 	uxth.w	r8, r8
    if( p > 0 ) {
 8011a92:	2800      	cmp	r0, #0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011a94:	fa0f f388 	sxth.w	r3, r8
    if( p > 0 ) {
 8011a98:	f340 80d1 	ble.w	8011c3e <silk_shell_decoder+0x252>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011a9c:	5c39      	ldrb	r1, [r7, r0]
 8011a9e:	4874      	ldr	r0, [pc, #464]	; (8011c70 <silk_shell_decoder+0x284>)
 8011aa0:	2208      	movs	r2, #8
 8011aa2:	4401      	add	r1, r0
 8011aa4:	4630      	mov	r0, r6
 8011aa6:	9301      	str	r3, [sp, #4]
 8011aa8:	f7f6 fd70 	bl	800858c <ec_dec_icdf>
 8011aac:	9b01      	ldr	r3, [sp, #4]
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011aae:	ebaa 0a00 	sub.w	sl, sl, r0
 8011ab2:	f8a4 a002 	strh.w	sl, [r4, #2]
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011ab6:	8020      	strh	r0, [r4, #0]
    if( p > 0 ) {
 8011ab8:	2b00      	cmp	r3, #0
 8011aba:	f340 80bd 	ble.w	8011c38 <silk_shell_decoder+0x24c>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011abe:	5cfb      	ldrb	r3, [r7, r3]
 8011ac0:	496b      	ldr	r1, [pc, #428]	; (8011c70 <silk_shell_decoder+0x284>)
 8011ac2:	2208      	movs	r2, #8
 8011ac4:	4419      	add	r1, r3
 8011ac6:	4630      	mov	r0, r6
 8011ac8:	f7f6 fd60 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011acc:	eba8 0800 	sub.w	r8, r8, r0
 8011ad0:	f8a4 8006 	strh.w	r8, [r4, #6]
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011ad4:	80a0      	strh	r0, [r4, #4]
    if( p > 0 ) {
 8011ad6:	f1bb 0f00 	cmp.w	fp, #0
 8011ada:	dd94      	ble.n	8011a06 <silk_shell_decoder+0x1a>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011adc:	f817 300b 	ldrb.w	r3, [r7, fp]
 8011ae0:	4962      	ldr	r1, [pc, #392]	; (8011c6c <silk_shell_decoder+0x280>)
 8011ae2:	2208      	movs	r2, #8
 8011ae4:	4419      	add	r1, r3
 8011ae6:	4630      	mov	r0, r6
 8011ae8:	f7f6 fd50 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011aec:	9b00      	ldr	r3, [sp, #0]
 8011aee:	fa1f fa80 	uxth.w	sl, r0
 8011af2:	eba3 080a 	sub.w	r8, r3, sl
    decode_split( &pulses0[  4 ], &pulses0[  5 ], psRangeDec, pulses1[ 2 ], silk_shell_code_table0 );
 8011af6:	b200      	sxth	r0, r0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011af8:	fa1f f888 	uxth.w	r8, r8
    if( p > 0 ) {
 8011afc:	2800      	cmp	r0, #0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011afe:	fa0f fb88 	sxth.w	fp, r8
    if( p > 0 ) {
 8011b02:	f340 809f 	ble.w	8011c44 <silk_shell_decoder+0x258>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011b06:	5c3b      	ldrb	r3, [r7, r0]
 8011b08:	4959      	ldr	r1, [pc, #356]	; (8011c70 <silk_shell_decoder+0x284>)
 8011b0a:	2208      	movs	r2, #8
 8011b0c:	4419      	add	r1, r3
 8011b0e:	4630      	mov	r0, r6
 8011b10:	f7f6 fd3c 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011b14:	ebaa 0a00 	sub.w	sl, sl, r0
 8011b18:	f8a4 a00a 	strh.w	sl, [r4, #10]
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011b1c:	8120      	strh	r0, [r4, #8]
    if( p > 0 ) {
 8011b1e:	f1bb 0f00 	cmp.w	fp, #0
 8011b22:	f77f af72 	ble.w	8011a0a <silk_shell_decoder+0x1e>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011b26:	f817 300b 	ldrb.w	r3, [r7, fp]
 8011b2a:	4951      	ldr	r1, [pc, #324]	; (8011c70 <silk_shell_decoder+0x284>)
 8011b2c:	2208      	movs	r2, #8
 8011b2e:	4419      	add	r1, r3
 8011b30:	4630      	mov	r0, r6
 8011b32:	f7f6 fd2b 	bl	800858c <ec_dec_icdf>
    if( p > 0 ) {
 8011b36:	f1b9 0f00 	cmp.w	r9, #0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011b3a:	eba8 0800 	sub.w	r8, r8, r0
 8011b3e:	f8a4 800e 	strh.w	r8, [r4, #14]
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011b42:	81a0      	strh	r0, [r4, #12]
    if( p > 0 ) {
 8011b44:	f77f af67 	ble.w	8011a16 <silk_shell_decoder+0x2a>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011b48:	4f45      	ldr	r7, [pc, #276]	; (8011c60 <silk_shell_decoder+0x274>)
 8011b4a:	4947      	ldr	r1, [pc, #284]	; (8011c68 <silk_shell_decoder+0x27c>)
 8011b4c:	f817 3009 	ldrb.w	r3, [r7, r9]
 8011b50:	2208      	movs	r2, #8
 8011b52:	4419      	add	r1, r3
 8011b54:	4630      	mov	r0, r6
 8011b56:	f7f6 fd19 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011b5a:	fa1f f880 	uxth.w	r8, r0
 8011b5e:	eba5 0508 	sub.w	r5, r5, r8
    decode_split( &pulses1[  4 ], &pulses1[  5 ], psRangeDec, pulses2[ 2 ], silk_shell_code_table1 );
 8011b62:	b200      	sxth	r0, r0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011b64:	b2ad      	uxth	r5, r5
    if( p > 0 ) {
 8011b66:	2800      	cmp	r0, #0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011b68:	fa0f f985 	sxth.w	r9, r5
    if( p > 0 ) {
 8011b6c:	dd6d      	ble.n	8011c4a <silk_shell_decoder+0x25e>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011b6e:	5c3b      	ldrb	r3, [r7, r0]
 8011b70:	493e      	ldr	r1, [pc, #248]	; (8011c6c <silk_shell_decoder+0x280>)
 8011b72:	2208      	movs	r2, #8
 8011b74:	4419      	add	r1, r3
 8011b76:	4630      	mov	r0, r6
 8011b78:	f7f6 fd08 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011b7c:	fa1f fa80 	uxth.w	sl, r0
 8011b80:	eba8 080a 	sub.w	r8, r8, sl
    decode_split( &pulses0[  8 ], &pulses0[  9 ], psRangeDec, pulses1[ 4 ], silk_shell_code_table0 );
 8011b84:	b200      	sxth	r0, r0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011b86:	fa1f f888 	uxth.w	r8, r8
    if( p > 0 ) {
 8011b8a:	2800      	cmp	r0, #0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011b8c:	fa0f fb88 	sxth.w	fp, r8
    if( p > 0 ) {
 8011b90:	dd60      	ble.n	8011c54 <silk_shell_decoder+0x268>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011b92:	5c3b      	ldrb	r3, [r7, r0]
 8011b94:	4936      	ldr	r1, [pc, #216]	; (8011c70 <silk_shell_decoder+0x284>)
 8011b96:	2208      	movs	r2, #8
 8011b98:	4419      	add	r1, r3
 8011b9a:	4630      	mov	r0, r6
 8011b9c:	f7f6 fcf6 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011ba0:	ebaa 0a00 	sub.w	sl, sl, r0
 8011ba4:	f8a4 a012 	strh.w	sl, [r4, #18]
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011ba8:	8220      	strh	r0, [r4, #16]
    if( p > 0 ) {
 8011baa:	f1bb 0f00 	cmp.w	fp, #0
 8011bae:	dd4e      	ble.n	8011c4e <silk_shell_decoder+0x262>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011bb0:	f817 300b 	ldrb.w	r3, [r7, fp]
 8011bb4:	492e      	ldr	r1, [pc, #184]	; (8011c70 <silk_shell_decoder+0x284>)
 8011bb6:	2208      	movs	r2, #8
 8011bb8:	4419      	add	r1, r3
 8011bba:	4630      	mov	r0, r6
 8011bbc:	f7f6 fce6 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011bc0:	eba8 0800 	sub.w	r8, r8, r0
 8011bc4:	f8a4 8016 	strh.w	r8, [r4, #22]
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011bc8:	82a0      	strh	r0, [r4, #20]
    if( p > 0 ) {
 8011bca:	f1b9 0f00 	cmp.w	r9, #0
 8011bce:	f77f af25 	ble.w	8011a1c <silk_shell_decoder+0x30>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011bd2:	f817 3009 	ldrb.w	r3, [r7, r9]
 8011bd6:	4925      	ldr	r1, [pc, #148]	; (8011c6c <silk_shell_decoder+0x280>)
 8011bd8:	2208      	movs	r2, #8
 8011bda:	4419      	add	r1, r3
 8011bdc:	4630      	mov	r0, r6
 8011bde:	f7f6 fcd5 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011be2:	fa1f f880 	uxth.w	r8, r0
 8011be6:	eba5 0508 	sub.w	r5, r5, r8
    decode_split( &pulses0[ 12 ], &pulses0[ 13 ], psRangeDec, pulses1[ 6 ], silk_shell_code_table0 );
 8011bea:	b200      	sxth	r0, r0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011bec:	b2ad      	uxth	r5, r5
    if( p > 0 ) {
 8011bee:	2800      	cmp	r0, #0
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011bf0:	fa0f f985 	sxth.w	r9, r5
    if( p > 0 ) {
 8011bf4:	dd31      	ble.n	8011c5a <silk_shell_decoder+0x26e>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011bf6:	5c3b      	ldrb	r3, [r7, r0]
 8011bf8:	491d      	ldr	r1, [pc, #116]	; (8011c70 <silk_shell_decoder+0x284>)
 8011bfa:	2208      	movs	r2, #8
 8011bfc:	4419      	add	r1, r3
 8011bfe:	4630      	mov	r0, r6
 8011c00:	f7f6 fcc4 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011c04:	eba8 0300 	sub.w	r3, r8, r0
 8011c08:	8363      	strh	r3, [r4, #26]
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011c0a:	8320      	strh	r0, [r4, #24]
    if( p > 0 ) {
 8011c0c:	f1b9 0f00 	cmp.w	r9, #0
 8011c10:	f77f af06 	ble.w	8011a20 <silk_shell_decoder+0x34>
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011c14:	f817 3009 	ldrb.w	r3, [r7, r9]
 8011c18:	4915      	ldr	r1, [pc, #84]	; (8011c70 <silk_shell_decoder+0x284>)
 8011c1a:	4630      	mov	r0, r6
 8011c1c:	4419      	add	r1, r3
 8011c1e:	2208      	movs	r2, #8
 8011c20:	f7f6 fcb4 	bl	800858c <ec_dec_icdf>
        p_child2[ 0 ] = p - p_child1[ 0 ];
 8011c24:	1a2d      	subs	r5, r5, r0
 8011c26:	83e5      	strh	r5, [r4, #30]
        p_child1[ 0 ] = ec_dec_icdf( psRangeDec, &shell_table[ silk_shell_code_table_offsets[ p ] ], 8 );
 8011c28:	83a0      	strh	r0, [r4, #28]
}
 8011c2a:	b003      	add	sp, #12
 8011c2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011c30:	46a9      	mov	r9, r5
 8011c32:	e6e5      	b.n	8011a00 <silk_shell_decoder+0x14>
        p_child1[ 0 ] = 0;
 8011c34:	2300      	movs	r3, #0
 8011c36:	6023      	str	r3, [r4, #0]
 8011c38:	2300      	movs	r3, #0
 8011c3a:	6063      	str	r3, [r4, #4]
 8011c3c:	e74b      	b.n	8011ad6 <silk_shell_decoder+0xea>
 8011c3e:	2200      	movs	r2, #0
 8011c40:	6022      	str	r2, [r4, #0]
 8011c42:	e739      	b.n	8011ab8 <silk_shell_decoder+0xcc>
 8011c44:	2300      	movs	r3, #0
 8011c46:	60a3      	str	r3, [r4, #8]
 8011c48:	e769      	b.n	8011b1e <silk_shell_decoder+0x132>
 8011c4a:	2300      	movs	r3, #0
 8011c4c:	6123      	str	r3, [r4, #16]
 8011c4e:	2300      	movs	r3, #0
 8011c50:	6163      	str	r3, [r4, #20]
 8011c52:	e7ba      	b.n	8011bca <silk_shell_decoder+0x1de>
 8011c54:	2300      	movs	r3, #0
 8011c56:	6123      	str	r3, [r4, #16]
 8011c58:	e7a7      	b.n	8011baa <silk_shell_decoder+0x1be>
 8011c5a:	2300      	movs	r3, #0
 8011c5c:	61a3      	str	r3, [r4, #24]
 8011c5e:	e7d5      	b.n	8011c0c <silk_shell_decoder+0x220>
 8011c60:	08017f90 	.word	0x08017f90
 8011c64:	08017ef8 	.word	0x08017ef8
 8011c68:	08017e60 	.word	0x08017e60
 8011c6c:	08017dc8 	.word	0x08017dc8
 8011c70:	08017d30 	.word	0x08017d30

08011c74 <silk_insertion_sort_increasing_all_values_int16>:

    /* Safety checks */
    celt_assert( L >  0 );

    /* Sort vector elements by value, increasing order */
    for( i = 1; i < L; i++ ) {
 8011c74:	2901      	cmp	r1, #1
 8011c76:	dd27      	ble.n	8011cc8 <silk_insertion_sort_increasing_all_values_int16+0x54>
{
 8011c78:	b4f0      	push	{r4, r5, r6, r7}
    for( i = 1; i < L; i++ ) {
 8011c7a:	2600      	movs	r6, #0
 8011c7c:	f101 3cff 	add.w	ip, r1, #4294967295
 8011c80:	1c87      	adds	r7, r0, #2
        value = a[ i ];
 8011c82:	f937 5b02 	ldrsh.w	r5, [r7], #2
        for( j = i - 1; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
 8011c86:	4633      	mov	r3, r6
 8011c88:	f937 2c04 	ldrsh.w	r2, [r7, #-4]
 8011c8c:	4295      	cmp	r5, r2
 8011c8e:	da13      	bge.n	8011cb8 <silk_insertion_sort_increasing_all_values_int16+0x44>
 8011c90:	4639      	mov	r1, r7
 8011c92:	e003      	b.n	8011c9c <silk_insertion_sort_increasing_all_values_int16+0x28>
 8011c94:	f931 2c04 	ldrsh.w	r2, [r1, #-4]
 8011c98:	4295      	cmp	r5, r2
 8011c9a:	da05      	bge.n	8011ca8 <silk_insertion_sort_increasing_all_values_int16+0x34>
 8011c9c:	3b01      	subs	r3, #1
            a[ j + 1 ] = a[ j ]; /* Shift value */
 8011c9e:	f821 2d02 	strh.w	r2, [r1, #-2]!
        for( j = i - 1; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
 8011ca2:	1c5a      	adds	r2, r3, #1
 8011ca4:	461c      	mov	r4, r3
 8011ca6:	d1f5      	bne.n	8011c94 <silk_insertion_sort_increasing_all_values_int16+0x20>
 8011ca8:	3601      	adds	r6, #1
        }
        a[ j + 1 ] = value; /* Write value */
 8011caa:	3401      	adds	r4, #1
    for( i = 1; i < L; i++ ) {
 8011cac:	45b4      	cmp	ip, r6
        a[ j + 1 ] = value; /* Write value */
 8011cae:	f820 5014 	strh.w	r5, [r0, r4, lsl #1]
    for( i = 1; i < L; i++ ) {
 8011cb2:	d1e6      	bne.n	8011c82 <silk_insertion_sort_increasing_all_values_int16+0xe>
    }
}
 8011cb4:	bcf0      	pop	{r4, r5, r6, r7}
 8011cb6:	4770      	bx	lr
        for( j = i - 1; ( j >= 0 ) && ( value < a[ j ] ); j-- ) {
 8011cb8:	4634      	mov	r4, r6
 8011cba:	3601      	adds	r6, #1
        a[ j + 1 ] = value; /* Write value */
 8011cbc:	3401      	adds	r4, #1
    for( i = 1; i < L; i++ ) {
 8011cbe:	45b4      	cmp	ip, r6
        a[ j + 1 ] = value; /* Write value */
 8011cc0:	f820 5014 	strh.w	r5, [r0, r4, lsl #1]
    for( i = 1; i < L; i++ ) {
 8011cc4:	d1dd      	bne.n	8011c82 <silk_insertion_sort_increasing_all_values_int16+0xe>
 8011cc6:	e7f5      	b.n	8011cb4 <silk_insertion_sort_increasing_all_values_int16+0x40>
 8011cc8:	4770      	bx	lr
 8011cca:	bf00      	nop

08011ccc <silk_stereo_MS_to_LR>:
    opus_int16                  x2[],                           /* I/O  Right input signal, becomes side signal     */
    const opus_int32            pred_Q13[],                     /* I    Predictors                                  */
    opus_int                    fs_kHz,                         /* I    Samples rate (kHz)                          */
    opus_int                    frame_length                    /* I    Number of samples                           */
)
{
 8011ccc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    silk_memcpy( state->sSide, &x2[ frame_length ], 2 * sizeof( opus_int16 ) );

    /* Interpolate predictors and add prediction to side channel */
    pred0_Q13  = state->pred_prev_Q13[ 0 ];
    pred1_Q13  = state->pred_prev_Q13[ 1 ];
    denom_Q16  = silk_DIV32_16( (opus_int32)1 << 16, STEREO_INTERP_LEN_MS * fs_kHz );
 8011cd0:	f44f 3a80 	mov.w	sl, #65536	; 0x10000
{
 8011cd4:	4683      	mov	fp, r0
 8011cd6:	b087      	sub	sp, #28
 8011cd8:	9f10      	ldr	r7, [sp, #64]	; 0x40
    silk_memcpy( x1, state->sMid,  2 * sizeof( opus_int16 ) );
 8011cda:	6840      	ldr	r0, [r0, #4]
    denom_Q16  = silk_DIV32_16( (opus_int32)1 << 16, STEREO_INTERP_LEN_MS * fs_kHz );
 8011cdc:	00ff      	lsls	r7, r7, #3
 8011cde:	fb9a faf7 	sdiv	sl, sl, r7
    silk_memcpy( x1, state->sMid,  2 * sizeof( opus_int16 ) );
 8011ce2:	6008      	str	r0, [r1, #0]
    silk_memcpy( x2, state->sSide, 2 * sizeof( opus_int16 ) );
 8011ce4:	f8db 0008 	ldr.w	r0, [fp, #8]
    silk_memcpy( state->sMid,  &x1[ frame_length ], 2 * sizeof( opus_int16 ) );
 8011ce8:	9c11      	ldr	r4, [sp, #68]	; 0x44
    silk_memcpy( x2, state->sSide, 2 * sizeof( opus_int16 ) );
 8011cea:	6010      	str	r0, [r2, #0]
    silk_memcpy( state->sMid,  &x1[ frame_length ], 2 * sizeof( opus_int16 ) );
 8011cec:	0064      	lsls	r4, r4, #1
 8011cee:	5908      	ldr	r0, [r1, r4]
    pred0_Q13  = state->pred_prev_Q13[ 0 ];
 8011cf0:	f9bb e000 	ldrsh.w	lr, [fp]
    silk_memcpy( state->sMid,  &x1[ frame_length ], 2 * sizeof( opus_int16 ) );
 8011cf4:	f8cb 0004 	str.w	r0, [fp, #4]
    silk_memcpy( state->sSide, &x2[ frame_length ], 2 * sizeof( opus_int16 ) );
 8011cf8:	5910      	ldr	r0, [r2, r4]
    silk_memcpy( state->sMid,  &x1[ frame_length ], 2 * sizeof( opus_int16 ) );
 8011cfa:	9402      	str	r4, [sp, #8]
    silk_memcpy( state->sSide, &x2[ frame_length ], 2 * sizeof( opus_int16 ) );
 8011cfc:	f8cb 0008 	str.w	r0, [fp, #8]
    delta0_Q13 = silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
 8011d00:	6818      	ldr	r0, [r3, #0]
    delta1_Q13 = silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 1 ] - state->pred_prev_Q13[ 1 ], denom_Q16 ), 16 );
 8011d02:	685c      	ldr	r4, [r3, #4]
    delta0_Q13 = silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
 8011d04:	9003      	str	r0, [sp, #12]
 8011d06:	eba0 030e 	sub.w	r3, r0, lr
 8011d0a:	fa0f f08a 	sxth.w	r0, sl
 8011d0e:	fb13 f300 	smulbb	r3, r3, r0
    pred1_Q13  = state->pred_prev_Q13[ 1 ];
 8011d12:	f9bb 8002 	ldrsh.w	r8, [fp, #2]
    delta0_Q13 = silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
 8011d16:	13db      	asrs	r3, r3, #15
 8011d18:	3301      	adds	r3, #1
    delta1_Q13 = silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 1 ] - state->pred_prev_Q13[ 1 ], denom_Q16 ), 16 );
 8011d1a:	eba4 0a08 	sub.w	sl, r4, r8
    delta0_Q13 = silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
 8011d1e:	105b      	asrs	r3, r3, #1
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
 8011d20:	2f00      	cmp	r7, #0
    delta1_Q13 = silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 1 ] - state->pred_prev_Q13[ 1 ], denom_Q16 ), 16 );
 8011d22:	9404      	str	r4, [sp, #16]
 8011d24:	fb1a fa00 	smulbb	sl, sl, r0
    delta0_Q13 = silk_RSHIFT_ROUND( silk_SMULBB( pred_Q13[ 0 ] - state->pred_prev_Q13[ 0 ], denom_Q16 ), 16 );
 8011d28:	9301      	str	r3, [sp, #4]
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
 8011d2a:	dd47      	ble.n	8011dbc <silk_stereo_MS_to_LR+0xf0>
 8011d2c:	ea4f 3aea 	mov.w	sl, sl, asr #15
 8011d30:	f10a 0a01 	add.w	sl, sl, #1
 8011d34:	ea4f 0a6a 	mov.w	sl, sl, asr #1
 8011d38:	f04f 0c00 	mov.w	ip, #0
        pred0_Q13 += delta0_Q13;
        pred1_Q13 += delta1_Q13;
        sum = silk_LSHIFT( silk_ADD_LSHIFT( x1[ n ] + x1[ n + 2 ], x1[ n + 1 ], 1 ), 9 );       /* Q11 */
        sum = silk_SMLAWB( silk_LSHIFT( (opus_int32)x2[ n + 1 ], 8 ), sum, pred0_Q13 );         /* Q8  */
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)x1[ n + 1 ], 11 ), pred1_Q13 );        /* Q8  */
        x2[ n + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
 8011d3c:	f8cd b014 	str.w	fp, [sp, #20]
 8011d40:	e00b      	b.n	8011d5a <silk_stereo_MS_to_LR+0x8e>
 8011d42:	f519 4f00 	cmn.w	r9, #32768	; 0x8000
 8011d46:	f2c0 80a6 	blt.w	8011e96 <silk_stereo_MS_to_LR+0x1ca>
 8011d4a:	fa0f f989 	sxth.w	r9, r9
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
 8011d4e:	f10c 0c01 	add.w	ip, ip, #1
 8011d52:	4567      	cmp	r7, ip
        x2[ n + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
 8011d54:	f822 9004 	strh.w	r9, [r2, r4]
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
 8011d58:	dd2e      	ble.n	8011db8 <silk_stereo_MS_to_LR+0xec>
        sum = silk_LSHIFT( silk_ADD_LSHIFT( x1[ n ] + x1[ n + 2 ], x1[ n + 1 ], 1 ), 9 );       /* Q11 */
 8011d5a:	ea4f 044c 	mov.w	r4, ip, lsl #1
 8011d5e:	190b      	adds	r3, r1, r4
 8011d60:	f9b3 0004 	ldrsh.w	r0, [r3, #4]
 8011d64:	f931 301c 	ldrsh.w	r3, [r1, ip, lsl #1]
 8011d68:	3402      	adds	r4, #2
 8011d6a:	5f0d      	ldrsh	r5, [r1, r4]
 8011d6c:	4418      	add	r0, r3
        pred0_Q13 += delta0_Q13;
 8011d6e:	9b01      	ldr	r3, [sp, #4]
        sum = silk_SMLAWB( silk_LSHIFT( (opus_int32)x2[ n + 1 ], 8 ), sum, pred0_Q13 );         /* Q8  */
 8011d70:	f932 9004 	ldrsh.w	r9, [r2, r4]
        pred0_Q13 += delta0_Q13;
 8011d74:	449e      	add	lr, r3
        sum = silk_LSHIFT( silk_ADD_LSHIFT( x1[ n ] + x1[ n + 2 ], x1[ n + 1 ], 1 ), 9 );       /* Q11 */
 8011d76:	eb00 0045 	add.w	r0, r0, r5, lsl #1
 8011d7a:	0240      	lsls	r0, r0, #9
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011d7c:	ea4f 460e 	mov.w	r6, lr, lsl #16
        pred1_Q13 += delta1_Q13;
 8011d80:	44d0      	add	r8, sl
  __asm__(
 8011d82:	fb80 b306 	smull	fp, r3, r0, r6
        sum = silk_SMLAWB( silk_LSHIFT( (opus_int32)x2[ n + 1 ], 8 ), sum, pred0_Q13 );         /* Q8  */
 8011d86:	eb03 2309 	add.w	r3, r3, r9, lsl #8
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)x1[ n + 1 ], 11 ), pred1_Q13 );        /* Q8  */
 8011d8a:	02ed      	lsls	r5, r5, #11
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011d8c:	ea4f 4008 	mov.w	r0, r8, lsl #16
  __asm__(
 8011d90:	fb85 6900 	smull	r6, r9, r5, r0
 8011d94:	4499      	add	r9, r3
        x2[ n + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
 8011d96:	ea4f 19e9 	mov.w	r9, r9, asr #7
 8011d9a:	f109 0901 	add.w	r9, r9, #1
 8011d9e:	ea4f 0969 	mov.w	r9, r9, asr #1
 8011da2:	f5b9 4f00 	cmp.w	r9, #32768	; 0x8000
 8011da6:	dbcc      	blt.n	8011d42 <silk_stereo_MS_to_LR+0x76>
 8011da8:	f647 79ff 	movw	r9, #32767	; 0x7fff
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
 8011dac:	f10c 0c01 	add.w	ip, ip, #1
 8011db0:	4567      	cmp	r7, ip
        x2[ n + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
 8011db2:	f822 9004 	strh.w	r9, [r2, r4]
    for( n = 0; n < STEREO_INTERP_LEN_MS * fs_kHz; n++ ) {
 8011db6:	dcd0      	bgt.n	8011d5a <silk_stereo_MS_to_LR+0x8e>
 8011db8:	f8dd b014 	ldr.w	fp, [sp, #20]
    }
    pred0_Q13 = pred_Q13[ 0 ];
    pred1_Q13 = pred_Q13[ 1 ];
    for( n = STEREO_INTERP_LEN_MS * fs_kHz; n < frame_length; n++ ) {
 8011dbc:	9811      	ldr	r0, [sp, #68]	; 0x44
 8011dbe:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
 8011dc2:	4287      	cmp	r7, r0
 8011dc4:	f9bd 900c 	ldrsh.w	r9, [sp, #12]
 8011dc8:	9301      	str	r3, [sp, #4]
 8011dca:	da30      	bge.n	8011e2e <silk_stereo_MS_to_LR+0x162>
      : "%r"(a), "r"(SAFE_SHL(b,16))
 8011dcc:	ea4f 4c03 	mov.w	ip, r3, lsl #16
 8011dd0:	9b02      	ldr	r3, [sp, #8]
 8011dd2:	007f      	lsls	r7, r7, #1
 8011dd4:	19ce      	adds	r6, r1, r7
 8011dd6:	ea4f 4e09 	mov.w	lr, r9, lsl #16
 8011dda:	4417      	add	r7, r2
 8011ddc:	eb01 0803 	add.w	r8, r1, r3
 8011de0:	e006      	b.n	8011df0 <silk_stereo_MS_to_LR+0x124>
        sum = silk_LSHIFT( silk_ADD_LSHIFT( x1[ n ] + x1[ n + 2 ], x1[ n + 1 ], 1 ), 9 );       /* Q11 */
        sum = silk_SMLAWB( silk_LSHIFT( (opus_int32)x2[ n + 1 ], 8 ), sum, pred0_Q13 );         /* Q8  */
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)x1[ n + 1 ], 11 ), pred1_Q13 );        /* Q8  */
        x2[ n + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
 8011de2:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8011de6:	db59      	blt.n	8011e9c <silk_stereo_MS_to_LR+0x1d0>
 8011de8:	b21b      	sxth	r3, r3
    for( n = STEREO_INTERP_LEN_MS * fs_kHz; n < frame_length; n++ ) {
 8011dea:	4546      	cmp	r6, r8
        x2[ n + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
 8011dec:	803b      	strh	r3, [r7, #0]
    for( n = STEREO_INTERP_LEN_MS * fs_kHz; n < frame_length; n++ ) {
 8011dee:	d01e      	beq.n	8011e2e <silk_stereo_MS_to_LR+0x162>
        sum = silk_LSHIFT( silk_ADD_LSHIFT( x1[ n ] + x1[ n + 2 ], x1[ n + 1 ], 1 ), 9 );       /* Q11 */
 8011df0:	f9b6 3000 	ldrsh.w	r3, [r6]
 8011df4:	f936 4f02 	ldrsh.w	r4, [r6, #2]!
        sum = silk_SMLAWB( silk_LSHIFT( (opus_int32)x2[ n + 1 ], 8 ), sum, pred0_Q13 );         /* Q8  */
 8011df8:	f937 5f02 	ldrsh.w	r5, [r7, #2]!
        sum = silk_LSHIFT( silk_ADD_LSHIFT( x1[ n ] + x1[ n + 2 ], x1[ n + 1 ], 1 ), 9 );       /* Q11 */
 8011dfc:	f9b6 0002 	ldrsh.w	r0, [r6, #2]
 8011e00:	4418      	add	r0, r3
 8011e02:	eb00 0044 	add.w	r0, r0, r4, lsl #1
 8011e06:	0240      	lsls	r0, r0, #9
  __asm__(
 8011e08:	fb80 a30e 	smull	sl, r3, r0, lr
        sum = silk_SMLAWB( silk_LSHIFT( (opus_int32)x2[ n + 1 ], 8 ), sum, pred0_Q13 );         /* Q8  */
 8011e0c:	eb03 2305 	add.w	r3, r3, r5, lsl #8
        sum = silk_SMLAWB( sum, silk_LSHIFT( (opus_int32)x1[ n + 1 ], 11 ), pred1_Q13 );        /* Q8  */
 8011e10:	02e4      	lsls	r4, r4, #11
 8011e12:	fb84 500c 	smull	r5, r0, r4, ip
 8011e16:	4403      	add	r3, r0
        x2[ n + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
 8011e18:	11db      	asrs	r3, r3, #7
 8011e1a:	3301      	adds	r3, #1
 8011e1c:	105b      	asrs	r3, r3, #1
 8011e1e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8011e22:	dbde      	blt.n	8011de2 <silk_stereo_MS_to_LR+0x116>
 8011e24:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( n = STEREO_INTERP_LEN_MS * fs_kHz; n < frame_length; n++ ) {
 8011e28:	4546      	cmp	r6, r8
        x2[ n + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
 8011e2a:	803b      	strh	r3, [r7, #0]
    for( n = STEREO_INTERP_LEN_MS * fs_kHz; n < frame_length; n++ ) {
 8011e2c:	d1e0      	bne.n	8011df0 <silk_stereo_MS_to_LR+0x124>
    }
    state->pred_prev_Q13[ 0 ] = pred_Q13[ 0 ];
    state->pred_prev_Q13[ 1 ] = pred_Q13[ 1 ];
 8011e2e:	9b01      	ldr	r3, [sp, #4]
    state->pred_prev_Q13[ 0 ] = pred_Q13[ 0 ];
 8011e30:	f8ab 9000 	strh.w	r9, [fp]
    state->pred_prev_Q13[ 1 ] = pred_Q13[ 1 ];
 8011e34:	f8ab 3002 	strh.w	r3, [fp, #2]

    /* Convert to left/right signals */
    for( n = 0; n < frame_length; n++ ) {
 8011e38:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8011e3a:	2b00      	cmp	r3, #0
 8011e3c:	dd28      	ble.n	8011e90 <silk_stereo_MS_to_LR+0x1c4>
 8011e3e:	9b02      	ldr	r3, [sp, #8]
        sum  = x1[ n + 1 ] + (opus_int32)x2[ n + 1 ];
        diff = x1[ n + 1 ] - (opus_int32)x2[ n + 1 ];
        x1[ n + 1 ] = (opus_int16)silk_SAT16( sum );
 8011e40:	4e19      	ldr	r6, [pc, #100]	; (8011ea8 <silk_stereo_MS_to_LR+0x1dc>)
 8011e42:	440b      	add	r3, r1
 8011e44:	461d      	mov	r5, r3
 8011e46:	e00e      	b.n	8011e66 <silk_stereo_MS_to_LR+0x19a>
 8011e48:	f510 4f00 	cmn.w	r0, #32768	; 0x8000
 8011e4c:	db28      	blt.n	8011ea0 <silk_stereo_MS_to_LR+0x1d4>
 8011e4e:	b200      	sxth	r0, r0
        x2[ n + 1 ] = (opus_int16)silk_SAT16( diff );
 8011e50:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
        x1[ n + 1 ] = (opus_int16)silk_SAT16( sum );
 8011e54:	8008      	strh	r0, [r1, #0]
        x2[ n + 1 ] = (opus_int16)silk_SAT16( diff );
 8011e56:	da16      	bge.n	8011e86 <silk_stereo_MS_to_LR+0x1ba>
 8011e58:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8011e5c:	db22      	blt.n	8011ea4 <silk_stereo_MS_to_LR+0x1d8>
 8011e5e:	b21b      	sxth	r3, r3
    for( n = 0; n < frame_length; n++ ) {
 8011e60:	428d      	cmp	r5, r1
        x2[ n + 1 ] = (opus_int16)silk_SAT16( diff );
 8011e62:	8013      	strh	r3, [r2, #0]
    for( n = 0; n < frame_length; n++ ) {
 8011e64:	d014      	beq.n	8011e90 <silk_stereo_MS_to_LR+0x1c4>
        sum  = x1[ n + 1 ] + (opus_int32)x2[ n + 1 ];
 8011e66:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
 8011e6a:	f932 4f02 	ldrsh.w	r4, [r2, #2]!
 8011e6e:	18e0      	adds	r0, r4, r3
        x1[ n + 1 ] = (opus_int16)silk_SAT16( sum );
 8011e70:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
        diff = x1[ n + 1 ] - (opus_int32)x2[ n + 1 ];
 8011e74:	eba3 0304 	sub.w	r3, r3, r4
        x1[ n + 1 ] = (opus_int16)silk_SAT16( sum );
 8011e78:	dbe6      	blt.n	8011e48 <silk_stereo_MS_to_LR+0x17c>
 8011e7a:	f647 70ff 	movw	r0, #32767	; 0x7fff
        x2[ n + 1 ] = (opus_int16)silk_SAT16( diff );
 8011e7e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
        x1[ n + 1 ] = (opus_int16)silk_SAT16( sum );
 8011e82:	8008      	strh	r0, [r1, #0]
        x2[ n + 1 ] = (opus_int16)silk_SAT16( diff );
 8011e84:	dbe8      	blt.n	8011e58 <silk_stereo_MS_to_LR+0x18c>
 8011e86:	f647 73ff 	movw	r3, #32767	; 0x7fff
    for( n = 0; n < frame_length; n++ ) {
 8011e8a:	428d      	cmp	r5, r1
        x2[ n + 1 ] = (opus_int16)silk_SAT16( diff );
 8011e8c:	8013      	strh	r3, [r2, #0]
    for( n = 0; n < frame_length; n++ ) {
 8011e8e:	d1ea      	bne.n	8011e66 <silk_stereo_MS_to_LR+0x19a>
    }
}
 8011e90:	b007      	add	sp, #28
 8011e92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        x2[ n + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
 8011e96:	f8df 9010 	ldr.w	r9, [pc, #16]	; 8011ea8 <silk_stereo_MS_to_LR+0x1dc>
 8011e9a:	e758      	b.n	8011d4e <silk_stereo_MS_to_LR+0x82>
        x2[ n + 1 ] = (opus_int16)silk_SAT16( silk_RSHIFT_ROUND( sum, 8 ) );
 8011e9c:	4b02      	ldr	r3, [pc, #8]	; (8011ea8 <silk_stereo_MS_to_LR+0x1dc>)
 8011e9e:	e7a4      	b.n	8011dea <silk_stereo_MS_to_LR+0x11e>
        x1[ n + 1 ] = (opus_int16)silk_SAT16( sum );
 8011ea0:	4630      	mov	r0, r6
 8011ea2:	e7d5      	b.n	8011e50 <silk_stereo_MS_to_LR+0x184>
        x2[ n + 1 ] = (opus_int16)silk_SAT16( diff );
 8011ea4:	4633      	mov	r3, r6
 8011ea6:	e7db      	b.n	8011e60 <silk_stereo_MS_to_LR+0x194>
 8011ea8:	ffff8000 	.word	0xffff8000

08011eac <silk_stereo_decode_pred>:
/* Decode mid/side predictors */
void silk_stereo_decode_pred(
    ec_dec                      *psRangeDec,                    /* I/O  Compressor data structure                   */
    opus_int32                  pred_Q13[]                      /* O    Predictors                                  */
)
{
 8011eac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    opus_int   n, ix[ 2 ][ 3 ];
    opus_int32 low_Q13, step_Q13;

    /* Entropy decoding */
    n = ec_dec_icdf( psRangeDec, silk_stereo_pred_joint_iCDF, 8 );
 8011eb0:	2208      	movs	r2, #8
{
 8011eb2:	460e      	mov	r6, r1
    n = ec_dec_icdf( psRangeDec, silk_stereo_pred_joint_iCDF, 8 );
 8011eb4:	4928      	ldr	r1, [pc, #160]	; (8011f58 <silk_stereo_decode_pred+0xac>)
{
 8011eb6:	4680      	mov	r8, r0
    n = ec_dec_icdf( psRangeDec, silk_stereo_pred_joint_iCDF, 8 );
 8011eb8:	f7f6 fb68 	bl	800858c <ec_dec_icdf>
 8011ebc:	4603      	mov	r3, r0
    ix[ 0 ][ 2 ] = silk_DIV32_16( n, 5 );
 8011ebe:	4a27      	ldr	r2, [pc, #156]	; (8011f5c <silk_stereo_decode_pred+0xb0>)
 8011ec0:	17c4      	asrs	r4, r0, #31
 8011ec2:	fb82 1200 	smull	r1, r2, r2, r0
    ix[ 1 ][ 2 ] = n - 5 * ix[ 0 ][ 2 ];
    for( n = 0; n < 2; n++ ) {
        ix[ n ][ 0 ] = ec_dec_icdf( psRangeDec, silk_uniform3_iCDF, 8 );
 8011ec6:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 8011f68 <silk_stereo_decode_pred+0xbc>
    ix[ 0 ][ 2 ] = silk_DIV32_16( n, 5 );
 8011eca:	ebc4 0462 	rsb	r4, r4, r2, asr #1
    ix[ 1 ][ 2 ] = n - 5 * ix[ 0 ][ 2 ];
 8011ece:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
        ix[ n ][ 0 ] = ec_dec_icdf( psRangeDec, silk_uniform3_iCDF, 8 );
 8011ed2:	4649      	mov	r1, r9
    ix[ 1 ][ 2 ] = n - 5 * ix[ 0 ][ 2 ];
 8011ed4:	ebc4 0585 	rsb	r5, r4, r5, lsl #2
        ix[ n ][ 0 ] = ec_dec_icdf( psRangeDec, silk_uniform3_iCDF, 8 );
 8011ed8:	2208      	movs	r2, #8
 8011eda:	4640      	mov	r0, r8
    ix[ 1 ][ 2 ] = n - 5 * ix[ 0 ][ 2 ];
 8011edc:	441d      	add	r5, r3
        ix[ n ][ 0 ] = ec_dec_icdf( psRangeDec, silk_uniform3_iCDF, 8 );
 8011ede:	f7f6 fb55 	bl	800858c <ec_dec_icdf>
        ix[ n ][ 1 ] = ec_dec_icdf( psRangeDec, silk_uniform5_iCDF, 8 );
 8011ee2:	f8df b088 	ldr.w	fp, [pc, #136]	; 8011f6c <silk_stereo_decode_pred+0xc0>
        ix[ n ][ 0 ] = ec_dec_icdf( psRangeDec, silk_uniform3_iCDF, 8 );
 8011ee6:	4682      	mov	sl, r0
        ix[ n ][ 1 ] = ec_dec_icdf( psRangeDec, silk_uniform5_iCDF, 8 );
 8011ee8:	4659      	mov	r1, fp
 8011eea:	2208      	movs	r2, #8
 8011eec:	4640      	mov	r0, r8
 8011eee:	f7f6 fb4d 	bl	800858c <ec_dec_icdf>
        ix[ n ][ 0 ] = ec_dec_icdf( psRangeDec, silk_uniform3_iCDF, 8 );
 8011ef2:	4649      	mov	r1, r9
        ix[ n ][ 1 ] = ec_dec_icdf( psRangeDec, silk_uniform5_iCDF, 8 );
 8011ef4:	4607      	mov	r7, r0
        ix[ n ][ 0 ] = ec_dec_icdf( psRangeDec, silk_uniform3_iCDF, 8 );
 8011ef6:	2208      	movs	r2, #8
 8011ef8:	4640      	mov	r0, r8
 8011efa:	f7f6 fb47 	bl	800858c <ec_dec_icdf>
 8011efe:	4681      	mov	r9, r0
        ix[ n ][ 1 ] = ec_dec_icdf( psRangeDec, silk_uniform5_iCDF, 8 );
 8011f00:	4659      	mov	r1, fp
 8011f02:	2208      	movs	r2, #8
 8011f04:	4640      	mov	r0, r8
 8011f06:	f7f6 fb41 	bl	800858c <ec_dec_icdf>
    }

    /* Dequantize */
    for( n = 0; n < 2; n++ ) {
        ix[ n ][ 0 ] += 3 * ix[ n ][ 2 ];
 8011f0a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8011f0e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
        low_Q13 = silk_stereo_pred_quant_Q13[ ix[ n ][ 0 ] ];
 8011f12:	4a13      	ldr	r2, [pc, #76]	; (8011f60 <silk_stereo_decode_pred+0xb4>)
        ix[ n ][ 0 ] += 3 * ix[ n ][ 2 ];
 8011f14:	4454      	add	r4, sl
 8011f16:	444d      	add	r5, r9
        step_Q13 = silk_SMULWB( silk_stereo_pred_quant_Q13[ ix[ n ][ 0 ] + 1 ] - low_Q13,
 8011f18:	1c63      	adds	r3, r4, #1
 8011f1a:	1c69      	adds	r1, r5, #1
        low_Q13 = silk_stereo_pred_quant_Q13[ ix[ n ][ 0 ] ];
 8011f1c:	f932 c015 	ldrsh.w	ip, [r2, r5, lsl #1]
        step_Q13 = silk_SMULWB( silk_stereo_pred_quant_Q13[ ix[ n ][ 0 ] + 1 ] - low_Q13,
 8011f20:	f932 1011 	ldrsh.w	r1, [r2, r1, lsl #1]
        low_Q13 = silk_stereo_pred_quant_Q13[ ix[ n ][ 0 ] ];
 8011f24:	f932 5014 	ldrsh.w	r5, [r2, r4, lsl #1]
            SILK_FIX_CONST( 0.5 / STEREO_QUANT_SUB_STEPS, 16 ) );
        pred_Q13[ n ] = silk_SMLABB( low_Q13, step_Q13, 2 * ix[ n ][ 1 ] + 1 );
 8011f28:	0040      	lsls	r0, r0, #1
        step_Q13 = silk_SMULWB( silk_stereo_pred_quant_Q13[ ix[ n ][ 0 ] + 1 ] - low_Q13,
 8011f2a:	f932 2013 	ldrsh.w	r2, [r2, r3, lsl #1]
        pred_Q13[ n ] = silk_SMLABB( low_Q13, step_Q13, 2 * ix[ n ][ 1 ] + 1 );
 8011f2e:	007f      	lsls	r7, r7, #1
 8011f30:	f100 0e01 	add.w	lr, r0, #1
 8011f34:	3701      	adds	r7, #1
        step_Q13 = silk_SMULWB( silk_stereo_pred_quant_Q13[ ix[ n ][ 0 ] + 1 ] - low_Q13,
 8011f36:	eba1 040c 	sub.w	r4, r1, ip
 8011f3a:	1b52      	subs	r2, r2, r5
 8011f3c:	4909      	ldr	r1, [pc, #36]	; (8011f64 <silk_stereo_decode_pred+0xb8>)
 8011f3e:	fb84 3001 	smull	r3, r0, r4, r1
 8011f42:	fb82 4301 	smull	r4, r3, r2, r1
        pred_Q13[ n ] = silk_SMLABB( low_Q13, step_Q13, 2 * ix[ n ][ 1 ] + 1 );
 8011f46:	fb10 c00e 	smlabb	r0, r0, lr, ip
 8011f4a:	fb13 5307 	smlabb	r3, r3, r7, r5
    }

    /* Subtract second from first predictor (helps when actually applying these) */
    pred_Q13[ 0 ] -= pred_Q13[ 1 ];
 8011f4e:	1a1b      	subs	r3, r3, r0
 8011f50:	e9c6 3000 	strd	r3, r0, [r6]
}
 8011f54:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011f58:	08017b8c 	.word	0x08017b8c
 8011f5c:	66666667 	.word	0x66666667
 8011f60:	08017ba8 	.word	0x08017ba8
 8011f64:	199a0000 	.word	0x199a0000
 8011f68:	08017bd0 	.word	0x08017bd0
 8011f6c:	08017bd8 	.word	0x08017bd8

08011f70 <silk_stereo_decode_mid_only>:
/* Decode mid-only flag */
void silk_stereo_decode_mid_only(
    ec_dec                      *psRangeDec,                    /* I/O  Compressor data structure                   */
    opus_int                    *decode_only_mid                /* O    Flag that only mid channel has been coded   */
)
{
 8011f70:	b510      	push	{r4, lr}
    /* Decode flag that only mid channel is coded */
    *decode_only_mid = ec_dec_icdf( psRangeDec, silk_stereo_only_code_mid_iCDF, 8 );
 8011f72:	2208      	movs	r2, #8
{
 8011f74:	460c      	mov	r4, r1
    *decode_only_mid = ec_dec_icdf( psRangeDec, silk_stereo_only_code_mid_iCDF, 8 );
 8011f76:	4902      	ldr	r1, [pc, #8]	; (8011f80 <silk_stereo_decode_mid_only+0x10>)
 8011f78:	f7f6 fb08 	bl	800858c <ec_dec_icdf>
 8011f7c:	6020      	str	r0, [r4, #0]
}
 8011f7e:	bd10      	pop	{r4, pc}
 8011f80:	08017b88 	.word	0x08017b88

08011f84 <silk_sum_sqr_shift>:
    opus_int32                  *energy,            /* O   Energy of x, after shifting to the right                     */
    opus_int                    *shift,             /* O   Number of bits right shift applied to energy                 */
    const opus_int16            *x,                 /* I   Input vector                                                 */
    opus_int                    len                 /* I   Length of input vector                                       */
)
{
 8011f84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011f88:	2b00      	cmp	r3, #0
 8011f8a:	d060      	beq.n	801204e <silk_sum_sqr_shift+0xca>
 8011f8c:	fab3 f883 	clz	r8, r3
 8011f90:	f103 39ff 	add.w	r9, r3, #4294967295

    /* Do a first run with the maximum shift we could have. */
    shft = 31-silk_CLZ32(len);
    /* Let's be conservative with rounding and start with nrg=len. */
    nrg  = len;
    for( i = 0; i < len - 1; i += 2 ) {
 8011f94:	f1b9 0f00 	cmp.w	r9, #0
    shft = 31-silk_CLZ32(len);
 8011f98:	f1c8 0c1f 	rsb	ip, r8, #31
 8011f9c:	f1c8 0822 	rsb	r8, r8, #34	; 0x22
    for( i = 0; i < len - 1; i += 2 ) {
 8011fa0:	dd59      	ble.n	8012056 <silk_sum_sqr_shift+0xd2>
 8011fa2:	4615      	mov	r5, r2
 8011fa4:	461e      	mov	r6, r3
 8011fa6:	f1a3 0e02 	sub.w	lr, r3, #2
 8011faa:	ea4f 0e5e 	mov.w	lr, lr, lsr #1
 8011fae:	1d17      	adds	r7, r2, #4
 8011fb0:	eb07 078e 	add.w	r7, r7, lr, lsl #2
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
 8011fb4:	f9b5 a000 	ldrsh.w	sl, [r5]
        nrg_tmp = silk_SMLABB_ovflw( nrg_tmp, x[ i + 1 ], x[ i + 1 ] );
 8011fb8:	f9b5 4002 	ldrsh.w	r4, [r5, #2]
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
 8011fbc:	fb0a fa0a 	mul.w	sl, sl, sl
        nrg_tmp = silk_SMLABB_ovflw( nrg_tmp, x[ i + 1 ], x[ i + 1 ] );
 8011fc0:	fb04 a404 	mla	r4, r4, r4, sl
 8011fc4:	3504      	adds	r5, #4
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
 8011fc6:	fa24 f40c 	lsr.w	r4, r4, ip
    for( i = 0; i < len - 1; i += 2 ) {
 8011fca:	42af      	cmp	r7, r5
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
 8011fcc:	4426      	add	r6, r4
    for( i = 0; i < len - 1; i += 2 ) {
 8011fce:	d1f1      	bne.n	8011fb4 <silk_sum_sqr_shift+0x30>
 8011fd0:	f10e 0e01 	add.w	lr, lr, #1
 8011fd4:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    }
    if( i < len ) {
 8011fd8:	4573      	cmp	r3, lr
 8011fda:	dd06      	ble.n	8011fea <silk_sum_sqr_shift+0x66>
        /* One sample left to process */
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
 8011fdc:	f932 401e 	ldrsh.w	r4, [r2, lr, lsl #1]
 8011fe0:	fb04 f404 	mul.w	r4, r4, r4
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
 8011fe4:	fa24 fc0c 	lsr.w	ip, r4, ip
 8011fe8:	4466      	add	r6, ip
 8011fea:	fab6 f686 	clz	r6, r6
    silk_assert( nrg >= 0 );
    /* Make sure the result will fit in a 32-bit signed integer with two bits
       of headroom. */
    shft = silk_max_32(0, shft+3 - silk_CLZ32(nrg));
    nrg = 0;
    for( i = 0 ; i < len - 1; i += 2 ) {
 8011fee:	f1b9 0f00 	cmp.w	r9, #0
    shft = silk_max_32(0, shft+3 - silk_CLZ32(nrg));
 8011ff2:	eba8 0706 	sub.w	r7, r8, r6
    return (((a) > (b)) ? (a) : (b));
 8011ff6:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
    for( i = 0 ; i < len - 1; i += 2 ) {
 8011ffa:	dd30      	ble.n	801205e <silk_sum_sqr_shift+0xda>
 8011ffc:	4615      	mov	r5, r2
    nrg = 0;
 8011ffe:	f04f 0c00 	mov.w	ip, #0
 8012002:	f1a3 0e02 	sub.w	lr, r3, #2
 8012006:	ea4f 0e5e 	mov.w	lr, lr, lsr #1
 801200a:	f102 0804 	add.w	r8, r2, #4
 801200e:	eb08 088e 	add.w	r8, r8, lr, lsl #2
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
 8012012:	f9b5 6000 	ldrsh.w	r6, [r5]
        nrg_tmp = silk_SMLABB_ovflw( nrg_tmp, x[ i + 1 ], x[ i + 1 ] );
 8012016:	f9b5 4002 	ldrsh.w	r4, [r5, #2]
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
 801201a:	fb06 f606 	mul.w	r6, r6, r6
        nrg_tmp = silk_SMLABB_ovflw( nrg_tmp, x[ i + 1 ], x[ i + 1 ] );
 801201e:	fb04 6404 	mla	r4, r4, r4, r6
 8012022:	3504      	adds	r5, #4
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
 8012024:	40fc      	lsrs	r4, r7
    for( i = 0 ; i < len - 1; i += 2 ) {
 8012026:	45a8      	cmp	r8, r5
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
 8012028:	44a4      	add	ip, r4
    for( i = 0 ; i < len - 1; i += 2 ) {
 801202a:	d1f2      	bne.n	8012012 <silk_sum_sqr_shift+0x8e>
 801202c:	f10e 0e01 	add.w	lr, lr, #1
 8012030:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    }
    if( i < len ) {
 8012034:	4573      	cmp	r3, lr
 8012036:	dd05      	ble.n	8012044 <silk_sum_sqr_shift+0xc0>
        /* One sample left to process */
        nrg_tmp = silk_SMULBB( x[ i ], x[ i ] );
 8012038:	f932 301e 	ldrsh.w	r3, [r2, lr, lsl #1]
 801203c:	fb03 f303 	mul.w	r3, r3, r3
        nrg = (opus_int32)silk_ADD_RSHIFT_uint( nrg, nrg_tmp, shft );
 8012040:	40fb      	lsrs	r3, r7
 8012042:	449c      	add	ip, r3
    }

    silk_assert( nrg >= 0 );

    /* Output arguments */
    *shift  = shft;
 8012044:	600f      	str	r7, [r1, #0]
    *energy = nrg;
 8012046:	f8c0 c000 	str.w	ip, [r0]
}
 801204a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801204e:	461f      	mov	r7, r3
    nrg = 0;
 8012050:	469c      	mov	ip, r3
    for( i = 0 ; i < len - 1; i += 2 ) {
 8012052:	469e      	mov	lr, r3
 8012054:	e7ee      	b.n	8012034 <silk_sum_sqr_shift+0xb0>
    for( i = 0; i < len - 1; i += 2 ) {
 8012056:	461e      	mov	r6, r3
 8012058:	f04f 0e00 	mov.w	lr, #0
 801205c:	e7bc      	b.n	8011fd8 <silk_sum_sqr_shift+0x54>
    nrg = 0;
 801205e:	f04f 0c00 	mov.w	ip, #0
    for( i = 0 ; i < len - 1; i += 2 ) {
 8012062:	46e6      	mov	lr, ip
 8012064:	e7e6      	b.n	8012034 <silk_sum_sqr_shift+0xb0>
 8012066:	bf00      	nop

08012068 <opus_packet_get_samples_per_frame>:

int opus_packet_get_samples_per_frame(const unsigned char *data,
      opus_int32 Fs)
{
   int audiosize;
   if (data[0]&0x80)
 8012068:	7800      	ldrb	r0, [r0, #0]
 801206a:	0603      	lsls	r3, r0, #24
 801206c:	d41c      	bmi.n	80120a8 <opus_packet_get_samples_per_frame+0x40>
   {
      audiosize = ((data[0]>>3)&0x3);
      audiosize = (Fs<<audiosize)/400;
   } else if ((data[0]&0x60) == 0x60)
 801206e:	f000 0360 	and.w	r3, r0, #96	; 0x60
 8012072:	2b60      	cmp	r3, #96	; 0x60
 8012074:	d00b      	beq.n	801208e <opus_packet_get_samples_per_frame+0x26>
 8012076:	f3c0 00c1 	ubfx	r0, r0, #3, #2
   {
      audiosize = (data[0]&0x08) ? Fs/50 : Fs/100;
   } else {
      audiosize = ((data[0]>>3)&0x3);
      if (audiosize == 3)
 801207a:	2803      	cmp	r0, #3
 801207c:	d01e      	beq.n	80120bc <opus_packet_get_samples_per_frame+0x54>
         audiosize = Fs*60/1000;
      else
         audiosize = (Fs<<audiosize)/100;
 801207e:	4b14      	ldr	r3, [pc, #80]	; (80120d0 <opus_packet_get_samples_per_frame+0x68>)
 8012080:	4081      	lsls	r1, r0
 8012082:	fb83 3001 	smull	r3, r0, r3, r1
 8012086:	17c9      	asrs	r1, r1, #31
 8012088:	ebc1 1060 	rsb	r0, r1, r0, asr #5
   }
   return audiosize;
}
 801208c:	4770      	bx	lr
      audiosize = (data[0]&0x08) ? Fs/50 : Fs/100;
 801208e:	4b10      	ldr	r3, [pc, #64]	; (80120d0 <opus_packet_get_samples_per_frame+0x68>)
 8012090:	f010 0f08 	tst.w	r0, #8
 8012094:	ea4f 70e1 	mov.w	r0, r1, asr #31
 8012098:	fb83 3101 	smull	r3, r1, r3, r1
 801209c:	bf14      	ite	ne
 801209e:	ebc0 1021 	rsbne	r0, r0, r1, asr #4
 80120a2:	ebc0 1061 	rsbeq	r0, r0, r1, asr #5
 80120a6:	4770      	bx	lr
      audiosize = ((data[0]>>3)&0x3);
 80120a8:	f3c0 00c1 	ubfx	r0, r0, #3, #2
      audiosize = (Fs<<audiosize)/400;
 80120ac:	4b08      	ldr	r3, [pc, #32]	; (80120d0 <opus_packet_get_samples_per_frame+0x68>)
 80120ae:	4081      	lsls	r1, r0
 80120b0:	fb83 3001 	smull	r3, r0, r3, r1
 80120b4:	17c9      	asrs	r1, r1, #31
 80120b6:	ebc1 10e0 	rsb	r0, r1, r0, asr #7
 80120ba:	4770      	bx	lr
         audiosize = Fs*60/1000;
 80120bc:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 80120c0:	4804      	ldr	r0, [pc, #16]	; (80120d4 <opus_packet_get_samples_per_frame+0x6c>)
 80120c2:	0089      	lsls	r1, r1, #2
 80120c4:	fb80 3001 	smull	r3, r0, r0, r1
 80120c8:	17c9      	asrs	r1, r1, #31
 80120ca:	ebc1 10a0 	rsb	r0, r1, r0, asr #6
 80120ce:	4770      	bx	lr
 80120d0:	51eb851f 	.word	0x51eb851f
 80120d4:	10624dd3 	.word	0x10624dd3

080120d8 <opus_packet_parse_impl>:

int opus_packet_parse_impl(const unsigned char *data, opus_int32 len,
      int self_delimited, unsigned char *out_toc,
      const unsigned char *frames[48], opus_int16 size[48],
      int *payload_offset, opus_int32 *packet_offset)
{
 80120d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80120dc:	b085      	sub	sp, #20
 80120de:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
   int framesize;
   opus_int32 last_size;
   opus_int32 pad = 0;
   const unsigned char *data0 = data;

   if (size==NULL || len<0)
 80120e2:	f1bb 0f00 	cmp.w	fp, #0
 80120e6:	f000 81ff 	beq.w	80124e8 <opus_packet_parse_impl+0x410>
 80120ea:	2900      	cmp	r1, #0
 80120ec:	f2c0 81fc 	blt.w	80124e8 <opus_packet_parse_impl+0x410>
      return OPUS_BAD_ARG;
   if (len==0)
 80120f0:	d07b      	beq.n	80121ea <opus_packet_parse_impl+0x112>
   if (data[0]&0x80)
 80120f2:	7806      	ldrb	r6, [r0, #0]
 80120f4:	0634      	lsls	r4, r6, #24
 80120f6:	f100 80c3 	bmi.w	8012280 <opus_packet_parse_impl+0x1a8>
   } else if ((data[0]&0x60) == 0x60)
 80120fa:	f006 0460 	and.w	r4, r6, #96	; 0x60
 80120fe:	2c60      	cmp	r4, #96	; 0x60
 8012100:	d079      	beq.n	80121f6 <opus_packet_parse_impl+0x11e>
 8012102:	f3c6 04c1 	ubfx	r4, r6, #3, #2
      if (audiosize == 3)
 8012106:	2c03      	cmp	r4, #3
 8012108:	f000 8134 	beq.w	8012374 <opus_packet_parse_impl+0x29c>
         audiosize = (Fs<<audiosize)/100;
 801210c:	f64b 3580 	movw	r5, #48000	; 0xbb80
 8012110:	4fc1      	ldr	r7, [pc, #772]	; (8012418 <opus_packet_parse_impl+0x340>)
 8012112:	40a5      	lsls	r5, r4
 8012114:	fba7 4505 	umull	r4, r5, r7, r5
 8012118:	096d      	lsrs	r5, r5, #5

   cbr = 0;
   toc = *data++;
   len--;
   last_size = len;
   switch (toc&0x3)
 801211a:	f006 0703 	and.w	r7, r6, #3
 801211e:	2f01      	cmp	r7, #1
   toc = *data++;
 8012120:	f100 0401 	add.w	r4, r0, #1
   len--;
 8012124:	f101 3eff 	add.w	lr, r1, #4294967295
   switch (toc&0x3)
 8012128:	d074      	beq.n	8012214 <opus_packet_parse_impl+0x13c>
 801212a:	f0c0 80db 	bcc.w	80122e4 <opus_packet_parse_impl+0x20c>
 801212e:	2f02      	cmp	r7, #2
 8012130:	f040 80b0 	bne.w	8012294 <opus_packet_parse_impl+0x1bc>
   if (len<1)
 8012134:	f1be 0f00 	cmp.w	lr, #0
 8012138:	d053      	beq.n	80121e2 <opus_packet_parse_impl+0x10a>
   } else if (data[0]<252)
 801213a:	f890 c001 	ldrb.w	ip, [r0, #1]
 801213e:	f1bc 0ffb 	cmp.w	ip, #251	; 0xfb
 8012142:	f200 811a 	bhi.w	801237a <opus_packet_parse_impl+0x2a2>
      break;
   /* Two VBR frames */
   case 2:
      count = 2;
      bytes = parse_size(data, len, size);
      len -= bytes;
 8012146:	2501      	movs	r5, #1
      *size = data[0];
 8012148:	fa0f fc8c 	sxth.w	ip, ip
 801214c:	f8ab c000 	strh.w	ip, [fp]
      len -= bytes;
 8012150:	f1a1 0e02 	sub.w	lr, r1, #2
      if (size[0]<0 || size[0] > len)
 8012154:	45f4      	cmp	ip, lr
 8012156:	dc48      	bgt.n	80121ea <opus_packet_parse_impl+0x112>
   opus_int32 pad = 0;
 8012158:	2700      	movs	r7, #0
         return OPUS_INVALID_PACKET;
      data += bytes;
      last_size = len-size[0];
 801215a:	ebae 010c 	sub.w	r1, lr, ip
      count = 2;
 801215e:	f04f 0c02 	mov.w	ip, #2
   cbr = 0;
 8012162:	e9cd 1700 	strd	r1, r7, [sp]
      data += bytes;
 8012166:	442c      	add	r4, r5
            size[i] = (opus_int16)last_size;
      }
      break;
   }
   /* Self-delimited framing has an extra size for the last frame. */
   if (self_delimited)
 8012168:	2a00      	cmp	r2, #0
 801216a:	d05f      	beq.n	801222c <opus_packet_parse_impl+0x154>
 801216c:	f10c 4200 	add.w	r2, ip, #2147483648	; 0x80000000
 8012170:	3a01      	subs	r2, #1
 8012172:	4675      	mov	r5, lr
 8012174:	f8dd e000 	ldr.w	lr, [sp]
 8012178:	0052      	lsls	r2, r2, #1
   {
      bytes = parse_size(data, len, size+count-1);
 801217a:	eb0b 0102 	add.w	r1, fp, r2
   if (len<1)
 801217e:	2d00      	cmp	r5, #0
 8012180:	f000 80d1 	beq.w	8012326 <opus_packet_parse_impl+0x24e>
   } else if (data[0]<252)
 8012184:	f894 9000 	ldrb.w	r9, [r4]
 8012188:	f1b9 0ffb 	cmp.w	r9, #251	; 0xfb
 801218c:	f240 80b8 	bls.w	8012300 <opus_packet_parse_impl+0x228>
   } else if (len<2)
 8012190:	2d01      	cmp	r5, #1
 8012192:	f000 81a5 	beq.w	80124e0 <opus_packet_parse_impl+0x408>
      len -= bytes;
 8012196:	f04f 0802 	mov.w	r8, #2
      return 2;
 801219a:	46c2      	mov	sl, r8
      *size = 4*data[1] + data[0];
 801219c:	7862      	ldrb	r2, [r4, #1]
      len -= bytes;
 801219e:	3d02      	subs	r5, #2
      *size = 4*data[1] + data[0];
 80121a0:	eb09 0982 	add.w	r9, r9, r2, lsl #2
 80121a4:	f8a1 9000 	strh.w	r9, [r1]
      if (size[count-1]<0 || size[count-1] > len)
 80121a8:	45a9      	cmp	r9, r5
 80121aa:	dc1e      	bgt.n	80121ea <opus_packet_parse_impl+0x112>
         return OPUS_INVALID_PACKET;
      data += bytes;
      /* For CBR packets, apply the size to all the frames. */
      if (cbr)
 80121ac:	9a01      	ldr	r2, [sp, #4]
      data += bytes;
 80121ae:	4444      	add	r4, r8
      if (cbr)
 80121b0:	2a00      	cmp	r2, #0
 80121b2:	f000 80da 	beq.w	801236a <opus_packet_parse_impl+0x292>
      {
         if (size[count-1]*count > len)
 80121b6:	fb0c f209 	mul.w	r2, ip, r9
 80121ba:	42aa      	cmp	r2, r5
 80121bc:	dc15      	bgt.n	80121ea <opus_packet_parse_impl+0x112>
            return OPUS_INVALID_PACKET;
         for (i=0;i<count-1;i++)
 80121be:	f1bc 0f01 	cmp.w	ip, #1
 80121c2:	f1ab 0802 	sub.w	r8, fp, #2
 80121c6:	d03d      	beq.n	8012244 <opus_packet_parse_impl+0x16c>
 80121c8:	f1ab 0504 	sub.w	r5, fp, #4
 80121cc:	4642      	mov	r2, r8
 80121ce:	eb05 054c 	add.w	r5, r5, ip, lsl #1
 80121d2:	e001      	b.n	80121d8 <opus_packet_parse_impl+0x100>
 80121d4:	f9b1 9000 	ldrsh.w	r9, [r1]
            size[i] = size[count-1];
 80121d8:	f822 9f02 	strh.w	r9, [r2, #2]!
         for (i=0;i<count-1;i++)
 80121dc:	4295      	cmp	r5, r2
 80121de:	d1f9      	bne.n	80121d4 <opus_packet_parse_impl+0xfc>
 80121e0:	e030      	b.n	8012244 <opus_packet_parse_impl+0x16c>
      *size = -1;
 80121e2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80121e6:	f8ab 3000 	strh.w	r3, [fp]
         return OPUS_INVALID_PACKET;
 80121ea:	f06f 0c03 	mvn.w	ip, #3

   if (out_toc)
      *out_toc = toc;

   return count;
}
 80121ee:	4660      	mov	r0, ip
 80121f0:	b005      	add	sp, #20
 80121f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      audiosize = (data[0]&0x08) ? Fs/50 : Fs/100;
 80121f6:	f016 0f08 	tst.w	r6, #8
   switch (toc&0x3)
 80121fa:	f006 0703 	and.w	r7, r6, #3
      audiosize = (data[0]&0x08) ? Fs/50 : Fs/100;
 80121fe:	bf0c      	ite	eq
 8012200:	f44f 75f0 	moveq.w	r5, #480	; 0x1e0
 8012204:	f44f 7570 	movne.w	r5, #960	; 0x3c0
   switch (toc&0x3)
 8012208:	2f01      	cmp	r7, #1
   toc = *data++;
 801220a:	f100 0401 	add.w	r4, r0, #1
   len--;
 801220e:	f101 3eff 	add.w	lr, r1, #4294967295
   switch (toc&0x3)
 8012212:	d18a      	bne.n	801212a <opus_packet_parse_impl+0x52>
      if (!self_delimited)
 8012214:	2a00      	cmp	r2, #0
 8012216:	d17c      	bne.n	8012312 <opus_packet_parse_impl+0x23a>
         if (len&0x1)
 8012218:	f01e 0701 	ands.w	r7, lr, #1
 801221c:	d1e5      	bne.n	80121ea <opus_packet_parse_impl+0x112>
      count=2;
 801221e:	f04f 0c02 	mov.w	ip, #2
         last_size = len/2;
 8012222:	ea4f 026e 	mov.w	r2, lr, asr #1
 8012226:	9200      	str	r2, [sp, #0]
         size[0] = (opus_int16)last_size;
 8012228:	f8ab 2000 	strh.w	r2, [fp]
      if (last_size > 1275)
 801222c:	f240 42fb 	movw	r2, #1275	; 0x4fb
 8012230:	9900      	ldr	r1, [sp, #0]
 8012232:	4291      	cmp	r1, r2
 8012234:	dcd9      	bgt.n	80121ea <opus_packet_parse_impl+0x112>
      size[count-1] = (opus_int16)last_size;
 8012236:	f10c 4200 	add.w	r2, ip, #2147483648	; 0x80000000
 801223a:	3a01      	subs	r2, #1
 801223c:	f82b 1012 	strh.w	r1, [fp, r2, lsl #1]
 8012240:	f1ab 0802 	sub.w	r8, fp, #2
   if (payload_offset)
 8012244:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8012246:	b112      	cbz	r2, 801224e <opus_packet_parse_impl+0x176>
 8012248:	4611      	mov	r1, r2
      *payload_offset = (int)(data-data0);
 801224a:	1a22      	subs	r2, r4, r0
 801224c:	600a      	str	r2, [r1, #0]
 801224e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8012250:	2a00      	cmp	r2, #0
 8012252:	d04d      	beq.n	80122f0 <opus_packet_parse_impl+0x218>
 8012254:	3a04      	subs	r2, #4
 8012256:	eb02 058c 	add.w	r5, r2, ip, lsl #2
      data += size[i];
 801225a:	f938 1f02 	ldrsh.w	r1, [r8, #2]!
         frames[i] = data;
 801225e:	f842 4f04 	str.w	r4, [r2, #4]!
   for (i=0;i<count;i++)
 8012262:	4295      	cmp	r5, r2
      data += size[i];
 8012264:	440c      	add	r4, r1
   for (i=0;i<count;i++)
 8012266:	d1f8      	bne.n	801225a <opus_packet_parse_impl+0x182>
   if (packet_offset)
 8012268:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801226a:	b112      	cbz	r2, 8012272 <opus_packet_parse_impl+0x19a>
      *packet_offset = pad+(opus_int32)(data-data0);
 801226c:	1a20      	subs	r0, r4, r0
 801226e:	4407      	add	r7, r0
 8012270:	6017      	str	r7, [r2, #0]
   if (out_toc)
 8012272:	2b00      	cmp	r3, #0
 8012274:	d0bb      	beq.n	80121ee <opus_packet_parse_impl+0x116>
}
 8012276:	4660      	mov	r0, ip
      *out_toc = toc;
 8012278:	701e      	strb	r6, [r3, #0]
}
 801227a:	b005      	add	sp, #20
 801227c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      audiosize = (Fs<<audiosize)/400;
 8012280:	f64b 3580 	movw	r5, #48000	; 0xbb80
      audiosize = ((data[0]>>3)&0x3);
 8012284:	f3c6 07c1 	ubfx	r7, r6, #3, #2
      audiosize = (Fs<<audiosize)/400;
 8012288:	4c63      	ldr	r4, [pc, #396]	; (8012418 <opus_packet_parse_impl+0x340>)
 801228a:	40bd      	lsls	r5, r7
 801228c:	fba4 4505 	umull	r4, r5, r4, r5
 8012290:	09ed      	lsrs	r5, r5, #7
 8012292:	e742      	b.n	801211a <opus_packet_parse_impl+0x42>
      if (len<1)
 8012294:	f1be 0f00 	cmp.w	lr, #0
 8012298:	d0a7      	beq.n	80121ea <opus_packet_parse_impl+0x112>
      ch = *data++;
 801229a:	f890 8001 	ldrb.w	r8, [r0, #1]
 801229e:	f008 093f 	and.w	r9, r8, #63	; 0x3f
      count = ch&0x3F;
 80122a2:	46cc      	mov	ip, r9
      if (count <= 0 || framesize*(opus_int32)count > 5760)
 80122a4:	f1b9 0f00 	cmp.w	r9, #0
 80122a8:	d09f      	beq.n	80121ea <opus_packet_parse_impl+0x112>
 80122aa:	fb05 f509 	mul.w	r5, r5, r9
 80122ae:	f5b5 5fb4 	cmp.w	r5, #5760	; 0x1680
 80122b2:	dc9a      	bgt.n	80121ea <opus_packet_parse_impl+0x112>
      if (ch&0x40)
 80122b4:	f018 0740 	ands.w	r7, r8, #64	; 0x40
      len--;
 80122b8:	f1a1 0502 	sub.w	r5, r1, #2
      if (ch&0x40)
 80122bc:	d138      	bne.n	8012330 <opus_packet_parse_impl+0x258>
      ch = *data++;
 80122be:	1c84      	adds	r4, r0, #2
      cbr = !(ch&0x80);
 80122c0:	fa4f f888 	sxtb.w	r8, r8
 80122c4:	ea6f 0108 	mvn.w	r1, r8
      if (!cbr)
 80122c8:	f1b8 0f00 	cmp.w	r8, #0
      cbr = !(ch&0x80);
 80122cc:	ea4f 71d1 	mov.w	r1, r1, lsr #31
 80122d0:	9101      	str	r1, [sp, #4]
      if (!cbr)
 80122d2:	db5f      	blt.n	8012394 <opus_packet_parse_impl+0x2bc>
      } else if (!self_delimited)
 80122d4:	2a00      	cmp	r2, #0
 80122d6:	f000 80a1 	beq.w	801241c <opus_packet_parse_impl+0x344>
 80122da:	f109 4200 	add.w	r2, r9, #2147483648	; 0x80000000
 80122de:	3a01      	subs	r2, #1
 80122e0:	0052      	lsls	r2, r2, #1
 80122e2:	e74a      	b.n	801217a <opus_packet_parse_impl+0xa2>
   opus_int32 pad = 0;
 80122e4:	2700      	movs	r7, #0
      count=1;
 80122e6:	f04f 0c01 	mov.w	ip, #1
   cbr = 0;
 80122ea:	e9cd e700 	strd	lr, r7, [sp]
 80122ee:	e73b      	b.n	8012168 <opus_packet_parse_impl+0x90>
 80122f0:	eb08 014c 	add.w	r1, r8, ip, lsl #1
      data += size[i];
 80122f4:	f938 2f02 	ldrsh.w	r2, [r8, #2]!
   for (i=0;i<count;i++)
 80122f8:	4541      	cmp	r1, r8
      data += size[i];
 80122fa:	4414      	add	r4, r2
   for (i=0;i<count;i++)
 80122fc:	d1fa      	bne.n	80122f4 <opus_packet_parse_impl+0x21c>
 80122fe:	e7b3      	b.n	8012268 <opus_packet_parse_impl+0x190>
      len -= bytes;
 8012300:	f04f 0801 	mov.w	r8, #1
      *size = data[0];
 8012304:	fa0f f989 	sxth.w	r9, r9
 8012308:	f8a1 9000 	strh.w	r9, [r1]
      len -= bytes;
 801230c:	3d01      	subs	r5, #1
      return 1;
 801230e:	46c2      	mov	sl, r8
 8012310:	e74a      	b.n	80121a8 <opus_packet_parse_impl+0xd0>
 8012312:	2202      	movs	r2, #2
   len--;
 8012314:	4675      	mov	r5, lr
      cbr = 1;
 8012316:	9701      	str	r7, [sp, #4]
      count=2;
 8012318:	4694      	mov	ip, r2
   opus_int32 pad = 0;
 801231a:	2700      	movs	r7, #0
      bytes = parse_size(data, len, size+count-1);
 801231c:	eb0b 0102 	add.w	r1, fp, r2
   if (len<1)
 8012320:	2d00      	cmp	r5, #0
 8012322:	f47f af2f 	bne.w	8012184 <opus_packet_parse_impl+0xac>
      *size = -1;
 8012326:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801232a:	f82b 3002 	strh.w	r3, [fp, r2]
 801232e:	e75c      	b.n	80121ea <opus_packet_parse_impl+0x112>
            if (len<=0)
 8012330:	2d00      	cmp	r5, #0
 8012332:	f43f af5a 	beq.w	80121ea <opus_packet_parse_impl+0x112>
            p = *data++;
 8012336:	7885      	ldrb	r5, [r0, #2]
            len--;
 8012338:	3903      	subs	r1, #3
            tmp = p==255 ? 254: p;
 801233a:	2dff      	cmp	r5, #255	; 0xff
            p = *data++;
 801233c:	f100 0403 	add.w	r4, r0, #3
   opus_int32 pad = 0;
 8012340:	f04f 0700 	mov.w	r7, #0
            tmp = p==255 ? 254: p;
 8012344:	d003      	beq.n	801234e <opus_packet_parse_impl+0x276>
            pad += tmp;
 8012346:	442f      	add	r7, r5
      if (len<0)
 8012348:	1b4d      	subs	r5, r1, r5
 801234a:	d5b9      	bpl.n	80122c0 <opus_packet_parse_impl+0x1e8>
 801234c:	e74d      	b.n	80121ea <opus_packet_parse_impl+0x112>
 801234e:	f1a1 05fe 	sub.w	r5, r1, #254	; 0xfe
            if (len<=0)
 8012352:	2d00      	cmp	r5, #0
            pad += tmp;
 8012354:	f107 07fe 	add.w	r7, r7, #254	; 0xfe
            len--;
 8012358:	f1a1 01ff 	sub.w	r1, r1, #255	; 0xff
            if (len<=0)
 801235c:	f77f af45 	ble.w	80121ea <opus_packet_parse_impl+0x112>
            p = *data++;
 8012360:	f814 5b01 	ldrb.w	r5, [r4], #1
            tmp = p==255 ? 254: p;
 8012364:	2dff      	cmp	r5, #255	; 0xff
 8012366:	d1ee      	bne.n	8012346 <opus_packet_parse_impl+0x26e>
 8012368:	e7f1      	b.n	801234e <opus_packet_parse_impl+0x276>
      } else if (bytes+size[count-1] > last_size)
 801236a:	44d1      	add	r9, sl
 801236c:	45f1      	cmp	r9, lr
 801236e:	f77f af67 	ble.w	8012240 <opus_packet_parse_impl+0x168>
 8012372:	e73a      	b.n	80121ea <opus_packet_parse_impl+0x112>
         audiosize = Fs*60/1000;
 8012374:	f44f 6534 	mov.w	r5, #2880	; 0xb40
 8012378:	e6cf      	b.n	801211a <opus_packet_parse_impl+0x42>
   } else if (len<2)
 801237a:	f1be 0f01 	cmp.w	lr, #1
 801237e:	f43f af30 	beq.w	80121e2 <opus_packet_parse_impl+0x10a>
      len -= bytes;
 8012382:	463d      	mov	r5, r7
      *size = 4*data[1] + data[0];
 8012384:	7887      	ldrb	r7, [r0, #2]
      len -= bytes;
 8012386:	f1a1 0e03 	sub.w	lr, r1, #3
      *size = 4*data[1] + data[0];
 801238a:	eb0c 0c87 	add.w	ip, ip, r7, lsl #2
 801238e:	f8ab c000 	strh.w	ip, [fp]
 8012392:	e6df      	b.n	8012154 <opus_packet_parse_impl+0x7c>
         for (i=0;i<count-1;i++)
 8012394:	f1b9 0f01 	cmp.w	r9, #1
 8012398:	f000 80a9 	beq.w	80124ee <opus_packet_parse_impl+0x416>
 801239c:	f1ab 0802 	sub.w	r8, fp, #2
 80123a0:	eb08 0149 	add.w	r1, r8, r9, lsl #1
 80123a4:	9100      	str	r1, [sp, #0]
 80123a6:	46de      	mov	lr, fp
 80123a8:	4629      	mov	r1, r5
 80123aa:	e9cd 7602 	strd	r7, r6, [sp, #8]
 80123ae:	f8dd a000 	ldr.w	sl, [sp]
   if (len<1)
 80123b2:	b1fd      	cbz	r5, 80123f4 <opus_packet_parse_impl+0x31c>
   } else if (data[0]<252)
 80123b4:	f894 8000 	ldrb.w	r8, [r4]
 80123b8:	f1b8 0ffb 	cmp.w	r8, #251	; 0xfb
      *size = data[0];
 80123bc:	fa0f f688 	sxth.w	r6, r8
   } else if (data[0]<252)
 80123c0:	d81d      	bhi.n	80123fe <opus_packet_parse_impl+0x326>
            len -= bytes;
 80123c2:	f04f 0901 	mov.w	r9, #1
      return 1;
 80123c6:	464f      	mov	r7, r9
      *size = data[0];
 80123c8:	f8ae 6000 	strh.w	r6, [lr]
            len -= bytes;
 80123cc:	3d01      	subs	r5, #1
            last_size -= bytes+size[i];
 80123ce:	4437      	add	r7, r6
            if (size[i]<0 || size[i] > len)
 80123d0:	42ae      	cmp	r6, r5
 80123d2:	f10e 0e02 	add.w	lr, lr, #2
            data += bytes;
 80123d6:	444c      	add	r4, r9
            last_size -= bytes+size[i];
 80123d8:	eba1 0107 	sub.w	r1, r1, r7
            if (size[i]<0 || size[i] > len)
 80123dc:	f73f af05 	bgt.w	80121ea <opus_packet_parse_impl+0x112>
         for (i=0;i<count-1;i++)
 80123e0:	45f2      	cmp	sl, lr
 80123e2:	d1e6      	bne.n	80123b2 <opus_packet_parse_impl+0x2da>
         if (last_size<0)
 80123e4:	2900      	cmp	r1, #0
 80123e6:	9100      	str	r1, [sp, #0]
 80123e8:	e9dd 7602 	ldrd	r7, r6, [sp, #8]
 80123ec:	f6ff aefd 	blt.w	80121ea <opus_packet_parse_impl+0x112>
 80123f0:	46ae      	mov	lr, r5
 80123f2:	e6b9      	b.n	8012168 <opus_packet_parse_impl+0x90>
      *size = -1;
 80123f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80123f8:	f8ae 3000 	strh.w	r3, [lr]
 80123fc:	e6f5      	b.n	80121ea <opus_packet_parse_impl+0x112>
   } else if (len<2)
 80123fe:	2d01      	cmp	r5, #1
 8012400:	d0f8      	beq.n	80123f4 <opus_packet_parse_impl+0x31c>
            len -= bytes;
 8012402:	f04f 0902 	mov.w	r9, #2
      *size = 4*data[1] + data[0];
 8012406:	7866      	ldrb	r6, [r4, #1]
      return 2;
 8012408:	464f      	mov	r7, r9
      *size = 4*data[1] + data[0];
 801240a:	eb08 0686 	add.w	r6, r8, r6, lsl #2
            len -= bytes;
 801240e:	3d02      	subs	r5, #2
      *size = 4*data[1] + data[0];
 8012410:	f8ae 6000 	strh.w	r6, [lr]
 8012414:	e7db      	b.n	80123ce <opus_packet_parse_impl+0x2f6>
 8012416:	bf00      	nop
 8012418:	51eb851f 	.word	0x51eb851f
         last_size = len/count;
 801241c:	fb95 f1f9 	sdiv	r1, r5, r9
         if (last_size*count!=len)
 8012420:	fb01 fe09 	mul.w	lr, r1, r9
 8012424:	45ae      	cmp	lr, r5
 8012426:	9100      	str	r1, [sp, #0]
 8012428:	f47f aedf 	bne.w	80121ea <opus_packet_parse_impl+0x112>
         for (i=0;i<count-1;i++)
 801242c:	f1b9 0101 	subs.w	r1, r9, #1
 8012430:	9101      	str	r1, [sp, #4]
 8012432:	f43f aefb 	beq.w	801222c <opus_packet_parse_impl+0x154>
 8012436:	f1a9 0902 	sub.w	r9, r9, #2
 801243a:	f1b9 0f04 	cmp.w	r9, #4
 801243e:	f9bd a000 	ldrsh.w	sl, [sp]
 8012442:	f3cb 0e40 	ubfx	lr, fp, #1, #1
 8012446:	d929      	bls.n	801249c <opus_packet_parse_impl+0x3c4>
 8012448:	f1be 0f00 	cmp.w	lr, #0
 801244c:	d002      	beq.n	8012454 <opus_packet_parse_impl+0x37c>
 801244e:	2201      	movs	r2, #1
            size[i] = (opus_int16)last_size;
 8012450:	f8ab a000 	strh.w	sl, [fp]
 8012454:	f04f 0800 	mov.w	r8, #0
 8012458:	9901      	ldr	r1, [sp, #4]
         for (i=0;i<count-1;i++)
 801245a:	f8cd 800c 	str.w	r8, [sp, #12]
 801245e:	eba1 050e 	sub.w	r5, r1, lr
 8012462:	9502      	str	r5, [sp, #8]
 8012464:	ea4f 0955 	mov.w	r9, r5, lsr #1
 8012468:	2500      	movs	r5, #0
 801246a:	f36a 080f 	bfi	r8, sl, #0, #16
 801246e:	f36a 481f 	bfi	r8, sl, #16, #16
 8012472:	9900      	ldr	r1, [sp, #0]
 8012474:	f8cd 8000 	str.w	r8, [sp]
 8012478:	4698      	mov	r8, r3
 801247a:	9b00      	ldr	r3, [sp, #0]
 801247c:	eb0b 0e4e 	add.w	lr, fp, lr, lsl #1
 8012480:	3501      	adds	r5, #1
 8012482:	454d      	cmp	r5, r9
            size[i] = (opus_int16)last_size;
 8012484:	f84e 3b04 	str.w	r3, [lr], #4
 8012488:	d3fa      	bcc.n	8012480 <opus_packet_parse_impl+0x3a8>
 801248a:	9d02      	ldr	r5, [sp, #8]
 801248c:	9100      	str	r1, [sp, #0]
 801248e:	f025 0101 	bic.w	r1, r5, #1
 8012492:	42a9      	cmp	r1, r5
 8012494:	4643      	mov	r3, r8
 8012496:	440a      	add	r2, r1
 8012498:	f43f aec8 	beq.w	801222c <opus_packet_parse_impl+0x154>
         for (i=0;i<count-1;i++)
 801249c:	9d01      	ldr	r5, [sp, #4]
 801249e:	f102 0e01 	add.w	lr, r2, #1
 80124a2:	4575      	cmp	r5, lr
            size[i] = (opus_int16)last_size;
 80124a4:	f82b a012 	strh.w	sl, [fp, r2, lsl #1]
 80124a8:	ea4f 0142 	mov.w	r1, r2, lsl #1
         for (i=0;i<count-1;i++)
 80124ac:	f77f aebe 	ble.w	801222c <opus_packet_parse_impl+0x154>
 80124b0:	f102 0e02 	add.w	lr, r2, #2
            size[i] = (opus_int16)last_size;
 80124b4:	4459      	add	r1, fp
         for (i=0;i<count-1;i++)
 80124b6:	4575      	cmp	r5, lr
            size[i] = (opus_int16)last_size;
 80124b8:	f8a1 a002 	strh.w	sl, [r1, #2]
         for (i=0;i<count-1;i++)
 80124bc:	f77f aeb6 	ble.w	801222c <opus_packet_parse_impl+0x154>
 80124c0:	f102 0e03 	add.w	lr, r2, #3
 80124c4:	4575      	cmp	r5, lr
            size[i] = (opus_int16)last_size;
 80124c6:	f8a1 a004 	strh.w	sl, [r1, #4]
         for (i=0;i<count-1;i++)
 80124ca:	f77f aeaf 	ble.w	801222c <opus_packet_parse_impl+0x154>
 80124ce:	3204      	adds	r2, #4
 80124d0:	4295      	cmp	r5, r2
            size[i] = (opus_int16)last_size;
 80124d2:	f8a1 a006 	strh.w	sl, [r1, #6]
         for (i=0;i<count-1;i++)
 80124d6:	f77f aea9 	ble.w	801222c <opus_packet_parse_impl+0x154>
            size[i] = (opus_int16)last_size;
 80124da:	f8a1 a008 	strh.w	sl, [r1, #8]
 80124de:	e6a5      	b.n	801222c <opus_packet_parse_impl+0x154>
      *size = -1;
 80124e0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80124e4:	800b      	strh	r3, [r1, #0]
 80124e6:	e680      	b.n	80121ea <opus_packet_parse_impl+0x112>
      return OPUS_BAD_ARG;
 80124e8:	f04f 3cff 	mov.w	ip, #4294967295
 80124ec:	e67f      	b.n	80121ee <opus_packet_parse_impl+0x116>
         for (i=0;i<count-1;i++)
 80124ee:	46ae      	mov	lr, r5
 80124f0:	9500      	str	r5, [sp, #0]
 80124f2:	e639      	b.n	8012168 <opus_packet_parse_impl+0x90>

080124f4 <smooth_fade>:
static void smooth_fade(const opus_val16 *in1, const opus_val16 *in2,
      opus_val16 *out, int overlap, int channels,
      const opus_val16 *window, opus_int32 Fs)
{
   int i, c;
   int inc = 48000/Fs;
 80124f4:	f64b 3c80 	movw	ip, #48000	; 0xbb80
{
 80124f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80124fc:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80124fe:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   for (c=0;c<channels;c++)
 8012500:	2c00      	cmp	r4, #0
   int inc = 48000/Fs;
 8012502:	fb9c fcf5 	sdiv	ip, ip, r5
   for (c=0;c<channels;c++)
 8012506:	dd2b      	ble.n	8012560 <smooth_fade+0x6c>
 8012508:	2b00      	cmp	r3, #0
 801250a:	dd29      	ble.n	8012560 <smooth_fade+0x6c>
   {
      for (i=0;i<overlap;i++)
      {
         opus_val16 w = MULT16_16_Q15(window[i*inc], window[i*inc]);
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 801250c:	f647 78ff 	movw	r8, #32767	; 0x7fff
 8012510:	ea4f 0e44 	mov.w	lr, r4, lsl #1
 8012514:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 8012518:	eb01 090e 	add.w	r9, r1, lr
{
 801251c:	2500      	movs	r5, #0
      for (i=0;i<overlap;i++)
 801251e:	462e      	mov	r6, r5
 8012520:	9f0a      	ldr	r7, [sp, #40]	; 0x28
         opus_val16 w = MULT16_16_Q15(window[i*inc], window[i*inc]);
 8012522:	f9b7 a000 	ldrsh.w	sl, [r7]
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012526:	f830 b005 	ldrh.w	fp, [r0, r5]
         opus_val16 w = MULT16_16_Q15(window[i*inc], window[i*inc]);
 801252a:	fb0a fa0a 	mul.w	sl, sl, sl
 801252e:	ea4f 34ea 	mov.w	r4, sl, asr #15
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012532:	eba8 0a04 	sub.w	sl, r8, r4
 8012536:	fb1b fb0a 	smulbb	fp, fp, sl
 801253a:	f831 a005 	ldrh.w	sl, [r1, r5]
      for (i=0;i<overlap;i++)
 801253e:	3601      	adds	r6, #1
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012540:	fb14 b40a 	smlabb	r4, r4, sl, fp
      for (i=0;i<overlap;i++)
 8012544:	42b3      	cmp	r3, r6
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012546:	ea4f 34e4 	mov.w	r4, r4, asr #15
 801254a:	5354      	strh	r4, [r2, r5]
 801254c:	4467      	add	r7, ip
 801254e:	4475      	add	r5, lr
      for (i=0;i<overlap;i++)
 8012550:	d1e7      	bne.n	8012522 <smooth_fade+0x2e>
 8012552:	3102      	adds	r1, #2
   for (c=0;c<channels;c++)
 8012554:	4589      	cmp	r9, r1
 8012556:	f100 0002 	add.w	r0, r0, #2
 801255a:	f102 0202 	add.w	r2, r2, #2
 801255e:	d1dd      	bne.n	801251c <smooth_fade+0x28>
                                   Q15ONE-w, in1[i*channels+c]), 15);
      }
   }
}
 8012560:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08012564 <opus_decode_frame>:
   return mode;
}

static int opus_decode_frame(OpusDecoder *st, const unsigned char *data,
      opus_int32 len, opus_val16 *pcm, int frame_size, int decode_fec)
{
 8012564:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012568:	b0a9      	sub	sp, #164	; 0xa4
 801256a:	4604      	mov	r4, r0
   int celt_accum;
   ALLOC_STACK;

   silk_dec = (char*)st+st->silk_dec_offset;
   celt_dec = (CELTDecoder*)((char*)st+st->celt_dec_offset);
   F20 = st->Fs/50;
 801256c:	68c5      	ldr	r5, [r0, #12]
 801256e:	f8df c2e4 	ldr.w	ip, [pc, #740]	; 8012854 <opus_decode_frame+0x2f0>
 8012572:	17e8      	asrs	r0, r5, #31
 8012574:	fb8c 5c05 	smull	r5, ip, ip, r5
{
 8012578:	af04      	add	r7, sp, #16
   F20 = st->Fs/50;
 801257a:	ebc0 1a2c 	rsb	sl, r0, ip, asr #4
{
 801257e:	63bb      	str	r3, [r7, #56]	; 0x38
   F10 = F20>>1;
   F5 = F10>>1;
 8012580:	ea4f 03aa 	mov.w	r3, sl, asr #2
 8012584:	633b      	str	r3, [r7, #48]	; 0x30
   celt_dec = (CELTDecoder*)((char*)st+st->celt_dec_offset);
 8012586:	e9d4 3800 	ldrd	r3, r8, [r4]
 801258a:	637b      	str	r3, [r7, #52]	; 0x34
   opus_uint32 redundant_rng = 0;
 801258c:	2300      	movs	r3, #0
{
 801258e:	f8d7 50b8 	ldr.w	r5, [r7, #184]	; 0xb8
   F2_5 = F5>>1;
 8012592:	ea4f 06ea 	mov.w	r6, sl, asr #3
   if (frame_size < F2_5)
 8012596:	42ae      	cmp	r6, r5
   F2_5 = F5>>1;
 8012598:	627e      	str	r6, [r7, #36]	; 0x24
   opus_uint32 redundant_rng = 0;
 801259a:	65bb      	str	r3, [r7, #88]	; 0x58
{
 801259c:	6439      	str	r1, [r7, #64]	; 0x40
 801259e:	62fa      	str	r2, [r7, #44]	; 0x2c
   if (frame_size < F2_5)
 80125a0:	f300 83f6 	bgt.w	8012d90 <opus_decode_frame+0x82c>
   {
      RESTORE_STACK;
      return OPUS_BUFFER_TOO_SMALL;
   }
   /* Limit frame_size to avoid excessive stack allocations. */
   frame_size = IMIN(frame_size, st->Fs/25*3);
 80125a4:	ebc0 00ec 	rsb	r0, r0, ip, asr #3
 80125a8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80125ac:	4285      	cmp	r5, r0
 80125ae:	bfa8      	it	ge
 80125b0:	4605      	movge	r5, r0
   /* Payloads of 1 (2 including ToC) or 0 trigger the PLC/DTX */
   if (len<=1)
 80125b2:	2a01      	cmp	r2, #1
 80125b4:	ea4f 096a 	mov.w	r9, sl, asr #1
 80125b8:	dd27      	ble.n	801260a <opus_decode_frame+0xa6>
 80125ba:	460b      	mov	r3, r1
   {
      data = NULL;
      /* In that case, don't conceal more than what the ToC says */
      frame_size = IMIN(frame_size, st->frame_size);
   }
   if (data != NULL)
 80125bc:	b349      	cbz	r1, 8012612 <opus_decode_frame+0xae>
   {
      audiosize = st->frame_size;
      mode = st->mode;
      bandwidth = st->bandwidth;
      ec_dec_init(&dec,(unsigned char*)data,len);
 80125be:	f107 0360 	add.w	r3, r7, #96	; 0x60
      mode = st->mode;
 80125c2:	6ba6      	ldr	r6, [r4, #56]	; 0x38
      ec_dec_init(&dec,(unsigned char*)data,len);
 80125c4:	647b      	str	r3, [r7, #68]	; 0x44
 80125c6:	4618      	mov	r0, r3
      bandwidth = st->bandwidth;
 80125c8:	6b63      	ldr	r3, [r4, #52]	; 0x34
      audiosize = st->frame_size;
 80125ca:	f8d4 b040 	ldr.w	fp, [r4, #64]	; 0x40
      bandwidth = st->bandwidth;
 80125ce:	61fb      	str	r3, [r7, #28]
      mode = st->mode;
 80125d0:	63fe      	str	r6, [r7, #60]	; 0x3c
      ec_dec_init(&dec,(unsigned char*)data,len);
 80125d2:	f7f5 fe91 	bl	80082f8 <ec_dec_init>
   }

   /* In fixed-point, we can tell CELT to do the accumulation on top of the
      SILK PCM buffer. This saves some stack space. */
#ifdef FIXED_POINT
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 80125d6:	f240 33ea 	movw	r3, #1002	; 0x3ea
 80125da:	429e      	cmp	r6, r3
 80125dc:	d140      	bne.n	8012660 <opus_decode_frame+0xfc>
   celt_accum = 0;
#endif

   pcm_transition_silk_size = ALLOC_NONE;
   pcm_transition_celt_size = ALLOC_NONE;
   if (data!=NULL && st->prev_mode > 0 && (
 80125de:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80125e0:	2900      	cmp	r1, #0
 80125e2:	f300 82f9 	bgt.w	8012bd8 <opus_decode_frame+0x674>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 80125e6:	2300      	movs	r3, #0
 80125e8:	61bb      	str	r3, [r7, #24]
      if (mode == MODE_CELT_ONLY)
         pcm_transition_celt_size = F5*st->channels;
      else
         pcm_transition_silk_size = F5*st->channels;
   }
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 80125ea:	f8c7 d028 	str.w	sp, [r7, #40]	; 0x28
   if (transition && mode == MODE_CELT_ONLY)
   {
      pcm_transition = pcm_transition_celt;
      opus_decode_frame(st, NULL, 0, pcm_transition, IMIN(F5, audiosize), 0);
   }
   if (audiosize > frame_size)
 80125ee:	455d      	cmp	r5, fp
 80125f0:	f2c0 8124 	blt.w	801283c <opus_decode_frame+0x2d8>
   } else {
      frame_size = audiosize;
   }

   /* Don't allocate any memory when in CELT-only mode */
   pcm_silk_size = (mode != MODE_CELT_ONLY && !celt_accum) ? IMAX(F10, frame_size)*st->channels : ALLOC_NONE;
 80125f4:	f240 33ea 	movw	r3, #1002	; 0x3ea
 80125f8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80125fa:	429a      	cmp	r2, r3
 80125fc:	f04f 0300 	mov.w	r3, #0
 8012600:	617b      	str	r3, [r7, #20]
 8012602:	f040 8393 	bne.w	8012d2c <opus_decode_frame+0x7c8>
 8012606:	4698      	mov	r8, r3
 8012608:	e2f6      	b.n	8012bf8 <opus_decode_frame+0x694>
      frame_size = IMIN(frame_size, st->frame_size);
 801260a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 801260c:	429d      	cmp	r5, r3
 801260e:	bfa8      	it	ge
 8012610:	461d      	movge	r5, r3
      mode = st->prev_mode;
 8012612:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8012614:	63f9      	str	r1, [r7, #60]	; 0x3c
      if (mode == 0)
 8012616:	b969      	cbnz	r1, 8012634 <opus_decode_frame+0xd0>
         for (i=0;i<audiosize*st->channels;i++)
 8012618:	68a2      	ldr	r2, [r4, #8]
 801261a:	fb02 f205 	mul.w	r2, r2, r5
 801261e:	2a00      	cmp	r2, #0
 8012620:	dd03      	ble.n	801262a <opus_decode_frame+0xc6>
 8012622:	0052      	lsls	r2, r2, #1
 8012624:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8012626:	f001 fd7f 	bl	8014128 <memset>
   }

   RESTORE_STACK;
   return celt_ret < 0 ? celt_ret : audiosize;

}
 801262a:	4628      	mov	r0, r5
 801262c:	3794      	adds	r7, #148	; 0x94
 801262e:	46bd      	mov	sp, r7
 8012630:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (audiosize > F20)
 8012634:	4555      	cmp	r5, sl
 8012636:	f300 82ef 	bgt.w	8012c18 <opus_decode_frame+0x6b4>
      } else if (audiosize < F20)
 801263a:	f2c0 80e7 	blt.w	801280c <opus_decode_frame+0x2a8>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 801263e:	f240 33ea 	movw	r3, #1002	; 0x3ea
 8012642:	4299      	cmp	r1, r3
 8012644:	f000 84d0 	beq.w	8012fe8 <opus_decode_frame+0xa84>
 8012648:	454d      	cmp	r5, r9
 801264a:	bfb4      	ite	lt
 801264c:	2300      	movlt	r3, #0
 801264e:	2301      	movge	r3, #1
 8012650:	46ab      	mov	fp, r5
 8012652:	61bb      	str	r3, [r7, #24]
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 8012654:	2300      	movs	r3, #0
 8012656:	f8c7 d028 	str.w	sp, [r7, #40]	; 0x28
 801265a:	643b      	str	r3, [r7, #64]	; 0x40
 801265c:	61fb      	str	r3, [r7, #28]
 801265e:	e7c6      	b.n	80125ee <opus_decode_frame+0x8a>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8012660:	45a9      	cmp	r9, r5
 8012662:	bfcc      	ite	gt
 8012664:	2200      	movgt	r2, #0
 8012666:	2201      	movle	r2, #1
   if (data!=NULL && st->prev_mode > 0 && (
 8012668:	6be1      	ldr	r1, [r4, #60]	; 0x3c
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 801266a:	61ba      	str	r2, [r7, #24]
   if (data!=NULL && st->prev_mode > 0 && (
 801266c:	2900      	cmp	r1, #0
 801266e:	ddbc      	ble.n	80125ea <opus_decode_frame+0x86>
    || (mode != MODE_CELT_ONLY && st->prev_mode == MODE_CELT_ONLY) )
 8012670:	4299      	cmp	r1, r3
 8012672:	f000 82fc 	beq.w	8012c6e <opus_decode_frame+0x70a>
   int transition=0;
 8012676:	2300      	movs	r3, #0
 8012678:	617b      	str	r3, [r7, #20]
   pcm_transition_silk_size = ALLOC_NONE;
 801267a:	2301      	movs	r3, #1
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 801267c:	f8c7 d028 	str.w	sp, [r7, #40]	; 0x28
   pcm_transition_silk_size = ALLOC_NONE;
 8012680:	613b      	str	r3, [r7, #16]
   if (audiosize > frame_size)
 8012682:	455d      	cmp	r5, fp
 8012684:	f2c0 80da 	blt.w	801283c <opus_decode_frame+0x2d8>
   pcm_silk_size = (mode != MODE_CELT_ONLY && !celt_accum) ? IMAX(F10, frame_size)*st->channels : ALLOC_NONE;
 8012688:	69bb      	ldr	r3, [r7, #24]
 801268a:	2b00      	cmp	r3, #0
 801268c:	f040 829c 	bne.w	8012bc8 <opus_decode_frame+0x664>
 8012690:	45d9      	cmp	r9, fp
 8012692:	bfb8      	it	lt
 8012694:	46d9      	movlt	r9, fp
 8012696:	68a3      	ldr	r3, [r4, #8]
 8012698:	fb03 f309 	mul.w	r3, r3, r9
   ALLOC(pcm_silk, pcm_silk_size, opus_int16);
 801269c:	005b      	lsls	r3, r3, #1
 801269e:	3308      	adds	r3, #8
 80126a0:	f023 0307 	bic.w	r3, r3, #7
 80126a4:	ebad 0d03 	sub.w	sp, sp, r3
 80126a8:	ae04      	add	r6, sp, #16
 80126aa:	60be      	str	r6, [r7, #8]
      if (st->prev_mode==MODE_CELT_ONLY)
 80126ac:	f240 33ea 	movw	r3, #1002	; 0x3ea
 80126b0:	4299      	cmp	r1, r3
   silk_dec = (char*)st+st->silk_dec_offset;
 80126b2:	44a0      	add	r8, r4
      if (st->prev_mode==MODE_CELT_ONLY)
 80126b4:	f000 8353 	beq.w	8012d5e <opus_decode_frame+0x7fa>
      st->DecControl.payloadSize_ms = IMAX(10, 1000 * audiosize / st->Fs);
 80126b8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80126bc:	fb03 f30b 	mul.w	r3, r3, fp
 80126c0:	68e2      	ldr	r2, [r4, #12]
 80126c2:	fb93 f3f2 	sdiv	r3, r3, r2
 80126c6:	2b0a      	cmp	r3, #10
 80126c8:	bfb8      	it	lt
 80126ca:	230a      	movlt	r3, #10
 80126cc:	6223      	str	r3, [r4, #32]
      if (data != NULL)
 80126ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80126d0:	2b00      	cmp	r3, #0
 80126d2:	f000 82c9 	beq.w	8012c68 <opus_decode_frame+0x704>
        st->DecControl.nChannelsInternal = st->stream_channels;
 80126d6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80126d8:	6163      	str	r3, [r4, #20]
        if( mode == MODE_SILK_ONLY ) {
 80126da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80126dc:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80126e0:	f000 832d 	beq.w	8012d3e <opus_decode_frame+0x7da>
              st->DecControl.internalSampleRate = 16000;
 80126e4:	f44f 537a 	mov.w	r3, #16000	; 0x3e80
 80126e8:	61e3      	str	r3, [r4, #28]
     lost_flag = data == NULL ? 1 : 2 * decode_fec;
 80126ea:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80126ee:	ea4f 0943 	mov.w	r9, r3, lsl #1
 80126f2:	f104 0310 	add.w	r3, r4, #16
 80126f6:	f8c7 a00c 	str.w	sl, [r7, #12]
     decoded_samples = 0;
 80126fa:	2500      	movs	r5, #0
 80126fc:	469a      	mov	sl, r3
 80126fe:	e008      	b.n	8012712 <opus_decode_frame+0x1ae>
 8012700:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8012702:	68a2      	ldr	r2, [r4, #8]
 8012704:	fb02 f201 	mul.w	r2, r2, r1
 8012708:	0053      	lsls	r3, r2, #1
        decoded_samples += silk_frame_size;
 801270a:	440d      	add	r5, r1
      } while( decoded_samples < frame_size );
 801270c:	455d      	cmp	r5, fp
        pcm_ptr += silk_frame_size * st->channels;
 801270e:	441e      	add	r6, r3
      } while( decoded_samples < frame_size );
 8012710:	da2b      	bge.n	801276a <opus_decode_frame+0x206>
        silk_ret = silk_Decode( silk_dec, &st->DecControl,
 8012712:	fab5 f385 	clz	r3, r5
 8012716:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8012718:	095b      	lsrs	r3, r3, #5
 801271a:	9203      	str	r2, [sp, #12]
 801271c:	f107 0254 	add.w	r2, r7, #84	; 0x54
 8012720:	e9cd 6201 	strd	r6, r2, [sp, #4]
 8012724:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8012726:	4651      	mov	r1, sl
 8012728:	9200      	str	r2, [sp, #0]
 801272a:	4640      	mov	r0, r8
 801272c:	464a      	mov	r2, r9
 801272e:	f7fc fb5f 	bl	800edf0 <silk_Decode>
        if( silk_ret ) {
 8012732:	2800      	cmp	r0, #0
 8012734:	d0e4      	beq.n	8012700 <opus_decode_frame+0x19c>
           if (lost_flag) {
 8012736:	f1b9 0f00 	cmp.w	r9, #0
 801273a:	f000 82fd 	beq.w	8012d38 <opus_decode_frame+0x7d4>
              for (i=0;i<frame_size*st->channels;i++)
 801273e:	68a2      	ldr	r2, [r4, #8]
              silk_frame_size = frame_size;
 8012740:	f8c7 b054 	str.w	fp, [r7, #84]	; 0x54
              for (i=0;i<frame_size*st->channels;i++)
 8012744:	fb02 f20b 	mul.w	r2, r2, fp
 8012748:	2a00      	cmp	r2, #0
                 pcm_ptr[i] = 0;
 801274a:	ea4f 0342 	mov.w	r3, r2, lsl #1
              for (i=0;i<frame_size*st->channels;i++)
 801274e:	f340 8240 	ble.w	8012bd2 <opus_decode_frame+0x66e>
 8012752:	461a      	mov	r2, r3
 8012754:	2100      	movs	r1, #0
 8012756:	4630      	mov	r0, r6
 8012758:	623b      	str	r3, [r7, #32]
 801275a:	f001 fce5 	bl	8014128 <memset>
                 pcm_ptr[i] = 0;
 801275e:	4659      	mov	r1, fp
 8012760:	6a3b      	ldr	r3, [r7, #32]
        decoded_samples += silk_frame_size;
 8012762:	440d      	add	r5, r1
      } while( decoded_samples < frame_size );
 8012764:	455d      	cmp	r5, fp
        pcm_ptr += silk_frame_size * st->channels;
 8012766:	441e      	add	r6, r3
      } while( decoded_samples < frame_size );
 8012768:	dbd3      	blt.n	8012712 <opus_decode_frame+0x1ae>
   if (!decode_fec && mode != MODE_CELT_ONLY && data != NULL
 801276a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801276e:	f8d7 a00c 	ldr.w	sl, [r7, #12]
 8012772:	b9c3      	cbnz	r3, 80127a6 <opus_decode_frame+0x242>
 8012774:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012776:	2b00      	cmp	r3, #0
 8012778:	f000 8304 	beq.w	8012d84 <opus_decode_frame+0x820>
   suitable for making coding decisions.
  Return: The number of bits.
          This will always be slightly larger than the exact value (e.g., all
           rounding error is in the positive direction).*/
static OPUS_INLINE int ec_tell(ec_ctx *_this){
  return _this->nbits_total-EC_ILOG(_this->rng);
 801277c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    && ec_tell(&dec)+17+20*(st->mode == MODE_HYBRID) <= 8*len)
 801277e:	f240 31e9 	movw	r1, #1001	; 0x3e9
 8012782:	fab3 f383 	clz	r3, r3
 8012786:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8012788:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 801278a:	f1c3 0320 	rsb	r3, r3, #32
 801278e:	1ad3      	subs	r3, r2, r3
 8012790:	4288      	cmp	r0, r1
 8012792:	f103 0211 	add.w	r2, r3, #17
 8012796:	bf08      	it	eq
 8012798:	f103 0225 	addeq.w	r2, r3, #37	; 0x25
 801279c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801279e:	ebb2 0fc3 	cmp.w	r2, r3, lsl #3
 80127a2:	f340 8291 	ble.w	8012cc8 <opus_decode_frame+0x764>
   int celt_to_silk=0;
 80127a6:	f04f 0900 	mov.w	r9, #0
      start_band = 17;
 80127aa:	2511      	movs	r5, #17
 80127ac:	46c8      	mov	r8, r9
   int redundancy_bytes = 0;
 80127ae:	f8c7 900c 	str.w	r9, [r7, #12]
   int redundancy=0;
 80127b2:	f8c7 9020 	str.w	r9, [r7, #32]
   ALLOC(pcm_transition_silk, pcm_transition_silk_size, opus_val16);
 80127b6:	693b      	ldr	r3, [r7, #16]
   if (transition && mode != MODE_CELT_ONLY)
 80127b8:	697a      	ldr	r2, [r7, #20]
   ALLOC(pcm_transition_silk, pcm_transition_silk_size, opus_val16);
 80127ba:	005b      	lsls	r3, r3, #1
 80127bc:	3308      	adds	r3, #8
 80127be:	f023 0307 	bic.w	r3, r3, #7
 80127c2:	f8c7 d044 	str.w	sp, [r7, #68]	; 0x44
 80127c6:	ebad 0d03 	sub.w	sp, sp, r3
 80127ca:	ab04      	add	r3, sp, #16
   if (transition && mode != MODE_CELT_ONLY)
 80127cc:	b12a      	cbz	r2, 80127da <opus_decode_frame+0x276>
 80127ce:	f240 32ea 	movw	r2, #1002	; 0x3ea
 80127d2:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80127d4:	4291      	cmp	r1, r2
 80127d6:	f040 82c6 	bne.w	8012d66 <opus_decode_frame+0x802>
   celt_dec = (CELTDecoder*)((char*)st+st->celt_dec_offset);
 80127da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80127dc:	4423      	add	r3, r4
 80127de:	461e      	mov	r6, r3
   if (bandwidth)
 80127e0:	69fb      	ldr	r3, [r7, #28]
 80127e2:	2b00      	cmp	r3, #0
 80127e4:	d038      	beq.n	8012858 <opus_decode_frame+0x2f4>
 80127e6:	f2a3 434d 	subw	r3, r3, #1101	; 0x44d
 80127ea:	2b03      	cmp	r3, #3
 80127ec:	bf96      	itet	ls
 80127ee:	4a18      	ldrls	r2, [pc, #96]	; (8012850 <opus_decode_frame+0x2ec>)
      switch(bandwidth)
 80127f0:	2215      	movhi	r2, #21
 80127f2:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
      MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_END_BAND(endband)));
 80127f6:	f242 711c 	movw	r1, #10012	; 0x271c
 80127fa:	4630      	mov	r0, r6
 80127fc:	f7f4 fbd8 	bl	8006fb0 <opus_custom_decoder_ctl>
 8012800:	b350      	cbz	r0, 8012858 <opus_decode_frame+0x2f4>
 8012802:	f06f 0502 	mvn.w	r5, #2
 8012806:	f8d7 d044 	ldr.w	sp, [r7, #68]	; 0x44
 801280a:	e019      	b.n	8012840 <opus_decode_frame+0x2dc>
         if (audiosize > F10)
 801280c:	454d      	cmp	r5, r9
 801280e:	f300 8222 	bgt.w	8012c56 <opus_decode_frame+0x6f2>
         else if (mode != MODE_SILK_ONLY && audiosize > F5 && audiosize < F10)
 8012812:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
 8012816:	f43f af17 	beq.w	8012648 <opus_decode_frame+0xe4>
 801281a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801281c:	429d      	cmp	r5, r3
 801281e:	f77f af0e 	ble.w	801263e <opus_decode_frame+0xda>
 8012822:	454d      	cmp	r5, r9
 8012824:	f280 831f 	bge.w	8012e66 <opus_decode_frame+0x902>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8012828:	f240 33ea 	movw	r3, #1002	; 0x3ea
 801282c:	4299      	cmp	r1, r3
 801282e:	f000 83dd 	beq.w	8012fec <opus_decode_frame+0xa88>
 8012832:	2300      	movs	r3, #0
 8012834:	f8d7 b030 	ldr.w	fp, [r7, #48]	; 0x30
 8012838:	61bb      	str	r3, [r7, #24]
 801283a:	e70b      	b.n	8012654 <opus_decode_frame+0xf0>
      return OPUS_BAD_ARG;
 801283c:	f04f 35ff 	mov.w	r5, #4294967295
}
 8012840:	4628      	mov	r0, r5
 8012842:	f8d7 d028 	ldr.w	sp, [r7, #40]	; 0x28
 8012846:	3794      	adds	r7, #148	; 0x94
 8012848:	46bd      	mov	sp, r7
 801284a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801284e:	bf00      	nop
 8012850:	08017fd0 	.word	0x08017fd0
 8012854:	51eb851f 	.word	0x51eb851f
   MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_CHANNELS(st->stream_channels)));
 8012858:	6b22      	ldr	r2, [r4, #48]	; 0x30
 801285a:	f242 7118 	movw	r1, #10008	; 0x2718
 801285e:	4630      	mov	r0, r6
 8012860:	f7f4 fba6 	bl	8006fb0 <opus_custom_decoder_ctl>
 8012864:	2800      	cmp	r0, #0
 8012866:	d1cc      	bne.n	8012802 <opus_decode_frame+0x29e>
   redundant_audio_size = redundancy ? F5*st->channels : ALLOC_NONE;
 8012868:	6a3b      	ldr	r3, [r7, #32]
 801286a:	2b00      	cmp	r3, #0
 801286c:	f000 8209 	beq.w	8012c82 <opus_decode_frame+0x71e>
 8012870:	68a3      	ldr	r3, [r4, #8]
 8012872:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   ALLOC(redundant_audio, redundant_audio_size, opus_val16);
 8012874:	f8c7 d034 	str.w	sp, [r7, #52]	; 0x34
   redundant_audio_size = redundancy ? F5*st->channels : ALLOC_NONE;
 8012878:	fb03 f302 	mul.w	r3, r3, r2
   ALLOC(redundant_audio, redundant_audio_size, opus_val16);
 801287c:	005b      	lsls	r3, r3, #1
 801287e:	3308      	adds	r3, #8
 8012880:	f023 0307 	bic.w	r3, r3, #7
 8012884:	ebad 0d03 	sub.w	sp, sp, r3
 8012888:	ab04      	add	r3, sp, #16
 801288a:	61fb      	str	r3, [r7, #28]
   if (redundancy && celt_to_silk)
 801288c:	f1b9 0f00 	cmp.w	r9, #0
 8012890:	f040 8177 	bne.w	8012b82 <opus_decode_frame+0x61e>
   MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_START_BAND(start_band)));
 8012894:	462a      	mov	r2, r5
 8012896:	f242 711a 	movw	r1, #10010	; 0x271a
 801289a:	4630      	mov	r0, r6
 801289c:	f7f4 fb88 	bl	8006fb0 <opus_custom_decoder_ctl>
 80128a0:	4605      	mov	r5, r0
 80128a2:	2800      	cmp	r0, #0
 80128a4:	f040 818b 	bne.w	8012bbe <opus_decode_frame+0x65a>
   if (mode != MODE_SILK_ONLY)
 80128a8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80128aa:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80128ac:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
 80128b0:	4611      	mov	r1, r2
 80128b2:	f000 82a4 	beq.w	8012dfe <opus_decode_frame+0x89a>
      int celt_frame_size = IMIN(F20, frame_size);
 80128b6:	45da      	cmp	sl, fp
 80128b8:	4655      	mov	r5, sl
 80128ba:	bfa8      	it	ge
 80128bc:	465d      	movge	r5, fp
      if (mode != st->prev_mode && st->prev_mode > 0 && !st->prev_redundancy)
 80128be:	429a      	cmp	r2, r3
 80128c0:	d005      	beq.n	80128ce <opus_decode_frame+0x36a>
 80128c2:	2b00      	cmp	r3, #0
 80128c4:	dd03      	ble.n	80128ce <opus_decode_frame+0x36a>
 80128c6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80128c8:	2b00      	cmp	r3, #0
 80128ca:	f000 82f7 	beq.w	8012ebc <opus_decode_frame+0x958>
      celt_ret = celt_decode_with_ec(celt_dec, decode_fec ? NULL : data,
 80128ce:	69ba      	ldr	r2, [r7, #24]
 80128d0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80128d4:	9500      	str	r5, [sp, #0]
 80128d6:	9202      	str	r2, [sp, #8]
 80128d8:	2b00      	cmp	r3, #0
 80128da:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80128dc:	f107 0360 	add.w	r3, r7, #96	; 0x60
 80128e0:	9301      	str	r3, [sp, #4]
 80128e2:	bf0c      	ite	eq
 80128e4:	4611      	moveq	r1, r2
 80128e6:	2100      	movne	r1, #0
 80128e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80128ea:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80128ec:	4630      	mov	r0, r6
 80128ee:	f7f3 fb1b 	bl	8005f28 <celt_decode_with_ec>
   if (mode != MODE_CELT_ONLY && !celt_accum)
 80128f2:	f240 33ea 	movw	r3, #1002	; 0x3ea
 80128f6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
      celt_ret = celt_decode_with_ec(celt_dec, decode_fec ? NULL : data,
 80128f8:	4605      	mov	r5, r0
   if (mode != MODE_CELT_ONLY && !celt_accum)
 80128fa:	429a      	cmp	r2, r3
 80128fc:	f040 824b 	bne.w	8012d96 <opus_decode_frame+0x832>
 8012900:	f107 0a5c 	add.w	sl, r7, #92	; 0x5c
      MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_GET_MODE(&celt_mode)));
 8012904:	4652      	mov	r2, sl
 8012906:	f242 711f 	movw	r1, #10015	; 0x271f
 801290a:	4630      	mov	r0, r6
 801290c:	f7f4 fb50 	bl	8006fb0 <opus_custom_decoder_ctl>
 8012910:	2800      	cmp	r0, #0
 8012912:	f040 8154 	bne.w	8012bbe <opus_decode_frame+0x65a>
      window = celt_mode->window;
 8012916:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012918:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801291a:	61bb      	str	r3, [r7, #24]
   if (redundancy && !celt_to_silk)
 801291c:	6a3b      	ldr	r3, [r7, #32]
 801291e:	2b00      	cmp	r3, #0
 8012920:	d063      	beq.n	80129ea <opus_decode_frame+0x486>
 8012922:	f1b9 0f00 	cmp.w	r9, #0
 8012926:	f000 82d2 	beq.w	8012ece <opus_decode_frame+0x96a>
      for (c=0;c<st->channels;c++)
 801292a:	f8d4 c008 	ldr.w	ip, [r4, #8]
 801292e:	f1bc 0f00 	cmp.w	ip, #0
 8012932:	dd5a      	ble.n	80129ea <opus_decode_frame+0x486>
 8012934:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012936:	2b00      	cmp	r3, #0
 8012938:	dd57      	ble.n	80129ea <opus_decode_frame+0x486>
 801293a:	469a      	mov	sl, r3
 801293c:	69f9      	ldr	r1, [r7, #28]
 801293e:	ea4f 0e4c 	mov.w	lr, ip, lsl #1
 8012942:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8012944:	eb01 060e 	add.w	r6, r1, lr
         for (i=0;i<F2_5;i++)
 8012948:	2200      	movs	r2, #0
 801294a:	4613      	mov	r3, r2
 801294c:	643c      	str	r4, [r7, #64]	; 0x40
            pcm[st->channels*i+c] = redundant_audio[st->channels*i+c];
 801294e:	5acc      	ldrh	r4, [r1, r3]
         for (i=0;i<F2_5;i++)
 8012950:	3201      	adds	r2, #1
 8012952:	4592      	cmp	sl, r2
            pcm[st->channels*i+c] = redundant_audio[st->channels*i+c];
 8012954:	52c4      	strh	r4, [r0, r3]
 8012956:	4473      	add	r3, lr
         for (i=0;i<F2_5;i++)
 8012958:	d1f9      	bne.n	801294e <opus_decode_frame+0x3ea>
 801295a:	3102      	adds	r1, #2
      for (c=0;c<st->channels;c++)
 801295c:	428e      	cmp	r6, r1
 801295e:	6c3c      	ldr	r4, [r7, #64]	; 0x40
 8012960:	f100 0002 	add.w	r0, r0, #2
 8012964:	d1f0      	bne.n	8012948 <opus_decode_frame+0x3e4>
   int inc = 48000/Fs;
 8012966:	f64b 3380 	movw	r3, #48000	; 0xbb80
      smooth_fade(redundant_audio+st->channels*F2_5, pcm+st->channels*F2_5,
 801296a:	6a7e      	ldr	r6, [r7, #36]	; 0x24
   int inc = 48000/Fs;
 801296c:	68e2      	ldr	r2, [r4, #12]
      smooth_fade(redundant_audio+st->channels*F2_5, pcm+st->channels*F2_5,
 801296e:	fb0c fc06 	mul.w	ip, ip, r6
   int inc = 48000/Fs;
 8012972:	fb93 f3f2 	sdiv	r3, r3, r2
      smooth_fade(redundant_audio+st->channels*F2_5, pcm+st->channels*F2_5,
 8012976:	ea4f 024c 	mov.w	r2, ip, lsl #1
 801297a:	eb02 010e 	add.w	r1, r2, lr
 801297e:	e9c7 9b02 	strd	r9, fp, [r7, #8]
 8012982:	6139      	str	r1, [r7, #16]
 8012984:	4640      	mov	r0, r8
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012986:	f647 71ff 	movw	r1, #32767	; 0x7fff
 801298a:	46b0      	mov	r8, r6
 801298c:	4693      	mov	fp, r2
 801298e:	f8d7 c038 	ldr.w	ip, [r7, #56]	; 0x38
 8012992:	f8d7 901c 	ldr.w	r9, [r7, #28]
 8012996:	ea4f 0a43 	mov.w	sl, r3, lsl #1
 801299a:	61fd      	str	r5, [r7, #28]
 801299c:	607c      	str	r4, [r7, #4]
         for (i=0;i<F2_5;i++)
 801299e:	465c      	mov	r4, fp
      for (i=0;i<overlap;i++)
 80129a0:	2500      	movs	r5, #0
 80129a2:	69be      	ldr	r6, [r7, #24]
 80129a4:	6438      	str	r0, [r7, #64]	; 0x40
         opus_val16 w = MULT16_16_Q15(window[i*inc], window[i*inc]);
 80129a6:	f9b6 3000 	ldrsh.w	r3, [r6]
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 80129aa:	f839 0004 	ldrh.w	r0, [r9, r4]
         opus_val16 w = MULT16_16_Q15(window[i*inc], window[i*inc]);
 80129ae:	fb03 f303 	mul.w	r3, r3, r3
 80129b2:	13db      	asrs	r3, r3, #15
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 80129b4:	1aca      	subs	r2, r1, r3
 80129b6:	fb10 f202 	smulbb	r2, r0, r2
 80129ba:	f83c 0004 	ldrh.w	r0, [ip, r4]
      for (i=0;i<overlap;i++)
 80129be:	3501      	adds	r5, #1
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 80129c0:	fb13 2300 	smlabb	r3, r3, r0, r2
      for (i=0;i<overlap;i++)
 80129c4:	45a8      	cmp	r8, r5
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 80129c6:	ea4f 33e3 	mov.w	r3, r3, asr #15
 80129ca:	f82c 3004 	strh.w	r3, [ip, r4]
 80129ce:	4456      	add	r6, sl
 80129d0:	4474      	add	r4, lr
      for (i=0;i<overlap;i++)
 80129d2:	d1e8      	bne.n	80129a6 <opus_decode_frame+0x442>
   for (c=0;c<channels;c++)
 80129d4:	693b      	ldr	r3, [r7, #16]
 80129d6:	f10b 0b02 	add.w	fp, fp, #2
 80129da:	455b      	cmp	r3, fp
 80129dc:	6c38      	ldr	r0, [r7, #64]	; 0x40
 80129de:	d1de      	bne.n	801299e <opus_decode_frame+0x43a>
 80129e0:	e9d7 9b02 	ldrd	r9, fp, [r7, #8]
 80129e4:	4680      	mov	r8, r0
 80129e6:	69fd      	ldr	r5, [r7, #28]
 80129e8:	687c      	ldr	r4, [r7, #4]
   if (transition)
 80129ea:	697b      	ldr	r3, [r7, #20]
 80129ec:	2b00      	cmp	r3, #0
 80129ee:	d054      	beq.n	8012a9a <opus_decode_frame+0x536>
 80129f0:	e9d4 3102 	ldrd	r3, r1, [r4, #8]
 80129f4:	f64b 3280 	movw	r2, #48000	; 0xbb80
 80129f8:	fb92 faf1 	sdiv	sl, r2, r1
      if (audiosize >= F5)
 80129fc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80129fe:	4593      	cmp	fp, r2
 8012a00:	f2c0 82ac 	blt.w	8012f5c <opus_decode_frame+0x9f8>
         for (i=0;i<st->channels*F2_5;i++)
 8012a04:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8012a06:	fb03 f602 	mul.w	r6, r3, r2
 8012a0a:	2e00      	cmp	r6, #0
 8012a0c:	f340 82e2 	ble.w	8012fd4 <opus_decode_frame+0xa70>
            pcm[i] = pcm_transition[i];
 8012a10:	0076      	lsls	r6, r6, #1
 8012a12:	4632      	mov	r2, r6
 8012a14:	4641      	mov	r1, r8
 8012a16:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8012a18:	643b      	str	r3, [r7, #64]	; 0x40
 8012a1a:	f001 fb61 	bl	80140e0 <memcpy>
 8012a1e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   for (c=0;c<channels;c++)
 8012a20:	2b00      	cmp	r3, #0
 8012a22:	dd3a      	ble.n	8012a9a <opus_decode_frame+0x536>
 8012a24:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8012a26:	2a00      	cmp	r2, #0
 8012a28:	dd37      	ble.n	8012a9a <opus_decode_frame+0x536>
 8012a2a:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 8012a2e:	eb0e 0106 	add.w	r1, lr, r6
 8012a32:	6339      	str	r1, [r7, #48]	; 0x30
 8012a34:	4658      	mov	r0, fp
 8012a36:	f8c7 9024 	str.w	r9, [r7, #36]	; 0x24
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012a3a:	f647 71ff 	movw	r1, #32767	; 0x7fff
 8012a3e:	46b3      	mov	fp, r6
 8012a40:	4691      	mov	r9, r2
 8012a42:	f8d7 c038 	ldr.w	ip, [r7, #56]	; 0x38
 8012a46:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
 8012a4a:	61fd      	str	r5, [r7, #28]
 8012a4c:	617c      	str	r4, [r7, #20]
      for (i=0;i<overlap;i++)
 8012a4e:	465c      	mov	r4, fp
 8012a50:	2500      	movs	r5, #0
 8012a52:	69be      	ldr	r6, [r7, #24]
 8012a54:	6438      	str	r0, [r7, #64]	; 0x40
         opus_val16 w = MULT16_16_Q15(window[i*inc], window[i*inc]);
 8012a56:	f9b6 3000 	ldrsh.w	r3, [r6]
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012a5a:	f838 0004 	ldrh.w	r0, [r8, r4]
         opus_val16 w = MULT16_16_Q15(window[i*inc], window[i*inc]);
 8012a5e:	fb03 f303 	mul.w	r3, r3, r3
 8012a62:	13db      	asrs	r3, r3, #15
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012a64:	1aca      	subs	r2, r1, r3
 8012a66:	fb10 f202 	smulbb	r2, r0, r2
 8012a6a:	f83c 0004 	ldrh.w	r0, [ip, r4]
      for (i=0;i<overlap;i++)
 8012a6e:	3501      	adds	r5, #1
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012a70:	fb13 2300 	smlabb	r3, r3, r0, r2
      for (i=0;i<overlap;i++)
 8012a74:	45a9      	cmp	r9, r5
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012a76:	ea4f 33e3 	mov.w	r3, r3, asr #15
 8012a7a:	f82c 3004 	strh.w	r3, [ip, r4]
 8012a7e:	4456      	add	r6, sl
 8012a80:	4474      	add	r4, lr
      for (i=0;i<overlap;i++)
 8012a82:	d1e8      	bne.n	8012a56 <opus_decode_frame+0x4f2>
   for (c=0;c<channels;c++)
 8012a84:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012a86:	f10b 0b02 	add.w	fp, fp, #2
 8012a8a:	459b      	cmp	fp, r3
 8012a8c:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8012a8e:	d1de      	bne.n	8012a4e <opus_decode_frame+0x4ea>
 8012a90:	4683      	mov	fp, r0
 8012a92:	f8d7 9024 	ldr.w	r9, [r7, #36]	; 0x24
 8012a96:	69fd      	ldr	r5, [r7, #28]
 8012a98:	697c      	ldr	r4, [r7, #20]
   if(st->decode_gain)
 8012a9a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8012a9c:	2b00      	cmp	r3, #0
 8012a9e:	d05a      	beq.n	8012b56 <opus_decode_frame+0x5f2>
      gain = celt_exp2(MULT16_16_P15(QCONST16(6.48814081e-4f, 25), st->decode_gain));
 8012aa0:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8012aa4:	f245 510b 	movw	r1, #21771	; 0x550b
 8012aa8:	fb13 2301 	smlabb	r3, r3, r1, r2
 8012aac:	13db      	asrs	r3, r3, #15
/** Base-2 exponential approximation (2^x). (Q10 input, Q16 output) */
static OPUS_INLINE opus_val32 celt_exp2(opus_val16 x)
{
   int integer;
   opus_val16 frac;
   integer = SHR16(x,10);
 8012aae:	f343 2285 	sbfx	r2, r3, #10, #6
   if (integer>14)
 8012ab2:	2a0e      	cmp	r2, #14
 8012ab4:	f300 824d 	bgt.w	8012f52 <opus_decode_frame+0x9ee>
      return 0x7f000000;
   else if (integer < -15)
 8012ab8:	f112 0f0f 	cmn.w	r2, #15
 8012abc:	f2c0 824c 	blt.w	8012f58 <opus_decode_frame+0x9f4>
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 8012ac0:	f242 76dc 	movw	r6, #10204	; 0x27dc
 8012ac4:	f643 10e3 	movw	r0, #14819	; 0x39e3
 8012ac8:	f645 1114 	movw	r1, #22804	; 0x5914
      return 0;
   frac = celt_exp2_frac(x-SHL16(integer,10));
   return VSHR32(EXTEND32(frac), -integer-2);
 8012acc:	f06f 0e01 	mvn.w	lr, #1
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 8012ad0:	f643 78ff 	movw	r8, #16383	; 0x3fff
   frac = celt_exp2_frac(x-SHL16(integer,10));
 8012ad4:	fa1f fc82 	uxth.w	ip, r2
 8012ad8:	eba3 238c 	sub.w	r3, r3, ip, lsl #10
   frac = SHL16(x, 4);
 8012adc:	f343 030b 	sbfx	r3, r3, #0, #12
 8012ae0:	011b      	lsls	r3, r3, #4
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 8012ae2:	fb13 f606 	smulbb	r6, r3, r6
 8012ae6:	eb00 30e6 	add.w	r0, r0, r6, asr #15
 8012aea:	fb10 f003 	smulbb	r0, r0, r3
 8012aee:	eb01 30e0 	add.w	r0, r1, r0, asr #15
 8012af2:	fb10 f003 	smulbb	r0, r0, r3
   return VSHR32(EXTEND32(frac), -integer-2);
 8012af6:	ebae 0e02 	sub.w	lr, lr, r2
 8012afa:	f1be 0f00 	cmp.w	lr, #0
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 8012afe:	eb08 30e0 	add.w	r0, r8, r0, asr #15
 8012b02:	b200      	sxth	r0, r0
   return VSHR32(EXTEND32(frac), -integer-2);
 8012b04:	bfd6      	itet	le
 8012b06:	3202      	addle	r2, #2
 8012b08:	fa40 f00e 	asrgt.w	r0, r0, lr
 8012b0c:	4090      	lslle	r0, r2
      for (i=0;i<frame_size*st->channels;i++)
 8012b0e:	68a6      	ldr	r6, [r4, #8]
 8012b10:	fb06 f60b 	mul.w	r6, r6, fp
 8012b14:	2e00      	cmp	r6, #0
 8012b16:	dd1e      	ble.n	8012b56 <opus_decode_frame+0x5f2>
         pcm[i] = SATURATE(x, 32767);
 8012b18:	f647 7eff 	movw	lr, #32767	; 0x7fff
 8012b1c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012b1e:	f8df 84d8 	ldr.w	r8, [pc, #1240]	; 8012ff8 <opus_decode_frame+0xa94>
 8012b22:	1e99      	subs	r1, r3, #2
         x = MULT16_32_P16(pcm[i],gain);
 8012b24:	ea4f 4c20 	mov.w	ip, r0, asr #16
 8012b28:	eb01 0646 	add.w	r6, r1, r6, lsl #1
 8012b2c:	b280      	uxth	r0, r0
 8012b2e:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
 8012b32:	fb00 f203 	mul.w	r2, r0, r3
 8012b36:	fb0c f303 	mul.w	r3, ip, r3
 8012b3a:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
 8012b3e:	eb03 4322 	add.w	r3, r3, r2, asr #16
         pcm[i] = SATURATE(x, 32767);
 8012b42:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8012b46:	f280 814e 	bge.w	8012de6 <opus_decode_frame+0x882>
 8012b4a:	4543      	cmp	r3, r8
 8012b4c:	bfb8      	it	lt
 8012b4e:	4643      	movlt	r3, r8
      for (i=0;i<frame_size*st->channels;i++)
 8012b50:	42b1      	cmp	r1, r6
         pcm[i] = SATURATE(x, 32767);
 8012b52:	800b      	strh	r3, [r1, #0]
      for (i=0;i<frame_size*st->channels;i++)
 8012b54:	d1eb      	bne.n	8012b2e <opus_decode_frame+0x5ca>
   if (len <= 1)
 8012b56:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012b58:	2b01      	cmp	r3, #1
      st->rangeFinal = 0;
 8012b5a:	bfd1      	iteee	le
 8012b5c:	2300      	movle	r3, #0
      st->rangeFinal = dec.rng ^ redundant_rng;
 8012b5e:	6ffb      	ldrgt	r3, [r7, #124]	; 0x7c
 8012b60:	6dba      	ldrgt	r2, [r7, #88]	; 0x58
 8012b62:	4053      	eorgt	r3, r2
 8012b64:	64e3      	str	r3, [r4, #76]	; 0x4c
   st->prev_mode = mode;
 8012b66:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012b68:	63e3      	str	r3, [r4, #60]	; 0x3c
   st->prev_redundancy = redundancy && !celt_to_silk;
 8012b6a:	6a3b      	ldr	r3, [r7, #32]
 8012b6c:	b11b      	cbz	r3, 8012b76 <opus_decode_frame+0x612>
 8012b6e:	fab9 f389 	clz	r3, r9
 8012b72:	095b      	lsrs	r3, r3, #5
 8012b74:	623b      	str	r3, [r7, #32]
 8012b76:	6463      	str	r3, [r4, #68]	; 0x44
 8012b78:	ea15 0525 	ands.w	r5, r5, r5, asr #32
 8012b7c:	bf38      	it	cc
 8012b7e:	465d      	movcc	r5, fp
 8012b80:	e01f      	b.n	8012bc2 <opus_decode_frame+0x65e>
      MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_START_BAND(0)));
 8012b82:	4602      	mov	r2, r0
 8012b84:	f242 711a 	movw	r1, #10010	; 0x271a
 8012b88:	4630      	mov	r0, r6
 8012b8a:	613b      	str	r3, [r7, #16]
 8012b8c:	f7f4 fa10 	bl	8006fb0 <opus_custom_decoder_ctl>
 8012b90:	693b      	ldr	r3, [r7, #16]
 8012b92:	b9a0      	cbnz	r0, 8012bbe <opus_decode_frame+0x65a>
      celt_decode_with_ec(celt_dec, data+len, redundancy_bytes,
 8012b94:	e9cd 0001 	strd	r0, r0, [sp, #4]
 8012b98:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8012b9a:	9200      	str	r2, [sp, #0]
 8012b9c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8012b9e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8012ba0:	68fa      	ldr	r2, [r7, #12]
 8012ba2:	4401      	add	r1, r0
 8012ba4:	4630      	mov	r0, r6
 8012ba6:	f7f3 f9bf 	bl	8005f28 <celt_decode_with_ec>
      MUST_SUCCEED(celt_decoder_ctl(celt_dec, OPUS_GET_FINAL_RANGE(&redundant_rng)));
 8012baa:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8012bae:	f640 71bf 	movw	r1, #4031	; 0xfbf
 8012bb2:	4630      	mov	r0, r6
 8012bb4:	f7f4 f9fc 	bl	8006fb0 <opus_custom_decoder_ctl>
 8012bb8:	2800      	cmp	r0, #0
 8012bba:	f43f ae6b 	beq.w	8012894 <opus_decode_frame+0x330>
      MUST_SUCCEED(celt_decoder_ctl(celt_dec, OPUS_GET_FINAL_RANGE(&redundant_rng)));
 8012bbe:	f06f 0502 	mvn.w	r5, #2
 8012bc2:	f8d7 d034 	ldr.w	sp, [r7, #52]	; 0x34
 8012bc6:	e61e      	b.n	8012806 <opus_decode_frame+0x2a2>
   ALLOC(pcm_silk, pcm_silk_size, opus_int16);
 8012bc8:	f107 0348 	add.w	r3, r7, #72	; 0x48
 8012bcc:	6bbe      	ldr	r6, [r7, #56]	; 0x38
 8012bce:	60bb      	str	r3, [r7, #8]
 8012bd0:	e56c      	b.n	80126ac <opus_decode_frame+0x148>
              for (i=0;i<frame_size*st->channels;i++)
 8012bd2:	4659      	mov	r1, fp
 8012bd4:	0053      	lsls	r3, r2, #1
 8012bd6:	e598      	b.n	801270a <opus_decode_frame+0x1a6>
       (mode == MODE_CELT_ONLY && st->prev_mode != MODE_CELT_ONLY && !st->prev_redundancy)
 8012bd8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012bda:	4299      	cmp	r1, r3
 8012bdc:	d002      	beq.n	8012be4 <opus_decode_frame+0x680>
 8012bde:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8012be0:	2a00      	cmp	r2, #0
 8012be2:	d054      	beq.n	8012c8e <opus_decode_frame+0x72a>
   int transition=0;
 8012be4:	2300      	movs	r3, #0
   opus_val16 *pcm_transition=NULL;
 8012be6:	4698      	mov	r8, r3
   int transition=0;
 8012be8:	617b      	str	r3, [r7, #20]
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 8012bea:	f8c7 d028 	str.w	sp, [r7, #40]	; 0x28
   if (audiosize > frame_size)
 8012bee:	455d      	cmp	r5, fp
 8012bf0:	f6ff ae24 	blt.w	801283c <opus_decode_frame+0x2d8>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8012bf4:	2300      	movs	r3, #0
 8012bf6:	61bb      	str	r3, [r7, #24]
 8012bf8:	f240 33ea 	movw	r3, #1002	; 0x3ea
 8012bfc:	63fb      	str	r3, [r7, #60]	; 0x3c
 8012bfe:	2301      	movs	r3, #1
   ALLOC(pcm_silk, pcm_silk_size, opus_int16);
 8012c00:	f04f 0900 	mov.w	r9, #0
 8012c04:	613b      	str	r3, [r7, #16]
 8012c06:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8012c0a:	f8c7 900c 	str.w	r9, [r7, #12]
 8012c0e:	f8c7 9020 	str.w	r9, [r7, #32]
   start_band = 0;
 8012c12:	464d      	mov	r5, r9
   ALLOC(pcm_silk, pcm_silk_size, opus_int16);
 8012c14:	60bb      	str	r3, [r7, #8]
 8012c16:	e5ce      	b.n	80127b6 <opus_decode_frame+0x252>
 8012c18:	462e      	mov	r6, r5
            int ret = opus_decode_frame(st, NULL, 0, pcm, IMIN(audiosize, F20), 0);
 8012c1a:	f04f 0800 	mov.w	r8, #0
 8012c1e:	f8d7 9038 	ldr.w	r9, [r7, #56]	; 0x38
 8012c22:	4556      	cmp	r6, sl
 8012c24:	4633      	mov	r3, r6
 8012c26:	f04f 0200 	mov.w	r2, #0
 8012c2a:	bfa8      	it	ge
 8012c2c:	4653      	movge	r3, sl
 8012c2e:	4611      	mov	r1, r2
 8012c30:	e9cd 3800 	strd	r3, r8, [sp]
 8012c34:	4620      	mov	r0, r4
 8012c36:	464b      	mov	r3, r9
 8012c38:	f7ff fc94 	bl	8012564 <opus_decode_frame>
            if (ret<0)
 8012c3c:	2800      	cmp	r0, #0
            audiosize -= ret;
 8012c3e:	eba6 0600 	sub.w	r6, r6, r0
            if (ret<0)
 8012c42:	f2c0 808a 	blt.w	8012d5a <opus_decode_frame+0x7f6>
            pcm += ret*st->channels;
 8012c46:	68a3      	ldr	r3, [r4, #8]
         } while (audiosize > 0);
 8012c48:	2e00      	cmp	r6, #0
            pcm += ret*st->channels;
 8012c4a:	fb03 f300 	mul.w	r3, r3, r0
 8012c4e:	eb09 0943 	add.w	r9, r9, r3, lsl #1
         } while (audiosize > 0);
 8012c52:	dce6      	bgt.n	8012c22 <opus_decode_frame+0x6be>
 8012c54:	e4e9      	b.n	801262a <opus_decode_frame+0xc6>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8012c56:	f240 33ea 	movw	r3, #1002	; 0x3ea
 8012c5a:	4299      	cmp	r1, r3
 8012c5c:	f000 81bc 	beq.w	8012fd8 <opus_decode_frame+0xa74>
 8012c60:	2301      	movs	r3, #1
 8012c62:	46cb      	mov	fp, r9
 8012c64:	61bb      	str	r3, [r7, #24]
 8012c66:	e4f5      	b.n	8012654 <opus_decode_frame+0xf0>
     lost_flag = data == NULL ? 1 : 2 * decode_fec;
 8012c68:	f04f 0901 	mov.w	r9, #1
 8012c6c:	e541      	b.n	80126f2 <opus_decode_frame+0x18e>
         pcm_transition_silk_size = F5*st->channels;
 8012c6e:	68a3      	ldr	r3, [r4, #8]
 8012c70:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 8012c72:	f8c7 d028 	str.w	sp, [r7, #40]	; 0x28
         pcm_transition_silk_size = F5*st->channels;
 8012c76:	fb03 f302 	mul.w	r3, r3, r2
 8012c7a:	613b      	str	r3, [r7, #16]
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 8012c7c:	2301      	movs	r3, #1
 8012c7e:	617b      	str	r3, [r7, #20]
 8012c80:	e4ff      	b.n	8012682 <opus_decode_frame+0x11e>
   ALLOC(redundant_audio, redundant_audio_size, opus_val16);
 8012c82:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8012c86:	f8c7 d034 	str.w	sp, [r7, #52]	; 0x34
 8012c8a:	61fb      	str	r3, [r7, #28]
 8012c8c:	e602      	b.n	8012894 <opus_decode_frame+0x330>
      opus_decode_frame(st, NULL, 0, pcm_transition, IMIN(F5, audiosize), 0);
 8012c8e:	6b38      	ldr	r0, [r7, #48]	; 0x30
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 8012c90:	f8c7 d028 	str.w	sp, [r7, #40]	; 0x28
      opus_decode_frame(st, NULL, 0, pcm_transition, IMIN(F5, audiosize), 0);
 8012c94:	4558      	cmp	r0, fp
 8012c96:	4603      	mov	r3, r0
 8012c98:	bfa8      	it	ge
 8012c9a:	465b      	movge	r3, fp
 8012c9c:	4619      	mov	r1, r3
         pcm_transition_celt_size = F5*st->channels;
 8012c9e:	68a3      	ldr	r3, [r4, #8]
 8012ca0:	fb03 f300 	mul.w	r3, r3, r0
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 8012ca4:	005b      	lsls	r3, r3, #1
 8012ca6:	3308      	adds	r3, #8
 8012ca8:	f023 0307 	bic.w	r3, r3, #7
 8012cac:	ebad 0d03 	sub.w	sp, sp, r3
 8012cb0:	f10d 0810 	add.w	r8, sp, #16
      opus_decode_frame(st, NULL, 0, pcm_transition, IMIN(F5, audiosize), 0);
 8012cb4:	e9cd 1200 	strd	r1, r2, [sp]
 8012cb8:	4643      	mov	r3, r8
 8012cba:	4611      	mov	r1, r2
 8012cbc:	4620      	mov	r0, r4
 8012cbe:	f7ff fc51 	bl	8012564 <opus_decode_frame>
 8012cc2:	2301      	movs	r3, #1
 8012cc4:	617b      	str	r3, [r7, #20]
 8012cc6:	e792      	b.n	8012bee <opus_decode_frame+0x68a>
      if (mode == MODE_HYBRID)
 8012cc8:	f240 33e9 	movw	r3, #1001	; 0x3e9
 8012ccc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8012cce:	429a      	cmp	r2, r3
 8012cd0:	f000 80d3 	beq.w	8012e7a <opus_decode_frame+0x916>
         celt_to_silk = ec_dec_bit_logp(&dec, 1);
 8012cd4:	2101      	movs	r1, #1
 8012cd6:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8012cd8:	f7f5 fc06 	bl	80084e8 <ec_dec_bit_logp>
 8012cdc:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8012cde:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8012ce0:	fab2 f282 	clz	r2, r2
 8012ce4:	f1c2 0220 	rsb	r2, r2, #32
 8012ce8:	1a9b      	subs	r3, r3, r2
               (opus_int32)ec_dec_uint(&dec, 256)+2 :
 8012cea:	6af9      	ldr	r1, [r7, #44]	; 0x2c
               len-((ec_tell(&dec)+7)>>3);
 8012cec:	1dda      	adds	r2, r3, #7
               (opus_int32)ec_dec_uint(&dec, 256)+2 :
 8012cee:	eba1 02e2 	sub.w	r2, r1, r2, asr #3
 8012cf2:	60fa      	str	r2, [r7, #12]
         redundancy = 1;
 8012cf4:	2201      	movs	r2, #1
         celt_to_silk = ec_dec_bit_logp(&dec, 1);
 8012cf6:	4681      	mov	r9, r0
         redundancy = 1;
 8012cf8:	623a      	str	r2, [r7, #32]
         len -= redundancy_bytes;
 8012cfa:	68fa      	ldr	r2, [r7, #12]
 8012cfc:	1a89      	subs	r1, r1, r2
         if (len*8 < ec_tell(&dec))
 8012cfe:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
         len -= redundancy_bytes;
 8012d02:	62f9      	str	r1, [r7, #44]	; 0x2c
         if (len*8 < ec_tell(&dec))
 8012d04:	dd03      	ble.n	8012d0e <opus_decode_frame+0x7aa>
            redundancy_bytes = 0;
 8012d06:	2200      	movs	r2, #0
 8012d08:	60fa      	str	r2, [r7, #12]
            redundancy = 0;
 8012d0a:	623a      	str	r2, [r7, #32]
            len = 0;
 8012d0c:	62fa      	str	r2, [r7, #44]	; 0x2c
         dec.storage -= redundancy_bytes;
 8012d0e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8012d10:	f04f 0800 	mov.w	r8, #0
 8012d14:	1a9b      	subs	r3, r3, r2
 8012d16:	667b      	str	r3, [r7, #100]	; 0x64
   if (redundancy)
 8012d18:	6a3b      	ldr	r3, [r7, #32]
      start_band = 17;
 8012d1a:	2511      	movs	r5, #17
   if (redundancy)
 8012d1c:	2b00      	cmp	r3, #0
 8012d1e:	f43f ad4a 	beq.w	80127b6 <opus_decode_frame+0x252>
   ALLOC(pcm_transition_silk, pcm_transition_silk_size, opus_val16);
 8012d22:	f8c7 d044 	str.w	sp, [r7, #68]	; 0x44
      transition = 0;
 8012d26:	f8c7 8014 	str.w	r8, [r7, #20]
 8012d2a:	e556      	b.n	80127da <opus_decode_frame+0x276>
   pcm_silk_size = (mode != MODE_CELT_ONLY && !celt_accum) ? IMAX(F10, frame_size)*st->channels : ALLOC_NONE;
 8012d2c:	2301      	movs	r3, #1
 8012d2e:	613b      	str	r3, [r7, #16]
 8012d30:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8012d34:	647b      	str	r3, [r7, #68]	; 0x44
 8012d36:	e4a7      	b.n	8012688 <opus_decode_frame+0x124>
             return OPUS_INTERNAL_ERROR;
 8012d38:	f06f 0502 	mvn.w	r5, #2
 8012d3c:	e580      	b.n	8012840 <opus_decode_frame+0x2dc>
           if( bandwidth == OPUS_BANDWIDTH_NARROWBAND ) {
 8012d3e:	f240 434d 	movw	r3, #1101	; 0x44d
 8012d42:	69fa      	ldr	r2, [r7, #28]
 8012d44:	429a      	cmp	r2, r3
 8012d46:	d054      	beq.n	8012df2 <opus_decode_frame+0x88e>
           } else if( bandwidth == OPUS_BANDWIDTH_MEDIUMBAND ) {
 8012d48:	f240 434e 	movw	r3, #1102	; 0x44e
 8012d4c:	429a      	cmp	r2, r3
 8012d4e:	f47f acc9 	bne.w	80126e4 <opus_decode_frame+0x180>
              st->DecControl.internalSampleRate = 12000;
 8012d52:	f642 63e0 	movw	r3, #12000	; 0x2ee0
 8012d56:	61e3      	str	r3, [r4, #28]
 8012d58:	e4c7      	b.n	80126ea <opus_decode_frame+0x186>
 8012d5a:	4605      	mov	r5, r0
 8012d5c:	e465      	b.n	801262a <opus_decode_frame+0xc6>
         silk_InitDecoder( silk_dec );
 8012d5e:	4640      	mov	r0, r8
 8012d60:	f7fc f832 	bl	800edc8 <silk_InitDecoder>
 8012d64:	e4a8      	b.n	80126b8 <opus_decode_frame+0x154>
      opus_decode_frame(st, NULL, 0, pcm_transition, IMIN(F5, audiosize), 0);
 8012d66:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8012d68:	6a38      	ldr	r0, [r7, #32]
 8012d6a:	455a      	cmp	r2, fp
 8012d6c:	bfa8      	it	ge
 8012d6e:	465a      	movge	r2, fp
 8012d70:	4611      	mov	r1, r2
 8012d72:	2200      	movs	r2, #0
 8012d74:	e9cd 1000 	strd	r1, r0, [sp]
 8012d78:	4611      	mov	r1, r2
 8012d7a:	4620      	mov	r0, r4
   ALLOC(pcm_transition_silk, pcm_transition_silk_size, opus_val16);
 8012d7c:	4698      	mov	r8, r3
      opus_decode_frame(st, NULL, 0, pcm_transition, IMIN(F5, audiosize), 0);
 8012d7e:	f7ff fbf1 	bl	8012564 <opus_decode_frame>
 8012d82:	e52a      	b.n	80127da <opus_decode_frame+0x276>
   int celt_to_silk=0;
 8012d84:	4699      	mov	r9, r3
   int redundancy_bytes = 0;
 8012d86:	60fb      	str	r3, [r7, #12]
   int redundancy=0;
 8012d88:	623b      	str	r3, [r7, #32]
 8012d8a:	4698      	mov	r8, r3
      start_band = 17;
 8012d8c:	2511      	movs	r5, #17
 8012d8e:	e512      	b.n	80127b6 <opus_decode_frame+0x252>
      return OPUS_BUFFER_TOO_SMALL;
 8012d90:	f06f 0501 	mvn.w	r5, #1
 8012d94:	e449      	b.n	801262a <opus_decode_frame+0xc6>
 8012d96:	f107 0a5c 	add.w	sl, r7, #92	; 0x5c
   if (mode != MODE_CELT_ONLY && !celt_accum)
 8012d9a:	69bb      	ldr	r3, [r7, #24]
 8012d9c:	2b00      	cmp	r3, #0
 8012d9e:	f47f adb1 	bne.w	8012904 <opus_decode_frame+0x3a0>
      for (i=0;i<frame_size*st->channels;i++)
 8012da2:	68a0      	ldr	r0, [r4, #8]
 8012da4:	fb00 f00b 	mul.w	r0, r0, fp
 8012da8:	2800      	cmp	r0, #0
 8012daa:	f77f adab 	ble.w	8012904 <opus_decode_frame+0x3a0>
 8012dae:	6bbb      	ldr	r3, [r7, #56]	; 0x38

#define ABS16(x) ((x) < 0 ? (-(x)) : (x))
#define ABS32(x) ((x) < 0 ? (-(x)) : (x))

static OPUS_INLINE opus_int16 SAT16(opus_int32 x) {
   return x > 32767 ? 32767 : x < -32768 ? -32768 : (opus_int16)x;
 8012db0:	f8df c248 	ldr.w	ip, [pc, #584]	; 8012ffc <opus_decode_frame+0xa98>
 8012db4:	1e9a      	subs	r2, r3, #2
 8012db6:	68bb      	ldr	r3, [r7, #8]
 8012db8:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 8012dbc:	1e99      	subs	r1, r3, #2
 8012dbe:	e007      	b.n	8012dd0 <opus_decode_frame+0x86c>
 8012dc0:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8012dc4:	db19      	blt.n	8012dfa <opus_decode_frame+0x896>
 8012dc6:	b21b      	sxth	r3, r3
 8012dc8:	4290      	cmp	r0, r2
         pcm[i] = SAT16(ADD32(pcm[i], pcm_silk[i]));
 8012dca:	8013      	strh	r3, [r2, #0]
      for (i=0;i<frame_size*st->channels;i++)
 8012dcc:	f43f ad9a 	beq.w	8012904 <opus_decode_frame+0x3a0>
         pcm[i] = SAT16(ADD32(pcm[i], pcm_silk[i]));
 8012dd0:	f931 3f02 	ldrsh.w	r3, [r1, #2]!
 8012dd4:	f932 ef02 	ldrsh.w	lr, [r2, #2]!
 8012dd8:	4473      	add	r3, lr
 8012dda:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8012dde:	dbef      	blt.n	8012dc0 <opus_decode_frame+0x85c>
 8012de0:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8012de4:	e7f0      	b.n	8012dc8 <opus_decode_frame+0x864>
      for (i=0;i<frame_size*st->channels;i++)
 8012de6:	42b1      	cmp	r1, r6
         pcm[i] = SATURATE(x, 32767);
 8012de8:	f8a1 e000 	strh.w	lr, [r1]
      for (i=0;i<frame_size*st->channels;i++)
 8012dec:	f47f ae9f 	bne.w	8012b2e <opus_decode_frame+0x5ca>
 8012df0:	e6b1      	b.n	8012b56 <opus_decode_frame+0x5f2>
              st->DecControl.internalSampleRate = 8000;
 8012df2:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 8012df6:	61e3      	str	r3, [r4, #28]
 8012df8:	e477      	b.n	80126ea <opus_decode_frame+0x186>
 8012dfa:	4663      	mov	r3, ip
 8012dfc:	e7e4      	b.n	8012dc8 <opus_decode_frame+0x864>
      unsigned char silence[2] = {0xFF, 0xFF};
 8012dfe:	4a7d      	ldr	r2, [pc, #500]	; (8012ff4 <opus_decode_frame+0xa90>)
      if (!celt_accum)
 8012e00:	69b9      	ldr	r1, [r7, #24]
      unsigned char silence[2] = {0xFF, 0xFF};
 8012e02:	8812      	ldrh	r2, [r2, #0]
 8012e04:	f8a7 205c 	strh.w	r2, [r7, #92]	; 0x5c
      if (!celt_accum)
 8012e08:	b951      	cbnz	r1, 8012e20 <opus_decode_frame+0x8bc>
         for (i=0;i<frame_size*st->channels;i++)
 8012e0a:	68a2      	ldr	r2, [r4, #8]
 8012e0c:	fb02 f20b 	mul.w	r2, r2, fp
 8012e10:	2a00      	cmp	r2, #0
 8012e12:	dd05      	ble.n	8012e20 <opus_decode_frame+0x8bc>
 8012e14:	0052      	lsls	r2, r2, #1
 8012e16:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8012e18:	613b      	str	r3, [r7, #16]
 8012e1a:	f001 f985 	bl	8014128 <memset>
 8012e1e:	693b      	ldr	r3, [r7, #16]
      if (st->prev_mode == MODE_HYBRID && !(redundancy && celt_to_silk && st->prev_redundancy) )
 8012e20:	f240 32e9 	movw	r2, #1001	; 0x3e9
 8012e24:	4293      	cmp	r3, r2
 8012e26:	d1b6      	bne.n	8012d96 <opus_decode_frame+0x832>
 8012e28:	6a3b      	ldr	r3, [r7, #32]
 8012e2a:	b12b      	cbz	r3, 8012e38 <opus_decode_frame+0x8d4>
 8012e2c:	f1b9 0f00 	cmp.w	r9, #0
 8012e30:	d002      	beq.n	8012e38 <opus_decode_frame+0x8d4>
 8012e32:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8012e34:	2b00      	cmp	r3, #0
 8012e36:	d1ae      	bne.n	8012d96 <opus_decode_frame+0x832>
         MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_START_BAND(0)));
 8012e38:	2200      	movs	r2, #0
 8012e3a:	f242 711a 	movw	r1, #10010	; 0x271a
 8012e3e:	4630      	mov	r0, r6
 8012e40:	f7f4 f8b6 	bl	8006fb0 <opus_custom_decoder_ctl>
 8012e44:	2800      	cmp	r0, #0
 8012e46:	f47f aeba 	bne.w	8012bbe <opus_decode_frame+0x65a>
         celt_decode_with_ec(celt_dec, silence, 2, pcm, F2_5, NULL, celt_accum);
 8012e4a:	69bb      	ldr	r3, [r7, #24]
 8012e4c:	f107 0a5c 	add.w	sl, r7, #92	; 0x5c
 8012e50:	e9cd 0301 	strd	r0, r3, [sp, #4]
 8012e54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012e56:	4651      	mov	r1, sl
 8012e58:	9300      	str	r3, [sp, #0]
 8012e5a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012e5c:	2202      	movs	r2, #2
 8012e5e:	4630      	mov	r0, r6
 8012e60:	f7f3 f862 	bl	8005f28 <celt_decode_with_ec>
 8012e64:	e799      	b.n	8012d9a <opus_decode_frame+0x836>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8012e66:	f240 33ea 	movw	r3, #1002	; 0x3ea
 8012e6a:	4299      	cmp	r1, r3
 8012e6c:	f000 80bc 	beq.w	8012fe8 <opus_decode_frame+0xa84>
 8012e70:	2301      	movs	r3, #1
 8012e72:	46ab      	mov	fp, r5
 8012e74:	61bb      	str	r3, [r7, #24]
 8012e76:	f7ff bbed 	b.w	8012654 <opus_decode_frame+0xf0>
         redundancy = ec_dec_bit_logp(&dec, 12);
 8012e7a:	210c      	movs	r1, #12
 8012e7c:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8012e7e:	f7f5 fb33 	bl	80084e8 <ec_dec_bit_logp>
      if (redundancy)
 8012e82:	6238      	str	r0, [r7, #32]
 8012e84:	b920      	cbnz	r0, 8012e90 <opus_decode_frame+0x92c>
   int celt_to_silk=0;
 8012e86:	4681      	mov	r9, r0
   int redundancy_bytes = 0;
 8012e88:	60f8      	str	r0, [r7, #12]
 8012e8a:	4680      	mov	r8, r0
      start_band = 17;
 8012e8c:	2511      	movs	r5, #17
 8012e8e:	e492      	b.n	80127b6 <opus_decode_frame+0x252>
         celt_to_silk = ec_dec_bit_logp(&dec, 1);
 8012e90:	6c7d      	ldr	r5, [r7, #68]	; 0x44
 8012e92:	2101      	movs	r1, #1
 8012e94:	4628      	mov	r0, r5
 8012e96:	f7f5 fb27 	bl	80084e8 <ec_dec_bit_logp>
               (opus_int32)ec_dec_uint(&dec, 256)+2 :
 8012e9a:	f44f 7180 	mov.w	r1, #256	; 0x100
         celt_to_silk = ec_dec_bit_logp(&dec, 1);
 8012e9e:	4681      	mov	r9, r0
               (opus_int32)ec_dec_uint(&dec, 256)+2 :
 8012ea0:	4628      	mov	r0, r5
 8012ea2:	f7f5 fbcb 	bl	800863c <ec_dec_uint>
 8012ea6:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8012ea8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8012eaa:	fab2 f282 	clz	r2, r2
 8012eae:	1c81      	adds	r1, r0, #2
 8012eb0:	f1c2 0220 	rsb	r2, r2, #32
 8012eb4:	60f9      	str	r1, [r7, #12]
 8012eb6:	1a9b      	subs	r3, r3, r2
 8012eb8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8012eba:	e71e      	b.n	8012cfa <opus_decode_frame+0x796>
         MUST_SUCCEED(celt_decoder_ctl(celt_dec, OPUS_RESET_STATE));
 8012ebc:	f640 71bc 	movw	r1, #4028	; 0xfbc
 8012ec0:	4630      	mov	r0, r6
 8012ec2:	f7f4 f875 	bl	8006fb0 <opus_custom_decoder_ctl>
 8012ec6:	2800      	cmp	r0, #0
 8012ec8:	f47f ae79 	bne.w	8012bbe <opus_decode_frame+0x65a>
 8012ecc:	e4ff      	b.n	80128ce <opus_decode_frame+0x36a>
      MUST_SUCCEED(celt_decoder_ctl(celt_dec, OPUS_RESET_STATE));
 8012ece:	f640 71bc 	movw	r1, #4028	; 0xfbc
 8012ed2:	4630      	mov	r0, r6
 8012ed4:	f7f4 f86c 	bl	8006fb0 <opus_custom_decoder_ctl>
 8012ed8:	2800      	cmp	r0, #0
 8012eda:	f47f ae70 	bne.w	8012bbe <opus_decode_frame+0x65a>
      MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_START_BAND(0)));
 8012ede:	464a      	mov	r2, r9
 8012ee0:	f242 711a 	movw	r1, #10010	; 0x271a
 8012ee4:	4630      	mov	r0, r6
 8012ee6:	f7f4 f863 	bl	8006fb0 <opus_custom_decoder_ctl>
 8012eea:	2800      	cmp	r0, #0
 8012eec:	f47f ae67 	bne.w	8012bbe <opus_decode_frame+0x65a>
      celt_decode_with_ec(celt_dec, data+len, redundancy_bytes, redundant_audio, F5, NULL, 0);
 8012ef0:	e9cd 9901 	strd	r9, r9, [sp, #4]
 8012ef4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012ef6:	9300      	str	r3, [sp, #0]
 8012ef8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8012efa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012efc:	68fa      	ldr	r2, [r7, #12]
 8012efe:	4403      	add	r3, r0
 8012f00:	4619      	mov	r1, r3
 8012f02:	4630      	mov	r0, r6
 8012f04:	69fb      	ldr	r3, [r7, #28]
 8012f06:	f7f3 f80f 	bl	8005f28 <celt_decode_with_ec>
      MUST_SUCCEED(celt_decoder_ctl(celt_dec, OPUS_GET_FINAL_RANGE(&redundant_rng)));
 8012f0a:	4630      	mov	r0, r6
 8012f0c:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8012f10:	f640 71bf 	movw	r1, #4031	; 0xfbf
 8012f14:	f7f4 f84c 	bl	8006fb0 <opus_custom_decoder_ctl>
 8012f18:	2800      	cmp	r0, #0
 8012f1a:	f47f ae50 	bne.w	8012bbe <opus_decode_frame+0x65a>
      smooth_fade(pcm+st->channels*(frame_size-F2_5), redundant_audio+st->channels*F2_5,
 8012f1e:	68a3      	ldr	r3, [r4, #8]
 8012f20:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8012f22:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 8012f26:	ebab 0201 	sub.w	r2, fp, r1
 8012f2a:	fb01 f103 	mul.w	r1, r1, r3
 8012f2e:	69fe      	ldr	r6, [r7, #28]
 8012f30:	fb03 f202 	mul.w	r2, r3, r2
 8012f34:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8012f36:	9300      	str	r3, [sp, #0]
 8012f38:	f8cd c008 	str.w	ip, [sp, #8]
 8012f3c:	eb06 0141 	add.w	r1, r6, r1, lsl #1
 8012f40:	69be      	ldr	r6, [r7, #24]
 8012f42:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 8012f46:	9601      	str	r6, [sp, #4]
 8012f48:	4610      	mov	r0, r2
 8012f4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012f4c:	f7ff fad2 	bl	80124f4 <smooth_fade>
 8012f50:	e54b      	b.n	80129ea <opus_decode_frame+0x486>
      return 0x7f000000;
 8012f52:	f04f 40fe 	mov.w	r0, #2130706432	; 0x7f000000
 8012f56:	e5da      	b.n	8012b0e <opus_decode_frame+0x5aa>
      return 0;
 8012f58:	2000      	movs	r0, #0
 8012f5a:	e5d8      	b.n	8012b0e <opus_decode_frame+0x5aa>
   for (c=0;c<channels;c++)
 8012f5c:	2b00      	cmp	r3, #0
 8012f5e:	f77f ad9c 	ble.w	8012a9a <opus_decode_frame+0x536>
 8012f62:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8012f64:	2a00      	cmp	r2, #0
 8012f66:	f77f ad98 	ble.w	8012a9a <opus_decode_frame+0x536>
 8012f6a:	f8c7 b030 	str.w	fp, [r7, #48]	; 0x30
 8012f6e:	2000      	movs	r0, #0
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012f70:	f647 71ff 	movw	r1, #32767	; 0x7fff
 8012f74:	4693      	mov	fp, r2
 8012f76:	f8c7 9024 	str.w	r9, [r7, #36]	; 0x24
 8012f7a:	f8d7 9038 	ldr.w	r9, [r7, #56]	; 0x38
 8012f7e:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 8012f82:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
 8012f86:	61fd      	str	r5, [r7, #28]
      for (i=0;i<overlap;i++)
 8012f88:	4605      	mov	r5, r0
 8012f8a:	2600      	movs	r6, #0
 8012f8c:	f8d7 c018 	ldr.w	ip, [r7, #24]
 8012f90:	6438      	str	r0, [r7, #64]	; 0x40
         opus_val16 w = MULT16_16_Q15(window[i*inc], window[i*inc]);
 8012f92:	f9bc 3000 	ldrsh.w	r3, [ip]
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012f96:	f838 0005 	ldrh.w	r0, [r8, r5]
         opus_val16 w = MULT16_16_Q15(window[i*inc], window[i*inc]);
 8012f9a:	fb03 f303 	mul.w	r3, r3, r3
 8012f9e:	13db      	asrs	r3, r3, #15
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012fa0:	1aca      	subs	r2, r1, r3
 8012fa2:	fb10 f202 	smulbb	r2, r0, r2
 8012fa6:	f839 0005 	ldrh.w	r0, [r9, r5]
      for (i=0;i<overlap;i++)
 8012faa:	3601      	adds	r6, #1
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012fac:	fb13 2300 	smlabb	r3, r3, r0, r2
      for (i=0;i<overlap;i++)
 8012fb0:	45b3      	cmp	fp, r6
         out[i*channels+c] = SHR32(MAC16_16(MULT16_16(w,in2[i*channels+c]),
 8012fb2:	ea4f 33e3 	mov.w	r3, r3, asr #15
 8012fb6:	f829 3005 	strh.w	r3, [r9, r5]
 8012fba:	44d4      	add	ip, sl
 8012fbc:	4475      	add	r5, lr
      for (i=0;i<overlap;i++)
 8012fbe:	d1e8      	bne.n	8012f92 <opus_decode_frame+0xa2e>
 8012fc0:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8012fc2:	3002      	adds	r0, #2
   for (c=0;c<channels;c++)
 8012fc4:	4586      	cmp	lr, r0
 8012fc6:	d1df      	bne.n	8012f88 <opus_decode_frame+0xa24>
 8012fc8:	f8d7 b030 	ldr.w	fp, [r7, #48]	; 0x30
 8012fcc:	f8d7 9024 	ldr.w	r9, [r7, #36]	; 0x24
 8012fd0:	69fd      	ldr	r5, [r7, #28]
 8012fd2:	e562      	b.n	8012a9a <opus_decode_frame+0x536>
 8012fd4:	0076      	lsls	r6, r6, #1
 8012fd6:	e523      	b.n	8012a20 <opus_decode_frame+0x4bc>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8012fd8:	46cb      	mov	fp, r9
 8012fda:	f240 33ea 	movw	r3, #1002	; 0x3ea
 8012fde:	63fb      	str	r3, [r7, #60]	; 0x3c
 8012fe0:	2300      	movs	r3, #0
 8012fe2:	61bb      	str	r3, [r7, #24]
 8012fe4:	f7ff bb36 	b.w	8012654 <opus_decode_frame+0xf0>
 8012fe8:	46ab      	mov	fp, r5
 8012fea:	e7f6      	b.n	8012fda <opus_decode_frame+0xa76>
 8012fec:	f8d7 b030 	ldr.w	fp, [r7, #48]	; 0x30
 8012ff0:	e7f3      	b.n	8012fda <opus_decode_frame+0xa76>
 8012ff2:	bf00      	nop
 8012ff4:	08014e9c 	.word	0x08014e9c
 8012ff8:	ffff8001 	.word	0xffff8001
 8012ffc:	ffff8000 	.word	0xffff8000

08013000 <opus_decode>:

#ifdef FIXED_POINT

int opus_decode(OpusDecoder *st, const unsigned char *data,
      opus_int32 len, opus_val16 *pcm, int frame_size, int decode_fec)
{
 8013000:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013004:	b0ad      	sub	sp, #180	; 0xb4
 8013006:	af04      	add	r7, sp, #16
   if(frame_size<=0)
 8013008:	e9d7 5432 	ldrd	r5, r4, [r7, #200]	; 0xc8
 801300c:	2d00      	cmp	r5, #0
 801300e:	f340 82f2 	ble.w	80135f6 <opus_decode+0x5f6>
   if (decode_fec<0 || decode_fec>1)
 8013012:	2c01      	cmp	r4, #1
 8013014:	f200 82ef 	bhi.w	80135f6 <opus_decode+0x5f6>
 8013018:	62bb      	str	r3, [r7, #40]	; 0x28
 801301a:	4693      	mov	fp, r2
 801301c:	460d      	mov	r5, r1
 801301e:	4682      	mov	sl, r0
   if ((decode_fec || len==0 || data==NULL) && frame_size%(st->Fs/400)!=0)
 8013020:	2c00      	cmp	r4, #0
 8013022:	f000 808c 	beq.w	801313e <opus_decode+0x13e>
 8013026:	68c2      	ldr	r2, [r0, #12]
 8013028:	49d6      	ldr	r1, [pc, #856]	; (8013384 <opus_decode+0x384>)
 801302a:	17d3      	asrs	r3, r2, #31
 801302c:	fb81 0102 	smull	r0, r1, r1, r2
 8013030:	f8d7 00c8 	ldr.w	r0, [r7, #200]	; 0xc8
 8013034:	ebc3 11e1 	rsb	r1, r3, r1, asr #7
 8013038:	fb90 f0f1 	sdiv	r0, r0, r1
 801303c:	f8d7 60c8 	ldr.w	r6, [r7, #200]	; 0xc8
 8013040:	fb01 6110 	mls	r1, r1, r0, r6
 8013044:	2900      	cmp	r1, #0
 8013046:	f040 82d6 	bne.w	80135f6 <opus_decode+0x5f6>
   if (len==0 || data==NULL)
 801304a:	f1bb 0f00 	cmp.w	fp, #0
 801304e:	f000 808c 	beq.w	801316a <opus_decode+0x16a>
 8013052:	2d00      	cmp	r5, #0
 8013054:	f000 8089 	beq.w	801316a <opus_decode+0x16a>
   } else if (len<0)
 8013058:	f1bb 0f00 	cmp.w	fp, #0
 801305c:	f2c0 82cb 	blt.w	80135f6 <opus_decode+0x5f6>
   packet_mode = opus_packet_get_mode(data);
 8013060:	782b      	ldrb	r3, [r5, #0]
   if (data[0]&0x80)
 8013062:	061a      	lsls	r2, r3, #24
 8013064:	f100 82cc 	bmi.w	8013600 <opus_decode+0x600>
   } else if ((data[0]&0x60) == 0x60)
 8013068:	f003 0260 	and.w	r2, r3, #96	; 0x60
 801306c:	2a60      	cmp	r2, #96	; 0x60
 801306e:	f000 8245 	beq.w	80134fc <opus_decode+0x4fc>
   } else if ((data[0]&0x60) == 0x60)
   {
      bandwidth = (data[0]&0x10) ? OPUS_BANDWIDTH_FULLBAND :
                                   OPUS_BANDWIDTH_SUPERWIDEBAND;
   } else {
      bandwidth = OPUS_BANDWIDTH_NARROWBAND + ((data[0]>>5)&0x3);
 8013072:	095b      	lsrs	r3, r3, #5
 8013074:	f203 484d 	addw	r8, r3, #1101	; 0x44d
      mode = MODE_SILK_ONLY;
 8013078:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 801307c:	62fb      	str	r3, [r7, #44]	; 0x2c
   packet_frame_size = opus_packet_get_samples_per_frame(data, st->Fs);
 801307e:	f8da 100c 	ldr.w	r1, [sl, #12]
 8013082:	4628      	mov	r0, r5
 8013084:	f7fe fff0 	bl	8012068 <opus_packet_get_samples_per_frame>
 8013088:	4681      	mov	r9, r0
   return bandwidth;
}

int opus_packet_get_nb_channels(const unsigned char *data)
{
   return (data[0]&0x4) ? 2 : 1;
 801308a:	7828      	ldrb	r0, [r5, #0]
   count = opus_packet_parse_impl(data, len, self_delimited, &toc, NULL,
 801308c:	2200      	movs	r2, #0
   return (data[0]&0x4) ? 2 : 1;
 801308e:	f010 0f04 	tst.w	r0, #4
 8013092:	bf0c      	ite	eq
 8013094:	2601      	moveq	r6, #1
 8013096:	2602      	movne	r6, #2
   count = opus_packet_parse_impl(data, len, self_delimited, &toc, NULL,
 8013098:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801309c:	9302      	str	r3, [sp, #8]
 801309e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80130a2:	9301      	str	r3, [sp, #4]
 80130a4:	4659      	mov	r1, fp
 80130a6:	9203      	str	r2, [sp, #12]
 80130a8:	9200      	str	r2, [sp, #0]
 80130aa:	f107 0338 	add.w	r3, r7, #56	; 0x38
 80130ae:	4628      	mov	r0, r5
   return (data[0]&0x4) ? 2 : 1;
 80130b0:	627e      	str	r6, [r7, #36]	; 0x24
   count = opus_packet_parse_impl(data, len, self_delimited, &toc, NULL,
 80130b2:	f7ff f811 	bl	80120d8 <opus_packet_parse_impl>
   if (count<0)
 80130b6:	f1b0 0b00 	subs.w	fp, r0, #0
 80130ba:	f2c0 8133 	blt.w	8013324 <opus_decode+0x324>
   data += offset;
 80130be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80130c0:	441d      	add	r5, r3
   if (decode_fec)
 80130c2:	2c00      	cmp	r4, #0
 80130c4:	f000 816c 	beq.w	80133a0 <opus_decode+0x3a0>
      if (frame_size < packet_frame_size || packet_mode == MODE_CELT_ONLY || st->mode == MODE_CELT_ONLY)
 80130c8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80130cc:	454b      	cmp	r3, r9
 80130ce:	f2c0 82df 	blt.w	8013690 <opus_decode+0x690>
 80130d2:	f240 33ea 	movw	r3, #1002	; 0x3ea
 80130d6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80130d8:	429a      	cmp	r2, r3
 80130da:	f000 82d9 	beq.w	8013690 <opus_decode+0x690>
 80130de:	f8da 2038 	ldr.w	r2, [sl, #56]	; 0x38
 80130e2:	429a      	cmp	r2, r3
 80130e4:	f000 82d4 	beq.w	8013690 <opus_decode+0x690>
 80130e8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
      if (frame_size-packet_frame_size!=0)
 80130ec:	454b      	cmp	r3, r9
 80130ee:	eba3 0609 	sub.w	r6, r3, r9
 80130f2:	f040 8299 	bne.w	8013628 <opus_decode+0x628>
      ret = opus_decode_frame(st, data, size[0], pcm+st->channels*(frame_size-packet_frame_size),
 80130f6:	2001      	movs	r0, #1
 80130f8:	f8da 3008 	ldr.w	r3, [sl, #8]
      st->mode = packet_mode;
 80130fc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
      ret = opus_decode_frame(st, data, size[0], pcm+st->channels*(frame_size-packet_frame_size),
 80130fe:	fb03 f306 	mul.w	r3, r3, r6
      st->stream_channels = packet_stream_channels;
 8013102:	6a79      	ldr	r1, [r7, #36]	; 0x24
      ret = opus_decode_frame(st, data, size[0], pcm+st->channels*(frame_size-packet_frame_size),
 8013104:	6abc      	ldr	r4, [r7, #40]	; 0x28
      st->mode = packet_mode;
 8013106:	f8ca 2038 	str.w	r2, [sl, #56]	; 0x38
      st->stream_channels = packet_stream_channels;
 801310a:	f8ca 1030 	str.w	r1, [sl, #48]	; 0x30
      ret = opus_decode_frame(st, data, size[0], pcm+st->channels*(frame_size-packet_frame_size),
 801310e:	f9b7 2040 	ldrsh.w	r2, [r7, #64]	; 0x40
      st->bandwidth = packet_bandwidth;
 8013112:	f8ca 8034 	str.w	r8, [sl, #52]	; 0x34
      st->frame_size = packet_frame_size;
 8013116:	f8ca 9040 	str.w	r9, [sl, #64]	; 0x40
      ret = opus_decode_frame(st, data, size[0], pcm+st->channels*(frame_size-packet_frame_size),
 801311a:	4629      	mov	r1, r5
 801311c:	e9cd 9000 	strd	r9, r0, [sp]
 8013120:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 8013124:	4650      	mov	r0, sl
 8013126:	f7ff fa1d 	bl	8012564 <opus_decode_frame>
      if (ret<0)
 801312a:	f1b0 0b00 	subs.w	fp, r0, #0
 801312e:	f2c0 80f9 	blt.w	8013324 <opus_decode+0x324>
         st->last_packet_duration = frame_size;
 8013132:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8013136:	f8ca 3048 	str.w	r3, [sl, #72]	; 0x48
 801313a:	469b      	mov	fp, r3
 801313c:	e0f2      	b.n	8013324 <opus_decode+0x324>
   if ((decode_fec || len==0 || data==NULL) && frame_size%(st->Fs/400)!=0)
 801313e:	b10a      	cbz	r2, 8013144 <opus_decode+0x144>
 8013140:	2900      	cmp	r1, #0
 8013142:	d189      	bne.n	8013058 <opus_decode+0x58>
 8013144:	f8da 200c 	ldr.w	r2, [sl, #12]
 8013148:	498e      	ldr	r1, [pc, #568]	; (8013384 <opus_decode+0x384>)
 801314a:	17d3      	asrs	r3, r2, #31
 801314c:	fb81 0102 	smull	r0, r1, r1, r2
 8013150:	f8d7 00c8 	ldr.w	r0, [r7, #200]	; 0xc8
 8013154:	ebc3 11e1 	rsb	r1, r3, r1, asr #7
 8013158:	fb90 f0f1 	sdiv	r0, r0, r1
 801315c:	f8d7 40c8 	ldr.w	r4, [r7, #200]	; 0xc8
 8013160:	fb01 4110 	mls	r1, r1, r0, r4
 8013164:	2900      	cmp	r1, #0
 8013166:	f040 8246 	bne.w	80135f6 <opus_decode+0x5f6>
{
 801316a:	f04f 0b00 	mov.w	fp, #0
 801316e:	46d9      	mov	r9, fp
 8013170:	e014      	b.n	801319c <opus_decode+0x19c>
         for (i=0;i<audiosize*st->channels;i++)
 8013172:	fb04 f000 	mul.w	r0, r4, r0
 8013176:	2800      	cmp	r0, #0
 8013178:	dd04      	ble.n	8013184 <opus_decode+0x184>
 801317a:	0042      	lsls	r2, r0, #1
 801317c:	4631      	mov	r1, r6
 801317e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8013180:	f000 ffd2 	bl	8014128 <memset>
         if (ret<0)
 8013184:	2c00      	cmp	r4, #0
 8013186:	f2c0 82e7 	blt.w	8013758 <opus_decode+0x758>
      } while (pcm_count < frame_size);
 801318a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
         pcm_count += ret;
 801318e:	44a1      	add	r9, r4
      } while (pcm_count < frame_size);
 8013190:	454b      	cmp	r3, r9
 8013192:	f340 8140 	ble.w	8013416 <opus_decode+0x416>
 8013196:	f8da 200c 	ldr.w	r2, [sl, #12]
 801319a:	17d3      	asrs	r3, r2, #31
   F20 = st->Fs/50;
 801319c:	4979      	ldr	r1, [pc, #484]	; (8013384 <opus_decode+0x384>)
         ret = opus_decode_frame(st, NULL, 0, pcm+pcm_count*st->channels, frame_size-pcm_count, 0);
 801319e:	f8da 0008 	ldr.w	r0, [sl, #8]
   F20 = st->Fs/50;
 80131a2:	fb81 4102 	smull	r4, r1, r1, r2
         ret = opus_decode_frame(st, NULL, 0, pcm+pcm_count*st->channels, frame_size-pcm_count, 0);
 80131a6:	fb09 fc00 	mul.w	ip, r9, r0
 80131aa:	f8d7 40c8 	ldr.w	r4, [r7, #200]	; 0xc8
   F20 = st->Fs/50;
 80131ae:	ebc3 1821 	rsb	r8, r3, r1, asr #4
         ret = opus_decode_frame(st, NULL, 0, pcm+pcm_count*st->channels, frame_size-pcm_count, 0);
 80131b2:	6abd      	ldr	r5, [r7, #40]	; 0x28
   F2_5 = F5>>1;
 80131b4:	ea4f 06e8 	mov.w	r6, r8, asr #3
         ret = opus_decode_frame(st, NULL, 0, pcm+pcm_count*st->channels, frame_size-pcm_count, 0);
 80131b8:	eba4 0409 	sub.w	r4, r4, r9
 80131bc:	eb05 054c 	add.w	r5, r5, ip, lsl #1
   if (frame_size < F2_5)
 80131c0:	42b4      	cmp	r4, r6
   F2_5 = F5>>1;
 80131c2:	627e      	str	r6, [r7, #36]	; 0x24
         ret = opus_decode_frame(st, NULL, 0, pcm+pcm_count*st->channels, frame_size-pcm_count, 0);
 80131c4:	62fd      	str	r5, [r7, #44]	; 0x2c
   if (frame_size < F2_5)
 80131c6:	f2c0 8228 	blt.w	801361a <opus_decode+0x61a>
      frame_size = IMIN(frame_size, st->frame_size);
 80131ca:	f8da 5040 	ldr.w	r5, [sl, #64]	; 0x40
   frame_size = IMIN(frame_size, st->Fs/25*3);
 80131ce:	ebc3 01e1 	rsb	r1, r3, r1, asr #3
      frame_size = IMIN(frame_size, st->frame_size);
 80131d2:	42a5      	cmp	r5, r4
 80131d4:	bfa8      	it	ge
 80131d6:	4625      	movge	r5, r4
      mode = st->prev_mode;
 80131d8:	f8da 603c 	ldr.w	r6, [sl, #60]	; 0x3c
   frame_size = IMIN(frame_size, st->Fs/25*3);
 80131dc:	eb01 0441 	add.w	r4, r1, r1, lsl #1
      frame_size = IMIN(frame_size, st->frame_size);
 80131e0:	42ac      	cmp	r4, r5
 80131e2:	bfa8      	it	ge
 80131e4:	462c      	movge	r4, r5
      if (mode == 0)
 80131e6:	2e00      	cmp	r6, #0
 80131e8:	d0c3      	beq.n	8013172 <opus_decode+0x172>
      if (audiosize > F20)
 80131ea:	45a0      	cmp	r8, r4
 80131ec:	f2c0 809f 	blt.w	801332e <opus_decode+0x32e>
   celt_dec = (CELTDecoder*)((char*)st+st->celt_dec_offset);
 80131f0:	e9da 3100 	ldrd	r3, r1, [sl]
   F10 = F20>>1;
 80131f4:	ea4f 0b68 	mov.w	fp, r8, asr #1
   celt_dec = (CELTDecoder*)((char*)st+st->celt_dec_offset);
 80131f8:	61fb      	str	r3, [r7, #28]
      } else if (audiosize < F20)
 80131fa:	dd0a      	ble.n	8013212 <opus_decode+0x212>
         if (audiosize > F10)
 80131fc:	45a3      	cmp	fp, r4
 80131fe:	f2c0 80b4 	blt.w	801336a <opus_decode+0x36a>
         else if (mode != MODE_SILK_ONLY && audiosize > F5 && audiosize < F10)
 8013202:	f5b6 7f7a 	cmp.w	r6, #1000	; 0x3e8
 8013206:	d009      	beq.n	801321c <opus_decode+0x21c>
   F5 = F10>>1;
 8013208:	ea4f 03a8 	mov.w	r3, r8, asr #2
         else if (mode != MODE_SILK_ONLY && audiosize > F5 && audiosize < F10)
 801320c:	42a3      	cmp	r3, r4
 801320e:	f2c0 811c 	blt.w	801344a <opus_decode+0x44a>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8013212:	f240 33ea 	movw	r3, #1002	; 0x3ea
 8013216:	429e      	cmp	r6, r3
 8013218:	f000 810a 	beq.w	8013430 <opus_decode+0x430>
 801321c:	45a3      	cmp	fp, r4
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 801321e:	bfc8      	it	gt
 8013220:	f8c7 d018 	strgt.w	sp, [r7, #24]
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8013224:	f340 81ea 	ble.w	80135fc <opus_decode+0x5fc>
   pcm_silk_size = (mode != MODE_CELT_ONLY && !celt_accum) ? IMAX(F10, frame_size)*st->channels : ALLOC_NONE;
 8013228:	45a3      	cmp	fp, r4
 801322a:	465b      	mov	r3, fp
 801322c:	bfb8      	it	lt
 801322e:	4623      	movlt	r3, r4
 8013230:	fb00 f303 	mul.w	r3, r0, r3
   ALLOC(pcm_silk, pcm_silk_size, opus_int16);
 8013234:	005b      	lsls	r3, r3, #1
 8013236:	3308      	adds	r3, #8
 8013238:	f023 0307 	bic.w	r3, r3, #7
 801323c:	ebad 0d03 	sub.w	sp, sp, r3
 8013240:	2300      	movs	r3, #0
 8013242:	46a3      	mov	fp, r4
 8013244:	ad04      	add	r5, sp, #16
 8013246:	607d      	str	r5, [r7, #4]
 8013248:	617b      	str	r3, [r7, #20]
      st->DecControl.payloadSize_ms = IMAX(10, 1000 * audiosize / st->Fs);
 801324a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 801324e:	fb03 f30b 	mul.w	r3, r3, fp
 8013252:	fb93 f2f2 	sdiv	r2, r3, r2
 8013256:	2a0a      	cmp	r2, #10
 8013258:	bfb8      	it	lt
 801325a:	220a      	movlt	r2, #10
 801325c:	eb0a 0301 	add.w	r3, sl, r1
 8013260:	f8ca 2020 	str.w	r2, [sl, #32]
 8013264:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8013268:	f10a 0210 	add.w	r2, sl, #16
 801326c:	e9c7 6803 	strd	r6, r8, [r7, #12]
 8013270:	f8c7 9008 	str.w	r9, [r7, #8]
 8013274:	465e      	mov	r6, fp
     decoded_samples = 0;
 8013276:	2400      	movs	r4, #0
 8013278:	4690      	mov	r8, r2
 801327a:	4689      	mov	r9, r1
 801327c:	469b      	mov	fp, r3
 801327e:	e009      	b.n	8013294 <opus_decode+0x294>
 8013280:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8013282:	f8da 2008 	ldr.w	r2, [sl, #8]
 8013286:	fb02 f201 	mul.w	r2, r2, r1
 801328a:	0053      	lsls	r3, r2, #1
        decoded_samples += silk_frame_size;
 801328c:	440c      	add	r4, r1
      } while( decoded_samples < frame_size );
 801328e:	42b4      	cmp	r4, r6
        pcm_ptr += silk_frame_size * st->channels;
 8013290:	441d      	add	r5, r3
      } while( decoded_samples < frame_size );
 8013292:	da28      	bge.n	80132e6 <opus_decode+0x2e6>
        silk_ret = silk_Decode( silk_dec, &st->DecControl,
 8013294:	fab4 f384 	clz	r3, r4
 8013298:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
 801329c:	095b      	lsrs	r3, r3, #5
 801329e:	9203      	str	r2, [sp, #12]
 80132a0:	f107 0238 	add.w	r2, r7, #56	; 0x38
 80132a4:	e9cd 5201 	strd	r5, r2, [sp, #4]
 80132a8:	f8cd 9000 	str.w	r9, [sp]
 80132ac:	2201      	movs	r2, #1
 80132ae:	4641      	mov	r1, r8
 80132b0:	4658      	mov	r0, fp
 80132b2:	f7fb fd9d 	bl	800edf0 <silk_Decode>
        if( silk_ret ) {
 80132b6:	2800      	cmp	r0, #0
 80132b8:	d0e2      	beq.n	8013280 <opus_decode+0x280>
              for (i=0;i<frame_size*st->channels;i++)
 80132ba:	f8da 2008 	ldr.w	r2, [sl, #8]
              silk_frame_size = frame_size;
 80132be:	63be      	str	r6, [r7, #56]	; 0x38
              for (i=0;i<frame_size*st->channels;i++)
 80132c0:	fb02 f206 	mul.w	r2, r2, r6
 80132c4:	2a00      	cmp	r2, #0
                 pcm_ptr[i] = 0;
 80132c6:	ea4f 0342 	mov.w	r3, r2, lsl #1
              for (i=0;i<frame_size*st->channels;i++)
 80132ca:	f340 80bb 	ble.w	8013444 <opus_decode+0x444>
 80132ce:	461a      	mov	r2, r3
 80132d0:	2100      	movs	r1, #0
 80132d2:	4628      	mov	r0, r5
 80132d4:	623b      	str	r3, [r7, #32]
 80132d6:	f000 ff27 	bl	8014128 <memset>
                 pcm_ptr[i] = 0;
 80132da:	4631      	mov	r1, r6
 80132dc:	6a3b      	ldr	r3, [r7, #32]
        decoded_samples += silk_frame_size;
 80132de:	440c      	add	r4, r1
      } while( decoded_samples < frame_size );
 80132e0:	42b4      	cmp	r4, r6
        pcm_ptr += silk_frame_size * st->channels;
 80132e2:	441d      	add	r5, r3
      } while( decoded_samples < frame_size );
 80132e4:	dbd6      	blt.n	8013294 <opus_decode+0x294>
      start_band = 17;
 80132e6:	2411      	movs	r4, #17
 80132e8:	f8d7 8010 	ldr.w	r8, [r7, #16]
 80132ec:	46b3      	mov	fp, r6
 80132ee:	e9d7 9602 	ldrd	r9, r6, [r7, #8]
   celt_dec = (CELTDecoder*)((char*)st+st->celt_dec_offset);
 80132f2:	69fb      	ldr	r3, [r7, #28]
   MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_CHANNELS(st->stream_channels)));
 80132f4:	f8da 2030 	ldr.w	r2, [sl, #48]	; 0x30
   celt_dec = (CELTDecoder*)((char*)st+st->celt_dec_offset);
 80132f8:	4453      	add	r3, sl
   MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_CHANNELS(st->stream_channels)));
 80132fa:	4618      	mov	r0, r3
 80132fc:	f242 7118 	movw	r1, #10008	; 0x2718
   celt_dec = (CELTDecoder*)((char*)st+st->celt_dec_offset);
 8013300:	461d      	mov	r5, r3
   MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_CHANNELS(st->stream_channels)));
 8013302:	f7f3 fe55 	bl	8006fb0 <opus_custom_decoder_ctl>
 8013306:	b948      	cbnz	r0, 801331c <opus_decode+0x31c>
   MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_START_BAND(start_band)));
 8013308:	4622      	mov	r2, r4
 801330a:	f242 711a 	movw	r1, #10010	; 0x271a
 801330e:	4628      	mov	r0, r5
 8013310:	f7f3 fe4e 	bl	8006fb0 <opus_custom_decoder_ctl>
 8013314:	4604      	mov	r4, r0
 8013316:	2800      	cmp	r0, #0
 8013318:	f000 80a1 	beq.w	801345e <opus_decode+0x45e>
      MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_GET_MODE(&celt_mode)));
 801331c:	f06f 0b02 	mvn.w	fp, #2
 8013320:	f8d7 d018 	ldr.w	sp, [r7, #24]
}
 8013324:	4658      	mov	r0, fp
 8013326:	37a4      	adds	r7, #164	; 0xa4
 8013328:	46bd      	mov	sp, r7
 801332a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (audiosize > F20)
 801332e:	4625      	mov	r5, r4
            int ret = opus_decode_frame(st, NULL, 0, pcm, IMIN(audiosize, F20), 0);
 8013330:	2600      	movs	r6, #0
 8013332:	f8d7 b02c 	ldr.w	fp, [r7, #44]	; 0x2c
 8013336:	45a8      	cmp	r8, r5
 8013338:	4643      	mov	r3, r8
 801333a:	f04f 0200 	mov.w	r2, #0
 801333e:	bfa8      	it	ge
 8013340:	462b      	movge	r3, r5
 8013342:	4611      	mov	r1, r2
 8013344:	e9cd 3600 	strd	r3, r6, [sp]
 8013348:	4650      	mov	r0, sl
 801334a:	465b      	mov	r3, fp
 801334c:	f7ff f90a 	bl	8012564 <opus_decode_frame>
            if (ret<0)
 8013350:	2800      	cmp	r0, #0
            audiosize -= ret;
 8013352:	eba5 0500 	sub.w	r5, r5, r0
            if (ret<0)
 8013356:	db58      	blt.n	801340a <opus_decode+0x40a>
            pcm += ret*st->channels;
 8013358:	f8da 3008 	ldr.w	r3, [sl, #8]
         } while (audiosize > 0);
 801335c:	2d00      	cmp	r5, #0
            pcm += ret*st->channels;
 801335e:	fb03 f300 	mul.w	r3, r3, r0
 8013362:	eb0b 0b43 	add.w	fp, fp, r3, lsl #1
         } while (audiosize > 0);
 8013366:	dce6      	bgt.n	8013336 <opus_decode+0x336>
 8013368:	e70c      	b.n	8013184 <opus_decode+0x184>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 801336a:	f240 33ea 	movw	r3, #1002	; 0x3ea
 801336e:	429e      	cmp	r6, r3
 8013370:	d00b      	beq.n	801338a <opus_decode+0x38a>
   ALLOC(pcm_silk, pcm_silk_size, opus_int16);
 8013372:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8013376:	607b      	str	r3, [r7, #4]
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8013378:	2301      	movs	r3, #1
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 801337a:	f8c7 d018 	str.w	sp, [r7, #24]
         ret = opus_decode_frame(st, NULL, 0, pcm+pcm_count*st->channels, frame_size-pcm_count, 0);
 801337e:	6afd      	ldr	r5, [r7, #44]	; 0x2c
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8013380:	617b      	str	r3, [r7, #20]
 8013382:	e762      	b.n	801324a <opus_decode+0x24a>
 8013384:	51eb851f 	.word	0x51eb851f
 8013388:	469b      	mov	fp, r3
   if (audiosize > frame_size)
 801338a:	455c      	cmp	r4, fp
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 801338c:	f8c7 d018 	str.w	sp, [r7, #24]
   if (audiosize > frame_size)
 8013390:	da51      	bge.n	8013436 <opus_decode+0x436>
      return OPUS_BAD_ARG;
 8013392:	f04f 3bff 	mov.w	fp, #4294967295
}
 8013396:	4658      	mov	r0, fp
 8013398:	37a4      	adds	r7, #164	; 0xa4
 801339a:	46bd      	mov	sp, r7
 801339c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (count*packet_frame_size > frame_size)
 80133a0:	fb0b f309 	mul.w	r3, fp, r9
 80133a4:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 80133a8:	429a      	cmp	r2, r3
 80133aa:	f2c0 8136 	blt.w	801361a <opus_decode+0x61a>
   st->mode = packet_mode;
 80133ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   st->frame_size = packet_frame_size;
 80133b0:	f8ca 9040 	str.w	r9, [sl, #64]	; 0x40
   st->bandwidth = packet_bandwidth;
 80133b4:	e9ca 830d 	strd	r8, r3, [sl, #52]	; 0x34
   st->stream_channels = packet_stream_channels;
 80133b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80133ba:	f8ca 3030 	str.w	r3, [sl, #48]	; 0x30
   for (i=0;i<count;i++)
 80133be:	f1bb 0f00 	cmp.w	fp, #0
 80133c2:	f000 812d 	beq.w	8013620 <opus_decode+0x620>
 80133c6:	f107 0640 	add.w	r6, r7, #64	; 0x40
 80133ca:	eb06 094b 	add.w	r9, r6, fp, lsl #1
      ret = opus_decode_frame(st, data, size[i], pcm+nb_samples*st->channels, frame_size-nb_samples, 0);
 80133ce:	46a0      	mov	r8, r4
 80133d0:	f8d7 b028 	ldr.w	fp, [r7, #40]	; 0x28
 80133d4:	e005      	b.n	80133e2 <opus_decode+0x3e2>
      data += size[i];
 80133d6:	f936 3c02 	ldrsh.w	r3, [r6, #-2]
   for (i=0;i<count;i++)
 80133da:	454e      	cmp	r6, r9
      data += size[i];
 80133dc:	441d      	add	r5, r3
   for (i=0;i<count;i++)
 80133de:	f000 811f 	beq.w	8013620 <opus_decode+0x620>
      ret = opus_decode_frame(st, data, size[i], pcm+nb_samples*st->channels, frame_size-nb_samples, 0);
 80133e2:	f8da 3008 	ldr.w	r3, [sl, #8]
 80133e6:	f8d7 10c8 	ldr.w	r1, [r7, #200]	; 0xc8
 80133ea:	fb03 f304 	mul.w	r3, r3, r4
 80133ee:	1b09      	subs	r1, r1, r4
 80133f0:	f936 2b02 	ldrsh.w	r2, [r6], #2
 80133f4:	eb0b 0343 	add.w	r3, fp, r3, lsl #1
 80133f8:	e9cd 1800 	strd	r1, r8, [sp]
 80133fc:	4650      	mov	r0, sl
 80133fe:	4629      	mov	r1, r5
 8013400:	f7ff f8b0 	bl	8012564 <opus_decode_frame>
      if (ret<0)
 8013404:	2800      	cmp	r0, #0
      nb_samples += ret;
 8013406:	4404      	add	r4, r0
      if (ret<0)
 8013408:	dae5      	bge.n	80133d6 <opus_decode+0x3d6>
 801340a:	4683      	mov	fp, r0
}
 801340c:	4658      	mov	r0, fp
 801340e:	37a4      	adds	r7, #164	; 0xa4
 8013410:	46bd      	mov	sp, r7
 8013412:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013416:	46cb      	mov	fp, r9
 8013418:	4658      	mov	r0, fp
 801341a:	37a4      	adds	r7, #164	; 0xa4
      st->last_packet_duration = pcm_count;
 801341c:	f8ca 9048 	str.w	r9, [sl, #72]	; 0x48
}
 8013420:	46bd      	mov	sp, r7
 8013422:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 8013426:	f240 33ea 	movw	r3, #1002	; 0x3ea
 801342a:	429e      	cmp	r6, r3
 801342c:	f040 80e6 	bne.w	80135fc <opus_decode+0x5fc>
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 8013430:	46a3      	mov	fp, r4
 8013432:	f8c7 d018 	str.w	sp, [r7, #24]
              for (i=0;i<frame_size*st->channels;i++)
 8013436:	2300      	movs	r3, #0
   ALLOC(pcm_silk, pcm_silk_size, opus_int16);
 8013438:	f107 0230 	add.w	r2, r7, #48	; 0x30
              for (i=0;i<frame_size*st->channels;i++)
 801343c:	617b      	str	r3, [r7, #20]
   ALLOC(pcm_silk, pcm_silk_size, opus_int16);
 801343e:	607a      	str	r2, [r7, #4]
   start_band = 0;
 8013440:	461c      	mov	r4, r3
 8013442:	e756      	b.n	80132f2 <opus_decode+0x2f2>
              for (i=0;i<frame_size*st->channels;i++)
 8013444:	4631      	mov	r1, r6
 8013446:	0053      	lsls	r3, r2, #1
 8013448:	e720      	b.n	801328c <opus_decode+0x28c>
         else if (mode != MODE_SILK_ONLY && audiosize > F5 && audiosize < F10)
 801344a:	45a3      	cmp	fp, r4
 801344c:	ddeb      	ble.n	8013426 <opus_decode+0x426>
   celt_accum = (mode != MODE_CELT_ONLY) && (frame_size >= F10);
 801344e:	f240 35ea 	movw	r5, #1002	; 0x3ea
 8013452:	42ae      	cmp	r6, r5
 8013454:	d098      	beq.n	8013388 <opus_decode+0x388>
   if (audiosize > frame_size)
 8013456:	461c      	mov	r4, r3
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 8013458:	f8c7 d018 	str.w	sp, [r7, #24]
 801345c:	e6e4      	b.n	8013228 <opus_decode+0x228>
   if (mode != MODE_SILK_ONLY)
 801345e:	f5b6 7f7a 	cmp.w	r6, #1000	; 0x3e8
 8013462:	f8da 303c 	ldr.w	r3, [sl, #60]	; 0x3c
 8013466:	f000 813d 	beq.w	80136e4 <opus_decode+0x6e4>
      int celt_frame_size = IMIN(F20, frame_size);
 801346a:	45d8      	cmp	r8, fp
 801346c:	bfa8      	it	ge
 801346e:	46d8      	movge	r8, fp
      if (mode != st->prev_mode && st->prev_mode > 0 && !st->prev_redundancy)
 8013470:	429e      	cmp	r6, r3
 8013472:	d00c      	beq.n	801348e <opus_decode+0x48e>
 8013474:	2b00      	cmp	r3, #0
 8013476:	dd0a      	ble.n	801348e <opus_decode+0x48e>
 8013478:	f8da 3044 	ldr.w	r3, [sl, #68]	; 0x44
 801347c:	b93b      	cbnz	r3, 801348e <opus_decode+0x48e>
         MUST_SUCCEED(celt_decoder_ctl(celt_dec, OPUS_RESET_STATE));
 801347e:	f640 71bc 	movw	r1, #4028	; 0xfbc
 8013482:	4628      	mov	r0, r5
 8013484:	f7f3 fd94 	bl	8006fb0 <opus_custom_decoder_ctl>
 8013488:	2800      	cmp	r0, #0
 801348a:	f47f af47 	bne.w	801331c <opus_decode+0x31c>
      celt_ret = celt_decode_with_ec(celt_dec, decode_fec ? NULL : data,
 801348e:	2200      	movs	r2, #0
 8013490:	6979      	ldr	r1, [r7, #20]
 8013492:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8013496:	9102      	str	r1, [sp, #8]
 8013498:	f8cd 8000 	str.w	r8, [sp]
 801349c:	9301      	str	r3, [sp, #4]
 801349e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80134a0:	4611      	mov	r1, r2
 80134a2:	4628      	mov	r0, r5
 80134a4:	f7f2 fd40 	bl	8005f28 <celt_decode_with_ec>
   if (mode != MODE_CELT_ONLY && !celt_accum)
 80134a8:	f240 33ea 	movw	r3, #1002	; 0x3ea
 80134ac:	429e      	cmp	r6, r3
      celt_ret = celt_decode_with_ec(celt_dec, decode_fec ? NULL : data,
 80134ae:	4604      	mov	r4, r0
 80134b0:	f107 083c 	add.w	r8, r7, #60	; 0x3c
   if (mode != MODE_CELT_ONLY && !celt_accum)
 80134b4:	d02d      	beq.n	8013512 <opus_decode+0x512>
 80134b6:	697b      	ldr	r3, [r7, #20]
 80134b8:	bb5b      	cbnz	r3, 8013512 <opus_decode+0x512>
      for (i=0;i<frame_size*st->channels;i++)
 80134ba:	f8da 3008 	ldr.w	r3, [sl, #8]
 80134be:	fb03 fc0b 	mul.w	ip, r3, fp
 80134c2:	f1bc 0f00 	cmp.w	ip, #0
 80134c6:	dd24      	ble.n	8013512 <opus_decode+0x512>
 80134c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80134ca:	1e99      	subs	r1, r3, #2
 80134cc:	687b      	ldr	r3, [r7, #4]
 80134ce:	eb01 0c4c 	add.w	ip, r1, ip, lsl #1
 80134d2:	1e98      	subs	r0, r3, #2
 80134d4:	e007      	b.n	80134e6 <opus_decode+0x4e6>
 80134d6:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 80134da:	f2c0 80d7 	blt.w	801368c <opus_decode+0x68c>
 80134de:	b21b      	sxth	r3, r3
 80134e0:	458c      	cmp	ip, r1
         pcm[i] = SAT16(ADD32(pcm[i], pcm_silk[i]));
 80134e2:	800b      	strh	r3, [r1, #0]
      for (i=0;i<frame_size*st->channels;i++)
 80134e4:	d015      	beq.n	8013512 <opus_decode+0x512>
         pcm[i] = SAT16(ADD32(pcm[i], pcm_silk[i]));
 80134e6:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
 80134ea:	f931 2f02 	ldrsh.w	r2, [r1, #2]!
 80134ee:	4413      	add	r3, r2
 80134f0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80134f4:	dbef      	blt.n	80134d6 <opus_decode+0x4d6>
 80134f6:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80134fa:	e7f1      	b.n	80134e0 <opus_decode+0x4e0>
      mode = MODE_HYBRID;
 80134fc:	f013 0f10 	tst.w	r3, #16
 8013500:	f240 33e9 	movw	r3, #1001	; 0x3e9
 8013504:	f240 4851 	movw	r8, #1105	; 0x451
 8013508:	62fb      	str	r3, [r7, #44]	; 0x2c
 801350a:	bf08      	it	eq
 801350c:	f44f 688a 	moveq.w	r8, #1104	; 0x450
 8013510:	e5b5      	b.n	801307e <opus_decode+0x7e>
      MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_GET_MODE(&celt_mode)));
 8013512:	4642      	mov	r2, r8
 8013514:	4628      	mov	r0, r5
 8013516:	f242 711f 	movw	r1, #10015	; 0x271f
 801351a:	f7f3 fd49 	bl	8006fb0 <opus_custom_decoder_ctl>
 801351e:	2800      	cmp	r0, #0
 8013520:	f47f aefc 	bne.w	801331c <opus_decode+0x31c>
   if(st->decode_gain)
 8013524:	f8da 3028 	ldr.w	r3, [sl, #40]	; 0x28
 8013528:	2b00      	cmp	r3, #0
 801352a:	d057      	beq.n	80135dc <opus_decode+0x5dc>
      gain = celt_exp2(MULT16_16_P15(QCONST16(6.48814081e-4f, 25), st->decode_gain));
 801352c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8013530:	f245 510b 	movw	r1, #21771	; 0x550b
 8013534:	fb13 2301 	smlabb	r3, r3, r1, r2
 8013538:	13db      	asrs	r3, r3, #15
   integer = SHR16(x,10);
 801353a:	f343 2285 	sbfx	r2, r3, #10, #6
   if (integer>14)
 801353e:	2a0e      	cmp	r2, #14
 8013540:	f300 8104 	bgt.w	801374c <opus_decode+0x74c>
   else if (integer < -15)
 8013544:	f112 0f0f 	cmn.w	r2, #15
 8013548:	f2c0 80fe 	blt.w	8013748 <opus_decode+0x748>
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 801354c:	f242 75dc 	movw	r5, #10204	; 0x27dc
 8013550:	f643 10e3 	movw	r0, #14819	; 0x39e3
 8013554:	f645 1114 	movw	r1, #22804	; 0x5914
   return VSHR32(EXTEND32(frac), -integer-2);
 8013558:	f06f 0c01 	mvn.w	ip, #1
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 801355c:	f643 7eff 	movw	lr, #16383	; 0x3fff
   frac = celt_exp2_frac(x-SHL16(integer,10));
 8013560:	fa1f f882 	uxth.w	r8, r2
 8013564:	eba3 2388 	sub.w	r3, r3, r8, lsl #10
   frac = SHL16(x, 4);
 8013568:	f343 030b 	sbfx	r3, r3, #0, #12
 801356c:	011b      	lsls	r3, r3, #4
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 801356e:	fb13 f505 	smulbb	r5, r3, r5
 8013572:	eb00 30e5 	add.w	r0, r0, r5, asr #15
 8013576:	fb10 f003 	smulbb	r0, r0, r3
 801357a:	eb01 31e0 	add.w	r1, r1, r0, asr #15
 801357e:	fb11 f103 	smulbb	r1, r1, r3
   return VSHR32(EXTEND32(frac), -integer-2);
 8013582:	ebac 0002 	sub.w	r0, ip, r2
 8013586:	2800      	cmp	r0, #0
   return ADD16(D0, MULT16_16_Q15(frac, ADD16(D1, MULT16_16_Q15(frac, ADD16(D2 , MULT16_16_Q15(D3,frac))))));
 8013588:	eb0e 31e1 	add.w	r1, lr, r1, asr #15
 801358c:	b209      	sxth	r1, r1
   return VSHR32(EXTEND32(frac), -integer-2);
 801358e:	bfd6      	itet	le
 8013590:	3202      	addle	r2, #2
 8013592:	4101      	asrgt	r1, r0
 8013594:	4091      	lslle	r1, r2
      for (i=0;i<frame_size*st->channels;i++)
 8013596:	f8da 5008 	ldr.w	r5, [sl, #8]
 801359a:	fb05 f50b 	mul.w	r5, r5, fp
 801359e:	2d00      	cmp	r5, #0
 80135a0:	dd1c      	ble.n	80135dc <opus_decode+0x5dc>
         pcm[i] = SATURATE(x, 32767);
 80135a2:	f647 7cff 	movw	ip, #32767	; 0x7fff
 80135a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
         x = MULT16_32_P16(pcm[i],gain);
 80135a8:	ea4f 4e21 	mov.w	lr, r1, asr #16
 80135ac:	1e98      	subs	r0, r3, #2
 80135ae:	eb00 0545 	add.w	r5, r0, r5, lsl #1
 80135b2:	b289      	uxth	r1, r1
 80135b4:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
 80135b8:	fb01 f203 	mul.w	r2, r1, r3
 80135bc:	fb0e f303 	mul.w	r3, lr, r3
 80135c0:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
 80135c4:	eb03 4322 	add.w	r3, r3, r2, asr #16
         pcm[i] = SATURATE(x, 32767);
 80135c8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80135cc:	da59      	bge.n	8013682 <opus_decode+0x682>
 80135ce:	4a63      	ldr	r2, [pc, #396]	; (801375c <opus_decode+0x75c>)
 80135d0:	4293      	cmp	r3, r2
 80135d2:	bfb8      	it	lt
 80135d4:	4613      	movlt	r3, r2
      for (i=0;i<frame_size*st->channels;i++)
 80135d6:	42a8      	cmp	r0, r5
         pcm[i] = SATURATE(x, 32767);
 80135d8:	8003      	strh	r3, [r0, #0]
      for (i=0;i<frame_size*st->channels;i++)
 80135da:	d1eb      	bne.n	80135b4 <opus_decode+0x5b4>
      st->rangeFinal = 0;
 80135dc:	2300      	movs	r3, #0
   st->prev_mode = mode;
 80135de:	f8ca 603c 	str.w	r6, [sl, #60]	; 0x3c
      st->rangeFinal = 0;
 80135e2:	f8ca 304c 	str.w	r3, [sl, #76]	; 0x4c
   st->prev_redundancy = redundancy && !celt_to_silk;
 80135e6:	f8ca 3044 	str.w	r3, [sl, #68]	; 0x44
   return celt_ret < 0 ? celt_ret : audiosize;
 80135ea:	429c      	cmp	r4, r3
 80135ec:	bfa8      	it	ge
 80135ee:	465c      	movge	r4, fp
 80135f0:	f8d7 d018 	ldr.w	sp, [r7, #24]
 80135f4:	e5c6      	b.n	8013184 <opus_decode+0x184>
      return OPUS_BAD_ARG;
 80135f6:	f04f 3bff 	mov.w	fp, #4294967295
 80135fa:	e693      	b.n	8013324 <opus_decode+0x324>
   ALLOC(pcm_transition_celt, pcm_transition_celt_size, opus_val16);
 80135fc:	46a3      	mov	fp, r4
 80135fe:	e6b8      	b.n	8013372 <opus_decode+0x372>
      bandwidth = OPUS_BANDWIDTH_MEDIUMBAND + ((data[0]>>5)&0x3);
 8013600:	f3c3 1341 	ubfx	r3, r3, #5, #2
      mode = MODE_CELT_ONLY;
 8013604:	2b00      	cmp	r3, #0
      if (bandwidth == OPUS_BANDWIDTH_MEDIUMBAND)
 8013606:	f203 484e 	addw	r8, r3, #1102	; 0x44e
      mode = MODE_CELT_ONLY;
 801360a:	f240 424d 	movw	r2, #1101	; 0x44d
 801360e:	f240 33ea 	movw	r3, #1002	; 0x3ea
 8013612:	bf08      	it	eq
 8013614:	4690      	moveq	r8, r2
 8013616:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013618:	e531      	b.n	801307e <opus_decode+0x7e>
      return OPUS_BUFFER_TOO_SMALL;
 801361a:	f06f 0b01 	mvn.w	fp, #1
   return opus_decode_native(st, data, len, pcm, frame_size, decode_fec, 0, NULL, 0);
 801361e:	e681      	b.n	8013324 <opus_decode+0x324>
   st->last_packet_duration = nb_samples;
 8013620:	f8ca 4048 	str.w	r4, [sl, #72]	; 0x48
 8013624:	46a3      	mov	fp, r4
 8013626:	e67d      	b.n	8013324 <opus_decode+0x324>
   if ((decode_fec || len==0 || data==NULL) && frame_size%(st->Fs/400)!=0)
 8013628:	f8da 200c 	ldr.w	r2, [sl, #12]
 801362c:	494c      	ldr	r1, [pc, #304]	; (8013760 <opus_decode+0x760>)
 801362e:	17d3      	asrs	r3, r2, #31
 8013630:	fb81 1202 	smull	r1, r2, r1, r2
 8013634:	ebc3 13e2 	rsb	r3, r3, r2, asr #7
 8013638:	fb96 f4f3 	sdiv	r4, r6, r3
 801363c:	fb03 6414 	mls	r4, r3, r4, r6
      duration_copy = st->last_packet_duration;
 8013640:	f8da 3048 	ldr.w	r3, [sl, #72]	; 0x48
 8013644:	623b      	str	r3, [r7, #32]
   if ((decode_fec || len==0 || data==NULL) && frame_size%(st->Fs/400)!=0)
 8013646:	2c00      	cmp	r4, #0
 8013648:	f040 8083 	bne.w	8013752 <opus_decode+0x752>
         ret = opus_decode_frame(st, NULL, 0, pcm+pcm_count*st->channels, frame_size-pcm_count, 0);
 801364c:	f8d7 b028 	ldr.w	fp, [r7, #40]	; 0x28
 8013650:	e001      	b.n	8013656 <opus_decode+0x656>
      } while (pcm_count < frame_size);
 8013652:	42b4      	cmp	r4, r6
 8013654:	da5e      	bge.n	8013714 <opus_decode+0x714>
         ret = opus_decode_frame(st, NULL, 0, pcm+pcm_count*st->channels, frame_size-pcm_count, 0);
 8013656:	2200      	movs	r2, #0
 8013658:	f8da 3008 	ldr.w	r3, [sl, #8]
 801365c:	1b30      	subs	r0, r6, r4
 801365e:	fb03 f304 	mul.w	r3, r3, r4
 8013662:	9000      	str	r0, [sp, #0]
 8013664:	4611      	mov	r1, r2
 8013666:	9201      	str	r2, [sp, #4]
 8013668:	eb0b 0343 	add.w	r3, fp, r3, lsl #1
 801366c:	4650      	mov	r0, sl
 801366e:	f7fe ff79 	bl	8012564 <opus_decode_frame>
         if (ret<0)
 8013672:	2800      	cmp	r0, #0
         pcm_count += ret;
 8013674:	4404      	add	r4, r0
         if (ret<0)
 8013676:	daec      	bge.n	8013652 <opus_decode+0x652>
 8013678:	4683      	mov	fp, r0
 801367a:	6a3b      	ldr	r3, [r7, #32]
            st->last_packet_duration = duration_copy;
 801367c:	f8ca 3048 	str.w	r3, [sl, #72]	; 0x48
 8013680:	e650      	b.n	8013324 <opus_decode+0x324>
      for (i=0;i<frame_size*st->channels;i++)
 8013682:	42a8      	cmp	r0, r5
         pcm[i] = SATURATE(x, 32767);
 8013684:	f8a0 c000 	strh.w	ip, [r0]
      for (i=0;i<frame_size*st->channels;i++)
 8013688:	d194      	bne.n	80135b4 <opus_decode+0x5b4>
 801368a:	e7a7      	b.n	80135dc <opus_decode+0x5dc>
 801368c:	4b35      	ldr	r3, [pc, #212]	; (8013764 <opus_decode+0x764>)
 801368e:	e727      	b.n	80134e0 <opus_decode+0x4e0>
   if ((decode_fec || len==0 || data==NULL) && frame_size%(st->Fs/400)!=0)
 8013690:	f8da 200c 	ldr.w	r2, [sl, #12]
 8013694:	4932      	ldr	r1, [pc, #200]	; (8013760 <opus_decode+0x760>)
 8013696:	17d3      	asrs	r3, r2, #31
 8013698:	fb81 1202 	smull	r1, r2, r1, r2
 801369c:	ebc3 13e2 	rsb	r3, r3, r2, asr #7
 80136a0:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 80136a4:	fb92 f4f3 	sdiv	r4, r2, r3
 80136a8:	fb03 2414 	mls	r4, r3, r4, r2
 80136ac:	2c00      	cmp	r4, #0
 80136ae:	d1a2      	bne.n	80135f6 <opus_decode+0x5f6>
         ret = opus_decode_frame(st, NULL, 0, pcm+pcm_count*st->channels, frame_size-pcm_count, 0);
 80136b0:	4625      	mov	r5, r4
 80136b2:	4616      	mov	r6, r2
 80136b4:	f8d7 8028 	ldr.w	r8, [r7, #40]	; 0x28
 80136b8:	e001      	b.n	80136be <opus_decode+0x6be>
      } while (pcm_count < frame_size);
 80136ba:	42a6      	cmp	r6, r4
 80136bc:	ddb0      	ble.n	8013620 <opus_decode+0x620>
         ret = opus_decode_frame(st, NULL, 0, pcm+pcm_count*st->channels, frame_size-pcm_count, 0);
 80136be:	2200      	movs	r2, #0
 80136c0:	f8da 3008 	ldr.w	r3, [sl, #8]
 80136c4:	1b30      	subs	r0, r6, r4
 80136c6:	fb03 f304 	mul.w	r3, r3, r4
 80136ca:	9000      	str	r0, [sp, #0]
 80136cc:	9501      	str	r5, [sp, #4]
 80136ce:	eb08 0343 	add.w	r3, r8, r3, lsl #1
 80136d2:	4611      	mov	r1, r2
 80136d4:	4650      	mov	r0, sl
 80136d6:	f7fe ff45 	bl	8012564 <opus_decode_frame>
         if (ret<0)
 80136da:	2800      	cmp	r0, #0
         pcm_count += ret;
 80136dc:	4404      	add	r4, r0
         if (ret<0)
 80136de:	daec      	bge.n	80136ba <opus_decode+0x6ba>
 80136e0:	4683      	mov	fp, r0
 80136e2:	e693      	b.n	801340c <opus_decode+0x40c>
      unsigned char silence[2] = {0xFF, 0xFF};
 80136e4:	f64f 72ff 	movw	r2, #65535	; 0xffff
      if (!celt_accum)
 80136e8:	6979      	ldr	r1, [r7, #20]
      unsigned char silence[2] = {0xFF, 0xFF};
 80136ea:	87ba      	strh	r2, [r7, #60]	; 0x3c
      if (!celt_accum)
 80136ec:	b959      	cbnz	r1, 8013706 <opus_decode+0x706>
         for (i=0;i<frame_size*st->channels;i++)
 80136ee:	f8da 2008 	ldr.w	r2, [sl, #8]
 80136f2:	fb02 f20b 	mul.w	r2, r2, fp
 80136f6:	2a00      	cmp	r2, #0
 80136f8:	dd05      	ble.n	8013706 <opus_decode+0x706>
 80136fa:	0052      	lsls	r2, r2, #1
 80136fc:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80136fe:	623b      	str	r3, [r7, #32]
 8013700:	f000 fd12 	bl	8014128 <memset>
 8013704:	6a3b      	ldr	r3, [r7, #32]
      if (st->prev_mode == MODE_HYBRID && !(redundancy && celt_to_silk && st->prev_redundancy) )
 8013706:	f240 32e9 	movw	r2, #1001	; 0x3e9
 801370a:	4293      	cmp	r3, r2
 801370c:	d005      	beq.n	801371a <opus_decode+0x71a>
 801370e:	f107 083c 	add.w	r8, r7, #60	; 0x3c
 8013712:	e6d0      	b.n	80134b6 <opus_decode+0x4b6>
      st->last_packet_duration = pcm_count;
 8013714:	f8ca 4048 	str.w	r4, [sl, #72]	; 0x48
 8013718:	e4ed      	b.n	80130f6 <opus_decode+0xf6>
         MUST_SUCCEED(celt_decoder_ctl(celt_dec, CELT_SET_START_BAND(0)));
 801371a:	2200      	movs	r2, #0
 801371c:	f242 711a 	movw	r1, #10010	; 0x271a
 8013720:	4628      	mov	r0, r5
 8013722:	f7f3 fc45 	bl	8006fb0 <opus_custom_decoder_ctl>
 8013726:	2800      	cmp	r0, #0
 8013728:	f47f adf8 	bne.w	801331c <opus_decode+0x31c>
         celt_decode_with_ec(celt_dec, silence, 2, pcm, F2_5, NULL, celt_accum);
 801372c:	697b      	ldr	r3, [r7, #20]
 801372e:	f107 083c 	add.w	r8, r7, #60	; 0x3c
 8013732:	e9cd 0301 	strd	r0, r3, [sp, #4]
 8013736:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013738:	4641      	mov	r1, r8
 801373a:	9300      	str	r3, [sp, #0]
 801373c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801373e:	2202      	movs	r2, #2
 8013740:	4628      	mov	r0, r5
 8013742:	f7f2 fbf1 	bl	8005f28 <celt_decode_with_ec>
 8013746:	e6b6      	b.n	80134b6 <opus_decode+0x4b6>
      return 0;
 8013748:	4601      	mov	r1, r0
 801374a:	e724      	b.n	8013596 <opus_decode+0x596>
      return 0x7f000000;
 801374c:	f04f 41fe 	mov.w	r1, #2130706432	; 0x7f000000
 8013750:	e721      	b.n	8013596 <opus_decode+0x596>
      return OPUS_BAD_ARG;
 8013752:	f04f 3bff 	mov.w	fp, #4294967295
 8013756:	e791      	b.n	801367c <opus_decode+0x67c>
         if (ret<0)
 8013758:	46a3      	mov	fp, r4
 801375a:	e5e3      	b.n	8013324 <opus_decode+0x324>
 801375c:	ffff8001 	.word	0xffff8001
 8013760:	51eb851f 	.word	0x51eb851f
 8013764:	ffff8000 	.word	0xffff8000

08013768 <__errno>:
 8013768:	4b01      	ldr	r3, [pc, #4]	; (8013770 <__errno+0x8>)
 801376a:	6818      	ldr	r0, [r3, #0]
 801376c:	4770      	bx	lr
 801376e:	bf00      	nop
 8013770:	2000000c 	.word	0x2000000c

08013774 <_fclose_r>:
 8013774:	b570      	push	{r4, r5, r6, lr}
 8013776:	4605      	mov	r5, r0
 8013778:	460c      	mov	r4, r1
 801377a:	b911      	cbnz	r1, 8013782 <_fclose_r+0xe>
 801377c:	2600      	movs	r6, #0
 801377e:	4630      	mov	r0, r6
 8013780:	bd70      	pop	{r4, r5, r6, pc}
 8013782:	b118      	cbz	r0, 801378c <_fclose_r+0x18>
 8013784:	6983      	ldr	r3, [r0, #24]
 8013786:	b90b      	cbnz	r3, 801378c <_fclose_r+0x18>
 8013788:	f000 f972 	bl	8013a70 <__sinit>
 801378c:	4b1f      	ldr	r3, [pc, #124]	; (801380c <_fclose_r+0x98>)
 801378e:	429c      	cmp	r4, r3
 8013790:	d132      	bne.n	80137f8 <_fclose_r+0x84>
 8013792:	686c      	ldr	r4, [r5, #4]
 8013794:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8013798:	2b00      	cmp	r3, #0
 801379a:	d0ef      	beq.n	801377c <_fclose_r+0x8>
 801379c:	4621      	mov	r1, r4
 801379e:	4628      	mov	r0, r5
 80137a0:	f000 f866 	bl	8013870 <__sflush_r>
 80137a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80137a6:	4606      	mov	r6, r0
 80137a8:	b133      	cbz	r3, 80137b8 <_fclose_r+0x44>
 80137aa:	6a21      	ldr	r1, [r4, #32]
 80137ac:	4628      	mov	r0, r5
 80137ae:	4798      	blx	r3
 80137b0:	2800      	cmp	r0, #0
 80137b2:	bfb8      	it	lt
 80137b4:	f04f 36ff 	movlt.w	r6, #4294967295
 80137b8:	89a3      	ldrh	r3, [r4, #12]
 80137ba:	061b      	lsls	r3, r3, #24
 80137bc:	d503      	bpl.n	80137c6 <_fclose_r+0x52>
 80137be:	6921      	ldr	r1, [r4, #16]
 80137c0:	4628      	mov	r0, r5
 80137c2:	f000 fcb9 	bl	8014138 <_free_r>
 80137c6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80137c8:	b141      	cbz	r1, 80137dc <_fclose_r+0x68>
 80137ca:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80137ce:	4299      	cmp	r1, r3
 80137d0:	d002      	beq.n	80137d8 <_fclose_r+0x64>
 80137d2:	4628      	mov	r0, r5
 80137d4:	f000 fcb0 	bl	8014138 <_free_r>
 80137d8:	2300      	movs	r3, #0
 80137da:	6363      	str	r3, [r4, #52]	; 0x34
 80137dc:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80137de:	b121      	cbz	r1, 80137ea <_fclose_r+0x76>
 80137e0:	4628      	mov	r0, r5
 80137e2:	f000 fca9 	bl	8014138 <_free_r>
 80137e6:	2300      	movs	r3, #0
 80137e8:	64a3      	str	r3, [r4, #72]	; 0x48
 80137ea:	f000 f9ad 	bl	8013b48 <__sfp_lock_acquire>
 80137ee:	2300      	movs	r3, #0
 80137f0:	81a3      	strh	r3, [r4, #12]
 80137f2:	f000 f9aa 	bl	8013b4a <__sfp_lock_release>
 80137f6:	e7c2      	b.n	801377e <_fclose_r+0xa>
 80137f8:	4b05      	ldr	r3, [pc, #20]	; (8013810 <_fclose_r+0x9c>)
 80137fa:	429c      	cmp	r4, r3
 80137fc:	d101      	bne.n	8013802 <_fclose_r+0x8e>
 80137fe:	68ac      	ldr	r4, [r5, #8]
 8013800:	e7c8      	b.n	8013794 <_fclose_r+0x20>
 8013802:	4b04      	ldr	r3, [pc, #16]	; (8013814 <_fclose_r+0xa0>)
 8013804:	429c      	cmp	r4, r3
 8013806:	bf08      	it	eq
 8013808:	68ec      	ldreq	r4, [r5, #12]
 801380a:	e7c3      	b.n	8013794 <_fclose_r+0x20>
 801380c:	08018000 	.word	0x08018000
 8013810:	08018020 	.word	0x08018020
 8013814:	08017fe0 	.word	0x08017fe0

08013818 <fclose>:
 8013818:	4b02      	ldr	r3, [pc, #8]	; (8013824 <fclose+0xc>)
 801381a:	4601      	mov	r1, r0
 801381c:	6818      	ldr	r0, [r3, #0]
 801381e:	f7ff bfa9 	b.w	8013774 <_fclose_r>
 8013822:	bf00      	nop
 8013824:	2000000c 	.word	0x2000000c

08013828 <ferror>:
 8013828:	b538      	push	{r3, r4, r5, lr}
 801382a:	4b0d      	ldr	r3, [pc, #52]	; (8013860 <ferror+0x38>)
 801382c:	4604      	mov	r4, r0
 801382e:	681d      	ldr	r5, [r3, #0]
 8013830:	b125      	cbz	r5, 801383c <ferror+0x14>
 8013832:	69ab      	ldr	r3, [r5, #24]
 8013834:	b913      	cbnz	r3, 801383c <ferror+0x14>
 8013836:	4628      	mov	r0, r5
 8013838:	f000 f91a 	bl	8013a70 <__sinit>
 801383c:	4b09      	ldr	r3, [pc, #36]	; (8013864 <ferror+0x3c>)
 801383e:	429c      	cmp	r4, r3
 8013840:	d104      	bne.n	801384c <ferror+0x24>
 8013842:	686c      	ldr	r4, [r5, #4]
 8013844:	89a0      	ldrh	r0, [r4, #12]
 8013846:	f3c0 1080 	ubfx	r0, r0, #6, #1
 801384a:	bd38      	pop	{r3, r4, r5, pc}
 801384c:	4b06      	ldr	r3, [pc, #24]	; (8013868 <ferror+0x40>)
 801384e:	429c      	cmp	r4, r3
 8013850:	d101      	bne.n	8013856 <ferror+0x2e>
 8013852:	68ac      	ldr	r4, [r5, #8]
 8013854:	e7f6      	b.n	8013844 <ferror+0x1c>
 8013856:	4b05      	ldr	r3, [pc, #20]	; (801386c <ferror+0x44>)
 8013858:	429c      	cmp	r4, r3
 801385a:	bf08      	it	eq
 801385c:	68ec      	ldreq	r4, [r5, #12]
 801385e:	e7f1      	b.n	8013844 <ferror+0x1c>
 8013860:	2000000c 	.word	0x2000000c
 8013864:	08018000 	.word	0x08018000
 8013868:	08018020 	.word	0x08018020
 801386c:	08017fe0 	.word	0x08017fe0

08013870 <__sflush_r>:
 8013870:	898a      	ldrh	r2, [r1, #12]
 8013872:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013876:	4605      	mov	r5, r0
 8013878:	0710      	lsls	r0, r2, #28
 801387a:	460c      	mov	r4, r1
 801387c:	d458      	bmi.n	8013930 <__sflush_r+0xc0>
 801387e:	684b      	ldr	r3, [r1, #4]
 8013880:	2b00      	cmp	r3, #0
 8013882:	dc05      	bgt.n	8013890 <__sflush_r+0x20>
 8013884:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8013886:	2b00      	cmp	r3, #0
 8013888:	dc02      	bgt.n	8013890 <__sflush_r+0x20>
 801388a:	2000      	movs	r0, #0
 801388c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8013890:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8013892:	2e00      	cmp	r6, #0
 8013894:	d0f9      	beq.n	801388a <__sflush_r+0x1a>
 8013896:	2300      	movs	r3, #0
 8013898:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 801389c:	682f      	ldr	r7, [r5, #0]
 801389e:	6a21      	ldr	r1, [r4, #32]
 80138a0:	602b      	str	r3, [r5, #0]
 80138a2:	d032      	beq.n	801390a <__sflush_r+0x9a>
 80138a4:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80138a6:	89a3      	ldrh	r3, [r4, #12]
 80138a8:	075a      	lsls	r2, r3, #29
 80138aa:	d505      	bpl.n	80138b8 <__sflush_r+0x48>
 80138ac:	6863      	ldr	r3, [r4, #4]
 80138ae:	1ac0      	subs	r0, r0, r3
 80138b0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80138b2:	b10b      	cbz	r3, 80138b8 <__sflush_r+0x48>
 80138b4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80138b6:	1ac0      	subs	r0, r0, r3
 80138b8:	2300      	movs	r3, #0
 80138ba:	4602      	mov	r2, r0
 80138bc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80138be:	4628      	mov	r0, r5
 80138c0:	6a21      	ldr	r1, [r4, #32]
 80138c2:	47b0      	blx	r6
 80138c4:	1c43      	adds	r3, r0, #1
 80138c6:	89a3      	ldrh	r3, [r4, #12]
 80138c8:	d106      	bne.n	80138d8 <__sflush_r+0x68>
 80138ca:	6829      	ldr	r1, [r5, #0]
 80138cc:	291d      	cmp	r1, #29
 80138ce:	d847      	bhi.n	8013960 <__sflush_r+0xf0>
 80138d0:	4a28      	ldr	r2, [pc, #160]	; (8013974 <__sflush_r+0x104>)
 80138d2:	40ca      	lsrs	r2, r1
 80138d4:	07d6      	lsls	r6, r2, #31
 80138d6:	d543      	bpl.n	8013960 <__sflush_r+0xf0>
 80138d8:	2200      	movs	r2, #0
 80138da:	04d9      	lsls	r1, r3, #19
 80138dc:	6062      	str	r2, [r4, #4]
 80138de:	6922      	ldr	r2, [r4, #16]
 80138e0:	6022      	str	r2, [r4, #0]
 80138e2:	d504      	bpl.n	80138ee <__sflush_r+0x7e>
 80138e4:	1c42      	adds	r2, r0, #1
 80138e6:	d101      	bne.n	80138ec <__sflush_r+0x7c>
 80138e8:	682b      	ldr	r3, [r5, #0]
 80138ea:	b903      	cbnz	r3, 80138ee <__sflush_r+0x7e>
 80138ec:	6560      	str	r0, [r4, #84]	; 0x54
 80138ee:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80138f0:	602f      	str	r7, [r5, #0]
 80138f2:	2900      	cmp	r1, #0
 80138f4:	d0c9      	beq.n	801388a <__sflush_r+0x1a>
 80138f6:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80138fa:	4299      	cmp	r1, r3
 80138fc:	d002      	beq.n	8013904 <__sflush_r+0x94>
 80138fe:	4628      	mov	r0, r5
 8013900:	f000 fc1a 	bl	8014138 <_free_r>
 8013904:	2000      	movs	r0, #0
 8013906:	6360      	str	r0, [r4, #52]	; 0x34
 8013908:	e7c0      	b.n	801388c <__sflush_r+0x1c>
 801390a:	2301      	movs	r3, #1
 801390c:	4628      	mov	r0, r5
 801390e:	47b0      	blx	r6
 8013910:	1c41      	adds	r1, r0, #1
 8013912:	d1c8      	bne.n	80138a6 <__sflush_r+0x36>
 8013914:	682b      	ldr	r3, [r5, #0]
 8013916:	2b00      	cmp	r3, #0
 8013918:	d0c5      	beq.n	80138a6 <__sflush_r+0x36>
 801391a:	2b1d      	cmp	r3, #29
 801391c:	d001      	beq.n	8013922 <__sflush_r+0xb2>
 801391e:	2b16      	cmp	r3, #22
 8013920:	d101      	bne.n	8013926 <__sflush_r+0xb6>
 8013922:	602f      	str	r7, [r5, #0]
 8013924:	e7b1      	b.n	801388a <__sflush_r+0x1a>
 8013926:	89a3      	ldrh	r3, [r4, #12]
 8013928:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801392c:	81a3      	strh	r3, [r4, #12]
 801392e:	e7ad      	b.n	801388c <__sflush_r+0x1c>
 8013930:	690f      	ldr	r7, [r1, #16]
 8013932:	2f00      	cmp	r7, #0
 8013934:	d0a9      	beq.n	801388a <__sflush_r+0x1a>
 8013936:	0793      	lsls	r3, r2, #30
 8013938:	680e      	ldr	r6, [r1, #0]
 801393a:	600f      	str	r7, [r1, #0]
 801393c:	bf0c      	ite	eq
 801393e:	694b      	ldreq	r3, [r1, #20]
 8013940:	2300      	movne	r3, #0
 8013942:	eba6 0807 	sub.w	r8, r6, r7
 8013946:	608b      	str	r3, [r1, #8]
 8013948:	f1b8 0f00 	cmp.w	r8, #0
 801394c:	dd9d      	ble.n	801388a <__sflush_r+0x1a>
 801394e:	4643      	mov	r3, r8
 8013950:	463a      	mov	r2, r7
 8013952:	6a21      	ldr	r1, [r4, #32]
 8013954:	4628      	mov	r0, r5
 8013956:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8013958:	47b0      	blx	r6
 801395a:	2800      	cmp	r0, #0
 801395c:	dc06      	bgt.n	801396c <__sflush_r+0xfc>
 801395e:	89a3      	ldrh	r3, [r4, #12]
 8013960:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8013964:	f04f 30ff 	mov.w	r0, #4294967295
 8013968:	81a3      	strh	r3, [r4, #12]
 801396a:	e78f      	b.n	801388c <__sflush_r+0x1c>
 801396c:	4407      	add	r7, r0
 801396e:	eba8 0800 	sub.w	r8, r8, r0
 8013972:	e7e9      	b.n	8013948 <__sflush_r+0xd8>
 8013974:	20400001 	.word	0x20400001

08013978 <_fflush_r>:
 8013978:	b538      	push	{r3, r4, r5, lr}
 801397a:	690b      	ldr	r3, [r1, #16]
 801397c:	4605      	mov	r5, r0
 801397e:	460c      	mov	r4, r1
 8013980:	b1db      	cbz	r3, 80139ba <_fflush_r+0x42>
 8013982:	b118      	cbz	r0, 801398c <_fflush_r+0x14>
 8013984:	6983      	ldr	r3, [r0, #24]
 8013986:	b90b      	cbnz	r3, 801398c <_fflush_r+0x14>
 8013988:	f000 f872 	bl	8013a70 <__sinit>
 801398c:	4b0c      	ldr	r3, [pc, #48]	; (80139c0 <_fflush_r+0x48>)
 801398e:	429c      	cmp	r4, r3
 8013990:	d109      	bne.n	80139a6 <_fflush_r+0x2e>
 8013992:	686c      	ldr	r4, [r5, #4]
 8013994:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8013998:	b17b      	cbz	r3, 80139ba <_fflush_r+0x42>
 801399a:	4621      	mov	r1, r4
 801399c:	4628      	mov	r0, r5
 801399e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80139a2:	f7ff bf65 	b.w	8013870 <__sflush_r>
 80139a6:	4b07      	ldr	r3, [pc, #28]	; (80139c4 <_fflush_r+0x4c>)
 80139a8:	429c      	cmp	r4, r3
 80139aa:	d101      	bne.n	80139b0 <_fflush_r+0x38>
 80139ac:	68ac      	ldr	r4, [r5, #8]
 80139ae:	e7f1      	b.n	8013994 <_fflush_r+0x1c>
 80139b0:	4b05      	ldr	r3, [pc, #20]	; (80139c8 <_fflush_r+0x50>)
 80139b2:	429c      	cmp	r4, r3
 80139b4:	bf08      	it	eq
 80139b6:	68ec      	ldreq	r4, [r5, #12]
 80139b8:	e7ec      	b.n	8013994 <_fflush_r+0x1c>
 80139ba:	2000      	movs	r0, #0
 80139bc:	bd38      	pop	{r3, r4, r5, pc}
 80139be:	bf00      	nop
 80139c0:	08018000 	.word	0x08018000
 80139c4:	08018020 	.word	0x08018020
 80139c8:	08017fe0 	.word	0x08017fe0

080139cc <fflush>:
 80139cc:	4601      	mov	r1, r0
 80139ce:	b920      	cbnz	r0, 80139da <fflush+0xe>
 80139d0:	4b04      	ldr	r3, [pc, #16]	; (80139e4 <fflush+0x18>)
 80139d2:	4905      	ldr	r1, [pc, #20]	; (80139e8 <fflush+0x1c>)
 80139d4:	6818      	ldr	r0, [r3, #0]
 80139d6:	f000 ba71 	b.w	8013ebc <_fwalk_reent>
 80139da:	4b04      	ldr	r3, [pc, #16]	; (80139ec <fflush+0x20>)
 80139dc:	6818      	ldr	r0, [r3, #0]
 80139de:	f7ff bfcb 	b.w	8013978 <_fflush_r>
 80139e2:	bf00      	nop
 80139e4:	08018040 	.word	0x08018040
 80139e8:	08013979 	.word	0x08013979
 80139ec:	2000000c 	.word	0x2000000c

080139f0 <std>:
 80139f0:	2300      	movs	r3, #0
 80139f2:	b510      	push	{r4, lr}
 80139f4:	4604      	mov	r4, r0
 80139f6:	6083      	str	r3, [r0, #8]
 80139f8:	8181      	strh	r1, [r0, #12]
 80139fa:	4619      	mov	r1, r3
 80139fc:	6643      	str	r3, [r0, #100]	; 0x64
 80139fe:	81c2      	strh	r2, [r0, #14]
 8013a00:	2208      	movs	r2, #8
 8013a02:	6183      	str	r3, [r0, #24]
 8013a04:	e9c0 3300 	strd	r3, r3, [r0]
 8013a08:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8013a0c:	305c      	adds	r0, #92	; 0x5c
 8013a0e:	f000 fb8b 	bl	8014128 <memset>
 8013a12:	4b05      	ldr	r3, [pc, #20]	; (8013a28 <std+0x38>)
 8013a14:	6224      	str	r4, [r4, #32]
 8013a16:	6263      	str	r3, [r4, #36]	; 0x24
 8013a18:	4b04      	ldr	r3, [pc, #16]	; (8013a2c <std+0x3c>)
 8013a1a:	62a3      	str	r3, [r4, #40]	; 0x28
 8013a1c:	4b04      	ldr	r3, [pc, #16]	; (8013a30 <std+0x40>)
 8013a1e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8013a20:	4b04      	ldr	r3, [pc, #16]	; (8013a34 <std+0x44>)
 8013a22:	6323      	str	r3, [r4, #48]	; 0x30
 8013a24:	bd10      	pop	{r4, pc}
 8013a26:	bf00      	nop
 8013a28:	08014501 	.word	0x08014501
 8013a2c:	08014523 	.word	0x08014523
 8013a30:	0801455b 	.word	0x0801455b
 8013a34:	0801457f 	.word	0x0801457f

08013a38 <_cleanup_r>:
 8013a38:	4901      	ldr	r1, [pc, #4]	; (8013a40 <_cleanup_r+0x8>)
 8013a3a:	f000 ba3f 	b.w	8013ebc <_fwalk_reent>
 8013a3e:	bf00      	nop
 8013a40:	08013979 	.word	0x08013979

08013a44 <__sfmoreglue>:
 8013a44:	b570      	push	{r4, r5, r6, lr}
 8013a46:	1e4a      	subs	r2, r1, #1
 8013a48:	2568      	movs	r5, #104	; 0x68
 8013a4a:	460e      	mov	r6, r1
 8013a4c:	4355      	muls	r5, r2
 8013a4e:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8013a52:	f000 fbbf 	bl	80141d4 <_malloc_r>
 8013a56:	4604      	mov	r4, r0
 8013a58:	b140      	cbz	r0, 8013a6c <__sfmoreglue+0x28>
 8013a5a:	2100      	movs	r1, #0
 8013a5c:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8013a60:	e9c0 1600 	strd	r1, r6, [r0]
 8013a64:	300c      	adds	r0, #12
 8013a66:	60a0      	str	r0, [r4, #8]
 8013a68:	f000 fb5e 	bl	8014128 <memset>
 8013a6c:	4620      	mov	r0, r4
 8013a6e:	bd70      	pop	{r4, r5, r6, pc}

08013a70 <__sinit>:
 8013a70:	6983      	ldr	r3, [r0, #24]
 8013a72:	b510      	push	{r4, lr}
 8013a74:	4604      	mov	r4, r0
 8013a76:	bb33      	cbnz	r3, 8013ac6 <__sinit+0x56>
 8013a78:	6503      	str	r3, [r0, #80]	; 0x50
 8013a7a:	4a13      	ldr	r2, [pc, #76]	; (8013ac8 <__sinit+0x58>)
 8013a7c:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 8013a80:	4b12      	ldr	r3, [pc, #72]	; (8013acc <__sinit+0x5c>)
 8013a82:	6282      	str	r2, [r0, #40]	; 0x28
 8013a84:	681b      	ldr	r3, [r3, #0]
 8013a86:	4298      	cmp	r0, r3
 8013a88:	bf04      	itt	eq
 8013a8a:	2301      	moveq	r3, #1
 8013a8c:	6183      	streq	r3, [r0, #24]
 8013a8e:	f000 f81f 	bl	8013ad0 <__sfp>
 8013a92:	6060      	str	r0, [r4, #4]
 8013a94:	4620      	mov	r0, r4
 8013a96:	f000 f81b 	bl	8013ad0 <__sfp>
 8013a9a:	60a0      	str	r0, [r4, #8]
 8013a9c:	4620      	mov	r0, r4
 8013a9e:	f000 f817 	bl	8013ad0 <__sfp>
 8013aa2:	2200      	movs	r2, #0
 8013aa4:	60e0      	str	r0, [r4, #12]
 8013aa6:	2104      	movs	r1, #4
 8013aa8:	6860      	ldr	r0, [r4, #4]
 8013aaa:	f7ff ffa1 	bl	80139f0 <std>
 8013aae:	2201      	movs	r2, #1
 8013ab0:	2109      	movs	r1, #9
 8013ab2:	68a0      	ldr	r0, [r4, #8]
 8013ab4:	f7ff ff9c 	bl	80139f0 <std>
 8013ab8:	2202      	movs	r2, #2
 8013aba:	2112      	movs	r1, #18
 8013abc:	68e0      	ldr	r0, [r4, #12]
 8013abe:	f7ff ff97 	bl	80139f0 <std>
 8013ac2:	2301      	movs	r3, #1
 8013ac4:	61a3      	str	r3, [r4, #24]
 8013ac6:	bd10      	pop	{r4, pc}
 8013ac8:	08013a39 	.word	0x08013a39
 8013acc:	08018040 	.word	0x08018040

08013ad0 <__sfp>:
 8013ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8013ad2:	4b1b      	ldr	r3, [pc, #108]	; (8013b40 <__sfp+0x70>)
 8013ad4:	4607      	mov	r7, r0
 8013ad6:	681e      	ldr	r6, [r3, #0]
 8013ad8:	69b3      	ldr	r3, [r6, #24]
 8013ada:	b913      	cbnz	r3, 8013ae2 <__sfp+0x12>
 8013adc:	4630      	mov	r0, r6
 8013ade:	f7ff ffc7 	bl	8013a70 <__sinit>
 8013ae2:	3648      	adds	r6, #72	; 0x48
 8013ae4:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 8013ae8:	3b01      	subs	r3, #1
 8013aea:	d503      	bpl.n	8013af4 <__sfp+0x24>
 8013aec:	6833      	ldr	r3, [r6, #0]
 8013aee:	b133      	cbz	r3, 8013afe <__sfp+0x2e>
 8013af0:	6836      	ldr	r6, [r6, #0]
 8013af2:	e7f7      	b.n	8013ae4 <__sfp+0x14>
 8013af4:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 8013af8:	b16d      	cbz	r5, 8013b16 <__sfp+0x46>
 8013afa:	3468      	adds	r4, #104	; 0x68
 8013afc:	e7f4      	b.n	8013ae8 <__sfp+0x18>
 8013afe:	2104      	movs	r1, #4
 8013b00:	4638      	mov	r0, r7
 8013b02:	f7ff ff9f 	bl	8013a44 <__sfmoreglue>
 8013b06:	6030      	str	r0, [r6, #0]
 8013b08:	2800      	cmp	r0, #0
 8013b0a:	d1f1      	bne.n	8013af0 <__sfp+0x20>
 8013b0c:	230c      	movs	r3, #12
 8013b0e:	4604      	mov	r4, r0
 8013b10:	603b      	str	r3, [r7, #0]
 8013b12:	4620      	mov	r0, r4
 8013b14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8013b16:	4b0b      	ldr	r3, [pc, #44]	; (8013b44 <__sfp+0x74>)
 8013b18:	2208      	movs	r2, #8
 8013b1a:	6665      	str	r5, [r4, #100]	; 0x64
 8013b1c:	4629      	mov	r1, r5
 8013b1e:	60a5      	str	r5, [r4, #8]
 8013b20:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8013b24:	e9c4 5500 	strd	r5, r5, [r4]
 8013b28:	e9c4 3503 	strd	r3, r5, [r4, #12]
 8013b2c:	e9c4 5505 	strd	r5, r5, [r4, #20]
 8013b30:	f000 fafa 	bl	8014128 <memset>
 8013b34:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8013b38:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 8013b3c:	e7e9      	b.n	8013b12 <__sfp+0x42>
 8013b3e:	bf00      	nop
 8013b40:	08018040 	.word	0x08018040
 8013b44:	ffff0001 	.word	0xffff0001

08013b48 <__sfp_lock_acquire>:
 8013b48:	4770      	bx	lr

08013b4a <__sfp_lock_release>:
 8013b4a:	4770      	bx	lr

08013b4c <_fopen_r>:
 8013b4c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8013b4e:	460f      	mov	r7, r1
 8013b50:	4611      	mov	r1, r2
 8013b52:	aa01      	add	r2, sp, #4
 8013b54:	4605      	mov	r5, r0
 8013b56:	f000 fdf9 	bl	801474c <__sflags>
 8013b5a:	4606      	mov	r6, r0
 8013b5c:	b918      	cbnz	r0, 8013b66 <_fopen_r+0x1a>
 8013b5e:	2400      	movs	r4, #0
 8013b60:	4620      	mov	r0, r4
 8013b62:	b003      	add	sp, #12
 8013b64:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013b66:	4628      	mov	r0, r5
 8013b68:	f7ff ffb2 	bl	8013ad0 <__sfp>
 8013b6c:	4604      	mov	r4, r0
 8013b6e:	2800      	cmp	r0, #0
 8013b70:	d0f5      	beq.n	8013b5e <_fopen_r+0x12>
 8013b72:	f44f 73db 	mov.w	r3, #438	; 0x1b6
 8013b76:	9a01      	ldr	r2, [sp, #4]
 8013b78:	4639      	mov	r1, r7
 8013b7a:	4628      	mov	r0, r5
 8013b7c:	f000 fb84 	bl	8014288 <_open_r>
 8013b80:	2800      	cmp	r0, #0
 8013b82:	da06      	bge.n	8013b92 <_fopen_r+0x46>
 8013b84:	2500      	movs	r5, #0
 8013b86:	f7ff ffdf 	bl	8013b48 <__sfp_lock_acquire>
 8013b8a:	81a5      	strh	r5, [r4, #12]
 8013b8c:	f7ff ffdd 	bl	8013b4a <__sfp_lock_release>
 8013b90:	e7e5      	b.n	8013b5e <_fopen_r+0x12>
 8013b92:	4b0a      	ldr	r3, [pc, #40]	; (8013bbc <_fopen_r+0x70>)
 8013b94:	81e0      	strh	r0, [r4, #14]
 8013b96:	6263      	str	r3, [r4, #36]	; 0x24
 8013b98:	4b09      	ldr	r3, [pc, #36]	; (8013bc0 <_fopen_r+0x74>)
 8013b9a:	81a6      	strh	r6, [r4, #12]
 8013b9c:	62a3      	str	r3, [r4, #40]	; 0x28
 8013b9e:	4b09      	ldr	r3, [pc, #36]	; (8013bc4 <_fopen_r+0x78>)
 8013ba0:	6224      	str	r4, [r4, #32]
 8013ba2:	62e3      	str	r3, [r4, #44]	; 0x2c
 8013ba4:	4b08      	ldr	r3, [pc, #32]	; (8013bc8 <_fopen_r+0x7c>)
 8013ba6:	6323      	str	r3, [r4, #48]	; 0x30
 8013ba8:	05f3      	lsls	r3, r6, #23
 8013baa:	d5d9      	bpl.n	8013b60 <_fopen_r+0x14>
 8013bac:	2302      	movs	r3, #2
 8013bae:	2200      	movs	r2, #0
 8013bb0:	4621      	mov	r1, r4
 8013bb2:	4628      	mov	r0, r5
 8013bb4:	f000 f870 	bl	8013c98 <_fseek_r>
 8013bb8:	e7d2      	b.n	8013b60 <_fopen_r+0x14>
 8013bba:	bf00      	nop
 8013bbc:	08014501 	.word	0x08014501
 8013bc0:	08014523 	.word	0x08014523
 8013bc4:	0801455b 	.word	0x0801455b
 8013bc8:	0801457f 	.word	0x0801457f

08013bcc <fopen>:
 8013bcc:	4b02      	ldr	r3, [pc, #8]	; (8013bd8 <fopen+0xc>)
 8013bce:	460a      	mov	r2, r1
 8013bd0:	4601      	mov	r1, r0
 8013bd2:	6818      	ldr	r0, [r3, #0]
 8013bd4:	f7ff bfba 	b.w	8013b4c <_fopen_r>
 8013bd8:	2000000c 	.word	0x2000000c

08013bdc <_fread_r>:
 8013bdc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013be0:	4615      	mov	r5, r2
 8013be2:	4607      	mov	r7, r0
 8013be4:	4689      	mov	r9, r1
 8013be6:	4693      	mov	fp, r2
 8013be8:	435d      	muls	r5, r3
 8013bea:	469a      	mov	sl, r3
 8013bec:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8013bee:	d03b      	beq.n	8013c68 <_fread_r+0x8c>
 8013bf0:	b118      	cbz	r0, 8013bfa <_fread_r+0x1e>
 8013bf2:	6983      	ldr	r3, [r0, #24]
 8013bf4:	b90b      	cbnz	r3, 8013bfa <_fread_r+0x1e>
 8013bf6:	f7ff ff3b 	bl	8013a70 <__sinit>
 8013bfa:	4b1d      	ldr	r3, [pc, #116]	; (8013c70 <_fread_r+0x94>)
 8013bfc:	429c      	cmp	r4, r3
 8013bfe:	d116      	bne.n	8013c2e <_fread_r+0x52>
 8013c00:	687c      	ldr	r4, [r7, #4]
 8013c02:	6863      	ldr	r3, [r4, #4]
 8013c04:	2b00      	cmp	r3, #0
 8013c06:	da01      	bge.n	8013c0c <_fread_r+0x30>
 8013c08:	2300      	movs	r3, #0
 8013c0a:	6063      	str	r3, [r4, #4]
 8013c0c:	462e      	mov	r6, r5
 8013c0e:	e9d4 1800 	ldrd	r1, r8, [r4]
 8013c12:	45b0      	cmp	r8, r6
 8013c14:	d315      	bcc.n	8013c42 <_fread_r+0x66>
 8013c16:	4632      	mov	r2, r6
 8013c18:	4648      	mov	r0, r9
 8013c1a:	f000 fa61 	bl	80140e0 <memcpy>
 8013c1e:	6863      	ldr	r3, [r4, #4]
 8013c20:	6825      	ldr	r5, [r4, #0]
 8013c22:	1b9b      	subs	r3, r3, r6
 8013c24:	4435      	add	r5, r6
 8013c26:	6063      	str	r3, [r4, #4]
 8013c28:	6025      	str	r5, [r4, #0]
 8013c2a:	4655      	mov	r5, sl
 8013c2c:	e01c      	b.n	8013c68 <_fread_r+0x8c>
 8013c2e:	4b11      	ldr	r3, [pc, #68]	; (8013c74 <_fread_r+0x98>)
 8013c30:	429c      	cmp	r4, r3
 8013c32:	d101      	bne.n	8013c38 <_fread_r+0x5c>
 8013c34:	68bc      	ldr	r4, [r7, #8]
 8013c36:	e7e4      	b.n	8013c02 <_fread_r+0x26>
 8013c38:	4b0f      	ldr	r3, [pc, #60]	; (8013c78 <_fread_r+0x9c>)
 8013c3a:	429c      	cmp	r4, r3
 8013c3c:	bf08      	it	eq
 8013c3e:	68fc      	ldreq	r4, [r7, #12]
 8013c40:	e7df      	b.n	8013c02 <_fread_r+0x26>
 8013c42:	4648      	mov	r0, r9
 8013c44:	4642      	mov	r2, r8
 8013c46:	f000 fa4b 	bl	80140e0 <memcpy>
 8013c4a:	6823      	ldr	r3, [r4, #0]
 8013c4c:	4621      	mov	r1, r4
 8013c4e:	4638      	mov	r0, r7
 8013c50:	4443      	add	r3, r8
 8013c52:	44c1      	add	r9, r8
 8013c54:	eba6 0608 	sub.w	r6, r6, r8
 8013c58:	6023      	str	r3, [r4, #0]
 8013c5a:	f000 fb95 	bl	8014388 <__srefill_r>
 8013c5e:	2800      	cmp	r0, #0
 8013c60:	d0d5      	beq.n	8013c0e <_fread_r+0x32>
 8013c62:	1bad      	subs	r5, r5, r6
 8013c64:	fbb5 f5fb 	udiv	r5, r5, fp
 8013c68:	4628      	mov	r0, r5
 8013c6a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013c6e:	bf00      	nop
 8013c70:	08018000 	.word	0x08018000
 8013c74:	08018020 	.word	0x08018020
 8013c78:	08017fe0 	.word	0x08017fe0

08013c7c <fread>:
 8013c7c:	b507      	push	{r0, r1, r2, lr}
 8013c7e:	9300      	str	r3, [sp, #0]
 8013c80:	4613      	mov	r3, r2
 8013c82:	460a      	mov	r2, r1
 8013c84:	4601      	mov	r1, r0
 8013c86:	4803      	ldr	r0, [pc, #12]	; (8013c94 <fread+0x18>)
 8013c88:	6800      	ldr	r0, [r0, #0]
 8013c8a:	f7ff ffa7 	bl	8013bdc <_fread_r>
 8013c8e:	b003      	add	sp, #12
 8013c90:	f85d fb04 	ldr.w	pc, [sp], #4
 8013c94:	2000000c 	.word	0x2000000c

08013c98 <_fseek_r>:
 8013c98:	f000 b80a 	b.w	8013cb0 <_fseeko_r>

08013c9c <fseek>:
 8013c9c:	4613      	mov	r3, r2
 8013c9e:	460a      	mov	r2, r1
 8013ca0:	4601      	mov	r1, r0
 8013ca2:	4802      	ldr	r0, [pc, #8]	; (8013cac <fseek+0x10>)
 8013ca4:	6800      	ldr	r0, [r0, #0]
 8013ca6:	f000 b803 	b.w	8013cb0 <_fseeko_r>
 8013caa:	bf00      	nop
 8013cac:	2000000c 	.word	0x2000000c

08013cb0 <_fseeko_r>:
 8013cb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013cb4:	460c      	mov	r4, r1
 8013cb6:	4691      	mov	r9, r2
 8013cb8:	461e      	mov	r6, r3
 8013cba:	4605      	mov	r5, r0
 8013cbc:	b118      	cbz	r0, 8013cc6 <_fseeko_r+0x16>
 8013cbe:	6983      	ldr	r3, [r0, #24]
 8013cc0:	b90b      	cbnz	r3, 8013cc6 <_fseeko_r+0x16>
 8013cc2:	f7ff fed5 	bl	8013a70 <__sinit>
 8013cc6:	4b3f      	ldr	r3, [pc, #252]	; (8013dc4 <_fseeko_r+0x114>)
 8013cc8:	429c      	cmp	r4, r3
 8013cca:	d112      	bne.n	8013cf2 <_fseeko_r+0x42>
 8013ccc:	686c      	ldr	r4, [r5, #4]
 8013cce:	89a3      	ldrh	r3, [r4, #12]
 8013cd0:	f403 7384 	and.w	r3, r3, #264	; 0x108
 8013cd4:	f5b3 7f84 	cmp.w	r3, #264	; 0x108
 8013cd8:	d103      	bne.n	8013ce2 <_fseeko_r+0x32>
 8013cda:	4621      	mov	r1, r4
 8013cdc:	4628      	mov	r0, r5
 8013cde:	f7ff fe4b 	bl	8013978 <_fflush_r>
 8013ce2:	f8d4 802c 	ldr.w	r8, [r4, #44]	; 0x2c
 8013ce6:	f1b8 0f00 	cmp.w	r8, #0
 8013cea:	d10c      	bne.n	8013d06 <_fseeko_r+0x56>
 8013cec:	231d      	movs	r3, #29
 8013cee:	602b      	str	r3, [r5, #0]
 8013cf0:	e057      	b.n	8013da2 <_fseeko_r+0xf2>
 8013cf2:	4b35      	ldr	r3, [pc, #212]	; (8013dc8 <_fseeko_r+0x118>)
 8013cf4:	429c      	cmp	r4, r3
 8013cf6:	d101      	bne.n	8013cfc <_fseeko_r+0x4c>
 8013cf8:	68ac      	ldr	r4, [r5, #8]
 8013cfa:	e7e8      	b.n	8013cce <_fseeko_r+0x1e>
 8013cfc:	4b33      	ldr	r3, [pc, #204]	; (8013dcc <_fseeko_r+0x11c>)
 8013cfe:	429c      	cmp	r4, r3
 8013d00:	bf08      	it	eq
 8013d02:	68ec      	ldreq	r4, [r5, #12]
 8013d04:	e7e3      	b.n	8013cce <_fseeko_r+0x1e>
 8013d06:	2e01      	cmp	r6, #1
 8013d08:	d030      	beq.n	8013d6c <_fseeko_r+0xbc>
 8013d0a:	2e02      	cmp	r6, #2
 8013d0c:	d001      	beq.n	8013d12 <_fseeko_r+0x62>
 8013d0e:	2e00      	cmp	r6, #0
 8013d10:	d155      	bne.n	8013dbe <_fseeko_r+0x10e>
 8013d12:	6923      	ldr	r3, [r4, #16]
 8013d14:	b91b      	cbnz	r3, 8013d1e <_fseeko_r+0x6e>
 8013d16:	4621      	mov	r1, r4
 8013d18:	4628      	mov	r0, r5
 8013d1a:	f000 f991 	bl	8014040 <__smakebuf_r>
 8013d1e:	4621      	mov	r1, r4
 8013d20:	4628      	mov	r0, r5
 8013d22:	f7ff fe29 	bl	8013978 <_fflush_r>
 8013d26:	4607      	mov	r7, r0
 8013d28:	2800      	cmp	r0, #0
 8013d2a:	d13a      	bne.n	8013da2 <_fseeko_r+0xf2>
 8013d2c:	4633      	mov	r3, r6
 8013d2e:	464a      	mov	r2, r9
 8013d30:	6a21      	ldr	r1, [r4, #32]
 8013d32:	4628      	mov	r0, r5
 8013d34:	47c0      	blx	r8
 8013d36:	3001      	adds	r0, #1
 8013d38:	d033      	beq.n	8013da2 <_fseeko_r+0xf2>
 8013d3a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8013d3c:	b141      	cbz	r1, 8013d50 <_fseeko_r+0xa0>
 8013d3e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8013d42:	4299      	cmp	r1, r3
 8013d44:	d002      	beq.n	8013d4c <_fseeko_r+0x9c>
 8013d46:	4628      	mov	r0, r5
 8013d48:	f000 f9f6 	bl	8014138 <_free_r>
 8013d4c:	2300      	movs	r3, #0
 8013d4e:	6363      	str	r3, [r4, #52]	; 0x34
 8013d50:	6923      	ldr	r3, [r4, #16]
 8013d52:	2100      	movs	r1, #0
 8013d54:	2208      	movs	r2, #8
 8013d56:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8013d5a:	6023      	str	r3, [r4, #0]
 8013d5c:	89a3      	ldrh	r3, [r4, #12]
 8013d5e:	6061      	str	r1, [r4, #4]
 8013d60:	f423 6302 	bic.w	r3, r3, #2080	; 0x820
 8013d64:	81a3      	strh	r3, [r4, #12]
 8013d66:	f000 f9df 	bl	8014128 <memset>
 8013d6a:	e01c      	b.n	8013da6 <_fseeko_r+0xf6>
 8013d6c:	4621      	mov	r1, r4
 8013d6e:	4628      	mov	r0, r5
 8013d70:	f7ff fe02 	bl	8013978 <_fflush_r>
 8013d74:	89a2      	ldrh	r2, [r4, #12]
 8013d76:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8013d7a:	d00c      	beq.n	8013d96 <_fseeko_r+0xe6>
 8013d7c:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8013d7e:	89a3      	ldrh	r3, [r4, #12]
 8013d80:	075a      	lsls	r2, r3, #29
 8013d82:	d513      	bpl.n	8013dac <_fseeko_r+0xfc>
 8013d84:	6863      	ldr	r3, [r4, #4]
 8013d86:	1ac0      	subs	r0, r0, r3
 8013d88:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8013d8a:	b10b      	cbz	r3, 8013d90 <_fseeko_r+0xe0>
 8013d8c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8013d8e:	1ac0      	subs	r0, r0, r3
 8013d90:	4481      	add	r9, r0
 8013d92:	2600      	movs	r6, #0
 8013d94:	e7bd      	b.n	8013d12 <_fseeko_r+0x62>
 8013d96:	6a21      	ldr	r1, [r4, #32]
 8013d98:	4633      	mov	r3, r6
 8013d9a:	4628      	mov	r0, r5
 8013d9c:	47c0      	blx	r8
 8013d9e:	1c41      	adds	r1, r0, #1
 8013da0:	d1ed      	bne.n	8013d7e <_fseeko_r+0xce>
 8013da2:	f04f 37ff 	mov.w	r7, #4294967295
 8013da6:	4638      	mov	r0, r7
 8013da8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8013dac:	071b      	lsls	r3, r3, #28
 8013dae:	d5ef      	bpl.n	8013d90 <_fseeko_r+0xe0>
 8013db0:	6823      	ldr	r3, [r4, #0]
 8013db2:	6922      	ldr	r2, [r4, #16]
 8013db4:	2b00      	cmp	r3, #0
 8013db6:	d0eb      	beq.n	8013d90 <_fseeko_r+0xe0>
 8013db8:	1a9b      	subs	r3, r3, r2
 8013dba:	4418      	add	r0, r3
 8013dbc:	e7e8      	b.n	8013d90 <_fseeko_r+0xe0>
 8013dbe:	2316      	movs	r3, #22
 8013dc0:	e795      	b.n	8013cee <_fseeko_r+0x3e>
 8013dc2:	bf00      	nop
 8013dc4:	08018000 	.word	0x08018000
 8013dc8:	08018020 	.word	0x08018020
 8013dcc:	08017fe0 	.word	0x08017fe0

08013dd0 <ftell>:
 8013dd0:	4b02      	ldr	r3, [pc, #8]	; (8013ddc <ftell+0xc>)
 8013dd2:	4601      	mov	r1, r0
 8013dd4:	6818      	ldr	r0, [r3, #0]
 8013dd6:	f000 b803 	b.w	8013de0 <_ftello_r>
 8013dda:	bf00      	nop
 8013ddc:	2000000c 	.word	0x2000000c

08013de0 <_ftello_r>:
 8013de0:	b570      	push	{r4, r5, r6, lr}
 8013de2:	460c      	mov	r4, r1
 8013de4:	4605      	mov	r5, r0
 8013de6:	b118      	cbz	r0, 8013df0 <_ftello_r+0x10>
 8013de8:	6983      	ldr	r3, [r0, #24]
 8013dea:	b90b      	cbnz	r3, 8013df0 <_ftello_r+0x10>
 8013dec:	f7ff fe40 	bl	8013a70 <__sinit>
 8013df0:	4b21      	ldr	r3, [pc, #132]	; (8013e78 <_ftello_r+0x98>)
 8013df2:	429c      	cmp	r4, r3
 8013df4:	d107      	bne.n	8013e06 <_ftello_r+0x26>
 8013df6:	686c      	ldr	r4, [r5, #4]
 8013df8:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8013dfa:	b976      	cbnz	r6, 8013e1a <_ftello_r+0x3a>
 8013dfc:	231d      	movs	r3, #29
 8013dfe:	602b      	str	r3, [r5, #0]
 8013e00:	f04f 30ff 	mov.w	r0, #4294967295
 8013e04:	bd70      	pop	{r4, r5, r6, pc}
 8013e06:	4b1d      	ldr	r3, [pc, #116]	; (8013e7c <_ftello_r+0x9c>)
 8013e08:	429c      	cmp	r4, r3
 8013e0a:	d101      	bne.n	8013e10 <_ftello_r+0x30>
 8013e0c:	68ac      	ldr	r4, [r5, #8]
 8013e0e:	e7f3      	b.n	8013df8 <_ftello_r+0x18>
 8013e10:	4b1b      	ldr	r3, [pc, #108]	; (8013e80 <_ftello_r+0xa0>)
 8013e12:	429c      	cmp	r4, r3
 8013e14:	bf08      	it	eq
 8013e16:	68ec      	ldreq	r4, [r5, #12]
 8013e18:	e7ee      	b.n	8013df8 <_ftello_r+0x18>
 8013e1a:	89a2      	ldrh	r2, [r4, #12]
 8013e1c:	f002 030c 	and.w	r3, r2, #12
 8013e20:	2b08      	cmp	r3, #8
 8013e22:	d119      	bne.n	8013e58 <_ftello_r+0x78>
 8013e24:	6823      	ldr	r3, [r4, #0]
 8013e26:	b1bb      	cbz	r3, 8013e58 <_ftello_r+0x78>
 8013e28:	6921      	ldr	r1, [r4, #16]
 8013e2a:	1a5b      	subs	r3, r3, r1
 8013e2c:	2b00      	cmp	r3, #0
 8013e2e:	dd13      	ble.n	8013e58 <_ftello_r+0x78>
 8013e30:	05d0      	lsls	r0, r2, #23
 8013e32:	d511      	bpl.n	8013e58 <_ftello_r+0x78>
 8013e34:	2302      	movs	r3, #2
 8013e36:	2200      	movs	r2, #0
 8013e38:	6a21      	ldr	r1, [r4, #32]
 8013e3a:	4628      	mov	r0, r5
 8013e3c:	47b0      	blx	r6
 8013e3e:	1c41      	adds	r1, r0, #1
 8013e40:	d0de      	beq.n	8013e00 <_ftello_r+0x20>
 8013e42:	89a3      	ldrh	r3, [r4, #12]
 8013e44:	075a      	lsls	r2, r3, #29
 8013e46:	d50e      	bpl.n	8013e66 <_ftello_r+0x86>
 8013e48:	6863      	ldr	r3, [r4, #4]
 8013e4a:	1ac0      	subs	r0, r0, r3
 8013e4c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8013e4e:	2b00      	cmp	r3, #0
 8013e50:	d0d8      	beq.n	8013e04 <_ftello_r+0x24>
 8013e52:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8013e54:	1ac0      	subs	r0, r0, r3
 8013e56:	e7d5      	b.n	8013e04 <_ftello_r+0x24>
 8013e58:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8013e5c:	d001      	beq.n	8013e62 <_ftello_r+0x82>
 8013e5e:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8013e60:	e7ef      	b.n	8013e42 <_ftello_r+0x62>
 8013e62:	2301      	movs	r3, #1
 8013e64:	e7e8      	b.n	8013e38 <_ftello_r+0x58>
 8013e66:	071b      	lsls	r3, r3, #28
 8013e68:	d5cc      	bpl.n	8013e04 <_ftello_r+0x24>
 8013e6a:	6823      	ldr	r3, [r4, #0]
 8013e6c:	2b00      	cmp	r3, #0
 8013e6e:	d0c9      	beq.n	8013e04 <_ftello_r+0x24>
 8013e70:	6922      	ldr	r2, [r4, #16]
 8013e72:	1a9b      	subs	r3, r3, r2
 8013e74:	4418      	add	r0, r3
 8013e76:	e7c5      	b.n	8013e04 <_ftello_r+0x24>
 8013e78:	08018000 	.word	0x08018000
 8013e7c:	08018020 	.word	0x08018020
 8013e80:	08017fe0 	.word	0x08017fe0

08013e84 <_fwalk>:
 8013e84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013e88:	4688      	mov	r8, r1
 8013e8a:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8013e8e:	2600      	movs	r6, #0
 8013e90:	b914      	cbnz	r4, 8013e98 <_fwalk+0x14>
 8013e92:	4630      	mov	r0, r6
 8013e94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8013e98:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 8013e9c:	3f01      	subs	r7, #1
 8013e9e:	d501      	bpl.n	8013ea4 <_fwalk+0x20>
 8013ea0:	6824      	ldr	r4, [r4, #0]
 8013ea2:	e7f5      	b.n	8013e90 <_fwalk+0xc>
 8013ea4:	89ab      	ldrh	r3, [r5, #12]
 8013ea6:	2b01      	cmp	r3, #1
 8013ea8:	d906      	bls.n	8013eb8 <_fwalk+0x34>
 8013eaa:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8013eae:	3301      	adds	r3, #1
 8013eb0:	d002      	beq.n	8013eb8 <_fwalk+0x34>
 8013eb2:	4628      	mov	r0, r5
 8013eb4:	47c0      	blx	r8
 8013eb6:	4306      	orrs	r6, r0
 8013eb8:	3568      	adds	r5, #104	; 0x68
 8013eba:	e7ef      	b.n	8013e9c <_fwalk+0x18>

08013ebc <_fwalk_reent>:
 8013ebc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013ec0:	4680      	mov	r8, r0
 8013ec2:	4689      	mov	r9, r1
 8013ec4:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8013ec8:	2600      	movs	r6, #0
 8013eca:	b914      	cbnz	r4, 8013ed2 <_fwalk_reent+0x16>
 8013ecc:	4630      	mov	r0, r6
 8013ece:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8013ed2:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 8013ed6:	3f01      	subs	r7, #1
 8013ed8:	d501      	bpl.n	8013ede <_fwalk_reent+0x22>
 8013eda:	6824      	ldr	r4, [r4, #0]
 8013edc:	e7f5      	b.n	8013eca <_fwalk_reent+0xe>
 8013ede:	89ab      	ldrh	r3, [r5, #12]
 8013ee0:	2b01      	cmp	r3, #1
 8013ee2:	d907      	bls.n	8013ef4 <_fwalk_reent+0x38>
 8013ee4:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8013ee8:	3301      	adds	r3, #1
 8013eea:	d003      	beq.n	8013ef4 <_fwalk_reent+0x38>
 8013eec:	4629      	mov	r1, r5
 8013eee:	4640      	mov	r0, r8
 8013ef0:	47c8      	blx	r9
 8013ef2:	4306      	orrs	r6, r0
 8013ef4:	3568      	adds	r5, #104	; 0x68
 8013ef6:	e7ee      	b.n	8013ed6 <_fwalk_reent+0x1a>

08013ef8 <_fwrite_r>:
 8013ef8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013efc:	9c08      	ldr	r4, [sp, #32]
 8013efe:	4689      	mov	r9, r1
 8013f00:	4617      	mov	r7, r2
 8013f02:	fb02 f803 	mul.w	r8, r2, r3
 8013f06:	4606      	mov	r6, r0
 8013f08:	b118      	cbz	r0, 8013f12 <_fwrite_r+0x1a>
 8013f0a:	6983      	ldr	r3, [r0, #24]
 8013f0c:	b90b      	cbnz	r3, 8013f12 <_fwrite_r+0x1a>
 8013f0e:	f7ff fdaf 	bl	8013a70 <__sinit>
 8013f12:	4b1d      	ldr	r3, [pc, #116]	; (8013f88 <_fwrite_r+0x90>)
 8013f14:	429c      	cmp	r4, r3
 8013f16:	d11a      	bne.n	8013f4e <_fwrite_r+0x56>
 8013f18:	6874      	ldr	r4, [r6, #4]
 8013f1a:	89a3      	ldrh	r3, [r4, #12]
 8013f1c:	071b      	lsls	r3, r3, #28
 8013f1e:	d520      	bpl.n	8013f62 <_fwrite_r+0x6a>
 8013f20:	6923      	ldr	r3, [r4, #16]
 8013f22:	b1f3      	cbz	r3, 8013f62 <_fwrite_r+0x6a>
 8013f24:	2500      	movs	r5, #0
 8013f26:	4545      	cmp	r5, r8
 8013f28:	d029      	beq.n	8013f7e <_fwrite_r+0x86>
 8013f2a:	68a3      	ldr	r3, [r4, #8]
 8013f2c:	f819 1005 	ldrb.w	r1, [r9, r5]
 8013f30:	3b01      	subs	r3, #1
 8013f32:	2b00      	cmp	r3, #0
 8013f34:	60a3      	str	r3, [r4, #8]
 8013f36:	da04      	bge.n	8013f42 <_fwrite_r+0x4a>
 8013f38:	69a2      	ldr	r2, [r4, #24]
 8013f3a:	4293      	cmp	r3, r2
 8013f3c:	db19      	blt.n	8013f72 <_fwrite_r+0x7a>
 8013f3e:	290a      	cmp	r1, #10
 8013f40:	d017      	beq.n	8013f72 <_fwrite_r+0x7a>
 8013f42:	6823      	ldr	r3, [r4, #0]
 8013f44:	1c5a      	adds	r2, r3, #1
 8013f46:	6022      	str	r2, [r4, #0]
 8013f48:	7019      	strb	r1, [r3, #0]
 8013f4a:	3501      	adds	r5, #1
 8013f4c:	e7eb      	b.n	8013f26 <_fwrite_r+0x2e>
 8013f4e:	4b0f      	ldr	r3, [pc, #60]	; (8013f8c <_fwrite_r+0x94>)
 8013f50:	429c      	cmp	r4, r3
 8013f52:	d101      	bne.n	8013f58 <_fwrite_r+0x60>
 8013f54:	68b4      	ldr	r4, [r6, #8]
 8013f56:	e7e0      	b.n	8013f1a <_fwrite_r+0x22>
 8013f58:	4b0d      	ldr	r3, [pc, #52]	; (8013f90 <_fwrite_r+0x98>)
 8013f5a:	429c      	cmp	r4, r3
 8013f5c:	bf08      	it	eq
 8013f5e:	68f4      	ldreq	r4, [r6, #12]
 8013f60:	e7db      	b.n	8013f1a <_fwrite_r+0x22>
 8013f62:	4621      	mov	r1, r4
 8013f64:	4630      	mov	r0, r6
 8013f66:	f000 fb73 	bl	8014650 <__swsetup_r>
 8013f6a:	2800      	cmp	r0, #0
 8013f6c:	d0da      	beq.n	8013f24 <_fwrite_r+0x2c>
 8013f6e:	2500      	movs	r5, #0
 8013f70:	e005      	b.n	8013f7e <_fwrite_r+0x86>
 8013f72:	4622      	mov	r2, r4
 8013f74:	4630      	mov	r0, r6
 8013f76:	f000 fb07 	bl	8014588 <__swbuf_r>
 8013f7a:	3001      	adds	r0, #1
 8013f7c:	d1e5      	bne.n	8013f4a <_fwrite_r+0x52>
 8013f7e:	fbb5 f0f7 	udiv	r0, r5, r7
 8013f82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8013f86:	bf00      	nop
 8013f88:	08018000 	.word	0x08018000
 8013f8c:	08018020 	.word	0x08018020
 8013f90:	08017fe0 	.word	0x08017fe0

08013f94 <fwrite>:
 8013f94:	b507      	push	{r0, r1, r2, lr}
 8013f96:	9300      	str	r3, [sp, #0]
 8013f98:	4613      	mov	r3, r2
 8013f9a:	460a      	mov	r2, r1
 8013f9c:	4601      	mov	r1, r0
 8013f9e:	4803      	ldr	r0, [pc, #12]	; (8013fac <fwrite+0x18>)
 8013fa0:	6800      	ldr	r0, [r0, #0]
 8013fa2:	f7ff ffa9 	bl	8013ef8 <_fwrite_r>
 8013fa6:	b003      	add	sp, #12
 8013fa8:	f85d fb04 	ldr.w	pc, [sp], #4
 8013fac:	2000000c 	.word	0x2000000c

08013fb0 <__libc_init_array>:
 8013fb0:	b570      	push	{r4, r5, r6, lr}
 8013fb2:	4e0d      	ldr	r6, [pc, #52]	; (8013fe8 <__libc_init_array+0x38>)
 8013fb4:	2500      	movs	r5, #0
 8013fb6:	4c0d      	ldr	r4, [pc, #52]	; (8013fec <__libc_init_array+0x3c>)
 8013fb8:	1ba4      	subs	r4, r4, r6
 8013fba:	10a4      	asrs	r4, r4, #2
 8013fbc:	42a5      	cmp	r5, r4
 8013fbe:	d109      	bne.n	8013fd4 <__libc_init_array+0x24>
 8013fc0:	4e0b      	ldr	r6, [pc, #44]	; (8013ff0 <__libc_init_array+0x40>)
 8013fc2:	2500      	movs	r5, #0
 8013fc4:	4c0b      	ldr	r4, [pc, #44]	; (8013ff4 <__libc_init_array+0x44>)
 8013fc6:	f000 ff57 	bl	8014e78 <_init>
 8013fca:	1ba4      	subs	r4, r4, r6
 8013fcc:	10a4      	asrs	r4, r4, #2
 8013fce:	42a5      	cmp	r5, r4
 8013fd0:	d105      	bne.n	8013fde <__libc_init_array+0x2e>
 8013fd2:	bd70      	pop	{r4, r5, r6, pc}
 8013fd4:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8013fd8:	3501      	adds	r5, #1
 8013fda:	4798      	blx	r3
 8013fdc:	e7ee      	b.n	8013fbc <__libc_init_array+0xc>
 8013fde:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8013fe2:	3501      	adds	r5, #1
 8013fe4:	4798      	blx	r3
 8013fe6:	e7f2      	b.n	8013fce <__libc_init_array+0x1e>
 8013fe8:	08018078 	.word	0x08018078
 8013fec:	08018078 	.word	0x08018078
 8013ff0:	08018078 	.word	0x08018078
 8013ff4:	0801807c 	.word	0x0801807c

08013ff8 <__swhatbuf_r>:
 8013ff8:	b570      	push	{r4, r5, r6, lr}
 8013ffa:	460e      	mov	r6, r1
 8013ffc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8014000:	b096      	sub	sp, #88	; 0x58
 8014002:	4614      	mov	r4, r2
 8014004:	2900      	cmp	r1, #0
 8014006:	461d      	mov	r5, r3
 8014008:	da07      	bge.n	801401a <__swhatbuf_r+0x22>
 801400a:	2300      	movs	r3, #0
 801400c:	602b      	str	r3, [r5, #0]
 801400e:	89b3      	ldrh	r3, [r6, #12]
 8014010:	061a      	lsls	r2, r3, #24
 8014012:	d410      	bmi.n	8014036 <__swhatbuf_r+0x3e>
 8014014:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8014018:	e00e      	b.n	8014038 <__swhatbuf_r+0x40>
 801401a:	466a      	mov	r2, sp
 801401c:	f000 fbcc 	bl	80147b8 <_fstat_r>
 8014020:	2800      	cmp	r0, #0
 8014022:	dbf2      	blt.n	801400a <__swhatbuf_r+0x12>
 8014024:	9a01      	ldr	r2, [sp, #4]
 8014026:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 801402a:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 801402e:	425a      	negs	r2, r3
 8014030:	415a      	adcs	r2, r3
 8014032:	602a      	str	r2, [r5, #0]
 8014034:	e7ee      	b.n	8014014 <__swhatbuf_r+0x1c>
 8014036:	2340      	movs	r3, #64	; 0x40
 8014038:	2000      	movs	r0, #0
 801403a:	6023      	str	r3, [r4, #0]
 801403c:	b016      	add	sp, #88	; 0x58
 801403e:	bd70      	pop	{r4, r5, r6, pc}

08014040 <__smakebuf_r>:
 8014040:	898b      	ldrh	r3, [r1, #12]
 8014042:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8014044:	079d      	lsls	r5, r3, #30
 8014046:	4606      	mov	r6, r0
 8014048:	460c      	mov	r4, r1
 801404a:	d507      	bpl.n	801405c <__smakebuf_r+0x1c>
 801404c:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8014050:	6023      	str	r3, [r4, #0]
 8014052:	6123      	str	r3, [r4, #16]
 8014054:	2301      	movs	r3, #1
 8014056:	6163      	str	r3, [r4, #20]
 8014058:	b002      	add	sp, #8
 801405a:	bd70      	pop	{r4, r5, r6, pc}
 801405c:	ab01      	add	r3, sp, #4
 801405e:	466a      	mov	r2, sp
 8014060:	f7ff ffca 	bl	8013ff8 <__swhatbuf_r>
 8014064:	9900      	ldr	r1, [sp, #0]
 8014066:	4605      	mov	r5, r0
 8014068:	4630      	mov	r0, r6
 801406a:	f000 f8b3 	bl	80141d4 <_malloc_r>
 801406e:	b948      	cbnz	r0, 8014084 <__smakebuf_r+0x44>
 8014070:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8014074:	059a      	lsls	r2, r3, #22
 8014076:	d4ef      	bmi.n	8014058 <__smakebuf_r+0x18>
 8014078:	f023 0303 	bic.w	r3, r3, #3
 801407c:	f043 0302 	orr.w	r3, r3, #2
 8014080:	81a3      	strh	r3, [r4, #12]
 8014082:	e7e3      	b.n	801404c <__smakebuf_r+0xc>
 8014084:	4b0d      	ldr	r3, [pc, #52]	; (80140bc <__smakebuf_r+0x7c>)
 8014086:	62b3      	str	r3, [r6, #40]	; 0x28
 8014088:	89a3      	ldrh	r3, [r4, #12]
 801408a:	6020      	str	r0, [r4, #0]
 801408c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8014090:	6120      	str	r0, [r4, #16]
 8014092:	81a3      	strh	r3, [r4, #12]
 8014094:	9b00      	ldr	r3, [sp, #0]
 8014096:	6163      	str	r3, [r4, #20]
 8014098:	9b01      	ldr	r3, [sp, #4]
 801409a:	b15b      	cbz	r3, 80140b4 <__smakebuf_r+0x74>
 801409c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80140a0:	4630      	mov	r0, r6
 80140a2:	f000 fb9b 	bl	80147dc <_isatty_r>
 80140a6:	b128      	cbz	r0, 80140b4 <__smakebuf_r+0x74>
 80140a8:	89a3      	ldrh	r3, [r4, #12]
 80140aa:	f023 0303 	bic.w	r3, r3, #3
 80140ae:	f043 0301 	orr.w	r3, r3, #1
 80140b2:	81a3      	strh	r3, [r4, #12]
 80140b4:	89a3      	ldrh	r3, [r4, #12]
 80140b6:	431d      	orrs	r5, r3
 80140b8:	81a5      	strh	r5, [r4, #12]
 80140ba:	e7cd      	b.n	8014058 <__smakebuf_r+0x18>
 80140bc:	08013a39 	.word	0x08013a39

080140c0 <malloc>:
 80140c0:	4b02      	ldr	r3, [pc, #8]	; (80140cc <malloc+0xc>)
 80140c2:	4601      	mov	r1, r0
 80140c4:	6818      	ldr	r0, [r3, #0]
 80140c6:	f000 b885 	b.w	80141d4 <_malloc_r>
 80140ca:	bf00      	nop
 80140cc:	2000000c 	.word	0x2000000c

080140d0 <free>:
 80140d0:	4b02      	ldr	r3, [pc, #8]	; (80140dc <free+0xc>)
 80140d2:	4601      	mov	r1, r0
 80140d4:	6818      	ldr	r0, [r3, #0]
 80140d6:	f000 b82f 	b.w	8014138 <_free_r>
 80140da:	bf00      	nop
 80140dc:	2000000c 	.word	0x2000000c

080140e0 <memcpy>:
 80140e0:	1e43      	subs	r3, r0, #1
 80140e2:	440a      	add	r2, r1
 80140e4:	b510      	push	{r4, lr}
 80140e6:	4291      	cmp	r1, r2
 80140e8:	d100      	bne.n	80140ec <memcpy+0xc>
 80140ea:	bd10      	pop	{r4, pc}
 80140ec:	f811 4b01 	ldrb.w	r4, [r1], #1
 80140f0:	f803 4f01 	strb.w	r4, [r3, #1]!
 80140f4:	e7f7      	b.n	80140e6 <memcpy+0x6>

080140f6 <memmove>:
 80140f6:	4288      	cmp	r0, r1
 80140f8:	eb01 0302 	add.w	r3, r1, r2
 80140fc:	b510      	push	{r4, lr}
 80140fe:	d807      	bhi.n	8014110 <memmove+0x1a>
 8014100:	1e42      	subs	r2, r0, #1
 8014102:	4299      	cmp	r1, r3
 8014104:	d00a      	beq.n	801411c <memmove+0x26>
 8014106:	f811 4b01 	ldrb.w	r4, [r1], #1
 801410a:	f802 4f01 	strb.w	r4, [r2, #1]!
 801410e:	e7f8      	b.n	8014102 <memmove+0xc>
 8014110:	4283      	cmp	r3, r0
 8014112:	d9f5      	bls.n	8014100 <memmove+0xa>
 8014114:	1881      	adds	r1, r0, r2
 8014116:	1ad2      	subs	r2, r2, r3
 8014118:	42d3      	cmn	r3, r2
 801411a:	d100      	bne.n	801411e <memmove+0x28>
 801411c:	bd10      	pop	{r4, pc}
 801411e:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8014122:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8014126:	e7f7      	b.n	8014118 <memmove+0x22>

08014128 <memset>:
 8014128:	4402      	add	r2, r0
 801412a:	4603      	mov	r3, r0
 801412c:	4293      	cmp	r3, r2
 801412e:	d100      	bne.n	8014132 <memset+0xa>
 8014130:	4770      	bx	lr
 8014132:	f803 1b01 	strb.w	r1, [r3], #1
 8014136:	e7f9      	b.n	801412c <memset+0x4>

08014138 <_free_r>:
 8014138:	b538      	push	{r3, r4, r5, lr}
 801413a:	4605      	mov	r5, r0
 801413c:	2900      	cmp	r1, #0
 801413e:	d045      	beq.n	80141cc <_free_r+0x94>
 8014140:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8014144:	1f0c      	subs	r4, r1, #4
 8014146:	2b00      	cmp	r3, #0
 8014148:	bfb8      	it	lt
 801414a:	18e4      	addlt	r4, r4, r3
 801414c:	f000 fb68 	bl	8014820 <__malloc_lock>
 8014150:	4a1f      	ldr	r2, [pc, #124]	; (80141d0 <_free_r+0x98>)
 8014152:	6813      	ldr	r3, [r2, #0]
 8014154:	4610      	mov	r0, r2
 8014156:	b933      	cbnz	r3, 8014166 <_free_r+0x2e>
 8014158:	6063      	str	r3, [r4, #4]
 801415a:	6014      	str	r4, [r2, #0]
 801415c:	4628      	mov	r0, r5
 801415e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8014162:	f000 bb5e 	b.w	8014822 <__malloc_unlock>
 8014166:	42a3      	cmp	r3, r4
 8014168:	d90c      	bls.n	8014184 <_free_r+0x4c>
 801416a:	6821      	ldr	r1, [r4, #0]
 801416c:	1862      	adds	r2, r4, r1
 801416e:	4293      	cmp	r3, r2
 8014170:	bf02      	ittt	eq
 8014172:	681a      	ldreq	r2, [r3, #0]
 8014174:	685b      	ldreq	r3, [r3, #4]
 8014176:	1852      	addeq	r2, r2, r1
 8014178:	6063      	str	r3, [r4, #4]
 801417a:	bf08      	it	eq
 801417c:	6022      	streq	r2, [r4, #0]
 801417e:	6004      	str	r4, [r0, #0]
 8014180:	e7ec      	b.n	801415c <_free_r+0x24>
 8014182:	4613      	mov	r3, r2
 8014184:	685a      	ldr	r2, [r3, #4]
 8014186:	b10a      	cbz	r2, 801418c <_free_r+0x54>
 8014188:	42a2      	cmp	r2, r4
 801418a:	d9fa      	bls.n	8014182 <_free_r+0x4a>
 801418c:	6819      	ldr	r1, [r3, #0]
 801418e:	1858      	adds	r0, r3, r1
 8014190:	42a0      	cmp	r0, r4
 8014192:	d10b      	bne.n	80141ac <_free_r+0x74>
 8014194:	6820      	ldr	r0, [r4, #0]
 8014196:	4401      	add	r1, r0
 8014198:	1858      	adds	r0, r3, r1
 801419a:	6019      	str	r1, [r3, #0]
 801419c:	4282      	cmp	r2, r0
 801419e:	d1dd      	bne.n	801415c <_free_r+0x24>
 80141a0:	6810      	ldr	r0, [r2, #0]
 80141a2:	6852      	ldr	r2, [r2, #4]
 80141a4:	4401      	add	r1, r0
 80141a6:	605a      	str	r2, [r3, #4]
 80141a8:	6019      	str	r1, [r3, #0]
 80141aa:	e7d7      	b.n	801415c <_free_r+0x24>
 80141ac:	d902      	bls.n	80141b4 <_free_r+0x7c>
 80141ae:	230c      	movs	r3, #12
 80141b0:	602b      	str	r3, [r5, #0]
 80141b2:	e7d3      	b.n	801415c <_free_r+0x24>
 80141b4:	6820      	ldr	r0, [r4, #0]
 80141b6:	1821      	adds	r1, r4, r0
 80141b8:	428a      	cmp	r2, r1
 80141ba:	bf02      	ittt	eq
 80141bc:	6811      	ldreq	r1, [r2, #0]
 80141be:	6852      	ldreq	r2, [r2, #4]
 80141c0:	1809      	addeq	r1, r1, r0
 80141c2:	6062      	str	r2, [r4, #4]
 80141c4:	bf08      	it	eq
 80141c6:	6021      	streq	r1, [r4, #0]
 80141c8:	605c      	str	r4, [r3, #4]
 80141ca:	e7c7      	b.n	801415c <_free_r+0x24>
 80141cc:	bd38      	pop	{r3, r4, r5, pc}
 80141ce:	bf00      	nop
 80141d0:	200000a4 	.word	0x200000a4

080141d4 <_malloc_r>:
 80141d4:	b570      	push	{r4, r5, r6, lr}
 80141d6:	1ccd      	adds	r5, r1, #3
 80141d8:	4606      	mov	r6, r0
 80141da:	f025 0503 	bic.w	r5, r5, #3
 80141de:	3508      	adds	r5, #8
 80141e0:	2d0c      	cmp	r5, #12
 80141e2:	bf38      	it	cc
 80141e4:	250c      	movcc	r5, #12
 80141e6:	2d00      	cmp	r5, #0
 80141e8:	db01      	blt.n	80141ee <_malloc_r+0x1a>
 80141ea:	42a9      	cmp	r1, r5
 80141ec:	d903      	bls.n	80141f6 <_malloc_r+0x22>
 80141ee:	230c      	movs	r3, #12
 80141f0:	6033      	str	r3, [r6, #0]
 80141f2:	2000      	movs	r0, #0
 80141f4:	bd70      	pop	{r4, r5, r6, pc}
 80141f6:	f000 fb13 	bl	8014820 <__malloc_lock>
 80141fa:	4a21      	ldr	r2, [pc, #132]	; (8014280 <_malloc_r+0xac>)
 80141fc:	6814      	ldr	r4, [r2, #0]
 80141fe:	4621      	mov	r1, r4
 8014200:	b991      	cbnz	r1, 8014228 <_malloc_r+0x54>
 8014202:	4c20      	ldr	r4, [pc, #128]	; (8014284 <_malloc_r+0xb0>)
 8014204:	6823      	ldr	r3, [r4, #0]
 8014206:	b91b      	cbnz	r3, 8014210 <_malloc_r+0x3c>
 8014208:	4630      	mov	r0, r6
 801420a:	f000 f949 	bl	80144a0 <_sbrk_r>
 801420e:	6020      	str	r0, [r4, #0]
 8014210:	4629      	mov	r1, r5
 8014212:	4630      	mov	r0, r6
 8014214:	f000 f944 	bl	80144a0 <_sbrk_r>
 8014218:	1c43      	adds	r3, r0, #1
 801421a:	d124      	bne.n	8014266 <_malloc_r+0x92>
 801421c:	230c      	movs	r3, #12
 801421e:	4630      	mov	r0, r6
 8014220:	6033      	str	r3, [r6, #0]
 8014222:	f000 fafe 	bl	8014822 <__malloc_unlock>
 8014226:	e7e4      	b.n	80141f2 <_malloc_r+0x1e>
 8014228:	680b      	ldr	r3, [r1, #0]
 801422a:	1b5b      	subs	r3, r3, r5
 801422c:	d418      	bmi.n	8014260 <_malloc_r+0x8c>
 801422e:	2b0b      	cmp	r3, #11
 8014230:	d90f      	bls.n	8014252 <_malloc_r+0x7e>
 8014232:	18cc      	adds	r4, r1, r3
 8014234:	600b      	str	r3, [r1, #0]
 8014236:	50cd      	str	r5, [r1, r3]
 8014238:	4630      	mov	r0, r6
 801423a:	f000 faf2 	bl	8014822 <__malloc_unlock>
 801423e:	f104 000b 	add.w	r0, r4, #11
 8014242:	1d23      	adds	r3, r4, #4
 8014244:	f020 0007 	bic.w	r0, r0, #7
 8014248:	1ac3      	subs	r3, r0, r3
 801424a:	d0d3      	beq.n	80141f4 <_malloc_r+0x20>
 801424c:	425a      	negs	r2, r3
 801424e:	50e2      	str	r2, [r4, r3]
 8014250:	e7d0      	b.n	80141f4 <_malloc_r+0x20>
 8014252:	428c      	cmp	r4, r1
 8014254:	684b      	ldr	r3, [r1, #4]
 8014256:	bf1a      	itte	ne
 8014258:	6063      	strne	r3, [r4, #4]
 801425a:	460c      	movne	r4, r1
 801425c:	6013      	streq	r3, [r2, #0]
 801425e:	e7eb      	b.n	8014238 <_malloc_r+0x64>
 8014260:	460c      	mov	r4, r1
 8014262:	6849      	ldr	r1, [r1, #4]
 8014264:	e7cc      	b.n	8014200 <_malloc_r+0x2c>
 8014266:	1cc4      	adds	r4, r0, #3
 8014268:	f024 0403 	bic.w	r4, r4, #3
 801426c:	42a0      	cmp	r0, r4
 801426e:	d005      	beq.n	801427c <_malloc_r+0xa8>
 8014270:	1a21      	subs	r1, r4, r0
 8014272:	4630      	mov	r0, r6
 8014274:	f000 f914 	bl	80144a0 <_sbrk_r>
 8014278:	3001      	adds	r0, #1
 801427a:	d0cf      	beq.n	801421c <_malloc_r+0x48>
 801427c:	6025      	str	r5, [r4, #0]
 801427e:	e7db      	b.n	8014238 <_malloc_r+0x64>
 8014280:	200000a4 	.word	0x200000a4
 8014284:	200000a8 	.word	0x200000a8

08014288 <_open_r>:
 8014288:	b538      	push	{r3, r4, r5, lr}
 801428a:	4605      	mov	r5, r0
 801428c:	4c06      	ldr	r4, [pc, #24]	; (80142a8 <_open_r+0x20>)
 801428e:	4608      	mov	r0, r1
 8014290:	4611      	mov	r1, r2
 8014292:	2200      	movs	r2, #0
 8014294:	6022      	str	r2, [r4, #0]
 8014296:	461a      	mov	r2, r3
 8014298:	f7ec f8f8 	bl	800048c <_open>
 801429c:	1c43      	adds	r3, r0, #1
 801429e:	d102      	bne.n	80142a6 <_open_r+0x1e>
 80142a0:	6823      	ldr	r3, [r4, #0]
 80142a2:	b103      	cbz	r3, 80142a6 <_open_r+0x1e>
 80142a4:	602b      	str	r3, [r5, #0]
 80142a6:	bd38      	pop	{r3, r4, r5, pc}
 80142a8:	200000dc 	.word	0x200000dc

080142ac <_puts_r>:
 80142ac:	b570      	push	{r4, r5, r6, lr}
 80142ae:	460e      	mov	r6, r1
 80142b0:	4605      	mov	r5, r0
 80142b2:	b118      	cbz	r0, 80142bc <_puts_r+0x10>
 80142b4:	6983      	ldr	r3, [r0, #24]
 80142b6:	b90b      	cbnz	r3, 80142bc <_puts_r+0x10>
 80142b8:	f7ff fbda 	bl	8013a70 <__sinit>
 80142bc:	69ab      	ldr	r3, [r5, #24]
 80142be:	68ac      	ldr	r4, [r5, #8]
 80142c0:	b913      	cbnz	r3, 80142c8 <_puts_r+0x1c>
 80142c2:	4628      	mov	r0, r5
 80142c4:	f7ff fbd4 	bl	8013a70 <__sinit>
 80142c8:	4b23      	ldr	r3, [pc, #140]	; (8014358 <_puts_r+0xac>)
 80142ca:	429c      	cmp	r4, r3
 80142cc:	d117      	bne.n	80142fe <_puts_r+0x52>
 80142ce:	686c      	ldr	r4, [r5, #4]
 80142d0:	89a3      	ldrh	r3, [r4, #12]
 80142d2:	071b      	lsls	r3, r3, #28
 80142d4:	d51d      	bpl.n	8014312 <_puts_r+0x66>
 80142d6:	6923      	ldr	r3, [r4, #16]
 80142d8:	b1db      	cbz	r3, 8014312 <_puts_r+0x66>
 80142da:	3e01      	subs	r6, #1
 80142dc:	68a3      	ldr	r3, [r4, #8]
 80142de:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 80142e2:	3b01      	subs	r3, #1
 80142e4:	60a3      	str	r3, [r4, #8]
 80142e6:	b9e9      	cbnz	r1, 8014324 <_puts_r+0x78>
 80142e8:	2b00      	cmp	r3, #0
 80142ea:	da2e      	bge.n	801434a <_puts_r+0x9e>
 80142ec:	4622      	mov	r2, r4
 80142ee:	210a      	movs	r1, #10
 80142f0:	4628      	mov	r0, r5
 80142f2:	f000 f949 	bl	8014588 <__swbuf_r>
 80142f6:	3001      	adds	r0, #1
 80142f8:	d011      	beq.n	801431e <_puts_r+0x72>
 80142fa:	200a      	movs	r0, #10
 80142fc:	e011      	b.n	8014322 <_puts_r+0x76>
 80142fe:	4b17      	ldr	r3, [pc, #92]	; (801435c <_puts_r+0xb0>)
 8014300:	429c      	cmp	r4, r3
 8014302:	d101      	bne.n	8014308 <_puts_r+0x5c>
 8014304:	68ac      	ldr	r4, [r5, #8]
 8014306:	e7e3      	b.n	80142d0 <_puts_r+0x24>
 8014308:	4b15      	ldr	r3, [pc, #84]	; (8014360 <_puts_r+0xb4>)
 801430a:	429c      	cmp	r4, r3
 801430c:	bf08      	it	eq
 801430e:	68ec      	ldreq	r4, [r5, #12]
 8014310:	e7de      	b.n	80142d0 <_puts_r+0x24>
 8014312:	4621      	mov	r1, r4
 8014314:	4628      	mov	r0, r5
 8014316:	f000 f99b 	bl	8014650 <__swsetup_r>
 801431a:	2800      	cmp	r0, #0
 801431c:	d0dd      	beq.n	80142da <_puts_r+0x2e>
 801431e:	f04f 30ff 	mov.w	r0, #4294967295
 8014322:	bd70      	pop	{r4, r5, r6, pc}
 8014324:	2b00      	cmp	r3, #0
 8014326:	da04      	bge.n	8014332 <_puts_r+0x86>
 8014328:	69a2      	ldr	r2, [r4, #24]
 801432a:	429a      	cmp	r2, r3
 801432c:	dc06      	bgt.n	801433c <_puts_r+0x90>
 801432e:	290a      	cmp	r1, #10
 8014330:	d004      	beq.n	801433c <_puts_r+0x90>
 8014332:	6823      	ldr	r3, [r4, #0]
 8014334:	1c5a      	adds	r2, r3, #1
 8014336:	6022      	str	r2, [r4, #0]
 8014338:	7019      	strb	r1, [r3, #0]
 801433a:	e7cf      	b.n	80142dc <_puts_r+0x30>
 801433c:	4622      	mov	r2, r4
 801433e:	4628      	mov	r0, r5
 8014340:	f000 f922 	bl	8014588 <__swbuf_r>
 8014344:	3001      	adds	r0, #1
 8014346:	d1c9      	bne.n	80142dc <_puts_r+0x30>
 8014348:	e7e9      	b.n	801431e <_puts_r+0x72>
 801434a:	6823      	ldr	r3, [r4, #0]
 801434c:	200a      	movs	r0, #10
 801434e:	1c5a      	adds	r2, r3, #1
 8014350:	6022      	str	r2, [r4, #0]
 8014352:	7018      	strb	r0, [r3, #0]
 8014354:	e7e5      	b.n	8014322 <_puts_r+0x76>
 8014356:	bf00      	nop
 8014358:	08018000 	.word	0x08018000
 801435c:	08018020 	.word	0x08018020
 8014360:	08017fe0 	.word	0x08017fe0

08014364 <puts>:
 8014364:	4b02      	ldr	r3, [pc, #8]	; (8014370 <puts+0xc>)
 8014366:	4601      	mov	r1, r0
 8014368:	6818      	ldr	r0, [r3, #0]
 801436a:	f7ff bf9f 	b.w	80142ac <_puts_r>
 801436e:	bf00      	nop
 8014370:	2000000c 	.word	0x2000000c

08014374 <lflush>:
 8014374:	8983      	ldrh	r3, [r0, #12]
 8014376:	f003 0309 	and.w	r3, r3, #9
 801437a:	2b09      	cmp	r3, #9
 801437c:	d101      	bne.n	8014382 <lflush+0xe>
 801437e:	f7ff bb25 	b.w	80139cc <fflush>
 8014382:	2000      	movs	r0, #0
 8014384:	4770      	bx	lr
	...

08014388 <__srefill_r>:
 8014388:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801438a:	460c      	mov	r4, r1
 801438c:	4605      	mov	r5, r0
 801438e:	b118      	cbz	r0, 8014398 <__srefill_r+0x10>
 8014390:	6983      	ldr	r3, [r0, #24]
 8014392:	b90b      	cbnz	r3, 8014398 <__srefill_r+0x10>
 8014394:	f7ff fb6c 	bl	8013a70 <__sinit>
 8014398:	4b3c      	ldr	r3, [pc, #240]	; (801448c <__srefill_r+0x104>)
 801439a:	429c      	cmp	r4, r3
 801439c:	d10a      	bne.n	80143b4 <__srefill_r+0x2c>
 801439e:	686c      	ldr	r4, [r5, #4]
 80143a0:	2300      	movs	r3, #0
 80143a2:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80143a6:	6063      	str	r3, [r4, #4]
 80143a8:	b293      	uxth	r3, r2
 80143aa:	069e      	lsls	r6, r3, #26
 80143ac:	d50c      	bpl.n	80143c8 <__srefill_r+0x40>
 80143ae:	f04f 30ff 	mov.w	r0, #4294967295
 80143b2:	e067      	b.n	8014484 <__srefill_r+0xfc>
 80143b4:	4b36      	ldr	r3, [pc, #216]	; (8014490 <__srefill_r+0x108>)
 80143b6:	429c      	cmp	r4, r3
 80143b8:	d101      	bne.n	80143be <__srefill_r+0x36>
 80143ba:	68ac      	ldr	r4, [r5, #8]
 80143bc:	e7f0      	b.n	80143a0 <__srefill_r+0x18>
 80143be:	4b35      	ldr	r3, [pc, #212]	; (8014494 <__srefill_r+0x10c>)
 80143c0:	429c      	cmp	r4, r3
 80143c2:	bf08      	it	eq
 80143c4:	68ec      	ldreq	r4, [r5, #12]
 80143c6:	e7eb      	b.n	80143a0 <__srefill_r+0x18>
 80143c8:	0758      	lsls	r0, r3, #29
 80143ca:	d449      	bmi.n	8014460 <__srefill_r+0xd8>
 80143cc:	06d9      	lsls	r1, r3, #27
 80143ce:	d405      	bmi.n	80143dc <__srefill_r+0x54>
 80143d0:	2309      	movs	r3, #9
 80143d2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80143d6:	602b      	str	r3, [r5, #0]
 80143d8:	81a2      	strh	r2, [r4, #12]
 80143da:	e7e8      	b.n	80143ae <__srefill_r+0x26>
 80143dc:	071a      	lsls	r2, r3, #28
 80143de:	d50b      	bpl.n	80143f8 <__srefill_r+0x70>
 80143e0:	4621      	mov	r1, r4
 80143e2:	4628      	mov	r0, r5
 80143e4:	f7ff fac8 	bl	8013978 <_fflush_r>
 80143e8:	2800      	cmp	r0, #0
 80143ea:	d1e0      	bne.n	80143ae <__srefill_r+0x26>
 80143ec:	89a3      	ldrh	r3, [r4, #12]
 80143ee:	60a0      	str	r0, [r4, #8]
 80143f0:	f023 0308 	bic.w	r3, r3, #8
 80143f4:	61a0      	str	r0, [r4, #24]
 80143f6:	81a3      	strh	r3, [r4, #12]
 80143f8:	89a3      	ldrh	r3, [r4, #12]
 80143fa:	f043 0304 	orr.w	r3, r3, #4
 80143fe:	81a3      	strh	r3, [r4, #12]
 8014400:	6923      	ldr	r3, [r4, #16]
 8014402:	b91b      	cbnz	r3, 801440c <__srefill_r+0x84>
 8014404:	4621      	mov	r1, r4
 8014406:	4628      	mov	r0, r5
 8014408:	f7ff fe1a 	bl	8014040 <__smakebuf_r>
 801440c:	f9b4 700c 	ldrsh.w	r7, [r4, #12]
 8014410:	b2be      	uxth	r6, r7
 8014412:	07b3      	lsls	r3, r6, #30
 8014414:	d00f      	beq.n	8014436 <__srefill_r+0xae>
 8014416:	2301      	movs	r3, #1
 8014418:	f006 0609 	and.w	r6, r6, #9
 801441c:	491e      	ldr	r1, [pc, #120]	; (8014498 <__srefill_r+0x110>)
 801441e:	81a3      	strh	r3, [r4, #12]
 8014420:	4b1e      	ldr	r3, [pc, #120]	; (801449c <__srefill_r+0x114>)
 8014422:	6818      	ldr	r0, [r3, #0]
 8014424:	f7ff fd2e 	bl	8013e84 <_fwalk>
 8014428:	2e09      	cmp	r6, #9
 801442a:	81a7      	strh	r7, [r4, #12]
 801442c:	d103      	bne.n	8014436 <__srefill_r+0xae>
 801442e:	4621      	mov	r1, r4
 8014430:	4628      	mov	r0, r5
 8014432:	f7ff fa1d 	bl	8013870 <__sflush_r>
 8014436:	6922      	ldr	r2, [r4, #16]
 8014438:	4628      	mov	r0, r5
 801443a:	6a66      	ldr	r6, [r4, #36]	; 0x24
 801443c:	6022      	str	r2, [r4, #0]
 801443e:	6963      	ldr	r3, [r4, #20]
 8014440:	6a21      	ldr	r1, [r4, #32]
 8014442:	47b0      	blx	r6
 8014444:	2800      	cmp	r0, #0
 8014446:	6060      	str	r0, [r4, #4]
 8014448:	dc1d      	bgt.n	8014486 <__srefill_r+0xfe>
 801444a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801444e:	bf17      	itett	ne
 8014450:	2200      	movne	r2, #0
 8014452:	f043 0320 	orreq.w	r3, r3, #32
 8014456:	f043 0340 	orrne.w	r3, r3, #64	; 0x40
 801445a:	6062      	strne	r2, [r4, #4]
 801445c:	81a3      	strh	r3, [r4, #12]
 801445e:	e7a6      	b.n	80143ae <__srefill_r+0x26>
 8014460:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8014462:	2900      	cmp	r1, #0
 8014464:	d0cc      	beq.n	8014400 <__srefill_r+0x78>
 8014466:	f104 0344 	add.w	r3, r4, #68	; 0x44
 801446a:	4299      	cmp	r1, r3
 801446c:	d002      	beq.n	8014474 <__srefill_r+0xec>
 801446e:	4628      	mov	r0, r5
 8014470:	f7ff fe62 	bl	8014138 <_free_r>
 8014474:	2000      	movs	r0, #0
 8014476:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8014478:	6360      	str	r0, [r4, #52]	; 0x34
 801447a:	6063      	str	r3, [r4, #4]
 801447c:	2b00      	cmp	r3, #0
 801447e:	d0bf      	beq.n	8014400 <__srefill_r+0x78>
 8014480:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8014482:	6023      	str	r3, [r4, #0]
 8014484:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8014486:	2000      	movs	r0, #0
 8014488:	e7fc      	b.n	8014484 <__srefill_r+0xfc>
 801448a:	bf00      	nop
 801448c:	08018000 	.word	0x08018000
 8014490:	08018020 	.word	0x08018020
 8014494:	08017fe0 	.word	0x08017fe0
 8014498:	08014375 	.word	0x08014375
 801449c:	08018040 	.word	0x08018040

080144a0 <_sbrk_r>:
 80144a0:	b538      	push	{r3, r4, r5, lr}
 80144a2:	2300      	movs	r3, #0
 80144a4:	4c05      	ldr	r4, [pc, #20]	; (80144bc <_sbrk_r+0x1c>)
 80144a6:	4605      	mov	r5, r0
 80144a8:	4608      	mov	r0, r1
 80144aa:	6023      	str	r3, [r4, #0]
 80144ac:	f7eb fff4 	bl	8000498 <_sbrk>
 80144b0:	1c43      	adds	r3, r0, #1
 80144b2:	d102      	bne.n	80144ba <_sbrk_r+0x1a>
 80144b4:	6823      	ldr	r3, [r4, #0]
 80144b6:	b103      	cbz	r3, 80144ba <_sbrk_r+0x1a>
 80144b8:	602b      	str	r3, [r5, #0]
 80144ba:	bd38      	pop	{r3, r4, r5, pc}
 80144bc:	200000dc 	.word	0x200000dc

080144c0 <siprintf>:
 80144c0:	b40e      	push	{r1, r2, r3}
 80144c2:	b500      	push	{lr}
 80144c4:	b09c      	sub	sp, #112	; 0x70
 80144c6:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80144ca:	ab1d      	add	r3, sp, #116	; 0x74
 80144cc:	9002      	str	r0, [sp, #8]
 80144ce:	9006      	str	r0, [sp, #24]
 80144d0:	9107      	str	r1, [sp, #28]
 80144d2:	9104      	str	r1, [sp, #16]
 80144d4:	4808      	ldr	r0, [pc, #32]	; (80144f8 <siprintf+0x38>)
 80144d6:	4909      	ldr	r1, [pc, #36]	; (80144fc <siprintf+0x3c>)
 80144d8:	f853 2b04 	ldr.w	r2, [r3], #4
 80144dc:	9105      	str	r1, [sp, #20]
 80144de:	a902      	add	r1, sp, #8
 80144e0:	6800      	ldr	r0, [r0, #0]
 80144e2:	9301      	str	r3, [sp, #4]
 80144e4:	f000 f9f8 	bl	80148d8 <_svfiprintf_r>
 80144e8:	9b02      	ldr	r3, [sp, #8]
 80144ea:	2200      	movs	r2, #0
 80144ec:	701a      	strb	r2, [r3, #0]
 80144ee:	b01c      	add	sp, #112	; 0x70
 80144f0:	f85d eb04 	ldr.w	lr, [sp], #4
 80144f4:	b003      	add	sp, #12
 80144f6:	4770      	bx	lr
 80144f8:	2000000c 	.word	0x2000000c
 80144fc:	ffff0208 	.word	0xffff0208

08014500 <__sread>:
 8014500:	b510      	push	{r4, lr}
 8014502:	460c      	mov	r4, r1
 8014504:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8014508:	f000 fc68 	bl	8014ddc <_read_r>
 801450c:	2800      	cmp	r0, #0
 801450e:	bfab      	itete	ge
 8014510:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8014512:	89a3      	ldrhlt	r3, [r4, #12]
 8014514:	181b      	addge	r3, r3, r0
 8014516:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 801451a:	bfac      	ite	ge
 801451c:	6563      	strge	r3, [r4, #84]	; 0x54
 801451e:	81a3      	strhlt	r3, [r4, #12]
 8014520:	bd10      	pop	{r4, pc}

08014522 <__swrite>:
 8014522:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014526:	461f      	mov	r7, r3
 8014528:	898b      	ldrh	r3, [r1, #12]
 801452a:	4605      	mov	r5, r0
 801452c:	460c      	mov	r4, r1
 801452e:	05db      	lsls	r3, r3, #23
 8014530:	4616      	mov	r6, r2
 8014532:	d505      	bpl.n	8014540 <__swrite+0x1e>
 8014534:	2302      	movs	r3, #2
 8014536:	2200      	movs	r2, #0
 8014538:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801453c:	f000 f95e 	bl	80147fc <_lseek_r>
 8014540:	89a3      	ldrh	r3, [r4, #12]
 8014542:	4632      	mov	r2, r6
 8014544:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8014548:	4628      	mov	r0, r5
 801454a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 801454e:	81a3      	strh	r3, [r4, #12]
 8014550:	463b      	mov	r3, r7
 8014552:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8014556:	f000 b869 	b.w	801462c <_write_r>

0801455a <__sseek>:
 801455a:	b510      	push	{r4, lr}
 801455c:	460c      	mov	r4, r1
 801455e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8014562:	f000 f94b 	bl	80147fc <_lseek_r>
 8014566:	1c43      	adds	r3, r0, #1
 8014568:	89a3      	ldrh	r3, [r4, #12]
 801456a:	bf15      	itete	ne
 801456c:	6560      	strne	r0, [r4, #84]	; 0x54
 801456e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8014572:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8014576:	81a3      	strheq	r3, [r4, #12]
 8014578:	bf18      	it	ne
 801457a:	81a3      	strhne	r3, [r4, #12]
 801457c:	bd10      	pop	{r4, pc}

0801457e <__sclose>:
 801457e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8014582:	f000 b8d3 	b.w	801472c <_close_r>
	...

08014588 <__swbuf_r>:
 8014588:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801458a:	460e      	mov	r6, r1
 801458c:	4614      	mov	r4, r2
 801458e:	4605      	mov	r5, r0
 8014590:	b118      	cbz	r0, 801459a <__swbuf_r+0x12>
 8014592:	6983      	ldr	r3, [r0, #24]
 8014594:	b90b      	cbnz	r3, 801459a <__swbuf_r+0x12>
 8014596:	f7ff fa6b 	bl	8013a70 <__sinit>
 801459a:	4b21      	ldr	r3, [pc, #132]	; (8014620 <__swbuf_r+0x98>)
 801459c:	429c      	cmp	r4, r3
 801459e:	d12a      	bne.n	80145f6 <__swbuf_r+0x6e>
 80145a0:	686c      	ldr	r4, [r5, #4]
 80145a2:	69a3      	ldr	r3, [r4, #24]
 80145a4:	60a3      	str	r3, [r4, #8]
 80145a6:	89a3      	ldrh	r3, [r4, #12]
 80145a8:	071a      	lsls	r2, r3, #28
 80145aa:	d52e      	bpl.n	801460a <__swbuf_r+0x82>
 80145ac:	6923      	ldr	r3, [r4, #16]
 80145ae:	b363      	cbz	r3, 801460a <__swbuf_r+0x82>
 80145b0:	6923      	ldr	r3, [r4, #16]
 80145b2:	b2f6      	uxtb	r6, r6
 80145b4:	6820      	ldr	r0, [r4, #0]
 80145b6:	4637      	mov	r7, r6
 80145b8:	1ac0      	subs	r0, r0, r3
 80145ba:	6963      	ldr	r3, [r4, #20]
 80145bc:	4283      	cmp	r3, r0
 80145be:	dc04      	bgt.n	80145ca <__swbuf_r+0x42>
 80145c0:	4621      	mov	r1, r4
 80145c2:	4628      	mov	r0, r5
 80145c4:	f7ff f9d8 	bl	8013978 <_fflush_r>
 80145c8:	bb28      	cbnz	r0, 8014616 <__swbuf_r+0x8e>
 80145ca:	68a3      	ldr	r3, [r4, #8]
 80145cc:	3001      	adds	r0, #1
 80145ce:	3b01      	subs	r3, #1
 80145d0:	60a3      	str	r3, [r4, #8]
 80145d2:	6823      	ldr	r3, [r4, #0]
 80145d4:	1c5a      	adds	r2, r3, #1
 80145d6:	6022      	str	r2, [r4, #0]
 80145d8:	701e      	strb	r6, [r3, #0]
 80145da:	6963      	ldr	r3, [r4, #20]
 80145dc:	4283      	cmp	r3, r0
 80145de:	d004      	beq.n	80145ea <__swbuf_r+0x62>
 80145e0:	89a3      	ldrh	r3, [r4, #12]
 80145e2:	07db      	lsls	r3, r3, #31
 80145e4:	d519      	bpl.n	801461a <__swbuf_r+0x92>
 80145e6:	2e0a      	cmp	r6, #10
 80145e8:	d117      	bne.n	801461a <__swbuf_r+0x92>
 80145ea:	4621      	mov	r1, r4
 80145ec:	4628      	mov	r0, r5
 80145ee:	f7ff f9c3 	bl	8013978 <_fflush_r>
 80145f2:	b190      	cbz	r0, 801461a <__swbuf_r+0x92>
 80145f4:	e00f      	b.n	8014616 <__swbuf_r+0x8e>
 80145f6:	4b0b      	ldr	r3, [pc, #44]	; (8014624 <__swbuf_r+0x9c>)
 80145f8:	429c      	cmp	r4, r3
 80145fa:	d101      	bne.n	8014600 <__swbuf_r+0x78>
 80145fc:	68ac      	ldr	r4, [r5, #8]
 80145fe:	e7d0      	b.n	80145a2 <__swbuf_r+0x1a>
 8014600:	4b09      	ldr	r3, [pc, #36]	; (8014628 <__swbuf_r+0xa0>)
 8014602:	429c      	cmp	r4, r3
 8014604:	bf08      	it	eq
 8014606:	68ec      	ldreq	r4, [r5, #12]
 8014608:	e7cb      	b.n	80145a2 <__swbuf_r+0x1a>
 801460a:	4621      	mov	r1, r4
 801460c:	4628      	mov	r0, r5
 801460e:	f000 f81f 	bl	8014650 <__swsetup_r>
 8014612:	2800      	cmp	r0, #0
 8014614:	d0cc      	beq.n	80145b0 <__swbuf_r+0x28>
 8014616:	f04f 37ff 	mov.w	r7, #4294967295
 801461a:	4638      	mov	r0, r7
 801461c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801461e:	bf00      	nop
 8014620:	08018000 	.word	0x08018000
 8014624:	08018020 	.word	0x08018020
 8014628:	08017fe0 	.word	0x08017fe0

0801462c <_write_r>:
 801462c:	b538      	push	{r3, r4, r5, lr}
 801462e:	4605      	mov	r5, r0
 8014630:	4c06      	ldr	r4, [pc, #24]	; (801464c <_write_r+0x20>)
 8014632:	4608      	mov	r0, r1
 8014634:	4611      	mov	r1, r2
 8014636:	2200      	movs	r2, #0
 8014638:	6022      	str	r2, [r4, #0]
 801463a:	461a      	mov	r2, r3
 801463c:	f7eb ff0a 	bl	8000454 <_write>
 8014640:	1c43      	adds	r3, r0, #1
 8014642:	d102      	bne.n	801464a <_write_r+0x1e>
 8014644:	6823      	ldr	r3, [r4, #0]
 8014646:	b103      	cbz	r3, 801464a <_write_r+0x1e>
 8014648:	602b      	str	r3, [r5, #0]
 801464a:	bd38      	pop	{r3, r4, r5, pc}
 801464c:	200000dc 	.word	0x200000dc

08014650 <__swsetup_r>:
 8014650:	4b32      	ldr	r3, [pc, #200]	; (801471c <__swsetup_r+0xcc>)
 8014652:	b570      	push	{r4, r5, r6, lr}
 8014654:	681d      	ldr	r5, [r3, #0]
 8014656:	4606      	mov	r6, r0
 8014658:	460c      	mov	r4, r1
 801465a:	b125      	cbz	r5, 8014666 <__swsetup_r+0x16>
 801465c:	69ab      	ldr	r3, [r5, #24]
 801465e:	b913      	cbnz	r3, 8014666 <__swsetup_r+0x16>
 8014660:	4628      	mov	r0, r5
 8014662:	f7ff fa05 	bl	8013a70 <__sinit>
 8014666:	4b2e      	ldr	r3, [pc, #184]	; (8014720 <__swsetup_r+0xd0>)
 8014668:	429c      	cmp	r4, r3
 801466a:	d10f      	bne.n	801468c <__swsetup_r+0x3c>
 801466c:	686c      	ldr	r4, [r5, #4]
 801466e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8014672:	b29a      	uxth	r2, r3
 8014674:	0715      	lsls	r5, r2, #28
 8014676:	d42c      	bmi.n	80146d2 <__swsetup_r+0x82>
 8014678:	06d0      	lsls	r0, r2, #27
 801467a:	d411      	bmi.n	80146a0 <__swsetup_r+0x50>
 801467c:	2209      	movs	r2, #9
 801467e:	6032      	str	r2, [r6, #0]
 8014680:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8014684:	f04f 30ff 	mov.w	r0, #4294967295
 8014688:	81a3      	strh	r3, [r4, #12]
 801468a:	e03e      	b.n	801470a <__swsetup_r+0xba>
 801468c:	4b25      	ldr	r3, [pc, #148]	; (8014724 <__swsetup_r+0xd4>)
 801468e:	429c      	cmp	r4, r3
 8014690:	d101      	bne.n	8014696 <__swsetup_r+0x46>
 8014692:	68ac      	ldr	r4, [r5, #8]
 8014694:	e7eb      	b.n	801466e <__swsetup_r+0x1e>
 8014696:	4b24      	ldr	r3, [pc, #144]	; (8014728 <__swsetup_r+0xd8>)
 8014698:	429c      	cmp	r4, r3
 801469a:	bf08      	it	eq
 801469c:	68ec      	ldreq	r4, [r5, #12]
 801469e:	e7e6      	b.n	801466e <__swsetup_r+0x1e>
 80146a0:	0751      	lsls	r1, r2, #29
 80146a2:	d512      	bpl.n	80146ca <__swsetup_r+0x7a>
 80146a4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80146a6:	b141      	cbz	r1, 80146ba <__swsetup_r+0x6a>
 80146a8:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80146ac:	4299      	cmp	r1, r3
 80146ae:	d002      	beq.n	80146b6 <__swsetup_r+0x66>
 80146b0:	4630      	mov	r0, r6
 80146b2:	f7ff fd41 	bl	8014138 <_free_r>
 80146b6:	2300      	movs	r3, #0
 80146b8:	6363      	str	r3, [r4, #52]	; 0x34
 80146ba:	89a3      	ldrh	r3, [r4, #12]
 80146bc:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80146c0:	81a3      	strh	r3, [r4, #12]
 80146c2:	2300      	movs	r3, #0
 80146c4:	6063      	str	r3, [r4, #4]
 80146c6:	6923      	ldr	r3, [r4, #16]
 80146c8:	6023      	str	r3, [r4, #0]
 80146ca:	89a3      	ldrh	r3, [r4, #12]
 80146cc:	f043 0308 	orr.w	r3, r3, #8
 80146d0:	81a3      	strh	r3, [r4, #12]
 80146d2:	6923      	ldr	r3, [r4, #16]
 80146d4:	b94b      	cbnz	r3, 80146ea <__swsetup_r+0x9a>
 80146d6:	89a3      	ldrh	r3, [r4, #12]
 80146d8:	f403 7320 	and.w	r3, r3, #640	; 0x280
 80146dc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80146e0:	d003      	beq.n	80146ea <__swsetup_r+0x9a>
 80146e2:	4621      	mov	r1, r4
 80146e4:	4630      	mov	r0, r6
 80146e6:	f7ff fcab 	bl	8014040 <__smakebuf_r>
 80146ea:	89a2      	ldrh	r2, [r4, #12]
 80146ec:	f012 0301 	ands.w	r3, r2, #1
 80146f0:	d00c      	beq.n	801470c <__swsetup_r+0xbc>
 80146f2:	2300      	movs	r3, #0
 80146f4:	60a3      	str	r3, [r4, #8]
 80146f6:	6963      	ldr	r3, [r4, #20]
 80146f8:	425b      	negs	r3, r3
 80146fa:	61a3      	str	r3, [r4, #24]
 80146fc:	6923      	ldr	r3, [r4, #16]
 80146fe:	b953      	cbnz	r3, 8014716 <__swsetup_r+0xc6>
 8014700:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8014704:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 8014708:	d1ba      	bne.n	8014680 <__swsetup_r+0x30>
 801470a:	bd70      	pop	{r4, r5, r6, pc}
 801470c:	0792      	lsls	r2, r2, #30
 801470e:	bf58      	it	pl
 8014710:	6963      	ldrpl	r3, [r4, #20]
 8014712:	60a3      	str	r3, [r4, #8]
 8014714:	e7f2      	b.n	80146fc <__swsetup_r+0xac>
 8014716:	2000      	movs	r0, #0
 8014718:	e7f7      	b.n	801470a <__swsetup_r+0xba>
 801471a:	bf00      	nop
 801471c:	2000000c 	.word	0x2000000c
 8014720:	08018000 	.word	0x08018000
 8014724:	08018020 	.word	0x08018020
 8014728:	08017fe0 	.word	0x08017fe0

0801472c <_close_r>:
 801472c:	b538      	push	{r3, r4, r5, lr}
 801472e:	2300      	movs	r3, #0
 8014730:	4c05      	ldr	r4, [pc, #20]	; (8014748 <_close_r+0x1c>)
 8014732:	4605      	mov	r5, r0
 8014734:	4608      	mov	r0, r1
 8014736:	6023      	str	r3, [r4, #0]
 8014738:	f7eb fe9a 	bl	8000470 <_close>
 801473c:	1c43      	adds	r3, r0, #1
 801473e:	d102      	bne.n	8014746 <_close_r+0x1a>
 8014740:	6823      	ldr	r3, [r4, #0]
 8014742:	b103      	cbz	r3, 8014746 <_close_r+0x1a>
 8014744:	602b      	str	r3, [r5, #0]
 8014746:	bd38      	pop	{r3, r4, r5, pc}
 8014748:	200000dc 	.word	0x200000dc

0801474c <__sflags>:
 801474c:	780b      	ldrb	r3, [r1, #0]
 801474e:	2b72      	cmp	r3, #114	; 0x72
 8014750:	b530      	push	{r4, r5, lr}
 8014752:	d02c      	beq.n	80147ae <__sflags+0x62>
 8014754:	2b77      	cmp	r3, #119	; 0x77
 8014756:	d007      	beq.n	8014768 <__sflags+0x1c>
 8014758:	2b61      	cmp	r3, #97	; 0x61
 801475a:	d10f      	bne.n	801477c <__sflags+0x30>
 801475c:	f44f 7402 	mov.w	r4, #520	; 0x208
 8014760:	2301      	movs	r3, #1
 8014762:	f44f 7084 	mov.w	r0, #264	; 0x108
 8014766:	e003      	b.n	8014770 <__sflags+0x24>
 8014768:	f44f 64c0 	mov.w	r4, #1536	; 0x600
 801476c:	2301      	movs	r3, #1
 801476e:	2008      	movs	r0, #8
 8014770:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 8014774:	b935      	cbnz	r5, 8014784 <__sflags+0x38>
 8014776:	4323      	orrs	r3, r4
 8014778:	6013      	str	r3, [r2, #0]
 801477a:	e002      	b.n	8014782 <__sflags+0x36>
 801477c:	2316      	movs	r3, #22
 801477e:	6003      	str	r3, [r0, #0]
 8014780:	2000      	movs	r0, #0
 8014782:	bd30      	pop	{r4, r5, pc}
 8014784:	2d62      	cmp	r5, #98	; 0x62
 8014786:	d00c      	beq.n	80147a2 <__sflags+0x56>
 8014788:	2d78      	cmp	r5, #120	; 0x78
 801478a:	d00d      	beq.n	80147a8 <__sflags+0x5c>
 801478c:	2d2b      	cmp	r5, #43	; 0x2b
 801478e:	d1ef      	bne.n	8014770 <__sflags+0x24>
 8014790:	f020 001c 	bic.w	r0, r0, #28
 8014794:	f023 0303 	bic.w	r3, r3, #3
 8014798:	f040 0010 	orr.w	r0, r0, #16
 801479c:	f043 0302 	orr.w	r3, r3, #2
 80147a0:	e7e6      	b.n	8014770 <__sflags+0x24>
 80147a2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80147a6:	e7e3      	b.n	8014770 <__sflags+0x24>
 80147a8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80147ac:	e7e0      	b.n	8014770 <__sflags+0x24>
 80147ae:	2400      	movs	r4, #0
 80147b0:	2004      	movs	r0, #4
 80147b2:	4623      	mov	r3, r4
 80147b4:	e7dc      	b.n	8014770 <__sflags+0x24>
	...

080147b8 <_fstat_r>:
 80147b8:	b538      	push	{r3, r4, r5, lr}
 80147ba:	2300      	movs	r3, #0
 80147bc:	4c06      	ldr	r4, [pc, #24]	; (80147d8 <_fstat_r+0x20>)
 80147be:	4605      	mov	r5, r0
 80147c0:	4608      	mov	r0, r1
 80147c2:	4611      	mov	r1, r2
 80147c4:	6023      	str	r3, [r4, #0]
 80147c6:	f7eb fe57 	bl	8000478 <_fstat>
 80147ca:	1c43      	adds	r3, r0, #1
 80147cc:	d102      	bne.n	80147d4 <_fstat_r+0x1c>
 80147ce:	6823      	ldr	r3, [r4, #0]
 80147d0:	b103      	cbz	r3, 80147d4 <_fstat_r+0x1c>
 80147d2:	602b      	str	r3, [r5, #0]
 80147d4:	bd38      	pop	{r3, r4, r5, pc}
 80147d6:	bf00      	nop
 80147d8:	200000dc 	.word	0x200000dc

080147dc <_isatty_r>:
 80147dc:	b538      	push	{r3, r4, r5, lr}
 80147de:	2300      	movs	r3, #0
 80147e0:	4c05      	ldr	r4, [pc, #20]	; (80147f8 <_isatty_r+0x1c>)
 80147e2:	4605      	mov	r5, r0
 80147e4:	4608      	mov	r0, r1
 80147e6:	6023      	str	r3, [r4, #0]
 80147e8:	f7eb fe4c 	bl	8000484 <_isatty>
 80147ec:	1c43      	adds	r3, r0, #1
 80147ee:	d102      	bne.n	80147f6 <_isatty_r+0x1a>
 80147f0:	6823      	ldr	r3, [r4, #0]
 80147f2:	b103      	cbz	r3, 80147f6 <_isatty_r+0x1a>
 80147f4:	602b      	str	r3, [r5, #0]
 80147f6:	bd38      	pop	{r3, r4, r5, pc}
 80147f8:	200000dc 	.word	0x200000dc

080147fc <_lseek_r>:
 80147fc:	b538      	push	{r3, r4, r5, lr}
 80147fe:	4605      	mov	r5, r0
 8014800:	4c06      	ldr	r4, [pc, #24]	; (801481c <_lseek_r+0x20>)
 8014802:	4608      	mov	r0, r1
 8014804:	4611      	mov	r1, r2
 8014806:	2200      	movs	r2, #0
 8014808:	6022      	str	r2, [r4, #0]
 801480a:	461a      	mov	r2, r3
 801480c:	f7eb fe3c 	bl	8000488 <_lseek>
 8014810:	1c43      	adds	r3, r0, #1
 8014812:	d102      	bne.n	801481a <_lseek_r+0x1e>
 8014814:	6823      	ldr	r3, [r4, #0]
 8014816:	b103      	cbz	r3, 801481a <_lseek_r+0x1e>
 8014818:	602b      	str	r3, [r5, #0]
 801481a:	bd38      	pop	{r3, r4, r5, pc}
 801481c:	200000dc 	.word	0x200000dc

08014820 <__malloc_lock>:
 8014820:	4770      	bx	lr

08014822 <__malloc_unlock>:
 8014822:	4770      	bx	lr

08014824 <__ssputs_r>:
 8014824:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014828:	688e      	ldr	r6, [r1, #8]
 801482a:	4682      	mov	sl, r0
 801482c:	460c      	mov	r4, r1
 801482e:	4690      	mov	r8, r2
 8014830:	429e      	cmp	r6, r3
 8014832:	4699      	mov	r9, r3
 8014834:	d837      	bhi.n	80148a6 <__ssputs_r+0x82>
 8014836:	898a      	ldrh	r2, [r1, #12]
 8014838:	f412 6f90 	tst.w	r2, #1152	; 0x480
 801483c:	d031      	beq.n	80148a2 <__ssputs_r+0x7e>
 801483e:	6825      	ldr	r5, [r4, #0]
 8014840:	2302      	movs	r3, #2
 8014842:	6909      	ldr	r1, [r1, #16]
 8014844:	1a6f      	subs	r7, r5, r1
 8014846:	6965      	ldr	r5, [r4, #20]
 8014848:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 801484c:	fb95 f5f3 	sdiv	r5, r5, r3
 8014850:	f109 0301 	add.w	r3, r9, #1
 8014854:	443b      	add	r3, r7
 8014856:	429d      	cmp	r5, r3
 8014858:	bf38      	it	cc
 801485a:	461d      	movcc	r5, r3
 801485c:	0553      	lsls	r3, r2, #21
 801485e:	d530      	bpl.n	80148c2 <__ssputs_r+0x9e>
 8014860:	4629      	mov	r1, r5
 8014862:	f7ff fcb7 	bl	80141d4 <_malloc_r>
 8014866:	4606      	mov	r6, r0
 8014868:	b950      	cbnz	r0, 8014880 <__ssputs_r+0x5c>
 801486a:	230c      	movs	r3, #12
 801486c:	f04f 30ff 	mov.w	r0, #4294967295
 8014870:	f8ca 3000 	str.w	r3, [sl]
 8014874:	89a3      	ldrh	r3, [r4, #12]
 8014876:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801487a:	81a3      	strh	r3, [r4, #12]
 801487c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8014880:	463a      	mov	r2, r7
 8014882:	6921      	ldr	r1, [r4, #16]
 8014884:	f7ff fc2c 	bl	80140e0 <memcpy>
 8014888:	89a3      	ldrh	r3, [r4, #12]
 801488a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 801488e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8014892:	81a3      	strh	r3, [r4, #12]
 8014894:	6126      	str	r6, [r4, #16]
 8014896:	443e      	add	r6, r7
 8014898:	6165      	str	r5, [r4, #20]
 801489a:	1bed      	subs	r5, r5, r7
 801489c:	6026      	str	r6, [r4, #0]
 801489e:	464e      	mov	r6, r9
 80148a0:	60a5      	str	r5, [r4, #8]
 80148a2:	454e      	cmp	r6, r9
 80148a4:	d900      	bls.n	80148a8 <__ssputs_r+0x84>
 80148a6:	464e      	mov	r6, r9
 80148a8:	4632      	mov	r2, r6
 80148aa:	4641      	mov	r1, r8
 80148ac:	6820      	ldr	r0, [r4, #0]
 80148ae:	f7ff fc22 	bl	80140f6 <memmove>
 80148b2:	68a3      	ldr	r3, [r4, #8]
 80148b4:	2000      	movs	r0, #0
 80148b6:	1b9b      	subs	r3, r3, r6
 80148b8:	60a3      	str	r3, [r4, #8]
 80148ba:	6823      	ldr	r3, [r4, #0]
 80148bc:	441e      	add	r6, r3
 80148be:	6026      	str	r6, [r4, #0]
 80148c0:	e7dc      	b.n	801487c <__ssputs_r+0x58>
 80148c2:	462a      	mov	r2, r5
 80148c4:	f000 faaa 	bl	8014e1c <_realloc_r>
 80148c8:	4606      	mov	r6, r0
 80148ca:	2800      	cmp	r0, #0
 80148cc:	d1e2      	bne.n	8014894 <__ssputs_r+0x70>
 80148ce:	6921      	ldr	r1, [r4, #16]
 80148d0:	4650      	mov	r0, sl
 80148d2:	f7ff fc31 	bl	8014138 <_free_r>
 80148d6:	e7c8      	b.n	801486a <__ssputs_r+0x46>

080148d8 <_svfiprintf_r>:
 80148d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80148dc:	461d      	mov	r5, r3
 80148de:	898b      	ldrh	r3, [r1, #12]
 80148e0:	b09d      	sub	sp, #116	; 0x74
 80148e2:	4680      	mov	r8, r0
 80148e4:	061f      	lsls	r7, r3, #24
 80148e6:	460c      	mov	r4, r1
 80148e8:	4616      	mov	r6, r2
 80148ea:	d50f      	bpl.n	801490c <_svfiprintf_r+0x34>
 80148ec:	690b      	ldr	r3, [r1, #16]
 80148ee:	b96b      	cbnz	r3, 801490c <_svfiprintf_r+0x34>
 80148f0:	2140      	movs	r1, #64	; 0x40
 80148f2:	f7ff fc6f 	bl	80141d4 <_malloc_r>
 80148f6:	6020      	str	r0, [r4, #0]
 80148f8:	6120      	str	r0, [r4, #16]
 80148fa:	b928      	cbnz	r0, 8014908 <_svfiprintf_r+0x30>
 80148fc:	230c      	movs	r3, #12
 80148fe:	f8c8 3000 	str.w	r3, [r8]
 8014902:	f04f 30ff 	mov.w	r0, #4294967295
 8014906:	e0c8      	b.n	8014a9a <_svfiprintf_r+0x1c2>
 8014908:	2340      	movs	r3, #64	; 0x40
 801490a:	6163      	str	r3, [r4, #20]
 801490c:	2300      	movs	r3, #0
 801490e:	f04f 0b01 	mov.w	fp, #1
 8014912:	9503      	str	r5, [sp, #12]
 8014914:	9309      	str	r3, [sp, #36]	; 0x24
 8014916:	2320      	movs	r3, #32
 8014918:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 801491c:	2330      	movs	r3, #48	; 0x30
 801491e:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8014922:	4637      	mov	r7, r6
 8014924:	463d      	mov	r5, r7
 8014926:	f815 3b01 	ldrb.w	r3, [r5], #1
 801492a:	b10b      	cbz	r3, 8014930 <_svfiprintf_r+0x58>
 801492c:	2b25      	cmp	r3, #37	; 0x25
 801492e:	d13e      	bne.n	80149ae <_svfiprintf_r+0xd6>
 8014930:	ebb7 0a06 	subs.w	sl, r7, r6
 8014934:	d00b      	beq.n	801494e <_svfiprintf_r+0x76>
 8014936:	4653      	mov	r3, sl
 8014938:	4632      	mov	r2, r6
 801493a:	4621      	mov	r1, r4
 801493c:	4640      	mov	r0, r8
 801493e:	f7ff ff71 	bl	8014824 <__ssputs_r>
 8014942:	3001      	adds	r0, #1
 8014944:	f000 80a4 	beq.w	8014a90 <_svfiprintf_r+0x1b8>
 8014948:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801494a:	4453      	add	r3, sl
 801494c:	9309      	str	r3, [sp, #36]	; 0x24
 801494e:	783b      	ldrb	r3, [r7, #0]
 8014950:	2b00      	cmp	r3, #0
 8014952:	f000 809d 	beq.w	8014a90 <_svfiprintf_r+0x1b8>
 8014956:	2300      	movs	r3, #0
 8014958:	f04f 32ff 	mov.w	r2, #4294967295
 801495c:	9304      	str	r3, [sp, #16]
 801495e:	9307      	str	r3, [sp, #28]
 8014960:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8014964:	931a      	str	r3, [sp, #104]	; 0x68
 8014966:	e9cd 2305 	strd	r2, r3, [sp, #20]
 801496a:	462f      	mov	r7, r5
 801496c:	2205      	movs	r2, #5
 801496e:	4851      	ldr	r0, [pc, #324]	; (8014ab4 <_svfiprintf_r+0x1dc>)
 8014970:	f817 1b01 	ldrb.w	r1, [r7], #1
 8014974:	f000 fa44 	bl	8014e00 <memchr>
 8014978:	9b04      	ldr	r3, [sp, #16]
 801497a:	b9d0      	cbnz	r0, 80149b2 <_svfiprintf_r+0xda>
 801497c:	06d9      	lsls	r1, r3, #27
 801497e:	bf44      	itt	mi
 8014980:	2220      	movmi	r2, #32
 8014982:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8014986:	071a      	lsls	r2, r3, #28
 8014988:	bf44      	itt	mi
 801498a:	222b      	movmi	r2, #43	; 0x2b
 801498c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8014990:	782a      	ldrb	r2, [r5, #0]
 8014992:	2a2a      	cmp	r2, #42	; 0x2a
 8014994:	d015      	beq.n	80149c2 <_svfiprintf_r+0xea>
 8014996:	462f      	mov	r7, r5
 8014998:	9a07      	ldr	r2, [sp, #28]
 801499a:	2000      	movs	r0, #0
 801499c:	250a      	movs	r5, #10
 801499e:	4639      	mov	r1, r7
 80149a0:	f811 3b01 	ldrb.w	r3, [r1], #1
 80149a4:	3b30      	subs	r3, #48	; 0x30
 80149a6:	2b09      	cmp	r3, #9
 80149a8:	d94d      	bls.n	8014a46 <_svfiprintf_r+0x16e>
 80149aa:	b1b8      	cbz	r0, 80149dc <_svfiprintf_r+0x104>
 80149ac:	e00f      	b.n	80149ce <_svfiprintf_r+0xf6>
 80149ae:	462f      	mov	r7, r5
 80149b0:	e7b8      	b.n	8014924 <_svfiprintf_r+0x4c>
 80149b2:	4a40      	ldr	r2, [pc, #256]	; (8014ab4 <_svfiprintf_r+0x1dc>)
 80149b4:	463d      	mov	r5, r7
 80149b6:	1a80      	subs	r0, r0, r2
 80149b8:	fa0b f000 	lsl.w	r0, fp, r0
 80149bc:	4318      	orrs	r0, r3
 80149be:	9004      	str	r0, [sp, #16]
 80149c0:	e7d3      	b.n	801496a <_svfiprintf_r+0x92>
 80149c2:	9a03      	ldr	r2, [sp, #12]
 80149c4:	1d11      	adds	r1, r2, #4
 80149c6:	6812      	ldr	r2, [r2, #0]
 80149c8:	2a00      	cmp	r2, #0
 80149ca:	9103      	str	r1, [sp, #12]
 80149cc:	db01      	blt.n	80149d2 <_svfiprintf_r+0xfa>
 80149ce:	9207      	str	r2, [sp, #28]
 80149d0:	e004      	b.n	80149dc <_svfiprintf_r+0x104>
 80149d2:	4252      	negs	r2, r2
 80149d4:	f043 0302 	orr.w	r3, r3, #2
 80149d8:	9207      	str	r2, [sp, #28]
 80149da:	9304      	str	r3, [sp, #16]
 80149dc:	783b      	ldrb	r3, [r7, #0]
 80149de:	2b2e      	cmp	r3, #46	; 0x2e
 80149e0:	d10c      	bne.n	80149fc <_svfiprintf_r+0x124>
 80149e2:	787b      	ldrb	r3, [r7, #1]
 80149e4:	2b2a      	cmp	r3, #42	; 0x2a
 80149e6:	d133      	bne.n	8014a50 <_svfiprintf_r+0x178>
 80149e8:	9b03      	ldr	r3, [sp, #12]
 80149ea:	3702      	adds	r7, #2
 80149ec:	1d1a      	adds	r2, r3, #4
 80149ee:	681b      	ldr	r3, [r3, #0]
 80149f0:	2b00      	cmp	r3, #0
 80149f2:	9203      	str	r2, [sp, #12]
 80149f4:	bfb8      	it	lt
 80149f6:	f04f 33ff 	movlt.w	r3, #4294967295
 80149fa:	9305      	str	r3, [sp, #20]
 80149fc:	4d2e      	ldr	r5, [pc, #184]	; (8014ab8 <_svfiprintf_r+0x1e0>)
 80149fe:	2203      	movs	r2, #3
 8014a00:	7839      	ldrb	r1, [r7, #0]
 8014a02:	4628      	mov	r0, r5
 8014a04:	f000 f9fc 	bl	8014e00 <memchr>
 8014a08:	b138      	cbz	r0, 8014a1a <_svfiprintf_r+0x142>
 8014a0a:	2340      	movs	r3, #64	; 0x40
 8014a0c:	1b40      	subs	r0, r0, r5
 8014a0e:	3701      	adds	r7, #1
 8014a10:	fa03 f000 	lsl.w	r0, r3, r0
 8014a14:	9b04      	ldr	r3, [sp, #16]
 8014a16:	4303      	orrs	r3, r0
 8014a18:	9304      	str	r3, [sp, #16]
 8014a1a:	7839      	ldrb	r1, [r7, #0]
 8014a1c:	2206      	movs	r2, #6
 8014a1e:	4827      	ldr	r0, [pc, #156]	; (8014abc <_svfiprintf_r+0x1e4>)
 8014a20:	1c7e      	adds	r6, r7, #1
 8014a22:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8014a26:	f000 f9eb 	bl	8014e00 <memchr>
 8014a2a:	2800      	cmp	r0, #0
 8014a2c:	d038      	beq.n	8014aa0 <_svfiprintf_r+0x1c8>
 8014a2e:	4b24      	ldr	r3, [pc, #144]	; (8014ac0 <_svfiprintf_r+0x1e8>)
 8014a30:	bb13      	cbnz	r3, 8014a78 <_svfiprintf_r+0x1a0>
 8014a32:	9b03      	ldr	r3, [sp, #12]
 8014a34:	3307      	adds	r3, #7
 8014a36:	f023 0307 	bic.w	r3, r3, #7
 8014a3a:	3308      	adds	r3, #8
 8014a3c:	9303      	str	r3, [sp, #12]
 8014a3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014a40:	444b      	add	r3, r9
 8014a42:	9309      	str	r3, [sp, #36]	; 0x24
 8014a44:	e76d      	b.n	8014922 <_svfiprintf_r+0x4a>
 8014a46:	fb05 3202 	mla	r2, r5, r2, r3
 8014a4a:	2001      	movs	r0, #1
 8014a4c:	460f      	mov	r7, r1
 8014a4e:	e7a6      	b.n	801499e <_svfiprintf_r+0xc6>
 8014a50:	2300      	movs	r3, #0
 8014a52:	3701      	adds	r7, #1
 8014a54:	250a      	movs	r5, #10
 8014a56:	4619      	mov	r1, r3
 8014a58:	9305      	str	r3, [sp, #20]
 8014a5a:	4638      	mov	r0, r7
 8014a5c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8014a60:	3a30      	subs	r2, #48	; 0x30
 8014a62:	2a09      	cmp	r2, #9
 8014a64:	d903      	bls.n	8014a6e <_svfiprintf_r+0x196>
 8014a66:	2b00      	cmp	r3, #0
 8014a68:	d0c8      	beq.n	80149fc <_svfiprintf_r+0x124>
 8014a6a:	9105      	str	r1, [sp, #20]
 8014a6c:	e7c6      	b.n	80149fc <_svfiprintf_r+0x124>
 8014a6e:	fb05 2101 	mla	r1, r5, r1, r2
 8014a72:	2301      	movs	r3, #1
 8014a74:	4607      	mov	r7, r0
 8014a76:	e7f0      	b.n	8014a5a <_svfiprintf_r+0x182>
 8014a78:	ab03      	add	r3, sp, #12
 8014a7a:	4622      	mov	r2, r4
 8014a7c:	a904      	add	r1, sp, #16
 8014a7e:	4640      	mov	r0, r8
 8014a80:	9300      	str	r3, [sp, #0]
 8014a82:	4b10      	ldr	r3, [pc, #64]	; (8014ac4 <_svfiprintf_r+0x1ec>)
 8014a84:	e000      	b.n	8014a88 <_svfiprintf_r+0x1b0>
 8014a86:	bf00      	nop
 8014a88:	f1b0 3fff 	cmp.w	r0, #4294967295
 8014a8c:	4681      	mov	r9, r0
 8014a8e:	d1d6      	bne.n	8014a3e <_svfiprintf_r+0x166>
 8014a90:	89a3      	ldrh	r3, [r4, #12]
 8014a92:	065b      	lsls	r3, r3, #25
 8014a94:	f53f af35 	bmi.w	8014902 <_svfiprintf_r+0x2a>
 8014a98:	9809      	ldr	r0, [sp, #36]	; 0x24
 8014a9a:	b01d      	add	sp, #116	; 0x74
 8014a9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014aa0:	ab03      	add	r3, sp, #12
 8014aa2:	4622      	mov	r2, r4
 8014aa4:	a904      	add	r1, sp, #16
 8014aa6:	4640      	mov	r0, r8
 8014aa8:	9300      	str	r3, [sp, #0]
 8014aaa:	4b06      	ldr	r3, [pc, #24]	; (8014ac4 <_svfiprintf_r+0x1ec>)
 8014aac:	f000 f884 	bl	8014bb8 <_printf_i>
 8014ab0:	e7ea      	b.n	8014a88 <_svfiprintf_r+0x1b0>
 8014ab2:	bf00      	nop
 8014ab4:	08018044 	.word	0x08018044
 8014ab8:	0801804a 	.word	0x0801804a
 8014abc:	0801804e 	.word	0x0801804e
 8014ac0:	00000000 	.word	0x00000000
 8014ac4:	08014825 	.word	0x08014825

08014ac8 <_printf_common>:
 8014ac8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014acc:	4691      	mov	r9, r2
 8014ace:	461f      	mov	r7, r3
 8014ad0:	688a      	ldr	r2, [r1, #8]
 8014ad2:	4606      	mov	r6, r0
 8014ad4:	690b      	ldr	r3, [r1, #16]
 8014ad6:	460c      	mov	r4, r1
 8014ad8:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8014adc:	4293      	cmp	r3, r2
 8014ade:	bfb8      	it	lt
 8014ae0:	4613      	movlt	r3, r2
 8014ae2:	f8c9 3000 	str.w	r3, [r9]
 8014ae6:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8014aea:	b112      	cbz	r2, 8014af2 <_printf_common+0x2a>
 8014aec:	3301      	adds	r3, #1
 8014aee:	f8c9 3000 	str.w	r3, [r9]
 8014af2:	6823      	ldr	r3, [r4, #0]
 8014af4:	0699      	lsls	r1, r3, #26
 8014af6:	bf42      	ittt	mi
 8014af8:	f8d9 3000 	ldrmi.w	r3, [r9]
 8014afc:	3302      	addmi	r3, #2
 8014afe:	f8c9 3000 	strmi.w	r3, [r9]
 8014b02:	6825      	ldr	r5, [r4, #0]
 8014b04:	f015 0506 	ands.w	r5, r5, #6
 8014b08:	d107      	bne.n	8014b1a <_printf_common+0x52>
 8014b0a:	f104 0a19 	add.w	sl, r4, #25
 8014b0e:	68e3      	ldr	r3, [r4, #12]
 8014b10:	f8d9 2000 	ldr.w	r2, [r9]
 8014b14:	1a9b      	subs	r3, r3, r2
 8014b16:	42ab      	cmp	r3, r5
 8014b18:	dc2b      	bgt.n	8014b72 <_printf_common+0xaa>
 8014b1a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8014b1e:	6822      	ldr	r2, [r4, #0]
 8014b20:	3300      	adds	r3, #0
 8014b22:	bf18      	it	ne
 8014b24:	2301      	movne	r3, #1
 8014b26:	0692      	lsls	r2, r2, #26
 8014b28:	d430      	bmi.n	8014b8c <_printf_common+0xc4>
 8014b2a:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8014b2e:	4639      	mov	r1, r7
 8014b30:	4630      	mov	r0, r6
 8014b32:	47c0      	blx	r8
 8014b34:	3001      	adds	r0, #1
 8014b36:	d023      	beq.n	8014b80 <_printf_common+0xb8>
 8014b38:	6823      	ldr	r3, [r4, #0]
 8014b3a:	341a      	adds	r4, #26
 8014b3c:	f854 5c0e 	ldr.w	r5, [r4, #-14]
 8014b40:	f003 0306 	and.w	r3, r3, #6
 8014b44:	f8d9 2000 	ldr.w	r2, [r9]
 8014b48:	f04f 0900 	mov.w	r9, #0
 8014b4c:	2b04      	cmp	r3, #4
 8014b4e:	f854 3c12 	ldr.w	r3, [r4, #-18]
 8014b52:	bf08      	it	eq
 8014b54:	1aad      	subeq	r5, r5, r2
 8014b56:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 8014b5a:	bf14      	ite	ne
 8014b5c:	2500      	movne	r5, #0
 8014b5e:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8014b62:	4293      	cmp	r3, r2
 8014b64:	bfc4      	itt	gt
 8014b66:	1a9b      	subgt	r3, r3, r2
 8014b68:	18ed      	addgt	r5, r5, r3
 8014b6a:	454d      	cmp	r5, r9
 8014b6c:	d11a      	bne.n	8014ba4 <_printf_common+0xdc>
 8014b6e:	2000      	movs	r0, #0
 8014b70:	e008      	b.n	8014b84 <_printf_common+0xbc>
 8014b72:	2301      	movs	r3, #1
 8014b74:	4652      	mov	r2, sl
 8014b76:	4639      	mov	r1, r7
 8014b78:	4630      	mov	r0, r6
 8014b7a:	47c0      	blx	r8
 8014b7c:	3001      	adds	r0, #1
 8014b7e:	d103      	bne.n	8014b88 <_printf_common+0xc0>
 8014b80:	f04f 30ff 	mov.w	r0, #4294967295
 8014b84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8014b88:	3501      	adds	r5, #1
 8014b8a:	e7c0      	b.n	8014b0e <_printf_common+0x46>
 8014b8c:	18e1      	adds	r1, r4, r3
 8014b8e:	1c5a      	adds	r2, r3, #1
 8014b90:	2030      	movs	r0, #48	; 0x30
 8014b92:	3302      	adds	r3, #2
 8014b94:	4422      	add	r2, r4
 8014b96:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8014b9a:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8014b9e:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8014ba2:	e7c2      	b.n	8014b2a <_printf_common+0x62>
 8014ba4:	2301      	movs	r3, #1
 8014ba6:	4622      	mov	r2, r4
 8014ba8:	4639      	mov	r1, r7
 8014baa:	4630      	mov	r0, r6
 8014bac:	47c0      	blx	r8
 8014bae:	3001      	adds	r0, #1
 8014bb0:	d0e6      	beq.n	8014b80 <_printf_common+0xb8>
 8014bb2:	f109 0901 	add.w	r9, r9, #1
 8014bb6:	e7d8      	b.n	8014b6a <_printf_common+0xa2>

08014bb8 <_printf_i>:
 8014bb8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8014bbc:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 8014bc0:	460c      	mov	r4, r1
 8014bc2:	7e09      	ldrb	r1, [r1, #24]
 8014bc4:	b085      	sub	sp, #20
 8014bc6:	4617      	mov	r7, r2
 8014bc8:	4606      	mov	r6, r0
 8014bca:	296e      	cmp	r1, #110	; 0x6e
 8014bcc:	4698      	mov	r8, r3
 8014bce:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8014bd0:	f000 80b3 	beq.w	8014d3a <_printf_i+0x182>
 8014bd4:	d822      	bhi.n	8014c1c <_printf_i+0x64>
 8014bd6:	2963      	cmp	r1, #99	; 0x63
 8014bd8:	d036      	beq.n	8014c48 <_printf_i+0x90>
 8014bda:	d80a      	bhi.n	8014bf2 <_printf_i+0x3a>
 8014bdc:	2900      	cmp	r1, #0
 8014bde:	f000 80b9 	beq.w	8014d54 <_printf_i+0x19c>
 8014be2:	2958      	cmp	r1, #88	; 0x58
 8014be4:	f000 8083 	beq.w	8014cee <_printf_i+0x136>
 8014be8:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8014bec:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 8014bf0:	e032      	b.n	8014c58 <_printf_i+0xa0>
 8014bf2:	2964      	cmp	r1, #100	; 0x64
 8014bf4:	d001      	beq.n	8014bfa <_printf_i+0x42>
 8014bf6:	2969      	cmp	r1, #105	; 0x69
 8014bf8:	d1f6      	bne.n	8014be8 <_printf_i+0x30>
 8014bfa:	6820      	ldr	r0, [r4, #0]
 8014bfc:	6813      	ldr	r3, [r2, #0]
 8014bfe:	0605      	lsls	r5, r0, #24
 8014c00:	f103 0104 	add.w	r1, r3, #4
 8014c04:	d52a      	bpl.n	8014c5c <_printf_i+0xa4>
 8014c06:	681b      	ldr	r3, [r3, #0]
 8014c08:	6011      	str	r1, [r2, #0]
 8014c0a:	2b00      	cmp	r3, #0
 8014c0c:	da03      	bge.n	8014c16 <_printf_i+0x5e>
 8014c0e:	222d      	movs	r2, #45	; 0x2d
 8014c10:	425b      	negs	r3, r3
 8014c12:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8014c16:	486f      	ldr	r0, [pc, #444]	; (8014dd4 <_printf_i+0x21c>)
 8014c18:	220a      	movs	r2, #10
 8014c1a:	e039      	b.n	8014c90 <_printf_i+0xd8>
 8014c1c:	2973      	cmp	r1, #115	; 0x73
 8014c1e:	f000 809d 	beq.w	8014d5c <_printf_i+0x1a4>
 8014c22:	d808      	bhi.n	8014c36 <_printf_i+0x7e>
 8014c24:	296f      	cmp	r1, #111	; 0x6f
 8014c26:	d020      	beq.n	8014c6a <_printf_i+0xb2>
 8014c28:	2970      	cmp	r1, #112	; 0x70
 8014c2a:	d1dd      	bne.n	8014be8 <_printf_i+0x30>
 8014c2c:	6823      	ldr	r3, [r4, #0]
 8014c2e:	f043 0320 	orr.w	r3, r3, #32
 8014c32:	6023      	str	r3, [r4, #0]
 8014c34:	e003      	b.n	8014c3e <_printf_i+0x86>
 8014c36:	2975      	cmp	r1, #117	; 0x75
 8014c38:	d017      	beq.n	8014c6a <_printf_i+0xb2>
 8014c3a:	2978      	cmp	r1, #120	; 0x78
 8014c3c:	d1d4      	bne.n	8014be8 <_printf_i+0x30>
 8014c3e:	2378      	movs	r3, #120	; 0x78
 8014c40:	4865      	ldr	r0, [pc, #404]	; (8014dd8 <_printf_i+0x220>)
 8014c42:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8014c46:	e055      	b.n	8014cf4 <_printf_i+0x13c>
 8014c48:	6813      	ldr	r3, [r2, #0]
 8014c4a:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8014c4e:	1d19      	adds	r1, r3, #4
 8014c50:	681b      	ldr	r3, [r3, #0]
 8014c52:	6011      	str	r1, [r2, #0]
 8014c54:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8014c58:	2301      	movs	r3, #1
 8014c5a:	e08c      	b.n	8014d76 <_printf_i+0x1be>
 8014c5c:	681b      	ldr	r3, [r3, #0]
 8014c5e:	f010 0f40 	tst.w	r0, #64	; 0x40
 8014c62:	6011      	str	r1, [r2, #0]
 8014c64:	bf18      	it	ne
 8014c66:	b21b      	sxthne	r3, r3
 8014c68:	e7cf      	b.n	8014c0a <_printf_i+0x52>
 8014c6a:	6813      	ldr	r3, [r2, #0]
 8014c6c:	6825      	ldr	r5, [r4, #0]
 8014c6e:	1d18      	adds	r0, r3, #4
 8014c70:	6010      	str	r0, [r2, #0]
 8014c72:	0628      	lsls	r0, r5, #24
 8014c74:	d501      	bpl.n	8014c7a <_printf_i+0xc2>
 8014c76:	681b      	ldr	r3, [r3, #0]
 8014c78:	e002      	b.n	8014c80 <_printf_i+0xc8>
 8014c7a:	0668      	lsls	r0, r5, #25
 8014c7c:	d5fb      	bpl.n	8014c76 <_printf_i+0xbe>
 8014c7e:	881b      	ldrh	r3, [r3, #0]
 8014c80:	296f      	cmp	r1, #111	; 0x6f
 8014c82:	4854      	ldr	r0, [pc, #336]	; (8014dd4 <_printf_i+0x21c>)
 8014c84:	bf14      	ite	ne
 8014c86:	220a      	movne	r2, #10
 8014c88:	2208      	moveq	r2, #8
 8014c8a:	2100      	movs	r1, #0
 8014c8c:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8014c90:	6865      	ldr	r5, [r4, #4]
 8014c92:	2d00      	cmp	r5, #0
 8014c94:	60a5      	str	r5, [r4, #8]
 8014c96:	f2c0 8095 	blt.w	8014dc4 <_printf_i+0x20c>
 8014c9a:	6821      	ldr	r1, [r4, #0]
 8014c9c:	f021 0104 	bic.w	r1, r1, #4
 8014ca0:	6021      	str	r1, [r4, #0]
 8014ca2:	2b00      	cmp	r3, #0
 8014ca4:	d13d      	bne.n	8014d22 <_printf_i+0x16a>
 8014ca6:	2d00      	cmp	r5, #0
 8014ca8:	f040 808e 	bne.w	8014dc8 <_printf_i+0x210>
 8014cac:	4665      	mov	r5, ip
 8014cae:	2a08      	cmp	r2, #8
 8014cb0:	d10b      	bne.n	8014cca <_printf_i+0x112>
 8014cb2:	6823      	ldr	r3, [r4, #0]
 8014cb4:	07db      	lsls	r3, r3, #31
 8014cb6:	d508      	bpl.n	8014cca <_printf_i+0x112>
 8014cb8:	6923      	ldr	r3, [r4, #16]
 8014cba:	6862      	ldr	r2, [r4, #4]
 8014cbc:	429a      	cmp	r2, r3
 8014cbe:	bfde      	ittt	le
 8014cc0:	2330      	movle	r3, #48	; 0x30
 8014cc2:	f805 3c01 	strble.w	r3, [r5, #-1]
 8014cc6:	f105 35ff 	addle.w	r5, r5, #4294967295
 8014cca:	ebac 0305 	sub.w	r3, ip, r5
 8014cce:	6123      	str	r3, [r4, #16]
 8014cd0:	f8cd 8000 	str.w	r8, [sp]
 8014cd4:	463b      	mov	r3, r7
 8014cd6:	aa03      	add	r2, sp, #12
 8014cd8:	4621      	mov	r1, r4
 8014cda:	4630      	mov	r0, r6
 8014cdc:	f7ff fef4 	bl	8014ac8 <_printf_common>
 8014ce0:	3001      	adds	r0, #1
 8014ce2:	d14d      	bne.n	8014d80 <_printf_i+0x1c8>
 8014ce4:	f04f 30ff 	mov.w	r0, #4294967295
 8014ce8:	b005      	add	sp, #20
 8014cea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8014cee:	4839      	ldr	r0, [pc, #228]	; (8014dd4 <_printf_i+0x21c>)
 8014cf0:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 8014cf4:	6813      	ldr	r3, [r2, #0]
 8014cf6:	6821      	ldr	r1, [r4, #0]
 8014cf8:	1d1d      	adds	r5, r3, #4
 8014cfa:	681b      	ldr	r3, [r3, #0]
 8014cfc:	6015      	str	r5, [r2, #0]
 8014cfe:	060a      	lsls	r2, r1, #24
 8014d00:	d50b      	bpl.n	8014d1a <_printf_i+0x162>
 8014d02:	07ca      	lsls	r2, r1, #31
 8014d04:	bf44      	itt	mi
 8014d06:	f041 0120 	orrmi.w	r1, r1, #32
 8014d0a:	6021      	strmi	r1, [r4, #0]
 8014d0c:	b91b      	cbnz	r3, 8014d16 <_printf_i+0x15e>
 8014d0e:	6822      	ldr	r2, [r4, #0]
 8014d10:	f022 0220 	bic.w	r2, r2, #32
 8014d14:	6022      	str	r2, [r4, #0]
 8014d16:	2210      	movs	r2, #16
 8014d18:	e7b7      	b.n	8014c8a <_printf_i+0xd2>
 8014d1a:	064d      	lsls	r5, r1, #25
 8014d1c:	bf48      	it	mi
 8014d1e:	b29b      	uxthmi	r3, r3
 8014d20:	e7ef      	b.n	8014d02 <_printf_i+0x14a>
 8014d22:	4665      	mov	r5, ip
 8014d24:	fbb3 f1f2 	udiv	r1, r3, r2
 8014d28:	fb02 3311 	mls	r3, r2, r1, r3
 8014d2c:	5cc3      	ldrb	r3, [r0, r3]
 8014d2e:	f805 3d01 	strb.w	r3, [r5, #-1]!
 8014d32:	460b      	mov	r3, r1
 8014d34:	2900      	cmp	r1, #0
 8014d36:	d1f5      	bne.n	8014d24 <_printf_i+0x16c>
 8014d38:	e7b9      	b.n	8014cae <_printf_i+0xf6>
 8014d3a:	6813      	ldr	r3, [r2, #0]
 8014d3c:	6825      	ldr	r5, [r4, #0]
 8014d3e:	1d18      	adds	r0, r3, #4
 8014d40:	6961      	ldr	r1, [r4, #20]
 8014d42:	6010      	str	r0, [r2, #0]
 8014d44:	0628      	lsls	r0, r5, #24
 8014d46:	681b      	ldr	r3, [r3, #0]
 8014d48:	d501      	bpl.n	8014d4e <_printf_i+0x196>
 8014d4a:	6019      	str	r1, [r3, #0]
 8014d4c:	e002      	b.n	8014d54 <_printf_i+0x19c>
 8014d4e:	066a      	lsls	r2, r5, #25
 8014d50:	d5fb      	bpl.n	8014d4a <_printf_i+0x192>
 8014d52:	8019      	strh	r1, [r3, #0]
 8014d54:	2300      	movs	r3, #0
 8014d56:	4665      	mov	r5, ip
 8014d58:	6123      	str	r3, [r4, #16]
 8014d5a:	e7b9      	b.n	8014cd0 <_printf_i+0x118>
 8014d5c:	6813      	ldr	r3, [r2, #0]
 8014d5e:	1d19      	adds	r1, r3, #4
 8014d60:	6011      	str	r1, [r2, #0]
 8014d62:	2100      	movs	r1, #0
 8014d64:	681d      	ldr	r5, [r3, #0]
 8014d66:	6862      	ldr	r2, [r4, #4]
 8014d68:	4628      	mov	r0, r5
 8014d6a:	f000 f849 	bl	8014e00 <memchr>
 8014d6e:	b108      	cbz	r0, 8014d74 <_printf_i+0x1bc>
 8014d70:	1b40      	subs	r0, r0, r5
 8014d72:	6060      	str	r0, [r4, #4]
 8014d74:	6863      	ldr	r3, [r4, #4]
 8014d76:	6123      	str	r3, [r4, #16]
 8014d78:	2300      	movs	r3, #0
 8014d7a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8014d7e:	e7a7      	b.n	8014cd0 <_printf_i+0x118>
 8014d80:	6923      	ldr	r3, [r4, #16]
 8014d82:	462a      	mov	r2, r5
 8014d84:	4639      	mov	r1, r7
 8014d86:	4630      	mov	r0, r6
 8014d88:	47c0      	blx	r8
 8014d8a:	3001      	adds	r0, #1
 8014d8c:	d0aa      	beq.n	8014ce4 <_printf_i+0x12c>
 8014d8e:	6823      	ldr	r3, [r4, #0]
 8014d90:	079b      	lsls	r3, r3, #30
 8014d92:	d413      	bmi.n	8014dbc <_printf_i+0x204>
 8014d94:	68e0      	ldr	r0, [r4, #12]
 8014d96:	9b03      	ldr	r3, [sp, #12]
 8014d98:	4298      	cmp	r0, r3
 8014d9a:	bfb8      	it	lt
 8014d9c:	4618      	movlt	r0, r3
 8014d9e:	e7a3      	b.n	8014ce8 <_printf_i+0x130>
 8014da0:	2301      	movs	r3, #1
 8014da2:	464a      	mov	r2, r9
 8014da4:	4639      	mov	r1, r7
 8014da6:	4630      	mov	r0, r6
 8014da8:	47c0      	blx	r8
 8014daa:	3001      	adds	r0, #1
 8014dac:	d09a      	beq.n	8014ce4 <_printf_i+0x12c>
 8014dae:	3501      	adds	r5, #1
 8014db0:	68e3      	ldr	r3, [r4, #12]
 8014db2:	9a03      	ldr	r2, [sp, #12]
 8014db4:	1a9b      	subs	r3, r3, r2
 8014db6:	42ab      	cmp	r3, r5
 8014db8:	dcf2      	bgt.n	8014da0 <_printf_i+0x1e8>
 8014dba:	e7eb      	b.n	8014d94 <_printf_i+0x1dc>
 8014dbc:	2500      	movs	r5, #0
 8014dbe:	f104 0919 	add.w	r9, r4, #25
 8014dc2:	e7f5      	b.n	8014db0 <_printf_i+0x1f8>
 8014dc4:	2b00      	cmp	r3, #0
 8014dc6:	d1ac      	bne.n	8014d22 <_printf_i+0x16a>
 8014dc8:	7803      	ldrb	r3, [r0, #0]
 8014dca:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8014dce:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8014dd2:	e76c      	b.n	8014cae <_printf_i+0xf6>
 8014dd4:	08018055 	.word	0x08018055
 8014dd8:	08018066 	.word	0x08018066

08014ddc <_read_r>:
 8014ddc:	b538      	push	{r3, r4, r5, lr}
 8014dde:	4605      	mov	r5, r0
 8014de0:	4c06      	ldr	r4, [pc, #24]	; (8014dfc <_read_r+0x20>)
 8014de2:	4608      	mov	r0, r1
 8014de4:	4611      	mov	r1, r2
 8014de6:	2200      	movs	r2, #0
 8014de8:	6022      	str	r2, [r4, #0]
 8014dea:	461a      	mov	r2, r3
 8014dec:	f7eb fb24 	bl	8000438 <_read>
 8014df0:	1c43      	adds	r3, r0, #1
 8014df2:	d102      	bne.n	8014dfa <_read_r+0x1e>
 8014df4:	6823      	ldr	r3, [r4, #0]
 8014df6:	b103      	cbz	r3, 8014dfa <_read_r+0x1e>
 8014df8:	602b      	str	r3, [r5, #0]
 8014dfa:	bd38      	pop	{r3, r4, r5, pc}
 8014dfc:	200000dc 	.word	0x200000dc

08014e00 <memchr>:
 8014e00:	b2c9      	uxtb	r1, r1
 8014e02:	4402      	add	r2, r0
 8014e04:	b510      	push	{r4, lr}
 8014e06:	4290      	cmp	r0, r2
 8014e08:	4603      	mov	r3, r0
 8014e0a:	d101      	bne.n	8014e10 <memchr+0x10>
 8014e0c:	2300      	movs	r3, #0
 8014e0e:	e003      	b.n	8014e18 <memchr+0x18>
 8014e10:	781c      	ldrb	r4, [r3, #0]
 8014e12:	3001      	adds	r0, #1
 8014e14:	428c      	cmp	r4, r1
 8014e16:	d1f6      	bne.n	8014e06 <memchr+0x6>
 8014e18:	4618      	mov	r0, r3
 8014e1a:	bd10      	pop	{r4, pc}

08014e1c <_realloc_r>:
 8014e1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014e1e:	4607      	mov	r7, r0
 8014e20:	4614      	mov	r4, r2
 8014e22:	460e      	mov	r6, r1
 8014e24:	b921      	cbnz	r1, 8014e30 <_realloc_r+0x14>
 8014e26:	4611      	mov	r1, r2
 8014e28:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8014e2c:	f7ff b9d2 	b.w	80141d4 <_malloc_r>
 8014e30:	b922      	cbnz	r2, 8014e3c <_realloc_r+0x20>
 8014e32:	4625      	mov	r5, r4
 8014e34:	f7ff f980 	bl	8014138 <_free_r>
 8014e38:	4628      	mov	r0, r5
 8014e3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8014e3c:	f000 f814 	bl	8014e68 <_malloc_usable_size_r>
 8014e40:	42a0      	cmp	r0, r4
 8014e42:	d20f      	bcs.n	8014e64 <_realloc_r+0x48>
 8014e44:	4621      	mov	r1, r4
 8014e46:	4638      	mov	r0, r7
 8014e48:	f7ff f9c4 	bl	80141d4 <_malloc_r>
 8014e4c:	4605      	mov	r5, r0
 8014e4e:	2800      	cmp	r0, #0
 8014e50:	d0f2      	beq.n	8014e38 <_realloc_r+0x1c>
 8014e52:	4631      	mov	r1, r6
 8014e54:	4622      	mov	r2, r4
 8014e56:	f7ff f943 	bl	80140e0 <memcpy>
 8014e5a:	4631      	mov	r1, r6
 8014e5c:	4638      	mov	r0, r7
 8014e5e:	f7ff f96b 	bl	8014138 <_free_r>
 8014e62:	e7e9      	b.n	8014e38 <_realloc_r+0x1c>
 8014e64:	4635      	mov	r5, r6
 8014e66:	e7e7      	b.n	8014e38 <_realloc_r+0x1c>

08014e68 <_malloc_usable_size_r>:
 8014e68:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8014e6c:	1f18      	subs	r0, r3, #4
 8014e6e:	2b00      	cmp	r3, #0
 8014e70:	bfbc      	itt	lt
 8014e72:	580b      	ldrlt	r3, [r1, r0]
 8014e74:	18c0      	addlt	r0, r0, r3
 8014e76:	4770      	bx	lr

08014e78 <_init>:
 8014e78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014e7a:	bf00      	nop
 8014e7c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8014e7e:	bc08      	pop	{r3}
 8014e80:	469e      	mov	lr, r3
 8014e82:	4770      	bx	lr

08014e84 <_fini>:
 8014e84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014e86:	bf00      	nop
 8014e88:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8014e8a:	bc08      	pop	{r3}
 8014e8c:	469e      	mov	lr, r3
 8014e8e:	4770      	bx	lr
